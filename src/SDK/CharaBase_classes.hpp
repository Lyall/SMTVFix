#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharaBase

#include "Basic.hpp"

#include "E_CHARA_MATERIAL_ANIMATION_SLOT_structs.hpp"
#include "BadStatusParticles_T_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "E_MapAction_Pla603_structs.hpp"
#include "E_IK_TYPE_LIST_structs.hpp"
#include "Project_structs.hpp"
#include "Project_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass CharaBase.CharaBase_C
// 0x05E0 (0x08C8 - 0x02E8)
class ACharaBase_C : public ACustomPawn
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x02E8(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UParticleSystemComponent*               Uplifting;                                         // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBoxComponent*                          NkmAreaBox;                                        // 0x02F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCharaBadStatus_C*                      CharaBadStatus;                                    // 0x0300(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCharaSmearFrameComponent_C*            CharaSmearFrameComponent;                          // 0x0308(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UParticleSystemComponent*               Aura;                                              // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UParticleSystemComponent*               TargetPoint;                                       // 0x0318(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        ParticleHolder;                                    // 0x0320(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCharaMotionPlayerComponent*            Motion;                                            // 0x0328(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCharaParamComponent*                   CharaParam;                                        // 0x0330(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCharaSinkHelperComponent_C*            SinkHelper;                                        // 0x0338(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	float                                         ___________val_496EF3A34B39672AA7B9A3966BB83C0E;   // 0x0340(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            ____________Direction_496EF3A34B39672AA7B9A3966BB83C0E; // 0x0344(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AC7[0x3];                                     // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     _________d;                                        // 0x0348(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ____________value_3D3DCBFD4432B7B25C9C1F93EA34E7FB; // 0x0350(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            _____________Direction_3D3DCBFD4432B7B25C9C1F93EA34E7FB; // 0x0354(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AC8[0x3];                                     // 0x0355(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     ___________;                                       // 0x0358(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ____________value_975ED5724FF6DF59285EBA8C22F8464D; // 0x0360(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            _____________Direction_975ED5724FF6DF59285EBA8C22F8464D; // 0x0364(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AC9[0x3];                                     // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     ____________0;                                     // 0x0368(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ForAlmostYugami_ParamValue_47524AA947083F3E0EC1298A624F39D7; // 0x0370(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            ForAlmostYugami__Direction_47524AA947083F3E0EC1298A624F39D7; // 0x0374(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2ACA[0x3];                                     // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     ForAlmostYugami;                                   // 0x0378(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaterialAnimSlot4_Anim_06D06D684A3FDF97E270E4822BBE1A67; // 0x0380(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            MaterialAnimSlot4__Direction_06D06D684A3FDF97E270E4822BBE1A67; // 0x0384(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2ACB[0x3];                                     // 0x0385(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     MaterialAnimSlot4;                                 // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaterialAnimSlot3_Anim_D188A2D1436F7664952EC99682631DDE; // 0x0390(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            MaterialAnimSlot3__Direction_D188A2D1436F7664952EC99682631DDE; // 0x0394(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2ACC[0x3];                                     // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     MaterialAnimSlot3;                                 // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaterialAnimSlot2_Anim_8C863F1B4BB9D227E84B8F93F67A4ACA; // 0x03A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            MaterialAnimSlot2__Direction_8C863F1B4BB9D227E84B8F93F67A4ACA; // 0x03A4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2ACD[0x3];                                     // 0x03A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     MaterialAnimSlot2;                                 // 0x03A8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaterialAnimSlot1_Anim_504772B14C9A90A8FBAE75A1A5414440; // 0x03B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            MaterialAnimSlot1__Direction_504772B14C9A90A8FBAE75A1A5414440; // 0x03B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2ACE[0x3];                                     // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     MaterialAnimSlot1;                                 // 0x03B8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            CharaShakeTimeline__Direction_B529E1B646FF2C0D6B73E69D9569813A; // 0x03C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2ACF[0x7];                                     // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     CharaShakeTimeline;                                // 0x03C8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaterialAnimSlot0_Anim_935A1B33450864D2C3AA9A8ABB4B2264; // 0x03D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            MaterialAnimSlot0__Direction_935A1B33450864D2C3AA9A8ABB4B2264; // 0x03D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AD0[0x3];                                     // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     MaterialAnimSlot0;                                 // 0x03D8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         _____UnionVal_6645B41F4C052DF4379AC5941088DC74;    // 0x03E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            ______Direction_6645B41F4C052DF4379AC5941088DC74;  // 0x03E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AD1[0x3];                                     // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     _S__;                                              // 0x03E8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_CHARA_MOTION_ID                             MotionID;                                          // 0x03F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_CHARA_MOTION_ID                             MotionIDPrevious;                                  // 0x03F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          LegIKEnableFlag;                                   // 0x03F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          HeadIKEnableFlag;                                  // 0x03F3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          EyeIKEnableFlag;                                   // 0x03F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          BodyIKEnableFlag;                                  // 0x03F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          FloatingIKEnableFlag;                              // 0x03F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AD2[0x1];                                     // 0x03F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WatchOnesStepCount;                                // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         PerchCount;                                        // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         FloatingIKPerch;                                   // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
	float                                         SinkActorOffset;                                   // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        LookAtComponent;                                   // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   LookAtSocket;                                      // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FCharaActionState                      ActionState;                                       // 0x0418(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	struct FCharaMoveParam                        M_MoveParam;                                       // 0x0428(0x0038)(Edit, BlueprintVisible, DisableEditOnInstance)
	float                                         M_MoveTotalTime;                                   // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_CurrentTime;                                     // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             Evt_Move;                                          // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          M_IsMoving;                                        // 0x0478(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AD3[0x7];                                     // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Evt_Dir;                                           // 0x0480(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FRotator                               M_DirTargetRot;                                    // 0x0490(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	float                                         M_DirInterp;                                       // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsDirMoving;                                     // 0x04A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	E_CHARA_MOTION_ID                             M_FinishedMotion;                                  // 0x04A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AD4[0x2];                                     // 0x04A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_CurrentBadStatus;                                // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsReservePauseMotion;                            // 0x04A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AD5[0x7];                                     // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BadStatusOpacity;                                  // 0x04B0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<class FName>                           CriticalOpacity;                                   // 0x04C0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	int32                                         M_Aura;                                            // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         M_AdaptedAuraIndex;                                // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AlwaysAutoTransitionAnimationMode;                 // 0x04D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AD6[0x7];                                     // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Notify_ApplyHit;                                   // 0x04E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          M_IsBeginFinishMotion;                             // 0x04F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AD7[0x3];                                     // 0x04F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_FinishMotionBeginTime;                           // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_FinishMotionBlendTime;                           // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsInterpFinishMotion;                            // 0x04FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AD8[0x3];                                     // 0x04FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Evt_Tilt;                                          // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         M_PrevBadStatus;                                   // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_BAD_STATUS                                  M_CurrentSurfaceStatus;                            // 0x0514(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsNeedResetMaterial;                             // 0x0515(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsParalyzed;                                     // 0x0516(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AD9[0x1];                                     // 0x0517(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomPoseWeightTable*                 PoseWeightTable;                                   // 0x0518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsNotifyApplyHit;                                // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2ADA[0x7];                                     // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBadStatusParticles_T>          M_BadParticleSettingsOn;                           // 0x0528(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<struct FBadStatusParticles_T>          M_BadParticleSettingsOff;                          // 0x0538(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          M_InitialVisibility;                               // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	uint8                                         Pad_2ADB[0x3];                                     // 0x0549(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_MotionBlendTime;                                 // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_MotionIsUseDuration;                             // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2ADC[0x3];                                     // 0x0551(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_MotionDuration;                                  // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_MotionIsUseBlendTime;                            // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsFreezeMotion;                                  // 0x0559(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2ADD[0x6];                                     // 0x055A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<E_ANIM_NOTIFY_APPLY_HIT_TYPE>          M_NotifyType;                                      // 0x0560(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsCompletelyDead;                                // 0x0570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_EnableFollowTargetEffect;                        // 0x0571(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2ADE[0x2];                                     // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_TargetSocketName;                                // 0x0574(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2ADF[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<E_BAD_STATUS, class UParticleSystemComponent*> M_BadStatusLoopParticles;                          // 0x0580(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	E_BAD_STATUS                                  M_CurrentSurfaceStatusMaterial;                    // 0x05D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AE0[0x7];                                     // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<E_BAD_STATUS>                          M_ValidBadStatus;                                  // 0x05D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsShowAllBadStatus;                              // 0x05E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AE1[0x7];                                     // 0x05E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBadStatusParticles_T>          M_LoadingBadSettings;                              // 0x05F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<class FName>                           M_OffMaterialParamNames;                           // 0x0600(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsBattleAnimationPlaying;                        // 0x0610(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsMotionHeadNotify;                              // 0x0611(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AE2[0x2];                                     // 0x0612(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_MeshRelativeScale;                               // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                M_MoveAmount;                                      // 0x0618(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AE3[0x4];                                     // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_BadStatsParam;                                   // 0x0628(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<struct FBadStatusParticles_T>          M_BadParticleSettingsUpdate;                       // 0x0638(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<struct FBadStatusParticles_T>          M_BadParticleSettingsReset;                        // 0x0648(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          M_InitializeMaterialOnBeginPlay;                   // 0x0658(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	uint8                                         Pad_2AE4[0x3];                                     // 0x0659(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_CharaPlayRate;                                   // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         M_ControledPSCs;                                   // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_CHARA_MOTION_ID                             M_RunToUnitMotion;                                 // 0x0664(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsAnnouncedInvalidMotionTable;                   // 0x0665(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsNotifyDeadTiming;                              // 0x0666(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AE5[0x1];                                     // 0x0667(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Evt_DamageMotionEnd;                               // 0x0668(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<struct FCharaMoveParam>                M_MoveParamCue;                                    // 0x0678(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<float>                                 M_DirInterpCue;                                    // 0x0688(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsNotifySkillFire;                               // 0x0698(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AE6[0x3];                                     // 0x0699(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               M_CharaShakeDir;                                   // 0x069C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	struct FRotator                               M_CharaShakeNextDir;                               // 0x06A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AE7[0x4];                                     // 0x06B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  M_IsUsedSlot;                                      // 0x06B8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<class FName>                           M_IsAlreadyChangeEnableEffect;                     // 0x06C8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<class FName>                           M_IsAlreadyChangeEnableDecal;                      // 0x06D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsNotifyWarpTiming;                              // 0x06E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	E_CHARA_MOTION_ID                             M_DefaultIdleMotion;                               // 0x06E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AE8[0x2];                                     // 0x06EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_DefaultMeshOffset;                               // 0x06EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CalcIKMax;                                         // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CalcIKCount;                                       // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CalcIKForceTrue;                                   // 0x0700(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CalcIKEventMode;                                   // 0x0701(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AE9[0x6];                                     // 0x0702(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialAnimCoreComponent_C*           MaterialAnimCore;                                  // 0x0708(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             Evt_OnFinishFade;                                  // 0x0710(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<class FName>                           M_AlmostYugamiParamName;                           // 0x0720(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	float                                         M_SpringArmUp_InitialLength;                       // 0x0730(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AEA[0x4];                                     // 0x0734(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    Ref_SpringArm_Up;                                  // 0x0738(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsRapidReturnActionNow;                          // 0x0740(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsNotifyRapidReturnTiming;                       // 0x0741(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AEB[0x6];                                     // 0x0742(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          M_NotifyDeadVoice;                                 // 0x0748(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<TSoftObjectPtr<class UMaterialParameterApplier>> M_OnMaterialApplier;                               // 0x0750(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsUplifting;                                     // 0x0760(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AEC[0x7];                                     // 0x0761(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystemComponent*>       M_MeshAttachedParticle;                            // 0x0768(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	float                                         MumbleTime;                                        // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AED[0x4];                                     // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharaBlink*                            BlinkAsset;                                        // 0x0780(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsNotifyEnableChangeMotion;                      // 0x0788(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsNotifyInSkillPerformDuration;                  // 0x0789(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          UseBlink;                                          // 0x078A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsBlinkToNotify;                                   // 0x078B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AEE[0x4];                                     // 0x078C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharaUpliftingLightComponent_C*        UpliftingLight;                                    // 0x0790(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_SKILL_TYPE                                  M_BattleVoiceSkillType;                            // 0x0798(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsUpliftingInPreparation;                        // 0x0799(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	E_ATTRIBUTE_TYPE                              M_BattleVoiceSkillAttr;                            // 0x079A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AEF[0x5];                                     // 0x079B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystemComponent*>       M_IgnoreMeshAttachedParticle;                      // 0x07A0(0x0010)(Edit, BlueprintVisible, ContainsInstancedReference)
	class UAnimSequenceBase*                      AnimationRef;                                      // 0x07B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsUpdateAnimation;                                 // 0x07B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	E_SKILL_TARGET                                M_BattleVoiceSkillTarget;                          // 0x07B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AF0[0x6];                                     // 0x07BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharaFloatingComponent_C*              CharaFloatingComp;                                 // 0x07C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCharaStepSmootherComponent_C*          CharaStepSmootherComp;                             // 0x07C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCharaSlopeAdapterComponent_C*          CharaSlopeAdapterComp;                             // 0x07D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UCharaSinkTesterInterface_C*>    CharaSinkTesterComps;                              // 0x07D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<class UCharaLegComponent_C*>           CharaLegComps;                                     // 0x07E8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<class UCharaBodyComponent_C*>          CharaBodyComps;                                    // 0x07F8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<class UCharaHeadComponent_C*>          CharaHeadComps;                                    // 0x0808(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<class UCharaEyeComponent_C*>           CharaEyeComps;                                     // 0x0818(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	class UCharaFaceComponent*                    CharaFaceComp;                                     // 0x0828(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsSilhouette;                                    // 0x0830(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AF1[0x3];                                     // 0x0831(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SaveGazeTarget;                                    // 0x0834(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         GazeUpdate;                                        // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AF2[0x4];                                     // 0x0844(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharaRotateComponent_C*                CharaRotateComponent;                              // 0x0848(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UParticleSystemComponent*>       M_BadStatusParticles;                              // 0x0850(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	class UAtomComponent*                         SE_MagatsuhiDevil;                                 // 0x0860(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UAtomComponent*>                 M_IgnoreAtomComps;                                 // 0x0868(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<class USkeletalMeshComponent*>         CreatedSkelMeshes;                                 // 0x0878(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          M_IsAuraChanged;                                   // 0x0888(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsUpdateIK;                                        // 0x0889(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AF3[0x6];                                     // 0x088A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASkeletalMeshActor*>             CreatedSkelActors;                                 // 0x0890(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	int32                                         M_BattleVoiceSkillID;                              // 0x08A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          LookAtActive;                                      // 0x08A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          LimitLookAtRange;                                  // 0x08A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AF4[0x2];                                     // 0x08A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtRange;                                       // 0x08A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ForceDisableLimitLookAt;                           // 0x08AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2AF5[0x3];                                     // 0x08AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LipClearDelay;                                     // 0x08B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AF6[0x4];                                     // 0x08B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystem*>                M_AbsoluteIgnoreParticleTemplate;                  // 0x08B8(0x0010)(Edit, BlueprintVisible)

public:
	void Evt_Move__DelegateSignature();
	void Evt_Dir__DelegateSignature();
	void Notify_ApplyHit__DelegateSignature();
	void Evt_Tilt__DelegateSignature();
	void Evt_DamageMotionEnd__DelegateSignature();
	void Evt_OnFinishFade__DelegateSignature();
	void ExecuteUbergraph_CharaBase(int32 EntryPoint);
	void BI_SetLipClearDelay(float Delay);
	void BI_ForceDisableLimitLookAt(bool Disable);
	void BI_SetLimitLookAtRange(bool IsActive);
	void StopInstantMaterialAnimation();
	void ControlUplifting();
	void InstantMaterialAnimation_Impl(E_CHARA_MATERIAL_ANIMATION_SLOT Slot, const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward);
	void InstantMaterialAnimationSlot4(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward);
	void InstantMaterialAnimationSlot3(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward);
	void InstantMaterialAnimationSlot2(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward);
	void InstantMaterialAnimationSlot1(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward);
	void InstantMaterialAnimationSlot0(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward);
	void InstantMaterialAnimation(const E_CHARA_MATERIAL_ANIMATION_SLOT Slot, const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward, bool IsOnlyFirstTime);
	void ResetAllParticleSystem();
	void SetCharaPlayRate(float CharaPlayRate);
	void ResetAllMaterialParam();
	void MotionHeadNotifyEvent();
	void OnTransformUpdatedForIK(bool Teleport);
	void ControlBadStatusParticles(float Delata);
	void ControlAura();
	void Evt_C_Dir();
	void Evt_C_Move();
	void PostEvaluateAnimation();
	void UpdateAnimation(float DeltaTime);
	void InitializeAnimation();
	void ReceiveTick(float DeltaSeconds);
	void ReceiveBeginPlay();
	void StopCharaShake();
	void RapidReturnAction();
	void RapidSummonAction(int32 CurrentStatus, bool Immediately);
	void SpawnAction(bool Param_PlayMotion, bool IsInstantEvent);
	void CharaShake(float Magnitude, float DurationSec);
	void ReturnAction(float PlayRate, bool IsInstantEvent);
	void SummonAction(int32 CurrentStatus, bool Immediately, bool IsInstantEvent, bool IsInBattle);
	void ReviveAction();
	void Act_Fusion_Release();
	void Act_Fusion_Prepare();
	void KnockBack(float Distance);
	void ResetBadStatusMaterialParameter();
	void Evt_EndAlmostYugami();
	void Evt_StartAlmostYugami();
	void PrintNames(const class FString& Title, const TArray<class FName>& Names);
	void UpdateSurfaceBadStatus(int32 CurrentStatus);
	void ReplayPresentMotion();
	void BadStatusMaterialOff(const TArray<E_BAD_STATUS>& OffBadStatus);
	void BadStatusMaterialOn(const TArray<E_BAD_STATUS>& OnBadStatus);
	void Evt_ResetBadStatusMaterial();
	void Evt_ResetEffect();
	void Evt_UpdateCharaState(int32 State, bool IsNoCureEffect, bool IsLacerationDamage);
	void ResetCritical();
	void SetCritical();
	void ResetState(int32 State);
	void StopDefaultBlink();
	void PlayDefaultBlink();
	void StopLipSync();
	void PlayLipSync(class UCharaLipSync* Param_PlayLipSync, bool IsLoop);
	void SetAuraMaterial(int32 AuraBit);
	void MapDettachWepon();
	void MapAttachWepon();
	void MapAttackAction();
	void SetState(int32 State);
	void DeathAction(uint8 InOption, bool DeadTimingOverride, float DeadTiming);
	void BI_SetHeadIKSpeed(float Speed);
	void StopSpeakingMotion();
	void PlaySpeakingMotion();
	void BI_SetForceUpdateLookAt(bool IsForceUpdate);
	void BI_TempToggleCameraDitherState(bool ForceDitherOff);
	void BI_GuestBattleFinalize();
	void BI_GuestBattleInitialize(bool Dither100);
	void BI_AdjustMeshScale(bool IsReset);
	void BI_SetDevilRootMotion(bool Enable);
	void BI_PlayStartEffect();
	void OnLoaded_A97098CA4B7318BB42959EAD76578B09(class UObject* Loaded);
	void OnLoaded_7FBAAD3F40145FB17876B482C2BD5698(class UObject* Loaded);
	void OnLoaded_2D74D81C4E9B44BA0E0FFB9ECDECDED5(class UObject* Loaded);
	void OnLoaded_F45D6EED4F92F9BB26E14F8BFD9F4C6D(class UObject* Loaded);
	void OnLoaded_FDBF0C12438F309C9DC5438C37BAF1BA(class UObject* Loaded);
	void MaterialAnimSlot4__UpdateFunc();
	void MaterialAnimSlot4__FinishedFunc();
	void MaterialAnimSlot3__UpdateFunc();
	void MaterialAnimSlot3__FinishedFunc();
	void MaterialAnimSlot2__UpdateFunc();
	void MaterialAnimSlot2__FinishedFunc();
	void MaterialAnimSlot1__UpdateFunc();
	void MaterialAnimSlot1__FinishedFunc();
	void MaterialAnimSlot0__UpdateFunc();
	void MaterialAnimSlot0__FinishedFunc();
	void CharaShakeTimeline__UpdateFunc();
	void CharaShakeTimeline__FinishedFunc();
	void _S____UpdateFunc();
	void _S____FinishedFunc();
	void ForAlmostYugami__UpdateFunc();
	void ForAlmostYugami__FinishedFunc();
	void _________d__UpdateFunc();
	void _________d__FinishedFunc();
	void _____________UpdateFunc_0();
	void _____________FinishedFunc_0();
	void _____________PauseMotion__EventFunc();
	void _____________UpdateFunc();
	void _____________FinishedFunc();
	void UserConstructionScript();
	void PlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool Param_IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime);
	void StopMotion();
	void PauseMotion();
	void ResumeMotion();
	void SetLegIKEnable(bool Enable, bool Immediately);
	void SetHeadIKEnable(bool Enable, bool Immediately);
	void SetEyeIKEnable(bool Enable, bool Immediately);
	void InitializeIK();
	void UpdateIK(float DeltaTime);
	void UpdateSink(float DeltaTime, TArray<class UCharaSinkTesterInterface_C*>& Array, struct FVector* Offset);
	void ApplySinkOffset();
	void LookAt(class USceneComponent* Point, class FName Socket);
	void LoadMotion();
	void InitializeMaterial();
	void OutLineSwitch(bool Value);
	void SelectFresnelSwitch(bool Value);
	void SelectSwitch(bool Value);
	void SetEffectBySocket(class UParticleSystem* TargetEffect, class FName SocketName);
	void GetSocketTransform(class FName SocketName, struct FTransform* RetValue);
	void Act_Death(uint8 InOption, bool DeadTimingOverride, float DeadTiming);
	void GetActionState(E_CHARA_ACTION_TYPE InAction, uint8* RetValue);
	void SetActionState(E_CHARA_ACTION_TYPE InAction, uint8 State);
	void IsActionRun(E_CHARA_ACTION_TYPE InAction, bool* RetValue);
	void ExecuteAction(E_CHARA_ACTION_TYPE InAction, uint8 InOptionByte, int32 InOptionInt, float InOptionFloat);
	void IsMotionFinished(E_CHARA_MOTION_ID Param_MotionID, bool* RetValue);
	void FootGround(bool* IsHit);
	void MoveFunc();
	void MoveTo(float Time, const struct FVector& To);
	void CallEvent(float DeltaTime);
	void DirFunc();
	void DirTo(float InterpValue, const struct FVector& To);
	void Act_RunToUnit(class ACharaBase_C* TargetUnit, float Time, float DirInterp, E_CHARA_MOTION_ID FinishedMotion, float Offset_Dest_Deg);
	void UpdateAction();
	void Act_BackStep(uint8 AvoidDirection);
	void UpdateRunToUnit();
	void UpdateBackStep();
	void GetNowMotionID(E_CHARA_MOTION_ID* RetValue);
	void ResetScalarParam(TArray<class FName>& ParamNames);
	void SetScalarParam(TArray<class FName>& ParamNames, float Val);
	void Act_Revive();
	void SetAuraEffect(class UParticleSystem* EffectTemplate);
	void SetParticleTemplate(class UParticleSystemComponent*& TargetParticleSys, class UParticleSystem* Template, float Scale, bool RelativeScale);
	void SetAura(E_CHARA_AURA_TYPE Param_Aura);
	void RemoveAura(E_CHARA_AURA_TYPE Param_Aura);
	void AdaptAura();
	void GetValidIdolMotionIDs(TArray<E_CHARA_MOTION_ID>* IDs);
	void Act_RunToLocation(const struct FVector& DestLocation, const struct FVector& LookLocation, float Time, float DirInterp, E_CHARA_MOTION_ID FinishedMotion);
	void AdjustValidMotionID(E_CHARA_MOTION_ID Param_MotionID, E_CHARA_MOTION_ID* ValidMotionID);
	void ApplyBadStatus(int32 Status, bool IsNoCureEffect, bool IsLacerationDamage);
	void ParalyzeMotionCtrl();
	void SetBodyIKEnable(bool Enable, bool Immediately);
	void SetNotifyApplyHit(bool IsNotified, E_ANIM_NOTIFY_APPLY_HIT_TYPE NotifyType);
	void IsNotifyApplyHit(bool* IsNotified, TArray<E_ANIM_NOTIFY_APPLY_HIT_TYPE>* NotifyType);
	void ToggleDitherEnable();
	void IsDitherEnable(bool* IsEnable);
	void SetDitherEnable(bool IsEnable);
	void SetAllVisibility(bool IsVisible);
	void Act_RunToLocation_NoDir(const struct FVector& Location, float Time, float DirInterp, E_CHARA_MOTION_ID FinishedMotion);
	void BattlePlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool Param_IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime);
	void UpdateFreeze(int32 NewBadStatus);
	void MoveWorldOffset(const struct FVector& DeltaVec);
	void ApplyBattleCollisionResponse(bool IsBattleSetting);
	void IsSameMotion(E_CHARA_MOTION_ID Param_MotionID, bool* RetValue);
	void HasValidMotion(E_CHARA_MOTION_ID Param_MotionID, bool* RetVal);
	void IsCompletelyDead(bool* RetVal);
	void EventPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime);
	void EventSetMotionRateScale(float MotionRateScale);
	void CalcEffectScale(float* RetVal);
	void ControlTargetEffect();
	void InvokeLegIKImmediately();
	void InvokeHeadIKImmediately();
	void InvokeEyeIKImmediately();
	void InvokeBodyIKImmediately();
	void SetLookAtIKEnable(bool Enable, bool Immediately, bool IncludeEyeIK);
	void InvokeLookAtIKImmediately(bool IncludeEyeIK);
	void InitializeExpression();
	void UpdateExpression(float DeltaTime);
	void SetMumbleEnable(bool Enable);
	void Act_Summon(int32 CurrentStatus, bool IsInBattle);
	void Act_Return(float PlayRate);
	void InvokeFloatingIKImmediately();
	void ResetSink(float Rate);
	void SetDitherDistance(float Distance, float InterpSec);
	void ResetDitherDistance(float InterpSec);
	void UpdateDither(float Delta_time);
	void IsParalyzed(bool* Param_IsParalyzed);
	void SetParalyzed(bool IsParalyzed);
	void SetDitherRate(float Rate, float InterpSec);
	void ResetDitherRate(float InterpSec);
	void ClearNotifyMotionHead();
	void IsNotifyMotionHead(bool* IsNotified);
	void MoveAfterAnimEndCallback(E_CHARA_MOTION_ID Param_MotionID);
	void GetCurrentSurfaceStatusMaterial(TArray<E_BAD_STATUS>* CurrentSurface);
	void SetVectorParam(TArray<class FName>& ParamNames, struct FLinearColor& Val);
	void WatchOnesStepBegin();
	void WatchOnesStepEnd();
	void SetMeshRelativeScale(float NewScale, float NewBoundScale);
	void GetMeshRelativeScale(float* Scale);
	void PerchBegin();
	void PerchEnd();
	class UMaterialAnimDecalComponent_C* SpawnMaterialAnimDecalAttached(class UMaterialInstance* DecalMaterial, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, float OverrideLifeSec, EAttachLocation LocationType, const struct FRotator& Rotation, bool IsCastOnlyStaticMesh);
	void InitializeBoneTrans();
	void InvalidIKBegin(class FName Param_Name, int32 Param_Index);
	void InvalidIKEnd(class FName Param_Name, int32 Param_Index);
	void CreateBadStatusPSComp(class UParticleSystemComponent** PSComp);
	void CommonEffectOff();
	void AttachClockingParticleSystem(class UParticleSystem* EmitterTemplate, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, bool IsCastShadow, bool bAutoDestroy);
	void GetCharaPlayRate(float* PlayRate);
	void ControlEffectPlayRate();
	void GetCurrentTime(float* Time);
	void SetRunToUnitMotion(E_CHARA_MOTION_ID Param_Motion);
	void SetNotifyDeadTiming(bool IsNotified);
	void IsNotifyDeadTiming(bool* IsNotified);
	void DamageAnimEndCallBack(E_CHARA_MOTION_ID Param_MotionID);
	void CalcBattleCameraScale(float* RetVal);
	void InitializeBounds();
	void RemoveAuraImmediately();
	void InitializeBadStatus();
	void PushCue_RunToLocation(const struct FVector& DestLocation, const struct FVector& LookLocation, float Time, float DirInterp);
	void IsEmptyCue_RunToLocation(bool* IsEmpty);
	void PopCue_RunToLocation(bool* IsValid, struct FCharaMoveParam* MoveParam, float* DirInterp);
	void SetNotifySkillFire(bool IsNotified);
	void IsNotifySkillFire(bool* IsNotified);
	void Act_Fade(bool IsFadeOut, float InterpSec);
	void SetScalarParamByArray(TArray<class UMaterialInstanceDynamic*>& Material, TArray<class FName>& ParamNames, float Val);
	void SetVectorParamByArray(TArray<class UMaterialInstanceDynamic*>& Material, TArray<class FName>& ParamNames, struct FLinearColor& Val);
	void RetrieveDMIs(TArray<int32>& ElementNo, TArray<class UMaterialInstanceDynamic*>* Materials);
	void CalcMaterialAnimSettingSec(TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, float* Sec);
	void InitAnimNotifyEffectData();
	void GetPreviousMotionID(E_CHARA_MOTION_ID* RetValue);
	void SetNowMotionID(E_CHARA_MOTION_ID MotionIDCurrent);
	void SetPreviousMotionID(E_CHARA_MOTION_ID Param_MotionID);
	void SetAlreadyChangeEnableEffect(class FName IsChanged);
	void GetAlreadyChangeEnableEffect(class FName Key, bool* IsChahged);
	void SetAlreadyChangeEnableDecal(class FName Key);
	void GetAlreadyChangeEnableDecal(class FName Key, bool* IsChanged);
	void SetMotionIsUseDuration(bool Param_IsUseDuration);
	void SetMotionDuration(float Duration);
	void SetIsUseBlendTime(bool IsUseBlendTime);
	void SetBlendTime(float BlendTime);
	void GetParalyzed(bool* Paralyzed);
	void IsFreezeMotion(bool* Param_M_IsFreezeMotion);
	void IsUseDuration(bool* Param_IsUseDuration);
	void Act_Spawn(bool PlayMotion);
	void SetNotifyWarpTiming(bool IsNotified);
	void IsNotifyWarpTiming(bool* IsNotified);
	void SetDefaultIdleMotion(E_CHARA_MOTION_ID Default_Idle);
	void GetDefaultIdleMotion(E_CHARA_MOTION_ID* Idle);
	void BattleMotionAnimEndCallBack(E_CHARA_MOTION_ID Param_MotionID);
	void InsertBatttlePlayMotionEndCallBack();
	void CheckUpdateIK(bool* ClacIK, int32* DeltaRate);
	void IsMaterialSlotPlaying(E_CHARA_MATERIAL_ANIMATION_SLOT Slot, bool* IsPlaying);
	void OnFinishDitherRate(E_CHARA_ACTION_TYPE CharaAction);
	void Get_BPI_CharaBaseAccessor(TScriptInterface<class IBPI_CharaBaseAccessor_C>* DataGetter);
	float CalcBadStatusEffectScale();
	void IsRapidReturnActionNow(bool* RetValue);
	void GetCurrentVisibility(bool* IsVisible);
	void Act_RapidSummon(int32 CurrentStatus, bool Immediately);
	void Act_RapidReturn(float PlayRate);
	void SetRapidReturnTiming(bool IsNotified);
	void IsNotifyRapidReturnTiming(bool* IsNotified);
	void SetNotifyDeadVoice(class USoundAtomCue* DeadVoice);
	void GetNotifyDeadVoice(class USoundAtomCue** DeadVoice);
	void GetBadStatusNames(TArray<E_BAD_STATUS>& BadStatus, TArray<class FName>* Names);
	void IsPauseMotion(bool* Paused);
	void StackPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime);
	void ResetAllParam();
	void SetUplifting(bool IsUplifting);
	void ActivateAttachedParticles();
	void DeactivateAttachedParticles(bool NoDestroyComponent);
	void RememberMeshAttachedParticles();
	void Cancel_RunToUnit();
	void GetMeshAttachedParticle(TArray<class UParticleSystemComponent*>* MeshAttachedParticle);
	float CalcMotionBlendTime(float Default);
	void GetCharaMotion(E_CHARA_MOTION_ID ID, struct FCharaMotion* CharaMotion, bool* IsValid);
	void CalcUpliftingEffectScale(float* RetVal);
	void ActivateParticleHolderAttachedParticles();
	void SetResidentSE(bool Activate);
	void IsPlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool* IsPlay);
	void BattleStopMotion();
	void CalcHugeBattleCameraScale(float* RetVal);
	void InitializeAnimNotify();
	void SetEnableCollision(bool Enable);
	void SetCollisionObjectType(ECollisionChannel Channel);
	void IsCalledAtInstantEvent(bool* Valid);
	void IsCharaShaking(bool* Shaking);
	void DeactivateBattleSpringArm();
	void ActivateBattleSpringArm();
	void CallEvent_Battle(float DeltaTime);
	void SetBattleSpringArmScale(float CalcedScale, bool IsHugeBattle);
	void DestroyAttachedParticles();
	void SetMoveTotalTime(float TotalTime);
	void SetParticlePlayRate(float Rate);
	void SetParticleHolderParticlesPlayRate(float Rate);
	void GetValidMotionIDs(TArray<E_CHARA_MOTION_ID>& CheckIDs, TArray<E_CHARA_MOTION_ID>* Valid_IDs);
	const class UCharaParamComponent* GetCharaParam();
	void RemoveAllMaterialAnimDecalAttached();
	void SetCharaPlayRateImpl(float Param_M_CharaPlayRate);
	void InitializePoseWeightTable();
	void LookAtCalc();
	void CheckNaviDevil(bool* NaviDevil);
	void SetIsUpdateAnimation(bool Update, bool* Ret);
	void SetAlwaysAutoTransitionAnimationMode(bool Check, bool* NotUse);
	void SetIsUpdateIK(bool Update, bool* Ret);
	void SetAttackAimLocation(const struct FVector& GrobalLocation, bool* NoUse);
	void BI_PlayMapAction(E_MapAction_Pla603 Action, bool* CanUse);
	void BI_EndMapAction(bool* CanUse);
	void BI_IsMapActionPlaying(bool* IsPlaying);
	void BI_SetNPCCollision(bool* Ret);
	void BI_GetMeshComponent(class UMeshComponent** MeshComp);
	void BI_GetPlayRate(float* PlayRate);
	void BI_GetEffectScale(float* EffectScale);
	void BI_GetCharaParamComponent(class UCharaParamComponent** Comp);
	void BI_GetCapsuleComponent(class UCapsuleComponent** Param);
	void BI_GetActorRotation(struct FRotator* Rotation);
	void BI_ResetScalarParam(TArray<class FName>& ParamNames, bool* NoUs);
	void BI_SetActionState(const E_CHARA_ACTION_TYPE InAction, uint8 State, bool* NoUse);
	void BI_CreateBadStatusPSComp(class UParticleSystemComponent** PSComp);
	void BI_BadStatusMaterialOff(const TArray<E_BAD_STATUS>& OffBadStatus, bool* NoUse);
	void BI_EvtResetBadStatusMaterial(bool* NoUse);
	void BI_EvtResetEffect(bool* NoUse);
	void BI_BadStatusMaterialOn(TArray<E_BAD_STATUS>& OnBadStatus, bool* NoUse);
	void BI_ResetState(int32 State, bool* NoUse);
	void BI_SetNotifyApplyHit(bool IsNotified, E_ANIM_NOTIFY_APPLY_HIT_TYPE NotifyType, bool* NoUse);
	void BI_InvalidIKEnd(class FName Param_Name, int32 Param_Index, bool* NoUse);
	void BI_SpawnMaterialAnimDecalAttached(const class UMaterialInstance*& DecalMaterial, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSettings, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, float OverrideLifeSec, uint8 LocationType, const struct FRotator& Rotation, class UMaterialAnimDecalComponent_C** Comp);
	void BI_GetAlreadyChangeEnableDecal(class FName Key, bool* IsChanged);
	void BI_SetAlreadyChangeEnableDecal(class FName Key, bool* NoUse);
	void BI_GetAlreadyChangeEnableEffect(class FName Key, bool* IsChanged);
	void BI_SetAlreadyChangeEnableEffect(class FName Key, bool* NoUse);
	void BI_PlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime, bool* NoUse);
	void BI_SetNotifyDeadTiming(bool IsNotified, bool* NoUse);
	void BI_InstantMaterialAnimation(E_CHARA_MATERIAL_ANIMATION_SLOT Slot, const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSettings, bool IsForward, bool IsOnlyFirstTime, bool* NoUse);
	void BI_AttachClockingParticleSystem(const class UParticleSystem*& EmitterTemplate, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, uint8 LocationType, const bool IsCastShadow, const bool AutoDestroy, bool* NoUse);
	void BI_SetNotifySkillFire(bool IsNotified, bool* NoUse);
	void BI_SetNotifyWarpTiming(bool IsNotified, bool* NoUse);
	void BI_PerchEnd(bool* NoUse);
	void BI_PerchBegin(bool* NoUse);
	void BI_WatchOnesStepEnd(bool* NoUse);
	void BI_WatchOnesStepBegin(bool* NoUse);
	void BI_InvalidIKBegin(class FName Param_Name, int32 Param_Index, bool* NoUse);
	void BI_SetParticleTemplate(const class UParticleSystemComponent*& TargetParticleSys, class UParticleSystem* Template, float Scale, bool* NoUse);
	void BI_GetCurrentSurfaceStatusMaterial(TArray<E_BAD_STATUS>* CurrentSurface);
	void BI_GetActionState(E_CHARA_ACTION_TYPE InAction, uint8* Value);
	void BI_EventPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime, bool* NoUse);
	void BI_SetCompletelyDead(bool IsDead, bool* NoUse);
	void BI_SetAllVisibility(bool IsVisible, bool* NoUse);
	void BI_InitializeMaterial(bool* No_Use);
	void BI_CommonEffectOff(bool* NoUse);
	void BI_PauseMotion(bool* NoUse);
	void BI_UpdateSurfaceBadStatus(int32 CurrentStatus, bool* NoUse);
	void BI_SetScalarParam(const TArray<class FName>& Param_Names, float Value, bool* No_Use);
	void BI_SetScalarParamByArray(const TArray<class UMaterialInstanceDynamic*>& Material, const TArray<class FName>& Param_Names, const float Value, bool* No_Use);
	void BI_GetSocketTransform(class FName SocketName, struct FTransform* RetVal);
	void BI_IsNotifyDeadTiming(bool* IsNotified);
	void BI_GetMeshRelativeScale(float* Scale);
	void BI_SetMeshRelativeScale(float NewScale, float NewBoundsScale, bool* NoUse);
	void BI_GetBadStatusEffectScale(float* Scale);
	void BI_SetNotifyRapidReturnTiming(bool IsNotified, bool* NoUse);
	void BI_IsNotifyRapidReturnTiming(bool* IsNotified);
	void BI_ApplyMaterialParam(class UMaterialParameterApplier* ParamApplier, bool* NoUse);
	void BI_GetTimeLineComponent(E_BTL_DEAD_EFFECT DeadEffect, class UTimelineComponent** Comp);
	void BI_SetVectorParam(TArray<class FName>& Param_Names, const struct FLinearColor& Vector, bool* No_Use);
	void BI_LookAt(class USceneComponent* Point, class FName Socket, bool* NoUse);
	void BI_GetSkeletalMeshComponents(TArray<class USkeletalMeshComponent*>* Meshes);
	void BI_SetNotifyDeadVoice(class USoundAtomCue* Voice, bool* NoUse);
	void BI_GetNotifyDeadVoice(class USoundAtomCue** Voice);
	void BI_RetrieveMotionNotifyNames(E_CHARA_MOTION_ID Param_Motion, TArray<class FString>* Names);
	void BI_CalcBattleCameraScale(float* Scale);
	void BI_GetMeshComponents(TArray<class UMeshComponent*>* Meshes);
	void BI_PlayDefaultBlink(bool* NoUse);
	void BI_StopDefaultBlink(bool* NoUse);
	void BI_StackPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime, bool* NoUse);
	void BI_ResetAllParam(bool* NoUse);
	void BI_StopMotion(bool* NoUse);
	void BI_GetMotionComponent(class UCharaMotionPlayerComponent** MotionComponent);
	void BI_GetEnableChangeMotion(bool* IsEnable);
	void BI_SetEnableChangeMotion(bool Enable, bool* NoUse);
	void BI_SetSkillPerformDuration(bool IsTrue, bool* NoUse);
	void BI_GetSkillPerformDuration(bool* IsTrue);
	void BI_GetPlayBlink(bool* IsPlay);
	void BI_PlayBlinkToNotify(bool* NoUse);
	void BI_StopBlinkToNotify(bool* NoUse);
	void BI_GetVoiceSkillType(E_SKILL_TYPE* Type);
	void BI_SetVoiceSkillType(E_SKILL_TYPE Type, bool* NoUse);
	void BI_SetElectrification(bool Enable, bool* NoUse);
	void BI_SetDitherEnable(bool Enable, bool* No_Use);
	void BI_SetDitherRate(float InRate, float InInterpSec, bool* No_Use);
	void BI_ResetDitherRate(float InInterpSec, bool* No_Use);
	void BI_SetVoiceSkillAttr(E_ATTRIBUTE_TYPE SkillAttr, bool* NoUse);
	void BI_GetVoiceSkillAttr(E_ATTRIBUTE_TYPE* SkillAttr);
	void BI_IsPlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool* IsPlay);
	void BI_SetFacial(class FName Facial, float BlendTimeOverride, bool* NotUse);
	void BI_GetDefaultAnimation(class UAnimSequenceBase** Ret);
	void BI_GetAnimInstance(class UAnimInstance** Ret);
	void BI_InvokeLookAtIKImmediately(bool IncludeEyeIK, bool* NoUse);
	void BI_IKEnableFlag(E_IK_TYPE_LIST Type, bool Enable, bool Immediately, bool* NoUse);
	void BI_CalcEffectScale(float* Scale);
	void BI_SetVoiceSkillTarget(E_SKILL_TARGET Target, bool* NoUse);
	void BI_GetVoiceSkillTarget(E_SKILL_TARGET* Target);
	void BI_GetDefaultIdleMotion(E_CHARA_MOTION_ID* Param_Motion);
	void BI_SetDefaultIdleMotion(E_CHARA_MOTION_ID Param_Motion, bool* NoUse);
	void BI_SetEnableCollision(bool Enable, bool* NoUse);
	void BI_SetCollisionObjectType(ECollisionChannel Channel, bool* NoUse);
	void BI_IsCharaShaking(bool* Shaking);
	void BI_StopCharaShake(bool* NoUse);
	void BI_GetForceRotate(bool* Ret);
	void BI_BattlePlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime, bool* NoUse);
	void BI_BattleStopMotion(bool* NoUse);
	void BI_EnableSilhouette(bool IsEnable, bool* NoUse);
	void BI_IsSilhouetteEnabled(bool* IsEnabled);
	void BI_FloatNoRotation(bool NoRotation, bool* NoUse);
	void BI_GetParentChara(TScriptInterface<class IBPI_CharaBaseAccessor_C>* Parent, bool* IsExist);
	void BI_CheckIgnoreAtomComp(class UAtomComponent*& IgnoreComp, bool* IsIgnoreID);
	void BI_AddIgnoreAtomComp(class UAtomComponent*& IgnoreComp, bool* NoUse);
	void BI_CreateSkeletalMeshComp(class USkeletalMeshComponent** SkelMeshComp);
	void BI_DestroySkeletalMeshComp(class USkeletalMeshComponent* SkelMeshComp, bool* NoUse);
	void BI_RemoveAllMaterialAnimDecalAttached(bool* NoUse);
	void BI_CreateSkeletalMeshActor(class ASkeletalMeshActor** SkelMeshActor);
	void BI_SetAnimBP(class UAnimInstance* AnimInstance, bool* NoUse);
	void BI_DestroySkeletalMeshActor(class ASkeletalMeshActor* SkelActor, bool* NoUse);
	void BI_GetSkeletalMeshActors(TArray<class ASkeletalMeshActor*>* SkelMeshActors);
	void BI_DeactivateAttachedParticles(bool NoDestroyComponent, bool* NoUse);
	void BI_ActivateAttachedParticles(bool* NoUse);
	void BI_SetVoiceSkillID(int32 SkillId, bool* NoUse);
	void BI_GetVoiceSkillID(int32* SkillId);
	void BI_DirectPlayMotion(class UAnimSequenceBase* DefaultAnim, class UAnimSequenceBase* LoopAnim, float MotionBlendTime, float StartOffsetTime, bool* NoUse);

	bool IsWatchingOnesStep() const;
	bool IsPerching() const;
	void GetMoveParam(struct FCharaMoveParam* MoveParam) const;
	void GetMoveTotalTime(float* Time) const;
	bool CheckPlayAnimNotifyDevilVoice(EDevilVoiceType DevilVoiceType) const;
	bool CheckMagatsuhiDevil() const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"CharaBase_C">();
	}
	static class ACharaBase_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharaBase_C>();
	}
};
static_assert(alignof(ACharaBase_C) == 0x000008, "Wrong alignment on ACharaBase_C");
static_assert(sizeof(ACharaBase_C) == 0x0008C8, "Wrong size on ACharaBase_C");
static_assert(offsetof(ACharaBase_C, UberGraphFrame) == 0x0002E8, "Member 'ACharaBase_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Uplifting) == 0x0002F0, "Member 'ACharaBase_C::Uplifting' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, NkmAreaBox) == 0x0002F8, "Member 'ACharaBase_C::NkmAreaBox' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaBadStatus) == 0x000300, "Member 'ACharaBase_C::CharaBadStatus' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaSmearFrameComponent) == 0x000308, "Member 'ACharaBase_C::CharaSmearFrameComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Aura) == 0x000310, "Member 'ACharaBase_C::Aura' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, TargetPoint) == 0x000318, "Member 'ACharaBase_C::TargetPoint' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ParticleHolder) == 0x000320, "Member 'ACharaBase_C::ParticleHolder' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Motion) == 0x000328, "Member 'ACharaBase_C::Motion' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaParam) == 0x000330, "Member 'ACharaBase_C::CharaParam' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, SinkHelper) == 0x000338, "Member 'ACharaBase_C::SinkHelper' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ___________val_496EF3A34B39672AA7B9A3966BB83C0E) == 0x000340, "Member 'ACharaBase_C::___________val_496EF3A34B39672AA7B9A3966BB83C0E' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ____________Direction_496EF3A34B39672AA7B9A3966BB83C0E) == 0x000344, "Member 'ACharaBase_C::____________Direction_496EF3A34B39672AA7B9A3966BB83C0E' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, _________d) == 0x000348, "Member 'ACharaBase_C::_________d' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ____________value_3D3DCBFD4432B7B25C9C1F93EA34E7FB) == 0x000350, "Member 'ACharaBase_C::____________value_3D3DCBFD4432B7B25C9C1F93EA34E7FB' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, _____________Direction_3D3DCBFD4432B7B25C9C1F93EA34E7FB) == 0x000354, "Member 'ACharaBase_C::_____________Direction_3D3DCBFD4432B7B25C9C1F93EA34E7FB' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ___________) == 0x000358, "Member 'ACharaBase_C::___________' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ____________value_975ED5724FF6DF59285EBA8C22F8464D) == 0x000360, "Member 'ACharaBase_C::____________value_975ED5724FF6DF59285EBA8C22F8464D' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, _____________Direction_975ED5724FF6DF59285EBA8C22F8464D) == 0x000364, "Member 'ACharaBase_C::_____________Direction_975ED5724FF6DF59285EBA8C22F8464D' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ____________0) == 0x000368, "Member 'ACharaBase_C::____________0' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ForAlmostYugami_ParamValue_47524AA947083F3E0EC1298A624F39D7) == 0x000370, "Member 'ACharaBase_C::ForAlmostYugami_ParamValue_47524AA947083F3E0EC1298A624F39D7' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ForAlmostYugami__Direction_47524AA947083F3E0EC1298A624F39D7) == 0x000374, "Member 'ACharaBase_C::ForAlmostYugami__Direction_47524AA947083F3E0EC1298A624F39D7' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ForAlmostYugami) == 0x000378, "Member 'ACharaBase_C::ForAlmostYugami' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot4_Anim_06D06D684A3FDF97E270E4822BBE1A67) == 0x000380, "Member 'ACharaBase_C::MaterialAnimSlot4_Anim_06D06D684A3FDF97E270E4822BBE1A67' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot4__Direction_06D06D684A3FDF97E270E4822BBE1A67) == 0x000384, "Member 'ACharaBase_C::MaterialAnimSlot4__Direction_06D06D684A3FDF97E270E4822BBE1A67' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot4) == 0x000388, "Member 'ACharaBase_C::MaterialAnimSlot4' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot3_Anim_D188A2D1436F7664952EC99682631DDE) == 0x000390, "Member 'ACharaBase_C::MaterialAnimSlot3_Anim_D188A2D1436F7664952EC99682631DDE' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot3__Direction_D188A2D1436F7664952EC99682631DDE) == 0x000394, "Member 'ACharaBase_C::MaterialAnimSlot3__Direction_D188A2D1436F7664952EC99682631DDE' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot3) == 0x000398, "Member 'ACharaBase_C::MaterialAnimSlot3' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot2_Anim_8C863F1B4BB9D227E84B8F93F67A4ACA) == 0x0003A0, "Member 'ACharaBase_C::MaterialAnimSlot2_Anim_8C863F1B4BB9D227E84B8F93F67A4ACA' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot2__Direction_8C863F1B4BB9D227E84B8F93F67A4ACA) == 0x0003A4, "Member 'ACharaBase_C::MaterialAnimSlot2__Direction_8C863F1B4BB9D227E84B8F93F67A4ACA' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot2) == 0x0003A8, "Member 'ACharaBase_C::MaterialAnimSlot2' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot1_Anim_504772B14C9A90A8FBAE75A1A5414440) == 0x0003B0, "Member 'ACharaBase_C::MaterialAnimSlot1_Anim_504772B14C9A90A8FBAE75A1A5414440' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot1__Direction_504772B14C9A90A8FBAE75A1A5414440) == 0x0003B4, "Member 'ACharaBase_C::MaterialAnimSlot1__Direction_504772B14C9A90A8FBAE75A1A5414440' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot1) == 0x0003B8, "Member 'ACharaBase_C::MaterialAnimSlot1' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaShakeTimeline__Direction_B529E1B646FF2C0D6B73E69D9569813A) == 0x0003C0, "Member 'ACharaBase_C::CharaShakeTimeline__Direction_B529E1B646FF2C0D6B73E69D9569813A' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaShakeTimeline) == 0x0003C8, "Member 'ACharaBase_C::CharaShakeTimeline' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot0_Anim_935A1B33450864D2C3AA9A8ABB4B2264) == 0x0003D0, "Member 'ACharaBase_C::MaterialAnimSlot0_Anim_935A1B33450864D2C3AA9A8ABB4B2264' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot0__Direction_935A1B33450864D2C3AA9A8ABB4B2264) == 0x0003D4, "Member 'ACharaBase_C::MaterialAnimSlot0__Direction_935A1B33450864D2C3AA9A8ABB4B2264' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimSlot0) == 0x0003D8, "Member 'ACharaBase_C::MaterialAnimSlot0' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, _____UnionVal_6645B41F4C052DF4379AC5941088DC74) == 0x0003E0, "Member 'ACharaBase_C::_____UnionVal_6645B41F4C052DF4379AC5941088DC74' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ______Direction_6645B41F4C052DF4379AC5941088DC74) == 0x0003E4, "Member 'ACharaBase_C::______Direction_6645B41F4C052DF4379AC5941088DC74' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, _S__) == 0x0003E8, "Member 'ACharaBase_C::_S__' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MotionID) == 0x0003F0, "Member 'ACharaBase_C::MotionID' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MotionIDPrevious) == 0x0003F1, "Member 'ACharaBase_C::MotionIDPrevious' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, LegIKEnableFlag) == 0x0003F2, "Member 'ACharaBase_C::LegIKEnableFlag' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, HeadIKEnableFlag) == 0x0003F3, "Member 'ACharaBase_C::HeadIKEnableFlag' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, EyeIKEnableFlag) == 0x0003F4, "Member 'ACharaBase_C::EyeIKEnableFlag' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, BodyIKEnableFlag) == 0x0003F5, "Member 'ACharaBase_C::BodyIKEnableFlag' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, FloatingIKEnableFlag) == 0x0003F6, "Member 'ACharaBase_C::FloatingIKEnableFlag' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, WatchOnesStepCount) == 0x0003F8, "Member 'ACharaBase_C::WatchOnesStepCount' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, PerchCount) == 0x0003FC, "Member 'ACharaBase_C::PerchCount' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, FloatingIKPerch) == 0x000400, "Member 'ACharaBase_C::FloatingIKPerch' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, SinkActorOffset) == 0x000404, "Member 'ACharaBase_C::SinkActorOffset' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, LookAtComponent) == 0x000408, "Member 'ACharaBase_C::LookAtComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, LookAtSocket) == 0x000410, "Member 'ACharaBase_C::LookAtSocket' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ActionState) == 0x000418, "Member 'ACharaBase_C::ActionState' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MoveParam) == 0x000428, "Member 'ACharaBase_C::M_MoveParam' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MoveTotalTime) == 0x000460, "Member 'ACharaBase_C::M_MoveTotalTime' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_CurrentTime) == 0x000464, "Member 'ACharaBase_C::M_CurrentTime' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Evt_Move) == 0x000468, "Member 'ACharaBase_C::Evt_Move' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsMoving) == 0x000478, "Member 'ACharaBase_C::M_IsMoving' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Evt_Dir) == 0x000480, "Member 'ACharaBase_C::Evt_Dir' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_DirTargetRot) == 0x000490, "Member 'ACharaBase_C::M_DirTargetRot' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_DirInterp) == 0x00049C, "Member 'ACharaBase_C::M_DirInterp' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsDirMoving) == 0x0004A0, "Member 'ACharaBase_C::M_IsDirMoving' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_FinishedMotion) == 0x0004A1, "Member 'ACharaBase_C::M_FinishedMotion' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_CurrentBadStatus) == 0x0004A4, "Member 'ACharaBase_C::M_CurrentBadStatus' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsReservePauseMotion) == 0x0004A8, "Member 'ACharaBase_C::M_IsReservePauseMotion' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, BadStatusOpacity) == 0x0004B0, "Member 'ACharaBase_C::BadStatusOpacity' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CriticalOpacity) == 0x0004C0, "Member 'ACharaBase_C::CriticalOpacity' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_Aura) == 0x0004D0, "Member 'ACharaBase_C::M_Aura' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_AdaptedAuraIndex) == 0x0004D4, "Member 'ACharaBase_C::M_AdaptedAuraIndex' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, AlwaysAutoTransitionAnimationMode) == 0x0004D8, "Member 'ACharaBase_C::AlwaysAutoTransitionAnimationMode' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Notify_ApplyHit) == 0x0004E0, "Member 'ACharaBase_C::Notify_ApplyHit' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsBeginFinishMotion) == 0x0004F0, "Member 'ACharaBase_C::M_IsBeginFinishMotion' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_FinishMotionBeginTime) == 0x0004F4, "Member 'ACharaBase_C::M_FinishMotionBeginTime' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_FinishMotionBlendTime) == 0x0004F8, "Member 'ACharaBase_C::M_FinishMotionBlendTime' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsInterpFinishMotion) == 0x0004FC, "Member 'ACharaBase_C::M_IsInterpFinishMotion' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Evt_Tilt) == 0x000500, "Member 'ACharaBase_C::Evt_Tilt' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_PrevBadStatus) == 0x000510, "Member 'ACharaBase_C::M_PrevBadStatus' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_CurrentSurfaceStatus) == 0x000514, "Member 'ACharaBase_C::M_CurrentSurfaceStatus' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsNeedResetMaterial) == 0x000515, "Member 'ACharaBase_C::M_IsNeedResetMaterial' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsParalyzed) == 0x000516, "Member 'ACharaBase_C::M_IsParalyzed' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, PoseWeightTable) == 0x000518, "Member 'ACharaBase_C::PoseWeightTable' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsNotifyApplyHit) == 0x000520, "Member 'ACharaBase_C::M_IsNotifyApplyHit' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BadParticleSettingsOn) == 0x000528, "Member 'ACharaBase_C::M_BadParticleSettingsOn' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BadParticleSettingsOff) == 0x000538, "Member 'ACharaBase_C::M_BadParticleSettingsOff' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_InitialVisibility) == 0x000548, "Member 'ACharaBase_C::M_InitialVisibility' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MotionBlendTime) == 0x00054C, "Member 'ACharaBase_C::M_MotionBlendTime' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MotionIsUseDuration) == 0x000550, "Member 'ACharaBase_C::M_MotionIsUseDuration' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MotionDuration) == 0x000554, "Member 'ACharaBase_C::M_MotionDuration' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MotionIsUseBlendTime) == 0x000558, "Member 'ACharaBase_C::M_MotionIsUseBlendTime' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsFreezeMotion) == 0x000559, "Member 'ACharaBase_C::M_IsFreezeMotion' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_NotifyType) == 0x000560, "Member 'ACharaBase_C::M_NotifyType' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsCompletelyDead) == 0x000570, "Member 'ACharaBase_C::M_IsCompletelyDead' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_EnableFollowTargetEffect) == 0x000571, "Member 'ACharaBase_C::M_EnableFollowTargetEffect' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_TargetSocketName) == 0x000574, "Member 'ACharaBase_C::M_TargetSocketName' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BadStatusLoopParticles) == 0x000580, "Member 'ACharaBase_C::M_BadStatusLoopParticles' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_CurrentSurfaceStatusMaterial) == 0x0005D0, "Member 'ACharaBase_C::M_CurrentSurfaceStatusMaterial' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_ValidBadStatus) == 0x0005D8, "Member 'ACharaBase_C::M_ValidBadStatus' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsShowAllBadStatus) == 0x0005E8, "Member 'ACharaBase_C::M_IsShowAllBadStatus' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_LoadingBadSettings) == 0x0005F0, "Member 'ACharaBase_C::M_LoadingBadSettings' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_OffMaterialParamNames) == 0x000600, "Member 'ACharaBase_C::M_OffMaterialParamNames' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsBattleAnimationPlaying) == 0x000610, "Member 'ACharaBase_C::M_IsBattleAnimationPlaying' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsMotionHeadNotify) == 0x000611, "Member 'ACharaBase_C::M_IsMotionHeadNotify' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MeshRelativeScale) == 0x000614, "Member 'ACharaBase_C::M_MeshRelativeScale' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MoveAmount) == 0x000618, "Member 'ACharaBase_C::M_MoveAmount' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BadStatsParam) == 0x000628, "Member 'ACharaBase_C::M_BadStatsParam' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BadParticleSettingsUpdate) == 0x000638, "Member 'ACharaBase_C::M_BadParticleSettingsUpdate' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BadParticleSettingsReset) == 0x000648, "Member 'ACharaBase_C::M_BadParticleSettingsReset' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_InitializeMaterialOnBeginPlay) == 0x000658, "Member 'ACharaBase_C::M_InitializeMaterialOnBeginPlay' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_CharaPlayRate) == 0x00065C, "Member 'ACharaBase_C::M_CharaPlayRate' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_ControledPSCs) == 0x000660, "Member 'ACharaBase_C::M_ControledPSCs' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_RunToUnitMotion) == 0x000664, "Member 'ACharaBase_C::M_RunToUnitMotion' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsAnnouncedInvalidMotionTable) == 0x000665, "Member 'ACharaBase_C::M_IsAnnouncedInvalidMotionTable' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsNotifyDeadTiming) == 0x000666, "Member 'ACharaBase_C::M_IsNotifyDeadTiming' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Evt_DamageMotionEnd) == 0x000668, "Member 'ACharaBase_C::Evt_DamageMotionEnd' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MoveParamCue) == 0x000678, "Member 'ACharaBase_C::M_MoveParamCue' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_DirInterpCue) == 0x000688, "Member 'ACharaBase_C::M_DirInterpCue' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsNotifySkillFire) == 0x000698, "Member 'ACharaBase_C::M_IsNotifySkillFire' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_CharaShakeDir) == 0x00069C, "Member 'ACharaBase_C::M_CharaShakeDir' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_CharaShakeNextDir) == 0x0006A8, "Member 'ACharaBase_C::M_CharaShakeNextDir' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsUsedSlot) == 0x0006B8, "Member 'ACharaBase_C::M_IsUsedSlot' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsAlreadyChangeEnableEffect) == 0x0006C8, "Member 'ACharaBase_C::M_IsAlreadyChangeEnableEffect' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsAlreadyChangeEnableDecal) == 0x0006D8, "Member 'ACharaBase_C::M_IsAlreadyChangeEnableDecal' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsNotifyWarpTiming) == 0x0006E8, "Member 'ACharaBase_C::M_IsNotifyWarpTiming' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_DefaultIdleMotion) == 0x0006E9, "Member 'ACharaBase_C::M_DefaultIdleMotion' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_DefaultMeshOffset) == 0x0006EC, "Member 'ACharaBase_C::M_DefaultMeshOffset' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CalcIKMax) == 0x0006F8, "Member 'ACharaBase_C::CalcIKMax' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CalcIKCount) == 0x0006FC, "Member 'ACharaBase_C::CalcIKCount' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CalcIKForceTrue) == 0x000700, "Member 'ACharaBase_C::CalcIKForceTrue' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CalcIKEventMode) == 0x000701, "Member 'ACharaBase_C::CalcIKEventMode' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MaterialAnimCore) == 0x000708, "Member 'ACharaBase_C::MaterialAnimCore' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Evt_OnFinishFade) == 0x000710, "Member 'ACharaBase_C::Evt_OnFinishFade' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_AlmostYugamiParamName) == 0x000720, "Member 'ACharaBase_C::M_AlmostYugamiParamName' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_SpringArmUp_InitialLength) == 0x000730, "Member 'ACharaBase_C::M_SpringArmUp_InitialLength' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, Ref_SpringArm_Up) == 0x000738, "Member 'ACharaBase_C::Ref_SpringArm_Up' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsRapidReturnActionNow) == 0x000740, "Member 'ACharaBase_C::M_IsRapidReturnActionNow' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsNotifyRapidReturnTiming) == 0x000741, "Member 'ACharaBase_C::M_IsNotifyRapidReturnTiming' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_NotifyDeadVoice) == 0x000748, "Member 'ACharaBase_C::M_NotifyDeadVoice' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_OnMaterialApplier) == 0x000750, "Member 'ACharaBase_C::M_OnMaterialApplier' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsUplifting) == 0x000760, "Member 'ACharaBase_C::M_IsUplifting' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_MeshAttachedParticle) == 0x000768, "Member 'ACharaBase_C::M_MeshAttachedParticle' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, MumbleTime) == 0x000778, "Member 'ACharaBase_C::MumbleTime' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, BlinkAsset) == 0x000780, "Member 'ACharaBase_C::BlinkAsset' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsNotifyEnableChangeMotion) == 0x000788, "Member 'ACharaBase_C::M_IsNotifyEnableChangeMotion' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsNotifyInSkillPerformDuration) == 0x000789, "Member 'ACharaBase_C::M_IsNotifyInSkillPerformDuration' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, UseBlink) == 0x00078A, "Member 'ACharaBase_C::UseBlink' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, IsBlinkToNotify) == 0x00078B, "Member 'ACharaBase_C::IsBlinkToNotify' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, UpliftingLight) == 0x000790, "Member 'ACharaBase_C::UpliftingLight' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BattleVoiceSkillType) == 0x000798, "Member 'ACharaBase_C::M_BattleVoiceSkillType' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsUpliftingInPreparation) == 0x000799, "Member 'ACharaBase_C::M_IsUpliftingInPreparation' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BattleVoiceSkillAttr) == 0x00079A, "Member 'ACharaBase_C::M_BattleVoiceSkillAttr' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IgnoreMeshAttachedParticle) == 0x0007A0, "Member 'ACharaBase_C::M_IgnoreMeshAttachedParticle' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, AnimationRef) == 0x0007B0, "Member 'ACharaBase_C::AnimationRef' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, IsUpdateAnimation) == 0x0007B8, "Member 'ACharaBase_C::IsUpdateAnimation' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BattleVoiceSkillTarget) == 0x0007B9, "Member 'ACharaBase_C::M_BattleVoiceSkillTarget' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaFloatingComp) == 0x0007C0, "Member 'ACharaBase_C::CharaFloatingComp' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaStepSmootherComp) == 0x0007C8, "Member 'ACharaBase_C::CharaStepSmootherComp' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaSlopeAdapterComp) == 0x0007D0, "Member 'ACharaBase_C::CharaSlopeAdapterComp' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaSinkTesterComps) == 0x0007D8, "Member 'ACharaBase_C::CharaSinkTesterComps' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaLegComps) == 0x0007E8, "Member 'ACharaBase_C::CharaLegComps' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaBodyComps) == 0x0007F8, "Member 'ACharaBase_C::CharaBodyComps' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaHeadComps) == 0x000808, "Member 'ACharaBase_C::CharaHeadComps' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaEyeComps) == 0x000818, "Member 'ACharaBase_C::CharaEyeComps' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaFaceComp) == 0x000828, "Member 'ACharaBase_C::CharaFaceComp' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsSilhouette) == 0x000830, "Member 'ACharaBase_C::M_IsSilhouette' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, SaveGazeTarget) == 0x000834, "Member 'ACharaBase_C::SaveGazeTarget' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, GazeUpdate) == 0x000840, "Member 'ACharaBase_C::GazeUpdate' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CharaRotateComponent) == 0x000848, "Member 'ACharaBase_C::CharaRotateComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BadStatusParticles) == 0x000850, "Member 'ACharaBase_C::M_BadStatusParticles' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, SE_MagatsuhiDevil) == 0x000860, "Member 'ACharaBase_C::SE_MagatsuhiDevil' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IgnoreAtomComps) == 0x000868, "Member 'ACharaBase_C::M_IgnoreAtomComps' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CreatedSkelMeshes) == 0x000878, "Member 'ACharaBase_C::CreatedSkelMeshes' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_IsAuraChanged) == 0x000888, "Member 'ACharaBase_C::M_IsAuraChanged' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, IsUpdateIK) == 0x000889, "Member 'ACharaBase_C::IsUpdateIK' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, CreatedSkelActors) == 0x000890, "Member 'ACharaBase_C::CreatedSkelActors' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_BattleVoiceSkillID) == 0x0008A0, "Member 'ACharaBase_C::M_BattleVoiceSkillID' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, LookAtActive) == 0x0008A4, "Member 'ACharaBase_C::LookAtActive' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, LimitLookAtRange) == 0x0008A5, "Member 'ACharaBase_C::LimitLookAtRange' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, LookAtRange) == 0x0008A8, "Member 'ACharaBase_C::LookAtRange' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, ForceDisableLimitLookAt) == 0x0008AC, "Member 'ACharaBase_C::ForceDisableLimitLookAt' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, LipClearDelay) == 0x0008B0, "Member 'ACharaBase_C::LipClearDelay' has a wrong offset!");
static_assert(offsetof(ACharaBase_C, M_AbsoluteIgnoreParticleTemplate) == 0x0008B8, "Member 'ACharaBase_C::M_AbsoluteIgnoreParticleTemplate' has a wrong offset!");

}

