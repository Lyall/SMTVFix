#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Sk_DamageResultOnly

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "BTL_EFFECT_PLAY_PARAM_structs.hpp"
#include "BTL_LIGHT_PLAY_PARAM_structs.hpp"
#include "BattleSkillActionBase_classes.hpp"
#include "Project_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass sk_DamageResultOnly.sk_DamageResultOnly_C
// 0x0070 (0x09B0 - 0x0940)
class ASk_DamageResultOnly_C final : public ABattleSkillActionBase_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_Sk_DamageResultOnly_C;              // 0x0938(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	TArray<struct FBTL_EFFECT_PLAY_PARAM>         InEffectPlayParam;                                 // 0x0940(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          IsReflectedProc;                                   // 0x0950(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_951[0x7];                                      // 0x0951(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBTL_LIGHT_PLAY_PARAM>          InLightPlayParam;                                  // 0x0958(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	int32                                         ApplyHitTask;                                      // 0x0968(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Is1vs1Reflect;                                     // 0x096C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsUsedAnimCam;                                   // 0x096D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_96E[0x2];                                      // 0x096E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectWaitTask;                                    // 0x0970(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_974[0x4];                                      // 0x0974(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_TrashActor;                                      // 0x0978(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TArray<class UActorComponent*>                M_TrashComponent;                                  // 0x0988(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          IsInBeginPlay;                                     // 0x0998(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_999[0x3];                                      // 0x0999(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReflectedRange;                                    // 0x099C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<int32>                                 MagatsuhiOtherActors;                              // 0x09A0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)

public:
	void ExecuteUbergraph_sk_DamageResultOnly(int32 EntryPoint);
	void Performance(int32 Step);
	void SetPlayParam(TArray<struct FBTL_EFFECT_PLAY_PARAM>& EffectPlayParam, TArray<struct FBTL_LIGHT_PLAY_PARAM>& LightPlayParam, bool IsUsedAnimCam, TArray<class AActor*>& TrashActor, TArray<class UActorComponent*>& TrashComponent);
	void SkipInitialize();
	void ForceDestroyLoadedModels();
	void ForceRestoreActorScale();
	void IsItemTelescope(bool* IsTelescope);
	void DestroyTrashActors();
	void StopMagatsuhiOtherActorsMotion();
	void Invisible_Loaded_Models();
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void ReceiveBeginPlay();
	void DeadFunc();
	void HitFunc();
	void IntroductionFunc();
	void FinishFunc();
	void CheckHit();
	void AnimNotify_ApplyHitFunc();
	void IntroductionItemFunc();
	E_SKILL_TARGET GetSkillArea();
	void AddFirstSettingTask(TArray<int32>& WaitTaskList);
	void FirstSetting();
	void InitActorDither();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"sk_DamageResultOnly_C">();
	}
	static class ASk_DamageResultOnly_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASk_DamageResultOnly_C>();
	}
};
static_assert(alignof(ASk_DamageResultOnly_C) == 0x000010, "Wrong alignment on ASk_DamageResultOnly_C");
static_assert(sizeof(ASk_DamageResultOnly_C) == 0x0009B0, "Wrong size on ASk_DamageResultOnly_C");
static_assert(offsetof(ASk_DamageResultOnly_C, UberGraphFrame_Sk_DamageResultOnly_C) == 0x000938, "Member 'ASk_DamageResultOnly_C::UberGraphFrame_Sk_DamageResultOnly_C' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, InEffectPlayParam) == 0x000940, "Member 'ASk_DamageResultOnly_C::InEffectPlayParam' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, IsReflectedProc) == 0x000950, "Member 'ASk_DamageResultOnly_C::IsReflectedProc' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, InLightPlayParam) == 0x000958, "Member 'ASk_DamageResultOnly_C::InLightPlayParam' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, ApplyHitTask) == 0x000968, "Member 'ASk_DamageResultOnly_C::ApplyHitTask' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, Is1vs1Reflect) == 0x00096C, "Member 'ASk_DamageResultOnly_C::Is1vs1Reflect' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, M_IsUsedAnimCam) == 0x00096D, "Member 'ASk_DamageResultOnly_C::M_IsUsedAnimCam' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, EffectWaitTask) == 0x000970, "Member 'ASk_DamageResultOnly_C::EffectWaitTask' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, M_TrashActor) == 0x000978, "Member 'ASk_DamageResultOnly_C::M_TrashActor' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, M_TrashComponent) == 0x000988, "Member 'ASk_DamageResultOnly_C::M_TrashComponent' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, IsInBeginPlay) == 0x000998, "Member 'ASk_DamageResultOnly_C::IsInBeginPlay' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, ReflectedRange) == 0x00099C, "Member 'ASk_DamageResultOnly_C::ReflectedRange' has a wrong offset!");
static_assert(offsetof(ASk_DamageResultOnly_C, MagatsuhiOtherActors) == 0x0009A0, "Member 'ASk_DamageResultOnly_C::MagatsuhiOtherActors' has a wrong offset!");

}

