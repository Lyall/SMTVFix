#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BattleSkillActionBase

#include "Basic.hpp"

#include "BTL_LIGHT_PLAY_PARAM_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "BattleSkillLight_t_structs.hpp"
#include "Project_structs.hpp"
#include "BattleSkillHitStop_T_structs.hpp"
#include "BTL_EFFECT_PLAY_PARAM_structs.hpp"
#include "BTL_ADD_SKILL_LIGHT_TASK_DATA_structs.hpp"
#include "PhysicsCore_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BattleSkillActionBase.BattleSkillActionBase_C
// 0x0720 (0x0940 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) ABattleSkillActionBase_C : public AActor
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0220(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class USceneComponent*                        TargetLookAtPoint;                                 // 0x0228(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        ActorLookAtPoint;                                  // 0x0230(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	struct FLinearColor                           TargetLightUpdater_Color_8DA36B374F0E40C887F4B28BA9CDEC3B; // 0x0240(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TargetLightUpdater_Radius_8DA36B374F0E40C887F4B28BA9CDEC3B; // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TargetLightUpdater_Intensity_8DA36B374F0E40C887F4B28BA9CDEC3B; // 0x0254(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            TargetLightUpdater__Direction_8DA36B374F0E40C887F4B28BA9CDEC3B; // 0x0258(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_309F[0x7];                                     // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     TargetLightUpdater;                                // 0x0260(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FLinearColor                           ActorLightUpdater_Color_829671D24B2D645E5C956C931C4E2CD9; // 0x0268(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ActorLightUpdater_Radius_829671D24B2D645E5C956C931C4E2CD9; // 0x0278(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ActorLightUpdater_Intensity_829671D24B2D645E5C956C931C4E2CD9; // 0x027C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            ActorLightUpdater__Direction_829671D24B2D645E5C956C931C4E2CD9; // 0x0280(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30A0[0x7];                                     // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     ActorLightUpdater;                                 // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LightBlinker_Radius_268FA2124C487D388FD7CD9A45AE2C4E; // 0x0290(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LightBlinker_Intensity_268FA2124C487D388FD7CD9A45AE2C4E; // 0x0294(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            LightBlinker__Direction_268FA2124C487D388FD7CD9A45AE2C4E; // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30A1[0x7];                                     // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     LightBlinker;                                      // 0x02A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_BTL_SKILL_ACTION_STATE                      M_Step;                                            // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30A2[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Evt_Introduction;                                  // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             Evt_Hit;                                           // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             Evt_Critical;                                      // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             Evt_Counter;                                       // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             Evt_Dead;                                          // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FSkillActionDesc                       M_Desc;                                            // 0x0300(0x0090)(Edit, BlueprintVisible, ExposeOnSpawn)
	TArray<int32>                                 M_CommandIDList;                                   // 0x0390(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	FMulticastInlineDelegateProperty_             Evt_Idle;                                          // 0x03A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	E_BTL_SKILL_ACTION_STATE                      M_PrevStep;                                        // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_Dead;                                            // 0x03B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_Counter;                                         // 0x03B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsFinish;                                        // 0x03B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30A3[0x4];                                     // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Evt_Finish;                                        // 0x03B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             Evt_Finalize;                                      // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             Evt_UpdateState;                                   // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          M_IsAppliedHit;                                    // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30A4[0x3];                                     // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_ApplyHitWaitingSec;                              // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsForceFinish;                                   // 0x03F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30A5[0x3];                                     // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AnimNotify_PlayEffectID;                         // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         M_AnimNotify_TransPrio;                            // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_BiAttackWaitTime;                                // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<int32>                                 M_BiAttackWaitComIDs;                              // 0x0400(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class FString                                 M_UniqueName;                                      // 0x0410(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<class ASkillActionPointLight_C*>       M_ActorPointLight;                                 // 0x0420(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TArray<class ASkillActionPointLight_C*>       M_TargetPointLight;                                // 0x0430(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TArray<TSoftObjectPtr<class UMaterialInterface>> M_LightFuncMaterial;                               // 0x0440(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsReservePerform_OnApplyHitFunc;                 // 0x0450(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30A6[0x7];                                     // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_WaitCommandList_OnApplyHitFunc;                  // 0x0458(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	int32                                         M_ExWaitComIndex;                                  // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         M_HitEffect;                                       // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FTransform                             M_RelativeTransform;                               // 0x0470(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	float                                         M_LifeSec;                                         // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         M_TranslucencyPriolity;                            // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_ApplyBlur;                                       // 0x04A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30A7[0x3];                                     // 0x04A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ApplyHitWaitTask;                                // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsDoneApplyHitDefault;                           // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30A8[0x3];                                     // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_StartBlurAmount;                                 // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_EndBlurAmount;                                   // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_BlurLerpSec;                                     // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_BlurStartKeepSec;                                // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30A9[0x4];                                     // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkillActionEffect>             M_Effects;                                         // 0x04C8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsCounterActor;                                  // 0x04D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	bool                                          M_IsUseForAttack;                                  // 0x04D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30AA[0x2];                                     // 0x04DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_AddRandomRollMin;                                // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_AddRandomRollMax;                                // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30AB[0x4];                                     // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Evt_SkillPerformance;                              // 0x04E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          M_IsAcceptAnimNotifyAvoidTiming;                   // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30AC[0x7];                                     // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_AnimNotify_AvoidedTargetIndexes;                 // 0x0500(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 M_ApplyHitWaitTaskList;                            // 0x0510(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 M_ComIDs;                                          // 0x0520(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	int32                                         M_TargetNowIndex;                                  // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_ApplyDelay;                                      // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         M_ComApplyHitBlankTask;                            // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30AD[0x4];                                     // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASkillActionPointLight_C*>       M_HitPointLight;                                   // 0x0540(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TMap<E_SKILL_HIT_STAMP_TYPE, struct FBattleSkillLight_t> M_SkillLightList;                                  // 0x0550(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	float                                         M_PlayRate;                                        // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          M_IsCounterEnd;                                    // 0x05A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30AE[0x3];                                     // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_LightAddCnt;                                     // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         M_LightAddCnt2;                                    // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<int32, int32>                            M_IntroWaitBlankTask;                              // 0x05B0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 M_IntroForceBreakTask;                             // 0x0600(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsBarrierTimingPassed;                           // 0x0610(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30AF[0x3];                                     // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_ApplyDelay_Random;                               // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsWorldRelative;                                 // 0x0618(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30B0[0x3];                                     // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_RotRandMin;                                      // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_RotRandMax;                                      // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30B1[0x4];                                     // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_ReflexForceBreakTask;                            // 0x0628(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsPreparedReflexCam;                             // 0x0638(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30B2[0x3];                                     // 0x0639(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_AimLocator;                                      // 0x063C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30B3[0x4];                                     // 0x0644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            M_BarrierReactionWaitTask;                         // 0x0648(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsOverrideBarrierTiming;                         // 0x0698(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsReserveApplyDrain;                             // 0x0699(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsChantCameraFront;                              // 0x069A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsCharaMoved;                                    // 0x069B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsAcceptAnimNotifyRapidReturn;                   // 0x069C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsDoneJustBeforeApplyHit;                        // 0x069D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30B4[0x2];                                     // 0x069E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_JustBeforeApplyHitSec;                           // 0x06A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsReservedJustBeforeApplyHit;                    // 0x06A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsJustBeforeApplyHitDefault;                     // 0x06A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30B5[0x2];                                     // 0x06A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBattleSkillHitStop_T                  M_DefaultHitStopData;                              // 0x06A8(0x0038)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             EvT_ItemIntroduction;                              // 0x06E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          M_IsAlreadyDirChanged;                             // 0x06F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsAlreadyActorMoveToTarget;                      // 0x06F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30B6[0x2];                                     // 0x06F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_SkillMotionOffsetPosition;                       // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                ActorMoveToTarget_MovePos;                         // 0x06F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_MeleeStartDistance;                              // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         M_MoveToTargetResult;                              // 0x0708(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30B7[0x4];                                     // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_AlreadyApplyHitList;                             // 0x0710(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	float                                         M_TargetDefenceArea;                               // 0x0720(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsBeginHitStop;                                  // 0x0724(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsForceUseHitStamp;                              // 0x0725(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30B8[0x2];                                     // 0x0726(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBTL_EFFECT_PLAY_PARAM>         M_EffectPlayParam;                                 // 0x0728(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsAlreadyCameraChanged;                          // 0x0738(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30B9[0x7];                                     // 0x0739(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_AnimCamPecIDs;                                   // 0x0740(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsForcedSkip;                                    // 0x0750(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_EnableForcedSkip;                                // 0x0751(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsUseReflexCam;                                  // 0x0752(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsRetrievePlayParam;                             // 0x0753(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsForceUseReflexCam;                             // 0x0754(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30BA[0x3];                                     // 0x0755(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBTL_LIGHT_PLAY_PARAM>          M_LightPlayParam;                                  // 0x0758(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 M_ApplyHitCamShakeTaskIDs;                         // 0x0768(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsForceOtherSideAllVisible;                      // 0x0778(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          M_IsCalledPlayEffectAbsorption;                    // 0x0779(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsManualCameraShake;                             // 0x077A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30BB[0x1];                                     // 0x077B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_JustBeforeApplyHitWaitTask;                      // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsAlreadyWarpAtIntroductionMelee;                // 0x0780(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30BC[0x7];                                     // 0x0781(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADevilSpawnDecal_C*>             M_DecalActors;                                     // 0x0788(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TArray<class UMaterialAnimDecalComponent_C*>  M_DecalComponents;                                 // 0x0798(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          M_IsJustBeforeApplyHitValidation;                  // 0x07A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IgnoreSkip;                                      // 0x07A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_Skiped;                                          // 0x07AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsWhiteOutDead;                                  // 0x07AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsIgnroeHitStop;                                 // 0x07AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsBecomeBadStatus;                               // 0x07AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30BD[0x2];                                     // 0x07AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_IsWhiteOutDeadTarget;                            // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30BE[0x4];                                     // 0x07B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_WhiteOutWaitTaskList;                            // 0x07B8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	int32                                         M_CntReflectKuishibari;                            // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsSkippingInProgress;                              // 0x07CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30BF[0x3];                                     // 0x07CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_HinderCheckRemainSec;                            // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30C0[0x4];                                     // 0x07D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACharaBase_C*>                   M_CameraHinders;                                   // 0x07D8(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	bool                                          M_IsActorScaleOne;                                 // 0x07E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_MultiMagatsuhiSkillActivated;                    // 0x07E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30C1[0x2];                                     // 0x07EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ServantPartyIndex;                               // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsUseServant;                                    // 0x07F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsLoadedServantModel;                            // 0x07F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_ContinueUpdate;                                  // 0x07F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsLoadedMagatsuhiModel;                          // 0x07F3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsRequestedServantModel;                         // 0x07F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsRequestedMagatsuhiModel;                       // 0x07F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30C2[0x2];                                     // 0x07F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SpendFrames;                                     // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         M_LoadingMagatsuhiModels;                          // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FTransform                             M_MoveToTargetTrans;                               // 0x0800(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	TArray<class UMaterialInterface*>             M_LightFuncMaterialIns;                            // 0x0830(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_IsLoadingLightFuncMaterial;                      // 0x0840(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30C3[0x7];                                     // 0x0841(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBTL_ADD_SKILL_LIGHT_TASK_DATA         M_AddActorPointLightData;                          // 0x0848(0x0068)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	int32                                         M_LoadedLightFuncMaterials;                        // 0x08B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsLoadedLightFuncMaterial;                       // 0x08B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30C4[0x3];                                     // 0x08B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_UniqueSkillInfoTask;                             // 0x08B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30C5[0x4];                                     // 0x08BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_ApplyHitWaitTaskList2;                           // 0x08C0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	float                                         M_SpendSec;                                        // 0x08D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_30C6[0x4];                                     // 0x08D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkillActionTargetInfo>         M_PrimaryTargetInfo;                               // 0x08D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<struct FSkillActionTargetInfo>         M_SecondaryTargetInfo;                             // 0x08E8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          M_SecondApplyHit;                                  // 0x08F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30C7[0x7];                                     // 0x08F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 UpliftingPartyIndex;                               // 0x0900(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UAnimSequenceBase*                      M_TsukuyomiMotion;                                 // 0x0910(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimSequenceBase*                      M_NormalMotion;                                    // 0x0918(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABattleHitStopCtrl_C*                   M_HitStopCtrl;                                     // 0x0920(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          M_IsBecomeBadStatusMud;                            // 0x0928(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsBecomeBadStatusDarkness;                       // 0x0929(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          M_IsComApplyHitDone;                               // 0x092A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_30C8[0x5];                                     // 0x092B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          M_SkipSE;                                          // 0x0930(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void Evt_Introduction__DelegateSignature();
	void Evt_Hit__DelegateSignature();
	void Evt_Critical__DelegateSignature();
	void Evt_Counter__DelegateSignature();
	void Evt_Dead__DelegateSignature();
	void Evt_Idle__DelegateSignature();
	void Evt_Finish__DelegateSignature();
	void Evt_Finalize__DelegateSignature();
	void Evt_UpdateState__DelegateSignature();
	void Evt_SkillPerformance__DelegateSignature(int32 Step);
	void EvT_ItemIntroduction__DelegateSignature();
	void ExecuteUbergraph_BattleSkillActionBase(int32 EntryPoint);
	void BI_FirstSetting();
	void End_HitStop();
	void BI_BeginHitStop();
	void BI_AddPointLight_Auto(const struct FBTL_ADD_SKILL_LIGHT_TASK_DATA& SkillLightData);
	void BI_BlinkHitLight(int32 PartyIndex);
	void BI_CallEvt_SkillPerformance(int32 Step);
	void Begin_HitStop();
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void Event_CallHit();
	void Seq_UpdateState();
	void Seq_Finalize();
	void Seq_Finish();
	void Seq_Idle();
	void Seq_Dead();
	void Seq_Counter();
	void Seq_Critical();
	void Seq_Hit();
	void Seq_Introduction();
	void ReceiveTick(float DeltaSeconds);
	void ReceiveBeginPlay();
	void Evt_ApplyHit(int32 WaitCommandIndex, int32 HitEffect, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotRandMin, float RotRandMax, bool ApplyBlur, float StartBlurAmount, float EndBlurAmount, float BlurStartKeepSec, float BlurLerpSec, TScriptInterface<class IBPI_BattleMain_C> MainWork, TScriptInterface<class IBPI_BattleParty_C> PartySystem, TScriptInterface<class IBPI_BattleTaskFactory_C> TaskFactory);
	void LoadLightFuncMaterials();
	void Add_Target_Party_PointLight_Impl(const TArray<int32>& PartyIndex, const struct FBTL_ADD_SKILL_LIGHT_TASK_DATA& LightData);
	void TargetPointLightAutoUpdate(int32 GroupID, class UCurveLinearColor* Color, class UCurveFloat* Intensity, class UCurveFloat* Radius);
	void ActorPointLightAutoUpdate(int32 GroupID, class UCurveLinearColor* Color, class UCurveFloat* Intensity, class UCurveFloat* Radius);
	void BlinkHitLight_Impl();
	void Add_Target_Point_Light_Impl(const TArray<int32>& PartyIndex, const struct FBTL_ADD_SKILL_LIGHT_TASK_DATA& LightData);
	void Add_Actor_Point_Light_Impl(const TArray<int32>& PartyIndex, const struct FBTL_ADD_SKILL_LIGHT_TASK_DATA& LightData);
	void OnLoaded_DAB82F5B47E17575A75C0C8219BE5104(class UObject* Loaded);
	void TargetLightUpdater__UpdateFunc();
	void TargetLightUpdater__FinishedFunc();
	void ActorLightUpdater__UpdateFunc();
	void ActorLightUpdater__FinishedFunc();
	void LightBlinker__UpdateFunc();
	void LightBlinker__FinishedFunc();
	void UserConstructionScript();
	void CallEvent();
	void IntroductionFunc();
	void HitFunc();
	void CriticalFunc();
	void CounterFunc();
	void DeadFunc();
	void Com_ActorSetMotion(int32 WaitCommandIndex, E_CHARA_MOTION_ID MotionID, bool WaitMotionFinished, float StartPosition, bool IsPlayOneScale, int32* Com_Index);
	void Initialize();
	void IsValidCommandIndex(int32 Param_Index, bool* RetValue);
	void AddComandID(int32 Param_Index);
	void Com_End();
	void Com_SetCamActorRelative(int32 WaitCommandIndex, const class FString& CameraName, bool WaitHokan, int32* ComIndex);
	void GetComandID(int32 Param_Index, int32* RetValue);
	void Com_PlayEffectActor(int32 WaitCommandIndex, int32 PlayIndex, const class FString& SocketName, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotYawRandMin, float RotYawRandMax, bool IsIgnoreSideScale, int32* ComIndex);
	void Com_PlayEffectTarget(int32 WaitCommandIndex, int32 PlayIndex, const class FString& SocketName, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotYawRandMin, float RotYawRandMax, bool HideInReflection, bool HideInAbsorbAndBlock, bool IsIgnoreSideScale, int32* ComIndex);
	void Com_WaitTime(int32 WaitCommandIndex, float DeltaTime, int32* ComIndex);
	void IdleFunc();
	void CheckIntroduction();
	void Com_CamShake(int32 WaitCommandIndex, int32 CamShakeTableIndex, float ShakeScale, bool IsMultiHit, bool IsCheckHit, int32* ComIndex);
	void Com_RadialBlurTarget(int32 WaitCommandIndex, const class FString& SocketName, const struct FVector& Offset, float DamageValue, float StartAmount, float EndAmount, float StartKeepSec, float LerpSec, bool HideInReflection, bool HideInAbsorbAndBlock, int32* ComIndex);
	void Com_RadialBlurOff(int32 WaitCommandIndex, int32* ComIndex);
	void GetBeforCommandIndex(int32* RetComIndex);
	void CheckHit();
	void Com_DeadTarget(int32 WaitCommandIndex, int32* ComIndex);
	void CheckDead();
	void FinishFunc();
	void IsFinished(bool* RetValue);
	void CheckCounter();
	void Com_AttackMoveActor(int32 WaitCommandIndex, int32* ComIndex);
	void Com_SetCamTargetRelative(int32 WaitCommandIndex, const class FString& CameraName, bool WaitHokan, bool IsConsiderActorLocation, bool ResetCharaParticle, int32* ComIndex);
	void IsUnitMotionEndAll(bool* RetValue);
	void Com_MessageShowSkillName(int32 WaitCommandIndex, int32* ComIndex);
	void Com_MessageHide(int32 WaitCommandIndex, int32* ComIndex);
	void FinalizeFunc();
	void CheckFinish();
	void ApplyHit_One(const struct FSkillActionTargetInfo& InTarget, int32 HitEffect, TArray<int32>& WaitTaskList, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TransPrio, float RotRandMin, float RotRandMax, bool ApplyBlur, float StartBlurAmount, float EndBlurAmount, float BlurStartKeepSec, float BlurLerpSec, TScriptInterface<class IBPI_BattleMain_C> MainWork, TScriptInterface<class IBPI_BattleParty_C> PartySystem, TScriptInterface<class IBPI_BattleTaskFactory_C> TaskFactory, bool IsReflection, TArray<int32>& WaitTaskList2, TArray<int32>* RetComIDs, TArray<int32>* RetNecessaryWaitComID);
	void Com_ApplyHit(int32 WaitCommandIndex, int32 HitEffect, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotYawRandMin, float RotYawRandMax, bool ApplyBlur, float StartBlurAmount, float EndBlurAmount, float BlurStartKeepSec, float BlurLerpSec, int32* ComIndex);
	void Com_PlayEffect(int32 WaitCommandIndex, int32 PlayIndex, const class FString& SocketName, const struct FTransform& RelativeTransforn, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotYawRandMin, float RorYawRandMax, bool IsIgnoreSideScale, int32* ComIndex);
	void ApplyStateFunc();
	void ApplyUnitState();
	void CheckApplyUnitState();
	void HitPrevFunc();
	void AnimNotify_ApplyHitFunc();
	void CallApplyHitFunc();
	void Com_ReserveApplyHit(int32* RetValue);
	void ApplyPartyPanel();
	void FindUnit(int32 PartyIndex, class ACharaBase_C** Unit);
	void Com_PlayEffectPair(int32 WaitCommandIndex, int32 PlayIndex, float LifeSec, int32 TranslucencyPriority, E_BTL_EFFECT_TYPE EfffectType, E_BTL_EFFECT_FORM EffectForm, const class FString& ActorSocketName, const struct FTransform& ActorSocketRelative, const class FString& TargetSocketName, float BulletSpeed, int32 BulletTangentDeg, float Gravity, float ExtensionDistance, bool HideInReflection, bool HideInAbsorbAndBlock, bool KeepBallEffect, int32* ComIndex, TArray<int32>* EffectID);
	void BIGetMainWork(TScriptInterface<class IBPI_BattleMain_C>* NewParam);
	void ApplyDamageMotion(TArray<int32>& WaitTaskList, int32 PartyIndex, TScriptInterface<class IBPI_BattleParty_C> PartySystem, TScriptInterface<class IBPI_BattleTaskFactory_C> TaskFactory, int32 MotionType, int32* RetPecID);
	void Com_ActorAction(int32 WaitCommandIndex, E_CHARA_ACTION_TYPE Action, uint8 Option, int32* Com_Index);
	void Com_SetCamOriginRelative(int32 WaitCommandIndex, const class FString& CameraName, bool WaitHokan, int32* ComIndex);
	void Com_Finish();
	void CheckAnimNotify();
	void AnimNotify_DamageMotion(int32 WaitComIndex, TArray<int32>& EffectWaitPecIDs, TScriptInterface<class IBPI_BattleTaskFactory_C> TaskFactory, bool EnableShake, int32* Com_Index);
	void AnimNotify_Effect(int32 WaitComIndex, int32 PlayEffectID, int32 TranslucencyPrio, const struct FTransform& OffsetTransform, TScriptInterface<class IBPI_BattleMain_C> MainWork, TScriptInterface<class IBPI_BattleParty_C> PartySystem, TScriptInterface<class IBPI_BattleTaskFactory_C> TaskFactory, int32* ComIndex, TArray<int32>* WaitPecIDs);
	void AnimNotify_Reset();
	void AnimNotify_IsHit(TArray<E_BTL_REFLECT_RES_TYPE>& NewParam, bool* IsHit);
	void Com_SetAnimNotifyEffect(int32 EffectID, int32 TranslucencyPrio);
	void Com_SetBiAttackWaitTime(float DeltaTime);
	void BIGetTaskFactory(TScriptInterface<class IBPI_BattleTaskFactory_C>* RetValue);
	void BIGetPartySystem(TScriptInterface<class IBPI_BattleParty_C>* RetValue);
	void Com_AddActorPointLight(class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSokect, bool IsCharaOnly);
	void Com_UpdateActorPointLight(int32 GroupID, const struct FLinearColor& Color, float Intensity, float AttenuationRadius, float LightFalloffExponent);
	void Com_AddTargetPointLight(class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSocket, bool HideInReflection, bool HideInAbsorbAndBlock, bool IsCharaOnly);
	void Com_UpdateTargetPointLight(int32 GroupID, const struct FLinearColor& Color, float Intensity, float AttenuationRadius, float LightFalloutExponent);
	void InitAllPointLight();
	void OnApplyHitFunc();
	void Com_InitActorPointLight();
	void InitPointLight(TArray<class ASkillActionPointLight_C*>& PointLights);
	void Com_InitTargetPointLight();
	void UpdatePointLight(TArray<class ASkillActionPointLight_C*>& LightArray, const struct FLinearColor& NewLightColor, float NewIntensity, float NewRadius, float NewLightFalloffExponent, int32 GroupID);
	void AddPointLight(class FName SocketName, int32 PartyIndex, TArray<class ASkillActionPointLight_C*>& TargetArray, class UMaterialInterface* LightFuncMaterial, bool IsCastShadow, const struct FVector& OffsetPos, bool IsFollowSocket, int32 GroupID, bool IsLightForBlink, bool IsPartyCentor, bool IsMagatsuhi, bool CheckSocketExist, class ASkillActionPointLight_C** AddedLight);
	void PutOnRadialForce();
	void ActivateRadialForce();
	void ApplyDrain(TArray<int32>& WaitTaskList, TArray<int32>& WaitTaskList2, TArray<int32>* RetComIDs);
	void Skill_Info_Mess_Task(TArray<int32>& WaitTaskList, E_SKILL_INFO_MESS_TIMING Timing, TScriptInterface<class IBPI_BattleTaskFactory_C> TaskFactory, bool IsHandleAllSkills, int32* TaSKID);
	void SkillMasterEffectTask(TArray<int32>& WaitTaskList, TArray<int32>* ComIndex);
	void ReservePerform_OnApplyHitFunc(TArray<int32>& WaitCommandList);
	void Supervise_OnApplyHitFunc();
	void CallMainAction();
	void CalcAvoidDirection(int32 TargetIndex, E_AVOID_DIRECTION* RetVal);
	void IsAnyHit(bool* RetValue);
	void BIGetSound(TScriptInterface<class IBPI_BattleSoundManager_C>* RetValue);
	void IsBstAny(bool* RetValue);
	void Com_SetAnimCamActorRelative(int32 WaitCommandIndex, class UCameraAnimationAsset* Asset, float BlendInTime, float BlendOutTime, bool HideOtherActor, bool HideAllActor, bool HideOtherTarget, bool HideAllTarget, class FName OriginTransSocket, const struct FTransform& OffsetTrans, bool HaveToCleanUp, bool IsPlayOneScale, bool ResetCharaParticle, int32* ComIndex);
	void Com_SetAnimCamTargetRelative(int32 WaitCommandIndex, class UCameraAnimationAsset* Asset, float BlendInTime, float BlendOutTime, bool HideOtherActor, bool HideAllActor, bool HideOtherTarget, bool HideAllTarget, class FName OriginTransSocket, const struct FTransform& OffsetTrans, bool HaveToCleanUp, bool ResetCharaParticle, int32* ComIndex);
	void Com_SetAnimCamOriginRelative(int32 WaitCommandIndex, class UCameraAnimationAsset* Asset, float BlendInTime, float BlendOutTime, const struct FTransform& OffsetTrans, bool HideOtherActor, bool HideAllActor, bool HideOtherTarget, bool HideAllTarget, bool HaveToCleanUp, bool IsPlayOneScale, int32* ComIndex);
	void RetrieveHitEffect(E_BTL_DAMAGE_HIT_TYPE DamageType, int32 EffectIndex, int32 CriticalLevel, bool IsAnimNotify, bool IsPlaySkillEffect, TScriptInterface<class IBPI_BattleMain_C> MainWork, TScriptInterface<class IBPI_BattleParty_C> PartySystem, bool IsReflection, struct FSkillActionEffect* SkillEffect, bool* IsHitStamp, bool* IsCritical, bool* IsAddCriticalSE);
	struct FTransform AddRandomRoll(struct FTransform& InTransform, float Min, float Max);
	void Com_PlayEffectActorParty(int32 WaitCommandIndex, int32 PlayIndex, const class FString& SocketName, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotYawRandMin, float RotYawRandMax, int32* ComIndex);
	void GetPartyCenter(int32 PartyIndex, class FName SocketName, TScriptInterface<class IBPI_BattleParty_C> PartySystem, struct FVector* Pos, struct FVector* Normal, struct FVector* Forward);
	void Com_PlayEffectTargetParty(int32 WaitCommandIndex, int32 PlayIndex, const class FString& SocketName, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotYawRandMin, float RotYawRandMax, int32* ComIndex);
	void Com_CallSkillPerformance(int32 WaitCommandIndex, int32 PerformanceStep, float RemainSec, int32* ComIndex);
	void GetTargetPartyIndex(TArray<int32>* Param_Index);
	void GetTargetCenter(TArray<int32>& PartyIndex, class FName SocketName, TScriptInterface<class IBPI_BattleParty_C> PartySystem, bool ForMagatsuhiSkill, struct FVector* Pos, struct FVector* Normal, struct FVector* Forward, float* DefenseArea);
	void Com_PlayerEscape(int32 WaitCommandIndex, float Length, float MoveTime, bool WaitMoveFinish, int32* ComIndex);
	void Com_MemberAction(int32 WaitCommandIndex, E_CHARA_ACTION_TYPE Action, uint8 Option, int32* Com_Index);
	void Com_MessageShowCommonMessage(int32 WaitCommandIndex, int32 CommonMsgID, int32* ComIndex);
	void Com_IgnoreCounterStop(class AActor* Actor);
	void BIGetPostProcess(TScriptInterface<class IBPI_BattlePostProcessCtrl_C>* RetValue);
	void Com_ActorMoveToTarget(int32 WaitCommandIndex, float DistanceFromTarget, float MoveTime, bool WaitMoveFinish, bool CheckTargetDefenseArea, bool CheckActorAttackReach, bool ConsiderActorScale, bool IgnoreCharaCollision, int32* ComIndex);
	void GetShakeScale(int32 TargetPartyIndex, float* RetValue);
	void OnSkillHitFunc();
	void AnimNotify_ApplyHit_OnPlayEffectFunc();
	void AnimNotify_AvoidTiming(int32 WaitComIndex, int32* ComIndex);
	void CallApplyHit_OnPlayEffectFunc();
	void Com_FadeOut(int32 WaitCommandIndex, bool IsWhite, float DurationSec, int32* ComIndex);
	void Com_FadeIn(int32 WaitCommandIndex, bool IsWhite, float DurationSec, int32* ComIndex);
	void IsWaitComDone(TArray<int32>& WaitComIDs, bool* IsDone);
	void Com_AddDecalActor(int32 WaitCommandIndex, class UMaterialInstance* DecalMaterial, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, float OverrideLifeSec, EAttachLocation LocationType, const struct FRotator& Rotation, float RotationRandMin, float RotationRandMax, bool AbsolutelyNoRotation, bool CastOnlyStaticMesh, int32* ComIndex);
	void Com_AddDecalTarget(int32 WaitCommandIndex, class UMaterialInstance* DecalMaterial, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, float OverrideLifeSec, EAttachLocation LocationType, const struct FRotator& Rotation, float RotationRandMin, float RotationRandMax, bool HideInReflection, bool HideInAbsorbAndBlock, bool AbsolutelyNoRotation, bool CastOnlyStaticMesh, int32* RetPecID);
	void Com_AddDecalActorParty(int32 WaitCommandIndex, class UMaterialInstance* DecalMaterial, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, const struct FRotator& Rotation, float RotationRandMin, float RotationRandMax, bool AbsolutelyNoRotation, bool CastOnlyStaticMesh, int32* ComIndex);
	void Com_AddDecalTargetParty(int32 WaitCommandIndex, class UMaterialInstance* DecalMaterial, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, const struct FRotator& Rotation, float RotationRandMin, float RotationRandMax, bool AbsolutelyNoRotation, bool CastOnlyStaticMesh, int32* ComIndex);
	void BlinkHitLight(int32 PartyIndex);
	void GetHitLightData(bool* IsValid, struct FBattleSkillLight_t* LightData);
	void LoadBattleSkillLightList();
	void SetPlayRate(float PlayRate);
	void GetPlayRate(float* PlayRate);
	void Com_CamShakeByRowName(int32 WaitCommandIndex, const class FString& TableRowName, float ShakeScale, bool IsMultiHit, bool IsCheckHit, int32* ComIndex);
	void Com_AddActorPointLight_Auto(int32 WaitCommandIndex, class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSokect, class UCurveLinearColor* Color, class UCurveFloat* Intensity, class UCurveFloat* Radius, class UCurveFloat* LightFalloffExponent, bool IsCharaOnly, int32* ComIndex);
	void InitLightUpdaterTimeline(class UTimelineComponent* Timeline, class UCurveLinearColor* ColorCurve, class UCurveFloat* IntensityCurve, class UCurveFloat* RadiusCurve);
	void AddActorPointLight_Auto_Impl(const struct FBTL_ADD_SKILL_LIGHT_TASK_DATA& SkillLightData);
	void AddTargetPointLight_Auto_Impl(const struct FBTL_ADD_SKILL_LIGHT_TASK_DATA& SkillLightData);
	void Com_AddTargetPointLight_Auto(int32 WaitCommandIndex, class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSokect, class UCurveLinearColor* Color, class UCurveFloat* Intensity, class UCurveFloat* Radius, class UCurveFloat* LightFalloffExponent, bool HideInReflection, bool HideInAbsorbAndBlock, bool IsCharaOnly, int32* ComIndex);
	void Com_CamShakeByClass(int32 WaitCommandIndex, class UClass* CamShakeClass, float ShakeScale, bool IsMultiHit, bool IsCheckHit, int32* ComIndex);
	void Com_RadialBlurActor(int32 WaitCommandIndex, const class FString& SocketName, const struct FVector& Offset, float DamageValue, float StartAmount, float EndAmount, float StartKeepSec, float LerpSec, bool IgnoreSideScale, int32* ComIndex);
	void Com_RadialBlurTargetParty(int32 WaitCommandIndex, const class FString& SocketName, const struct FVector& Offset, float DamageValue, float StartAmount, float EndAmount, float StartKeepSec, float LerpSec, int32* ComIndex);
	void Com_RadialBlurActorParty(int32 WaitCommandIndex, const class FString& SocketName, const struct FVector& Offset, float DamageValue, float StartAmount, float EndAmount, float StartKeepSec, float LerpSec, int32* ComIndex);
	void Com_AddActorPartyPointLight(class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSokect, bool IsCharaOnly);
	void Com_AddTargetPartyPointLight(class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSocket, bool IsCharaOnly);
	void Com_AddActorPartyPointLight_Auto(int32 WaitCommandIndex, class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSokect, class UCurveLinearColor* Color, class UCurveFloat* Intensity, class UCurveFloat* Radius, class UCurveFloat* LightFalloutExponent, bool IsCharaOnly, int32* ComIndex);
	void Com_AddTargetPartyPointLight_Auto(int32 WaitCommandIndex, class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSokect, class UCurveLinearColor* Color, class UCurveFloat* Intensity, class UCurveFloat* Radius, class UCurveFloat* LightFalloffExponent, bool IsCharaOnly, int32* ComIndex);
	void ActivatePointLightUpdate(class ASkillActionPointLight_C* PointLight, struct FBTL_ADD_SKILL_LIGHT_TASK_DATA& LightData);
	void Com_AddDecalToEffect(int32 WaitCommandIndex, TArray<int32>& EffectID, class UMaterialInstance* DecalMaterial, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, int32 LoopTimes, float CycleSec, const struct FRotator& Rotation, float RotationRandMin, float RotationRandMax, const struct FVector& Size, bool AbsolutelyNoRotation, bool CastOnlyStaticMesh, int32* ComIndex);
	void IsExistNotifyInMotion(int32 ActorIndex, E_CHARA_MOTION_ID MotionID, const class FString& NotifyName, bool* IsExist);
	void CheckIntorAnimNotify();
	void AddIntroForceBreakTask(int32 PecID);
	struct FTransform AddRandomYaw(struct FTransform& InTransform, float Min, float Max);
	void PrepareReflexCam();
	void AddTargetDeadTask(TArray<int32>& WaitList, TArray<int32>& DeadTarget, const struct FSkillActionTargetInfo& SkillActionTargetInfo);
	void CalcReflexTarget(int32 TargetIndex, bool* IsExist, int32* ReflexTargetIndex);
	void GetDamageMotionType(int32 PartyIndex, E_BTL_DAMAGE_HIT_TYPE DamageHitType, bool IsDead, int32 bst, TScriptInterface<class IBPI_BattleParty_C> PartySystem, bool IsResist, bool IsGuard, bool IsWeak, int32* DamageMotionIndex);
	void GetBstSEArray(int32 BadStatus, E_CHARA_BAD_STATUS_APPEAR Appear, TArray<class USoundAtomCue*>* RetValue);
	void AddPointLightAuto_Impl(const struct FBTL_ADD_SKILL_LIGHT_TASK_DATA& SkillLightData);
	void AddBarrierReactionTask(TScriptInterface<class IBPI_BattleTaskFactory_C> TaskFactory, TArray<int32>& WaitTaskList, int32 TargetIndex, E_BTL_REFLECT_RES_TYPE Reaction, float WaitSec, TArray<int32>* RetPecIDs);
	void Com_OverrideBarrierTiming(int32 WaitCommandIndex);
	void CalcAttackMoveSec(class ACharaBase_C* Attacker, const struct FVector& TargetLocation, float TargetDefenseArea, float* Sec);
	void Com_ReserveApplyDrain();
	void Com_ApplyDrain(int32 WaitCommandIndex, int32* ComIndex);
	void BIGetMainInterface(TScriptInterface<class IBPI_MainInterface>* AsBPI_Main_Interface);
	void PartyUtil(TScriptInterface<class IBPI_PTUtilInterface>* Param_PartyUtil);
	void BIGetPTUnitInterface(TScriptInterface<class IBPI_PTBPInterface_C>* AsBPI_PTBPInterface);
	void BIGetPTBadStatusInterface(TScriptInterface<class IBPI_PTBadStatusInterface>* AsBPI_PTBad_Status_Interface);
	void AddMagGaugeTask(TArray<int32>& WaitTaskList, TArray<int32>* ComIndex);
	void Com_ActorLookTarget(int32 WaitCommandIndex, float LookSpeed, bool WaitLookFinish, int32* ComIndex);
	void AdjustCameraName(const class FString& Input, class FString* Output, bool* IsAttack);
	void Com_Introduction_100_Series(int32 WaitCommandIndex, const class FString& CameraName, int32* ComIndex);
	void Com_Introduction_200_Series(int32 WaitCommandIndex, const class FString& CameraName, int32* ComIndex);
	void Com_Introduction_300_Series(int32 WaitCommanIndex, const class FString& CameraName, int32* ComIndex);
	void Com_Introduction_400_Series(int32 WaitCommandIndex, const class FString& CameraName, int32* ComIndex);
	void Com_Introduction_500_Series(int32 WaitCommandIndex, const class FString& CameraName, int32* ComIndex);
	void Com_Introduction_600_Series(int32 WaitCommandIndex, const class FString& CameraName, int32* ComIndex);
	void Com_Introduction_700_Series(int32 WaitCommandIndex, const class FString& CameraName, int32* ComIndex);
	void Com_Introduction_800_Series(int32 WaitCommandIindex, const class FString& CameraName, int32* ComIndex);
	void Com_Introduction_900_Series(int32 WaitCommandIndex, const class FString& CameraName, int32* ComIndex);
	void AddReichiPointTask(TArray<int32>& WaitTaskList, TArray<int32>* ComIndex);
	void AddActorBstTask(TArray<int32>& WaitTaskList, TArray<int32>* ComIndex);
	void IsTargetHitStan(bool* IsStan);
	void StartLookAt(class FName Socket);
	void StopLookAt();
	void StartLookAt_OnlyTarget(class FName Socket);
	void StopLookAt_OnlyTarget();
	void IsOverrideTargetLocation(int32 PartyIndex, bool* IsOverride, class FName* OverrideSocket);
	void Com_PlayEffectAbsorption(int32 WaitCommandIndex, class FName AbsorptionPointSocket, const struct FVector& AbsorptionPointOffset, class UCurveVector* AbsorptionParam, bool IsReverse, int32* ComIndex);
	void ActorBeHomePerformance();
	void IsEndActorBeHomePerformance(bool* IsEnd);
	void ActorAppearPerformance();
	void CheckAnimNotify_RapidReturn();
	void Com_EnemyAction(int32 WaitCommandIndex, E_CHARA_ACTION_TYPE Action, uint8 Option, int32* Com_Index);
	void Com_EnemyMotion(int32 WaitCommandIndex, E_CHARA_MOTION_ID Motion, TArray<E_BAD_STATUS>& IgnoreBst, int32* Com_Index);
	void IsTargetDead(bool* IsDead);
	void OnJustBeforeApplyHitFunc();
	void IsJustBeforeApplyHitTiming(int32 PartyIndex, bool* IsTiming);
	void RetrieveNotifyTiming(int32 ActorIndex, E_CHARA_MOTION_ID MotionID, const class FString& NotifyName, bool IsReverseSearch, float* Timing, bool* IsExist);
	void Com_ReserveJustBeforeApplyHit(float JustBeforeSec, bool IsDefaultTiming);
	void Com_MemberMotion(int32 WaitCommandIndex, E_CHARA_MOTION_ID Motion, TArray<E_BAD_STATUS>& IgnoreBst, int32* Com_Index);
	void SetHitStopParameter(const struct FBattleSkillHitStop_T& Parameter);
	void Com_BeginSkillHitStop(int32 WaitCommandIndex, int32* ComIindex);
	void UI_IConTask(TScriptInterface<class IBPI_BattleTaskFactory_C> TaskFactory, TArray<int32>& WaitTaskList, int32 TargetIndex, bool Resist, bool Guard, bool Combo, bool Weak, bool Miss, bool bLock, TArray<int32>* RetList);
	void CalcUnitSocketLocation(int32 PartyIndex, class FName SocketName, TScriptInterface<class IBPI_BattleParty_C> BPI_BattleParty, bool ForTarget, struct FVector* Root, struct FVector* SocketLocation, struct FRotator* Rotate, bool* Valid);
	E_SKILL_TARGET GetSkillArea();
	void IsThisOneTargetSkill(bool* IsOneTarget);
	void Com_SetAnimCamActorRelative_BySize(int32 WaitCommandIndex, TArray<class UCameraAnimationAsset*>& Asset, class UCurveFloat* LarpAlpha, float BlendInTime, float BlendOutTime, bool HideOtherActor, bool HideAllActor, bool HideOtherTarget, bool HideAllTarget, class FName OriginTransSocket, const struct FTransform& OffsetTrans, bool HaveToCleanUp, bool IsPlayOneScale, bool ResetCharaParticle, int32* ComIndex);
	void CalcTargetCamAnim(TArray<class UCameraAnimationAsset*>& CameraAnims, class UCurveFloat* LeapAlpha, class UCameraAnimationAsset** CameraAnim, class UCameraAnimationAsset** CameraAnim2nd, float* LerpAlpha);
	void Com_SetAnimCamTargetRelative_BySize(int32 WaitCommandIndex, TArray<class UCameraAnimationAsset*>& Asset, class UCurveFloat* LerpAlpha, float BlendInTime, float BlendOutTime, bool HideOtherActor, bool HideAllActor, bool HideOtherTarget, bool HideAllTarget, class FName OriginTransSocket, const struct FTransform& OffsetTrans, bool HaveToCleanUp, bool ResetCharaParticle, int32* ComIndex);
	void Com_SetAnimCamOriginRelative_BySize(int32 WaitCommandIndex, TArray<class UCameraAnimationAsset*>& Asset, class UCurveFloat* LerpAlpha, float BlendInTime, float BlendOutTime, const struct FTransform& OffsetTrans, bool HideOtherActor, bool HideAllActor, bool HideOtherTarget, bool HideAllTarget, bool HaveToCleanUp, bool IsPlayOneScale, int32* ComIndex);
	void Com_CamDepthOfField(int32 WaitCommandIndex, float FocalDistance, float Scale, float DurationSec, int32* ComIndex);
	void Com_Introduction_Item(int32* ComIndex);
	void IntroductionItemFunc();
	void GetActorPartyIndex(int32* Param_Index);
	void Com_TargetMotion(int32 WaitCommandIndex, E_CHARA_MOTION_ID Motion, bool RandomTiming, int32* Com_Index);
	void TargetLookToActor(TArray<int32>& WaitTaskList);
	void IsHitTarget(int32 TargetIndex, bool* IsHit);
	void Com_SetSequencerCamTargetRelative(int32 WaitCommandIndex, int32* ComIndex);
	void Com_Introduction_Melee(int32 WaitCommandIndex, float MeleeStartDistance, int32* ComIndex);
	void CalcMotionStartPosition(int32 PartyIndex, E_CHARA_MOTION_ID MotionID, const class FString& NotifyName, float OffsetPosition, float* StartPosition);
	void ApplyDebugParam();
	bool IsTargetOnlyActor();
	bool IsTargetContainsActor();
	void CalcUnitTall(int32 PartyIndex, float* Tall);
	void UndoDebugParam();
	void CalcPartyVisibilitySituation(bool HideOtherActor, bool HideAllActor, bool HideOtherTarget, bool HideAllTarget, TArray<int32>* VisiblePartyIndex, TArray<int32>* InvisiblePartyIndex);
	bool IsNormalAttack();
	void GetPlayParam(TArray<struct FBTL_EFFECT_PLAY_PARAM>& OutEffectPlayParam, TArray<struct FBTL_LIGHT_PLAY_PARAM>& OutLightPlayParam, TArray<class AActor*>& TrashActor, TArray<class UActorComponent*>& TrashComponent);
	void IsSkippable(bool* IsSkipable);
	void IsReflected(bool* Param_IsReflected);
	void Com_PlayEffectPairTargetParty(int32 WaitCommandIndex, int32 PlayIndex, float LifeSec, int32 TranslucencyPriority, E_BTL_EFFECT_TYPE EfffectType, E_BTL_EFFECT_FORM EffectForm, const class FString& ActorSocketName, const struct FTransform& ActorSocketRelative, const class FString& TargetSocketName, float BulletSpeed, int32 BulletTangentDeg, float Gravity, float ExtensionDistance, bool HideInReflection, bool HideInAbsorbAndBlock, int32* ComIndex, TArray<int32>* EffectID);
	void Update(float DeltaSec);
	void OutOfBattleSetting(int32 ActorIndex);
	void FirstSetting();
	void BIGetPTFlagInterface(TScriptInterface<class IBPI_PTFlagInterface>* AsBPI_PTFlag_Interface);
	void AddFirstSettingTask(TArray<int32>& WaitTaskList);
	void CheckLastAnimCamera();
	void AnimNotifyState_Reset();
	E_NAHOBINO_SKILL_MOTION GetNahobinoMotion(int32 Skill_ID);
	void IsForcedSkip(bool* Skip);
	void CheckBarrierReactionEnd();
	void CheckUseReflexCam();
	void SetAlreadyCameraChanged(bool IsTrue);
	void DamageResultSetting(bool* IsReflected, bool* Is1vs1Reflect);
	void SetChantCameraFront(bool Enable);
	E_SKILL_HIT_STAMP_TYPE GetSkillHitStampType();
	void CalcAttackMotion(int32 ActorIndex, E_CHARA_MOTION_ID* AttackMotion);
	void CalcSkillMotion(int32 ActorIndex, E_CHARA_MOTION_ID* MotionID);
	void ValueSelect(float PlayerSideValue, float EnemySideValue, float* Distance);
	void NoApplyHit();
	void IsBstOnlySkill(bool* IsBstOnly);
	void IsSkillForActorSide(bool* IsForActorSide);
	void GetHeroIndex(int32* Param_Index);
	void TranslateExtraActionToBadStatus(E_BTL_EXTRA_ACTION ExtraAction, E_BAD_STATUS* BadStatus);
	void AddNoticeSkillChangedTask(const TArray<E_BAD_STATUS>& BadStatusType);
	void CalcRandomNumPos(int32 DirectionNum, int32 DivisionNum, int32 MinimumNum, TArray<int32>& RandomPos);
	void CalcSkipCameraName(bool IsReflected, class FString* CameraName);
	void CheckChangeCamera();
	void CalcDamagePosOffset(int32& PosNo, int32 NumPosDirection, struct FVector* Offset);
	void CheckTargetResType(const struct FSkillActionTargetInfo& SkillActionTargetInfo, E_BTL_REFLECT_RES_TYPE ResType, bool* IsTheSameResType);
	void KuishibariInfoMessTask(TArray<int32>& WaitTaskList, E_SKILL_INFO_MESS_TIMING Timing, TScriptInterface<class IBPI_BattleTaskFactory_C> TaskFactory, TArray<int32>* TaSKID);
	void CalcMoveDestLocation(struct FVector* Location, struct FVector* Ave, float* DistFromTarget);
	void Com_ActorMoveToTargetLocation(int32 WaitCommandIndex, const struct FVector& DestLocation, const struct FVector& LookLocation, float MoveTime, bool WaitMoveFinish, int32* ComIndex);
	void IsInvalidData(E_BTL_DAMAGE_HIT_TYPE HitType, int32 Damage, int32 DamgeReal, int32 Rec, int32 DamageMP, int32 RecMP, bool* IsInvalid);
	void GetPartyRotation(int32 PartyIndex, struct FRotator* Rotation);
	void InitAllDecals();
	void AddStopAllSE_Task(int32 WaitCommandIndex, int32* WaitPecID);
	void SetActorDitherOff();
	void InitActorDither();
	class FString MakeSkillName(int32 ID, int32 ActorIndex, int32* Aptitude);
	void IsAlreadyCameraChanged(bool* Changed);
	void IsUseAnimCam(bool* IsUsed);
	void IsThisCallSkill(bool* IsCall);
	void GetSkillType(E_SKILL_TYPE* Type);
	void IsThisOneTargetCallSkill(bool* IsOneTarget);
	void Com_SetIgnoreSkip(int32 WaitCommandIndex);
	void SetIgnoreSkillSkip();
	void AddStopAllParticleTask(int32 WaitCommandIndex, int32* WaitPecID);
	void SetSkiped();
	void OverrideActorPartyIndex(int32 PartyIndex);
	void CalcActorLocation(struct FVector* ActorLocation);
	void GetSkillID(int32* ID);
	bool IsCallWhiteOut();
	void IsHeroDeadByReflection(bool* IsDead);
	void CheckMagatsuhiSkill(bool* IsMagatsuhiSkill, bool* IsFixMemberSkill);
	void Check_Model_Load();
	void CheckCameraHinder(float Delta);
	void CheckDoWhiteOut();
	void IsDeadImmortalBoss(int32 PartyIndex, E_KUISHIBARI_LEVEL KuishibariLevel, bool* IsDead);
	void IsAllTargetDead(bool* IsDead);
	void IsWarpAtIntroductionMelee(bool* M_IsWarpAtIntroductionMelee);
	void SelectActorCameraName(const class FString& Playerside, const class FString& EnemySide, class FString* Camera);
	void SelectTargetCameraName(const class FString& Playerside, const class FString& EnemySide, class FString* Camera);
	void FinalizeCameraHinder(bool Immediately);
	void RestoreCharaScale();
	void Com_MagatsuhiActorSetPosition(int32 WaitCommandIndex, bool PutOnRelativeDegree, float RelativeDegree, int32* Com_Index);
	void Com_MagatsuhiActorResetVisibilityAndScale(int32 WaitCommandIndex, bool ActorVisible, int32* Com_Index);
	void Com_PlayEffectMagatsuhiActorParty(int32 WaitCommandIndex, int32 PlayIndex, const class FString& SocketName, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotYawRandMin, float RotYawRandMax, int32* ComIndex);
	void GetMagatsuhiPartyCenter(class FName SocketName, TScriptInterface<class IBPI_BattleParty_C> PartySystem, struct FVector* Pos, struct FVector* Normal, struct FVector* Forward);
	void Com_PlayEffectMagatsuhiActor(int32 WaitCommandIndex, int32 PlayIndex, const class FString& SocketName, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotYawRandMin, float RotYawRandMax, bool IsIgnoreSideScale, int32* ComIndex);
	void Com_Add_Magatsuhi_Actor_Point_Light_Auto(int32 WaitCommandIndex, class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSokect, class UCurveLinearColor* Color, class UCurveFloat* Intensity, class UCurveFloat* Radius, class UCurveFloat* LightFalloffExponent, bool IsCharaOnly, bool CheckSocketExist, int32* ComIndex);
	void Com_AddMagatsuhiActorPartyPointLight_Auto(int32 WaitCommandIndex, class FName SocketName, const struct FVector& OffsetPos, int32 LightFuncMaterialIndex, int32 GroupID, bool IsCastShadow, bool IsFollowSokect, class UCurveLinearColor* Color, class UCurveFloat* Intensity, class UCurveFloat* Radius, class UCurveFloat* LightFalloutExponent, bool IsCharaOnly, int32* ComIndex);
	void Com_AddDecalMagatsuhiActor(int32 WaitCommandIndex, class UMaterialInstance* DecalMaterial, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, float OverrideLifeSec, EAttachLocation LocationType, const struct FRotator& Rotation, float RotationRandMin, float RotationRandMax, bool AbsolutelyNoRotation, bool CastOnlyStaticMesh, int32* ComIndex);
	void Com_AddDecalMagatsuhiActorParty(int32 WaitCommandIndex, class UMaterialInstance* DecalMaterial, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, const struct FRotator& Rotation, float RotationRandMin, float RotationRandMax, bool AbsolutelyNoRotation, bool CastOnlyStaticMesh, int32* ComIndex);
	void Com_Load_Servant_Model_Task(int32 Load_ID, bool SpawnAtHome, bool RegisterAsAnEnemy, int32* PecID);
	void Com_BeginCtrlServant();
	void Com_EndCtrlServant();
	void Destroy_Loaded_Model();
	void Com_ServantSetVisibility(int32 WaitCommandIndex, bool Visible, int32* Com_Index);
	void LoadMagatsuhiOtherActorModel();
	void IsModelLoaded(bool* Done);
	void MakeSkillUserTransformTask(TArray<int32>& WaitTaskList, const struct FTransform& Root, bool PutOnRelativeDegree, float RelativeDegree);
	void Com_Introduction_Summoner(int32 WaitCommandIndex, const class FString& CameraName, float Distance, E_CHARA_MOTION_ID MotionID, int32* PecID);
	void Com_Introduction_Servant_100_Series(int32 WaitCommandIndex, const class FString& CameraName, float DistanceFromSummoner, float DegreeFromForward, float MotionStartSec, float DelayPlayMotionSec, int32* ComIndex);
	void Com_Introduction_Servant_200_Series(int32 WaitCommandIndex, const class FString& CameraName, float DistanceFromSummoner, float DegreeFromForward, float MotionStartSec, float DelayPlayMotionSec, int32* ComIndex);
	void Com_Introduction_Servant_300_Series(int32 WaitCommandIndex, const class FString& CameraName, float DistanceFromSummoner, float DegreeFromForward, float MotionStartSec, float DelayPlayMotionSec, int32* ComIndex);
	void Com_Introduction_Servant_400_Series(int32 WaitCommandIndex, const class FString& CameraName, float DistanceFromSummoner, float DegreeFromForward, float MotionStartSec, float DelayPlayMotionSec, int32* ComIndex);
	void Com_Introduction_Servant_500_Series(int32 WaitCommandIndex, const class FString& CameraName, float DistanceFromSummoner, float DegreeFromForward, float MotionStartSec, float DelayPlayMotionSec, int32* ComIndex);
	void Com_Introduction_Servant_600_Series(int32 WaitCommandIndex, const class FString& CameraName, float DistanceFromSummoner, float DegreeFromForward, float MotionStartSec, float DelayPlayMotionSec, int32* ComIndex);
	void Com_Introduction_Servant_700_Series(int32 WaitCommandIndex, const class FString& CameraName, float DistanceFromSummoner, float DegreeFromForward, float MotionStartSec, float DelayPlayMotionSec, int32* ComIndex);
	void Com_Introduction_Servant_800_Series(int32 WaitCommandIndex, const class FString& CameraName, float DistanceFromSummoner, float DegreeFromForward, float MotionStartSec, float DelayPlayMotionSec, int32* ComIndex);
	void Com_Introduction_Servant_900_Series(int32 WaitCommandIndex, const class FString& CameraName, float DistanceFromSummoner, float DegreeFromForward, float MotionStartSec, float DelayPlayMotionSec, int32* ComIndex);
	void Com_Introduction_Servant_Melee(int32 WaitCommandIndex, bool FromSummoner, float Distance, float DegreeFromForward, int32* ComIndex);
	void GetServantPartyIndex(int32* PartyIndex);
	void Com_ActorMoveFromTargetTrans(int32 WaitCommandIndex, float Distance, float Degree, int32* PecID);
	void SetSkippingInProgress();
	void AddLightFuncMaterial(TSoftObjectPtr<class UMaterialInterface>& Material);
	void Com_EnableManualCamShake();
	void Com_CamShake_Impl(int32 WaitCommandIndex, float ShakeScale, bool IsMultiHit, int32 CamShakeTableIndex, const class FString& RowName, class UClass* ShakeClass, bool IsCheckHit, int32* ComIndex);
	void Com_CtrlPostProcess(int32 WaitComIndex, TArray<class UMaterialInstance*>& Material, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, int32* ComIndex);
	void PursuitAddDrawPressIcon();
	void Com_PlaySound2D(int32 WaitComIndex, class USoundAtomCue* AtomCue, bool SE_Sync_Playback_Speed, int32* ComIndex);
	void Check_Light_Func_Material_Load();
	void IsLightFuncMaterialLoaded(bool* Done);
	void CheckActorsUniqueSkillExtraEffect(E_AUTO_SKILL_EXTRA_EFFECT ExtraEffect, bool* Collect);
	void IsAnyCritical(bool* RetValue);
	void GetCriticalTargetPartyIndex(TArray<int32>* Param_Index);
	void ReturnTargetTask(TArray<int32>& WaitTaskList, TArray<int32>& TargetIndex, TArray<int32>* RetTaskIDs);
	void CheckUniqueSkillEfficacy(int32 UniqueSkillID, int32 PartyIndex, bool* Efficacy);
	void GetItemID(int32* ID);
	void BIGetPTMemDataInterface(TScriptInterface<class IBPI_PTMemDataInterface>* AsBPI_PTMemData);
	void ResetTargetCharaParticle(const TArray<int32>& WaitTaskList);
	void ResetActorCharaParticle(const TArray<int32>& WaitTaskList);
	void UnlockOpeningAchievement(TArray<int32>& WaitTaskList);
	void UnlockHIttingAchievement(TArray<int32>& WaitTaskList);
	void GetTargetInfo(TArray<struct FSkillActionTargetInfo>* Info);
	void SeparateTargetInfo();
	void GetTargetInfoLength(int32* Length);
	void GetFirstTargetInfo(struct FSkillActionTargetInfo* Info, bool* Valid);
	void GetReflexInfo(TArray<struct FSkillActionTargetInfo>* Info);
	void GetReflexInfoLength(int32* Length);
	void GetMagatsuhiOtherActors(TArray<int32>* Actors);
	void GetMagatsuhiOtherActorsLength(int32* Length);
	void GetExtraAction(E_BTL_EXTRA_ACTION* ExtraAction);
	void GetDrainInfo(struct FSkillActionDrainInfo* M_DrainInfo);
	void GetFirstReflexInfo(struct FSkillActionTargetInfo* Info, bool* Valid);
	void GetAddMagGauge(int32* AddMagGauge);
	void GetAddReichi(int32* AddReichi);
	void GetActorBst(int32* bst);
	void Com_SecondApplyHit(int32 WaitCommandIndex, int32 HitEffect, const struct FTransform& RelativeTransform, bool IsWorldRelative, float LifeSec, int32 TranslucencyPriority, float RotYawRandMin, float RotYawRandMax, bool ApplyBlur, float StartBlurAmount, float EndBlurAmount, float BlurStartKeepSec, float BlurLerpSec, int32* ComIndex);
	void Com_BeginSecondPerformance();
	void IsSkiped(bool* Skiped);
	void DisableUpliftingEffect();
	void EnableUpliftingEffect();
	void StopAttachedSkeletalMeshActor();
	void AddNahobinoMotion(E_CHARA_MOTION_ID Motion);
	void RemoveNahobinoMotion(E_CHARA_MOTION_ID Motion);
	void Com_AddUplifting(int32 WaitCommandIndex, int32* ComIndex);
	void Com_OtherMagatsuhiActorsMotion(int32 WaitCommandIndex, E_CHARA_MOTION_ID Motion, int32* Com_Index);
	void UpdatePlayRate_SkelMeshParticle(class ASkeletalMeshActor*& SkelMesh);
	void UpdatePlayRate_SkelMeshCompParticle(class USkeletalMeshComponent*& SkelMeshComp);
	void Invisible_Loaded_Model();
	void Com_ServantReturn(int32 WaitCommandIndex, float WaitSec, int32* ComIndex);
	void GetActorSide(E_BTL_SIDE* Side);
	void PrepareCounter();
	void PrepareServantSkillVoiceSetting();
	void PrepareMagatsuhiSkillVoiceSetting();
	void IsBlockOrAbsorb(bool* BlockOrAbsorb);
	void BI_Com_ActorSetMotion(int32 WaitCommandIndex, E_CHARA_MOTION_ID MotionID, bool WaitMotionFinished, int32* Com_Index);
	void BI_Com_AttackMoveActor(int32 WaitCommandIndex, int32* Com_Index);
	void BI_RegisterDecal(class ADevilSpawnDecal_C* Decal, bool* NoUse);
	void BI_RegisterDecalComponent(class UMaterialAnimDecalComponent_C* Decal, bool* NoUse);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BattleSkillActionBase_C">();
	}
	static class ABattleSkillActionBase_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleSkillActionBase_C>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABattleSkillActionBase_C) == 0x000010, "Wrong alignment on ABattleSkillActionBase_C");
static_assert(sizeof(ABattleSkillActionBase_C) == 0x000940, "Wrong size on ABattleSkillActionBase_C");
static_assert(offsetof(ABattleSkillActionBase_C, UberGraphFrame) == 0x000220, "Member 'ABattleSkillActionBase_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, TargetLookAtPoint) == 0x000228, "Member 'ABattleSkillActionBase_C::TargetLookAtPoint' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, ActorLookAtPoint) == 0x000230, "Member 'ABattleSkillActionBase_C::ActorLookAtPoint' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, DefaultSceneRoot) == 0x000238, "Member 'ABattleSkillActionBase_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, TargetLightUpdater_Color_8DA36B374F0E40C887F4B28BA9CDEC3B) == 0x000240, "Member 'ABattleSkillActionBase_C::TargetLightUpdater_Color_8DA36B374F0E40C887F4B28BA9CDEC3B' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, TargetLightUpdater_Radius_8DA36B374F0E40C887F4B28BA9CDEC3B) == 0x000250, "Member 'ABattleSkillActionBase_C::TargetLightUpdater_Radius_8DA36B374F0E40C887F4B28BA9CDEC3B' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, TargetLightUpdater_Intensity_8DA36B374F0E40C887F4B28BA9CDEC3B) == 0x000254, "Member 'ABattleSkillActionBase_C::TargetLightUpdater_Intensity_8DA36B374F0E40C887F4B28BA9CDEC3B' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, TargetLightUpdater__Direction_8DA36B374F0E40C887F4B28BA9CDEC3B) == 0x000258, "Member 'ABattleSkillActionBase_C::TargetLightUpdater__Direction_8DA36B374F0E40C887F4B28BA9CDEC3B' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, TargetLightUpdater) == 0x000260, "Member 'ABattleSkillActionBase_C::TargetLightUpdater' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, ActorLightUpdater_Color_829671D24B2D645E5C956C931C4E2CD9) == 0x000268, "Member 'ABattleSkillActionBase_C::ActorLightUpdater_Color_829671D24B2D645E5C956C931C4E2CD9' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, ActorLightUpdater_Radius_829671D24B2D645E5C956C931C4E2CD9) == 0x000278, "Member 'ABattleSkillActionBase_C::ActorLightUpdater_Radius_829671D24B2D645E5C956C931C4E2CD9' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, ActorLightUpdater_Intensity_829671D24B2D645E5C956C931C4E2CD9) == 0x00027C, "Member 'ABattleSkillActionBase_C::ActorLightUpdater_Intensity_829671D24B2D645E5C956C931C4E2CD9' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, ActorLightUpdater__Direction_829671D24B2D645E5C956C931C4E2CD9) == 0x000280, "Member 'ABattleSkillActionBase_C::ActorLightUpdater__Direction_829671D24B2D645E5C956C931C4E2CD9' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, ActorLightUpdater) == 0x000288, "Member 'ABattleSkillActionBase_C::ActorLightUpdater' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, LightBlinker_Radius_268FA2124C487D388FD7CD9A45AE2C4E) == 0x000290, "Member 'ABattleSkillActionBase_C::LightBlinker_Radius_268FA2124C487D388FD7CD9A45AE2C4E' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, LightBlinker_Intensity_268FA2124C487D388FD7CD9A45AE2C4E) == 0x000294, "Member 'ABattleSkillActionBase_C::LightBlinker_Intensity_268FA2124C487D388FD7CD9A45AE2C4E' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, LightBlinker__Direction_268FA2124C487D388FD7CD9A45AE2C4E) == 0x000298, "Member 'ABattleSkillActionBase_C::LightBlinker__Direction_268FA2124C487D388FD7CD9A45AE2C4E' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, LightBlinker) == 0x0002A0, "Member 'ABattleSkillActionBase_C::LightBlinker' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_Step) == 0x0002A8, "Member 'ABattleSkillActionBase_C::M_Step' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_Introduction) == 0x0002B0, "Member 'ABattleSkillActionBase_C::Evt_Introduction' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_Hit) == 0x0002C0, "Member 'ABattleSkillActionBase_C::Evt_Hit' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_Critical) == 0x0002D0, "Member 'ABattleSkillActionBase_C::Evt_Critical' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_Counter) == 0x0002E0, "Member 'ABattleSkillActionBase_C::Evt_Counter' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_Dead) == 0x0002F0, "Member 'ABattleSkillActionBase_C::Evt_Dead' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_Desc) == 0x000300, "Member 'ABattleSkillActionBase_C::M_Desc' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_CommandIDList) == 0x000390, "Member 'ABattleSkillActionBase_C::M_CommandIDList' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_Idle) == 0x0003A0, "Member 'ABattleSkillActionBase_C::Evt_Idle' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_PrevStep) == 0x0003B0, "Member 'ABattleSkillActionBase_C::M_PrevStep' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_Dead) == 0x0003B1, "Member 'ABattleSkillActionBase_C::M_Dead' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_Counter) == 0x0003B2, "Member 'ABattleSkillActionBase_C::M_Counter' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsFinish) == 0x0003B3, "Member 'ABattleSkillActionBase_C::M_IsFinish' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_Finish) == 0x0003B8, "Member 'ABattleSkillActionBase_C::Evt_Finish' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_Finalize) == 0x0003C8, "Member 'ABattleSkillActionBase_C::Evt_Finalize' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_UpdateState) == 0x0003D8, "Member 'ABattleSkillActionBase_C::Evt_UpdateState' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsAppliedHit) == 0x0003E8, "Member 'ABattleSkillActionBase_C::M_IsAppliedHit' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ApplyHitWaitingSec) == 0x0003EC, "Member 'ABattleSkillActionBase_C::M_ApplyHitWaitingSec' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsForceFinish) == 0x0003F0, "Member 'ABattleSkillActionBase_C::M_IsForceFinish' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_AnimNotify_PlayEffectID) == 0x0003F4, "Member 'ABattleSkillActionBase_C::M_AnimNotify_PlayEffectID' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_AnimNotify_TransPrio) == 0x0003F8, "Member 'ABattleSkillActionBase_C::M_AnimNotify_TransPrio' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_BiAttackWaitTime) == 0x0003FC, "Member 'ABattleSkillActionBase_C::M_BiAttackWaitTime' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_BiAttackWaitComIDs) == 0x000400, "Member 'ABattleSkillActionBase_C::M_BiAttackWaitComIDs' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_UniqueName) == 0x000410, "Member 'ABattleSkillActionBase_C::M_UniqueName' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ActorPointLight) == 0x000420, "Member 'ABattleSkillActionBase_C::M_ActorPointLight' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_TargetPointLight) == 0x000430, "Member 'ABattleSkillActionBase_C::M_TargetPointLight' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_LightFuncMaterial) == 0x000440, "Member 'ABattleSkillActionBase_C::M_LightFuncMaterial' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsReservePerform_OnApplyHitFunc) == 0x000450, "Member 'ABattleSkillActionBase_C::M_IsReservePerform_OnApplyHitFunc' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_WaitCommandList_OnApplyHitFunc) == 0x000458, "Member 'ABattleSkillActionBase_C::M_WaitCommandList_OnApplyHitFunc' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ExWaitComIndex) == 0x000468, "Member 'ABattleSkillActionBase_C::M_ExWaitComIndex' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_HitEffect) == 0x00046C, "Member 'ABattleSkillActionBase_C::M_HitEffect' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_RelativeTransform) == 0x000470, "Member 'ABattleSkillActionBase_C::M_RelativeTransform' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_LifeSec) == 0x0004A0, "Member 'ABattleSkillActionBase_C::M_LifeSec' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_TranslucencyPriolity) == 0x0004A4, "Member 'ABattleSkillActionBase_C::M_TranslucencyPriolity' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ApplyBlur) == 0x0004A8, "Member 'ABattleSkillActionBase_C::M_ApplyBlur' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ApplyHitWaitTask) == 0x0004AC, "Member 'ABattleSkillActionBase_C::M_ApplyHitWaitTask' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsDoneApplyHitDefault) == 0x0004B0, "Member 'ABattleSkillActionBase_C::M_IsDoneApplyHitDefault' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_StartBlurAmount) == 0x0004B4, "Member 'ABattleSkillActionBase_C::M_StartBlurAmount' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_EndBlurAmount) == 0x0004B8, "Member 'ABattleSkillActionBase_C::M_EndBlurAmount' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_BlurLerpSec) == 0x0004BC, "Member 'ABattleSkillActionBase_C::M_BlurLerpSec' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_BlurStartKeepSec) == 0x0004C0, "Member 'ABattleSkillActionBase_C::M_BlurStartKeepSec' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_Effects) == 0x0004C8, "Member 'ABattleSkillActionBase_C::M_Effects' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsCounterActor) == 0x0004D8, "Member 'ABattleSkillActionBase_C::M_IsCounterActor' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsUseForAttack) == 0x0004D9, "Member 'ABattleSkillActionBase_C::M_IsUseForAttack' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_AddRandomRollMin) == 0x0004DC, "Member 'ABattleSkillActionBase_C::M_AddRandomRollMin' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_AddRandomRollMax) == 0x0004E0, "Member 'ABattleSkillActionBase_C::M_AddRandomRollMax' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, Evt_SkillPerformance) == 0x0004E8, "Member 'ABattleSkillActionBase_C::Evt_SkillPerformance' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsAcceptAnimNotifyAvoidTiming) == 0x0004F8, "Member 'ABattleSkillActionBase_C::M_IsAcceptAnimNotifyAvoidTiming' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_AnimNotify_AvoidedTargetIndexes) == 0x000500, "Member 'ABattleSkillActionBase_C::M_AnimNotify_AvoidedTargetIndexes' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ApplyHitWaitTaskList) == 0x000510, "Member 'ABattleSkillActionBase_C::M_ApplyHitWaitTaskList' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ComIDs) == 0x000520, "Member 'ABattleSkillActionBase_C::M_ComIDs' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_TargetNowIndex) == 0x000530, "Member 'ABattleSkillActionBase_C::M_TargetNowIndex' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ApplyDelay) == 0x000534, "Member 'ABattleSkillActionBase_C::M_ApplyDelay' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ComApplyHitBlankTask) == 0x000538, "Member 'ABattleSkillActionBase_C::M_ComApplyHitBlankTask' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_HitPointLight) == 0x000540, "Member 'ABattleSkillActionBase_C::M_HitPointLight' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_SkillLightList) == 0x000550, "Member 'ABattleSkillActionBase_C::M_SkillLightList' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_PlayRate) == 0x0005A0, "Member 'ABattleSkillActionBase_C::M_PlayRate' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsCounterEnd) == 0x0005A4, "Member 'ABattleSkillActionBase_C::M_IsCounterEnd' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_LightAddCnt) == 0x0005A8, "Member 'ABattleSkillActionBase_C::M_LightAddCnt' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_LightAddCnt2) == 0x0005AC, "Member 'ABattleSkillActionBase_C::M_LightAddCnt2' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IntroWaitBlankTask) == 0x0005B0, "Member 'ABattleSkillActionBase_C::M_IntroWaitBlankTask' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IntroForceBreakTask) == 0x000600, "Member 'ABattleSkillActionBase_C::M_IntroForceBreakTask' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsBarrierTimingPassed) == 0x000610, "Member 'ABattleSkillActionBase_C::M_IsBarrierTimingPassed' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ApplyDelay_Random) == 0x000614, "Member 'ABattleSkillActionBase_C::M_ApplyDelay_Random' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsWorldRelative) == 0x000618, "Member 'ABattleSkillActionBase_C::M_IsWorldRelative' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_RotRandMin) == 0x00061C, "Member 'ABattleSkillActionBase_C::M_RotRandMin' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_RotRandMax) == 0x000620, "Member 'ABattleSkillActionBase_C::M_RotRandMax' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ReflexForceBreakTask) == 0x000628, "Member 'ABattleSkillActionBase_C::M_ReflexForceBreakTask' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsPreparedReflexCam) == 0x000638, "Member 'ABattleSkillActionBase_C::M_IsPreparedReflexCam' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_AimLocator) == 0x00063C, "Member 'ABattleSkillActionBase_C::M_AimLocator' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_BarrierReactionWaitTask) == 0x000648, "Member 'ABattleSkillActionBase_C::M_BarrierReactionWaitTask' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsOverrideBarrierTiming) == 0x000698, "Member 'ABattleSkillActionBase_C::M_IsOverrideBarrierTiming' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsReserveApplyDrain) == 0x000699, "Member 'ABattleSkillActionBase_C::M_IsReserveApplyDrain' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsChantCameraFront) == 0x00069A, "Member 'ABattleSkillActionBase_C::M_IsChantCameraFront' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsCharaMoved) == 0x00069B, "Member 'ABattleSkillActionBase_C::M_IsCharaMoved' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsAcceptAnimNotifyRapidReturn) == 0x00069C, "Member 'ABattleSkillActionBase_C::M_IsAcceptAnimNotifyRapidReturn' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsDoneJustBeforeApplyHit) == 0x00069D, "Member 'ABattleSkillActionBase_C::M_IsDoneJustBeforeApplyHit' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_JustBeforeApplyHitSec) == 0x0006A0, "Member 'ABattleSkillActionBase_C::M_JustBeforeApplyHitSec' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsReservedJustBeforeApplyHit) == 0x0006A4, "Member 'ABattleSkillActionBase_C::M_IsReservedJustBeforeApplyHit' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsJustBeforeApplyHitDefault) == 0x0006A5, "Member 'ABattleSkillActionBase_C::M_IsJustBeforeApplyHitDefault' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_DefaultHitStopData) == 0x0006A8, "Member 'ABattleSkillActionBase_C::M_DefaultHitStopData' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, EvT_ItemIntroduction) == 0x0006E0, "Member 'ABattleSkillActionBase_C::EvT_ItemIntroduction' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsAlreadyDirChanged) == 0x0006F0, "Member 'ABattleSkillActionBase_C::M_IsAlreadyDirChanged' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsAlreadyActorMoveToTarget) == 0x0006F1, "Member 'ABattleSkillActionBase_C::M_IsAlreadyActorMoveToTarget' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_SkillMotionOffsetPosition) == 0x0006F4, "Member 'ABattleSkillActionBase_C::M_SkillMotionOffsetPosition' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, ActorMoveToTarget_MovePos) == 0x0006F8, "Member 'ABattleSkillActionBase_C::ActorMoveToTarget_MovePos' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_MeleeStartDistance) == 0x000704, "Member 'ABattleSkillActionBase_C::M_MeleeStartDistance' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_MoveToTargetResult) == 0x000708, "Member 'ABattleSkillActionBase_C::M_MoveToTargetResult' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_AlreadyApplyHitList) == 0x000710, "Member 'ABattleSkillActionBase_C::M_AlreadyApplyHitList' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_TargetDefenceArea) == 0x000720, "Member 'ABattleSkillActionBase_C::M_TargetDefenceArea' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsBeginHitStop) == 0x000724, "Member 'ABattleSkillActionBase_C::M_IsBeginHitStop' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsForceUseHitStamp) == 0x000725, "Member 'ABattleSkillActionBase_C::M_IsForceUseHitStamp' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_EffectPlayParam) == 0x000728, "Member 'ABattleSkillActionBase_C::M_EffectPlayParam' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsAlreadyCameraChanged) == 0x000738, "Member 'ABattleSkillActionBase_C::M_IsAlreadyCameraChanged' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_AnimCamPecIDs) == 0x000740, "Member 'ABattleSkillActionBase_C::M_AnimCamPecIDs' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsForcedSkip) == 0x000750, "Member 'ABattleSkillActionBase_C::M_IsForcedSkip' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_EnableForcedSkip) == 0x000751, "Member 'ABattleSkillActionBase_C::M_EnableForcedSkip' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsUseReflexCam) == 0x000752, "Member 'ABattleSkillActionBase_C::M_IsUseReflexCam' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsRetrievePlayParam) == 0x000753, "Member 'ABattleSkillActionBase_C::M_IsRetrievePlayParam' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsForceUseReflexCam) == 0x000754, "Member 'ABattleSkillActionBase_C::M_IsForceUseReflexCam' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_LightPlayParam) == 0x000758, "Member 'ABattleSkillActionBase_C::M_LightPlayParam' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ApplyHitCamShakeTaskIDs) == 0x000768, "Member 'ABattleSkillActionBase_C::M_ApplyHitCamShakeTaskIDs' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsForceOtherSideAllVisible) == 0x000778, "Member 'ABattleSkillActionBase_C::M_IsForceOtherSideAllVisible' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsCalledPlayEffectAbsorption) == 0x000779, "Member 'ABattleSkillActionBase_C::M_IsCalledPlayEffectAbsorption' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsManualCameraShake) == 0x00077A, "Member 'ABattleSkillActionBase_C::M_IsManualCameraShake' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_JustBeforeApplyHitWaitTask) == 0x00077C, "Member 'ABattleSkillActionBase_C::M_JustBeforeApplyHitWaitTask' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsAlreadyWarpAtIntroductionMelee) == 0x000780, "Member 'ABattleSkillActionBase_C::M_IsAlreadyWarpAtIntroductionMelee' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_DecalActors) == 0x000788, "Member 'ABattleSkillActionBase_C::M_DecalActors' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_DecalComponents) == 0x000798, "Member 'ABattleSkillActionBase_C::M_DecalComponents' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsJustBeforeApplyHitValidation) == 0x0007A8, "Member 'ABattleSkillActionBase_C::M_IsJustBeforeApplyHitValidation' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IgnoreSkip) == 0x0007A9, "Member 'ABattleSkillActionBase_C::M_IgnoreSkip' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_Skiped) == 0x0007AA, "Member 'ABattleSkillActionBase_C::M_Skiped' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsWhiteOutDead) == 0x0007AB, "Member 'ABattleSkillActionBase_C::M_IsWhiteOutDead' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsIgnroeHitStop) == 0x0007AC, "Member 'ABattleSkillActionBase_C::M_IsIgnroeHitStop' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsBecomeBadStatus) == 0x0007AD, "Member 'ABattleSkillActionBase_C::M_IsBecomeBadStatus' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsWhiteOutDeadTarget) == 0x0007B0, "Member 'ABattleSkillActionBase_C::M_IsWhiteOutDeadTarget' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_WhiteOutWaitTaskList) == 0x0007B8, "Member 'ABattleSkillActionBase_C::M_WhiteOutWaitTaskList' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_CntReflectKuishibari) == 0x0007C8, "Member 'ABattleSkillActionBase_C::M_CntReflectKuishibari' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, IsSkippingInProgress) == 0x0007CC, "Member 'ABattleSkillActionBase_C::IsSkippingInProgress' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_HinderCheckRemainSec) == 0x0007D0, "Member 'ABattleSkillActionBase_C::M_HinderCheckRemainSec' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_CameraHinders) == 0x0007D8, "Member 'ABattleSkillActionBase_C::M_CameraHinders' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsActorScaleOne) == 0x0007E8, "Member 'ABattleSkillActionBase_C::M_IsActorScaleOne' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_MultiMagatsuhiSkillActivated) == 0x0007E9, "Member 'ABattleSkillActionBase_C::M_MultiMagatsuhiSkillActivated' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ServantPartyIndex) == 0x0007EC, "Member 'ABattleSkillActionBase_C::M_ServantPartyIndex' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsUseServant) == 0x0007F0, "Member 'ABattleSkillActionBase_C::M_IsUseServant' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsLoadedServantModel) == 0x0007F1, "Member 'ABattleSkillActionBase_C::M_IsLoadedServantModel' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ContinueUpdate) == 0x0007F2, "Member 'ABattleSkillActionBase_C::M_ContinueUpdate' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsLoadedMagatsuhiModel) == 0x0007F3, "Member 'ABattleSkillActionBase_C::M_IsLoadedMagatsuhiModel' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsRequestedServantModel) == 0x0007F4, "Member 'ABattleSkillActionBase_C::M_IsRequestedServantModel' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsRequestedMagatsuhiModel) == 0x0007F5, "Member 'ABattleSkillActionBase_C::M_IsRequestedMagatsuhiModel' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_SpendFrames) == 0x0007F8, "Member 'ABattleSkillActionBase_C::M_SpendFrames' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_LoadingMagatsuhiModels) == 0x0007FC, "Member 'ABattleSkillActionBase_C::M_LoadingMagatsuhiModels' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_MoveToTargetTrans) == 0x000800, "Member 'ABattleSkillActionBase_C::M_MoveToTargetTrans' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_LightFuncMaterialIns) == 0x000830, "Member 'ABattleSkillActionBase_C::M_LightFuncMaterialIns' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsLoadingLightFuncMaterial) == 0x000840, "Member 'ABattleSkillActionBase_C::M_IsLoadingLightFuncMaterial' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_AddActorPointLightData) == 0x000848, "Member 'ABattleSkillActionBase_C::M_AddActorPointLightData' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_LoadedLightFuncMaterials) == 0x0008B0, "Member 'ABattleSkillActionBase_C::M_LoadedLightFuncMaterials' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsLoadedLightFuncMaterial) == 0x0008B4, "Member 'ABattleSkillActionBase_C::M_IsLoadedLightFuncMaterial' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_UniqueSkillInfoTask) == 0x0008B8, "Member 'ABattleSkillActionBase_C::M_UniqueSkillInfoTask' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_ApplyHitWaitTaskList2) == 0x0008C0, "Member 'ABattleSkillActionBase_C::M_ApplyHitWaitTaskList2' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_SpendSec) == 0x0008D0, "Member 'ABattleSkillActionBase_C::M_SpendSec' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_PrimaryTargetInfo) == 0x0008D8, "Member 'ABattleSkillActionBase_C::M_PrimaryTargetInfo' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_SecondaryTargetInfo) == 0x0008E8, "Member 'ABattleSkillActionBase_C::M_SecondaryTargetInfo' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_SecondApplyHit) == 0x0008F8, "Member 'ABattleSkillActionBase_C::M_SecondApplyHit' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, UpliftingPartyIndex) == 0x000900, "Member 'ABattleSkillActionBase_C::UpliftingPartyIndex' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_TsukuyomiMotion) == 0x000910, "Member 'ABattleSkillActionBase_C::M_TsukuyomiMotion' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_NormalMotion) == 0x000918, "Member 'ABattleSkillActionBase_C::M_NormalMotion' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_HitStopCtrl) == 0x000920, "Member 'ABattleSkillActionBase_C::M_HitStopCtrl' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsBecomeBadStatusMud) == 0x000928, "Member 'ABattleSkillActionBase_C::M_IsBecomeBadStatusMud' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsBecomeBadStatusDarkness) == 0x000929, "Member 'ABattleSkillActionBase_C::M_IsBecomeBadStatusDarkness' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_IsComApplyHitDone) == 0x00092A, "Member 'ABattleSkillActionBase_C::M_IsComApplyHitDone' has a wrong offset!");
static_assert(offsetof(ABattleSkillActionBase_C, M_SkipSE) == 0x000930, "Member 'ABattleSkillActionBase_C::M_SkipSE' has a wrong offset!");

}

