#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_MovePiece

#include "Basic.hpp"

#include "BPI_MovePiece_classes.hpp"
#include "BPI_MovePiece_parameters.hpp"


namespace SDK
{

// Function BPI_MovePiece.BPI_MovePiece_C.BPI_InitMovePiece
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPieceData                       PieceData                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    IsBtlResult                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsForceGet                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    InfoOnly                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   PrevNum                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_MovePiece_C::BPI_InitMovePiece(const struct FPieceData& PieceData, bool IsBtlResult, bool IsForceGet, bool InfoOnly, int32 PrevNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_MovePiece_C", "BPI_InitMovePiece");

	Params::BPI_MovePiece_C_BPI_InitMovePiece Parms{};

	Parms.PieceData = std::move(PieceData);
	Parms.IsBtlResult = IsBtlResult;
	Parms.IsForceGet = IsForceGet;
	Parms.InfoOnly = InfoOnly;
	Parms.PrevNum = PrevNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_MovePiece.BPI_MovePiece_C.BPI_GetMovePieceCollision
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBoxComponent*                    Collision                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_MovePiece_C::BPI_GetMovePieceCollision(class UBoxComponent** Collision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_MovePiece_C", "BPI_GetMovePieceCollision");

	Params::BPI_MovePiece_C_BPI_GetMovePieceCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Collision != nullptr)
		*Collision = Parms.Collision;
}


// Function BPI_MovePiece.BPI_MovePiece_C.BPI_MissedTakara
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SaveId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TakaraActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AfterFlag                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HaveLimitOver                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_MovePiece_C::BPI_MissedTakara(int32 SaveId, class AActor* TakaraActor, int32 AfterFlag, bool HaveLimitOver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_MovePiece_C", "BPI_MissedTakara");

	Params::BPI_MovePiece_C_BPI_MissedTakara Parms{};

	Parms.SaveId = SaveId;
	Parms.TakaraActor = TakaraActor;
	Parms.AfterFlag = AfterFlag;
	Parms.HaveLimitOver = HaveLimitOver;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_MovePiece.BPI_MovePiece_C.BPI_ShowAgainMovePiece
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_MovePiece_C::BPI_ShowAgainMovePiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_MovePiece_C", "BPI_ShowAgainMovePiece");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPI_MovePiece.BPI_MovePiece_C.BPI_HideMovePiece
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_MovePiece_C::BPI_HideMovePiece()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_MovePiece_C", "BPI_HideMovePiece");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPI_MovePiece.BPI_MovePiece_C.BPI_CallWhenRoomRotateStart
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_MovePiece_C::BPI_CallWhenRoomRotateStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_MovePiece_C", "BPI_CallWhenRoomRotateStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPI_MovePiece.BPI_MovePiece_C.BPI_CallWhenRoomRotateEnd
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_MovePiece_C::BPI_CallWhenRoomRotateEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_MovePiece_C", "BPI_CallWhenRoomRotateEnd");

	UObject::ProcessEvent(Func, nullptr);
}

}

