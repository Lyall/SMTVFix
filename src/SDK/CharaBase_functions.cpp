#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharaBase

#include "Basic.hpp"

#include "CharaBase_classes.hpp"
#include "CharaBase_parameters.hpp"


namespace SDK
{

// Function CharaBase.CharaBase_C.Evt_Move__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_Move__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_Move__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_Dir__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_Dir__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_Dir__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Notify_ApplyHit__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Notify_ApplyHit__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Notify_ApplyHit__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_Tilt__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_Tilt__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_Tilt__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_DamageMotionEnd__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_DamageMotionEnd__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_DamageMotionEnd__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_OnFinishFade__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_OnFinishFade__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_OnFinishFade__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.ExecuteUbergraph_CharaBase
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::ExecuteUbergraph_CharaBase(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ExecuteUbergraph_CharaBase");

	Params::CharaBase_C_ExecuteUbergraph_CharaBase Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BI_SetLipClearDelay
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_SetLipClearDelay(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetLipClearDelay");

	Params::CharaBase_C_BI_SetLipClearDelay Parms{};

	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BI_ForceDisableLimitLookAt
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Disable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_ForceDisableLimitLookAt(bool Disable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_ForceDisableLimitLookAt");

	Params::CharaBase_C_BI_ForceDisableLimitLookAt Parms{};

	Parms.Disable = Disable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BI_SetLimitLookAtRange
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetLimitLookAtRange(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetLimitLookAtRange");

	Params::CharaBase_C_BI_SetLimitLookAtRange Parms{};

	Parms.IsActive = IsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.StopInstantMaterialAnimation
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::StopInstantMaterialAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "StopInstantMaterialAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.ControlUplifting
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ControlUplifting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ControlUplifting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.InstantMaterialAnimation_Impl
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MATERIAL_ANIMATION_SLOT         Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           ElementNo                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSetting                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsForward                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::InstantMaterialAnimation_Impl(E_CHARA_MATERIAL_ANIMATION_SLOT Slot, const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InstantMaterialAnimation_Impl");

	Params::CharaBase_C_InstantMaterialAnimation_Impl Parms{};

	Parms.Slot = Slot;
	Parms.ElementNo = std::move(ElementNo);
	Parms.MaterialAnimSetting = std::move(MaterialAnimSetting);
	Parms.IsForward = IsForward;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InstantMaterialAnimationSlot4
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>                           ElementNo                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSetting                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsForward                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::InstantMaterialAnimationSlot4(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InstantMaterialAnimationSlot4");

	Params::CharaBase_C_InstantMaterialAnimationSlot4 Parms{};

	Parms.ElementNo = std::move(ElementNo);
	Parms.MaterialAnimSetting = std::move(MaterialAnimSetting);
	Parms.IsForward = IsForward;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InstantMaterialAnimationSlot3
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>                           ElementNo                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSetting                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsForward                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::InstantMaterialAnimationSlot3(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InstantMaterialAnimationSlot3");

	Params::CharaBase_C_InstantMaterialAnimationSlot3 Parms{};

	Parms.ElementNo = std::move(ElementNo);
	Parms.MaterialAnimSetting = std::move(MaterialAnimSetting);
	Parms.IsForward = IsForward;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InstantMaterialAnimationSlot2
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>                           ElementNo                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSetting                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsForward                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::InstantMaterialAnimationSlot2(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InstantMaterialAnimationSlot2");

	Params::CharaBase_C_InstantMaterialAnimationSlot2 Parms{};

	Parms.ElementNo = std::move(ElementNo);
	Parms.MaterialAnimSetting = std::move(MaterialAnimSetting);
	Parms.IsForward = IsForward;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InstantMaterialAnimationSlot1
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>                           ElementNo                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSetting                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsForward                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::InstantMaterialAnimationSlot1(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InstantMaterialAnimationSlot1");

	Params::CharaBase_C_InstantMaterialAnimationSlot1 Parms{};

	Parms.ElementNo = std::move(ElementNo);
	Parms.MaterialAnimSetting = std::move(MaterialAnimSetting);
	Parms.IsForward = IsForward;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InstantMaterialAnimationSlot0
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>                           ElementNo                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSetting                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsForward                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::InstantMaterialAnimationSlot0(const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InstantMaterialAnimationSlot0");

	Params::CharaBase_C_InstantMaterialAnimationSlot0 Parms{};

	Parms.ElementNo = std::move(ElementNo);
	Parms.MaterialAnimSetting = std::move(MaterialAnimSetting);
	Parms.IsForward = IsForward;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InstantMaterialAnimation
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MATERIAL_ANIMATION_SLOT         Slot                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           ElementNo                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSetting                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsForward                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsOnlyFirstTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::InstantMaterialAnimation(const E_CHARA_MATERIAL_ANIMATION_SLOT Slot, const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, bool IsForward, bool IsOnlyFirstTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InstantMaterialAnimation");

	Params::CharaBase_C_InstantMaterialAnimation Parms{};

	Parms.Slot = Slot;
	Parms.ElementNo = std::move(ElementNo);
	Parms.MaterialAnimSetting = std::move(MaterialAnimSetting);
	Parms.IsForward = IsForward;
	Parms.IsOnlyFirstTime = IsOnlyFirstTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ResetAllParticleSystem
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ResetAllParticleSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetAllParticleSystem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetCharaPlayRate
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CharaPlayRate                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetCharaPlayRate(float CharaPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetCharaPlayRate");

	Params::CharaBase_C_SetCharaPlayRate Parms{};

	Parms.CharaPlayRate = CharaPlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ResetAllMaterialParam
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ResetAllMaterialParam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetAllMaterialParam");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MotionHeadNotifyEvent
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::MotionHeadNotifyEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MotionHeadNotifyEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.OnTransformUpdatedForIK
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Teleport                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::OnTransformUpdatedForIK(bool Teleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "OnTransformUpdatedForIK");

	Params::CharaBase_C_OnTransformUpdatedForIK Parms{};

	Parms.Teleport = Teleport;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ControlBadStatusParticles
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Delata                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::ControlBadStatusParticles(float Delata)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ControlBadStatusParticles");

	Params::CharaBase_C_ControlBadStatusParticles Parms{};

	Parms.Delata = Delata;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ControlAura
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ControlAura()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ControlAura");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_C_Dir
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_C_Dir()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_C_Dir");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_C_Move
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_C_Move()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_C_Move");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.PostEvaluateAnimation
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::PostEvaluateAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PostEvaluateAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.UpdateAnimation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::UpdateAnimation(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateAnimation");

	Params::CharaBase_C_UpdateAnimation Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InitializeAnimation
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitializeAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitializeAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ReceiveTick");

	Params::CharaBase_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ACharaBase_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.StopCharaShake
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::StopCharaShake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "StopCharaShake");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.RapidReturnAction
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::RapidReturnAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "RapidReturnAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.RapidSummonAction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentStatus                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::RapidSummonAction(int32 CurrentStatus, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "RapidSummonAction");

	Params::CharaBase_C_RapidSummonAction Parms{};

	Parms.CurrentStatus = CurrentStatus;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SpawnAction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_PlayMotion                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsInstantEvent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SpawnAction(bool Param_PlayMotion, bool IsInstantEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SpawnAction");

	Params::CharaBase_C_SpawnAction Parms{};

	Parms.Param_PlayMotion = Param_PlayMotion;
	Parms.IsInstantEvent = IsInstantEvent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.CharaShake
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Magnitude                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DurationSec                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CharaShake(float Magnitude, float DurationSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CharaShake");

	Params::CharaBase_C_CharaShake Parms{};

	Parms.Magnitude = Magnitude;
	Parms.DurationSec = DurationSec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ReturnAction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   PlayRate                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsInstantEvent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::ReturnAction(float PlayRate, bool IsInstantEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ReturnAction");

	Params::CharaBase_C_ReturnAction Parms{};

	Parms.PlayRate = PlayRate;
	Parms.IsInstantEvent = IsInstantEvent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SummonAction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentStatus                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsInstantEvent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsInBattle                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SummonAction(int32 CurrentStatus, bool Immediately, bool IsInstantEvent, bool IsInBattle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SummonAction");

	Params::CharaBase_C_SummonAction Parms{};

	Parms.CurrentStatus = CurrentStatus;
	Parms.Immediately = Immediately;
	Parms.IsInstantEvent = IsInstantEvent;
	Parms.IsInBattle = IsInBattle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ReviveAction
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ReviveAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ReviveAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Act Fusion Release
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Act_Fusion_Release()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act Fusion Release");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Act Fusion Prepare
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Act_Fusion_Prepare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act Fusion Prepare");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.KnockBack
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Distance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::KnockBack(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "KnockBack");

	Params::CharaBase_C_KnockBack Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ResetBadStatusMaterialParameter
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ResetBadStatusMaterialParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetBadStatusMaterialParameter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_EndAlmostYugami
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_EndAlmostYugami()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_EndAlmostYugami");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_StartAlmostYugami
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_StartAlmostYugami()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_StartAlmostYugami");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.PrintNames
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Title                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// TArray<class FName>                     Names                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ACharaBase_C::PrintNames(const class FString& Title, const TArray<class FName>& Names)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PrintNames");

	Params::CharaBase_C_PrintNames Parms{};

	Parms.Title = std::move(Title);
	Parms.Names = std::move(Names);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.UpdateSurfaceBadStatus
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentStatus                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::UpdateSurfaceBadStatus(int32 CurrentStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateSurfaceBadStatus");

	Params::CharaBase_C_UpdateSurfaceBadStatus Parms{};

	Parms.CurrentStatus = CurrentStatus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ReplayPresentMotion
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ReplayPresentMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ReplayPresentMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.BadStatusMaterialOff
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<E_BAD_STATUS>                    OffBadStatus                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ACharaBase_C::BadStatusMaterialOff(const TArray<E_BAD_STATUS>& OffBadStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BadStatusMaterialOff");

	Params::CharaBase_C_BadStatusMaterialOff Parms{};

	Parms.OffBadStatus = std::move(OffBadStatus);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BadStatusMaterialOn
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<E_BAD_STATUS>                    OnBadStatus                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ACharaBase_C::BadStatusMaterialOn(const TArray<E_BAD_STATUS>& OnBadStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BadStatusMaterialOn");

	Params::CharaBase_C_BadStatusMaterialOn Parms{};

	Parms.OnBadStatus = std::move(OnBadStatus);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.Evt_ResetBadStatusMaterial
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_ResetBadStatusMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_ResetBadStatusMaterial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_ResetEffect
// (BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Evt_ResetEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_ResetEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Evt_UpdateCharaState
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsNoCureEffect                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsLacerationDamage                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::Evt_UpdateCharaState(int32 State, bool IsNoCureEffect, bool IsLacerationDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Evt_UpdateCharaState");

	Params::CharaBase_C_Evt_UpdateCharaState Parms{};

	Parms.State = State;
	Parms.IsNoCureEffect = IsNoCureEffect;
	Parms.IsLacerationDamage = IsLacerationDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ResetCritical
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ResetCritical()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetCritical");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetCritical
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::SetCritical()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetCritical");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.ResetState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::ResetState(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetState");

	Params::CharaBase_C_ResetState Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.StopDefaultBlink
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::StopDefaultBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "StopDefaultBlink");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.PlayDefaultBlink
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::PlayDefaultBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PlayDefaultBlink");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.StopLipSync
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::StopLipSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "StopLipSync");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.PlayLipSync
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCharaLipSync*                    Param_PlayLipSync                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsLoop                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::PlayLipSync(class UCharaLipSync* Param_PlayLipSync, bool IsLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PlayLipSync");

	Params::CharaBase_C_PlayLipSync Parms{};

	Parms.Param_PlayLipSync = Param_PlayLipSync;
	Parms.IsLoop = IsLoop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetAuraMaterial
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   AuraBit                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetAuraMaterial(int32 AuraBit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetAuraMaterial");

	Params::CharaBase_C_SetAuraMaterial Parms{};

	Parms.AuraBit = AuraBit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.MapDettachWepon
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::MapDettachWepon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MapDettachWepon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MapAttachWepon
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::MapAttachWepon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MapAttachWepon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MapAttackAction
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::MapAttackAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MapAttackAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetState(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetState");

	Params::CharaBase_C_SetState Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.DeathAction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   InOption                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DeadTimingOverride                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   DeadTiming                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::DeathAction(uint8 InOption, bool DeadTimingOverride, float DeadTiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "DeathAction");

	Params::CharaBase_C_DeathAction Parms{};

	Parms.InOption = InOption;
	Parms.DeadTimingOverride = DeadTimingOverride;
	Parms.DeadTiming = DeadTiming;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BI_SetHeadIKSpeed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Speed                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_SetHeadIKSpeed(float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetHeadIKSpeed");

	Params::CharaBase_C_BI_SetHeadIKSpeed Parms{};

	Parms.Speed = Speed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.StopSpeakingMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::StopSpeakingMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "StopSpeakingMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.PlaySpeakingMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::PlaySpeakingMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PlaySpeakingMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.BI_SetForceUpdateLookAt
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsForceUpdate                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetForceUpdateLookAt(bool IsForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetForceUpdateLookAt");

	Params::CharaBase_C_BI_SetForceUpdateLookAt Parms{};

	Parms.IsForceUpdate = IsForceUpdate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BI_TempToggleCameraDitherState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ForceDitherOff                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_TempToggleCameraDitherState(bool ForceDitherOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_TempToggleCameraDitherState");

	Params::CharaBase_C_BI_TempToggleCameraDitherState Parms{};

	Parms.ForceDitherOff = ForceDitherOff;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BI_GuestBattleFinalize
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::BI_GuestBattleFinalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GuestBattleFinalize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.BI_GuestBattleInitialize
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dither100                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GuestBattleInitialize(bool Dither100)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GuestBattleInitialize");

	Params::CharaBase_C_BI_GuestBattleInitialize Parms{};

	Parms.Dither100 = Dither100;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BI_AdjustMeshScale
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsReset                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_AdjustMeshScale(bool IsReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_AdjustMeshScale");

	Params::CharaBase_C_BI_AdjustMeshScale Parms{};

	Parms.IsReset = IsReset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BI_SetDevilRootMotion
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetDevilRootMotion(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetDevilRootMotion");

	Params::CharaBase_C_BI_SetDevilRootMotion Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BI_PlayStartEffect
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::BI_PlayStartEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_PlayStartEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.OnLoaded_A97098CA4B7318BB42959EAD76578B09
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::OnLoaded_A97098CA4B7318BB42959EAD76578B09(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "OnLoaded_A97098CA4B7318BB42959EAD76578B09");

	Params::CharaBase_C_OnLoaded_A97098CA4B7318BB42959EAD76578B09 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.OnLoaded_7FBAAD3F40145FB17876B482C2BD5698
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::OnLoaded_7FBAAD3F40145FB17876B482C2BD5698(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "OnLoaded_7FBAAD3F40145FB17876B482C2BD5698");

	Params::CharaBase_C_OnLoaded_7FBAAD3F40145FB17876B482C2BD5698 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.OnLoaded_2D74D81C4E9B44BA0E0FFB9ECDECDED5
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::OnLoaded_2D74D81C4E9B44BA0E0FFB9ECDECDED5(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "OnLoaded_2D74D81C4E9B44BA0E0FFB9ECDECDED5");

	Params::CharaBase_C_OnLoaded_2D74D81C4E9B44BA0E0FFB9ECDECDED5 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.OnLoaded_F45D6EED4F92F9BB26E14F8BFD9F4C6D
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::OnLoaded_F45D6EED4F92F9BB26E14F8BFD9F4C6D(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "OnLoaded_F45D6EED4F92F9BB26E14F8BFD9F4C6D");

	Params::CharaBase_C_OnLoaded_F45D6EED4F92F9BB26E14F8BFD9F4C6D Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.OnLoaded_FDBF0C12438F309C9DC5438C37BAF1BA
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::OnLoaded_FDBF0C12438F309C9DC5438C37BAF1BA(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "OnLoaded_FDBF0C12438F309C9DC5438C37BAF1BA");

	Params::CharaBase_C_OnLoaded_FDBF0C12438F309C9DC5438C37BAF1BA Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot4__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot4__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot4__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot4__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot4__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot4__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot3__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot3__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot3__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot3__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot3__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot3__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot2__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot2__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot2__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot2__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot2__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot2__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot1__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot1__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot1__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot1__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot1__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot1__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot0__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot0__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot0__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MaterialAnimSlot0__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::MaterialAnimSlot0__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MaterialAnimSlot0__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.CharaShakeTimeline__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::CharaShakeTimeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CharaShakeTimeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.CharaShakeTimeline__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::CharaShakeTimeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CharaShakeTimeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.S__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::_S____UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "S__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.S__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::_S____FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "S__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.ForAlmostYugami__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::ForAlmostYugami__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ForAlmostYugami__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.ForAlmostYugami__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::ForAlmostYugami__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ForAlmostYugami__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.d__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::_________d__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "d__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.d__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::_________d__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "d__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.!__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::_____________UpdateFunc_0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "!__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.!__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::_____________FinishedFunc_0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "!__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.	__PauseMotion__EventFunc
// (BlueprintEvent)

void ACharaBase_C::_____________PauseMotion__EventFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "	__PauseMotion__EventFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.	__UpdateFunc
// (BlueprintEvent)

void ACharaBase_C::_____________UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "	__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.	__FinishedFunc
// (BlueprintEvent)

void ACharaBase_C::_____________FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "	__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.PlayMotion
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_IsUseDuration                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseBlendTimeOverride                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTimeOverride                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::PlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool Param_IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PlayMotion");

	Params::CharaBase_C_PlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;
	Parms.Param_IsUseDuration = Param_IsUseDuration;
	Parms.Duration = Duration;
	Parms.IsUseBlendTimeOverride = IsUseBlendTimeOverride;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.StopMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::StopMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "StopMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.PauseMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::PauseMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PauseMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.ResumeMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ResumeMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResumeMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetLegIKEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetLegIKEnable(bool Enable, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetLegIKEnable");

	Params::CharaBase_C_SetLegIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetHeadIKEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetHeadIKEnable(bool Enable, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetHeadIKEnable");

	Params::CharaBase_C_SetHeadIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetEyeIKEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetEyeIKEnable(bool Enable, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetEyeIKEnable");

	Params::CharaBase_C_SetEyeIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InitializeIK
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitializeIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitializeIK");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.UpdateIK
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::UpdateIK(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateIK");

	Params::CharaBase_C_UpdateIK Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.UpdateSink
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UCharaSinkTesterInterface_C*>Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FVector                          Offset                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::UpdateSink(float DeltaTime, TArray<class UCharaSinkTesterInterface_C*>& Array, struct FVector* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateSink");

	Params::CharaBase_C_UpdateSink Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function CharaBase.CharaBase_C.ApplySinkOffset
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ApplySinkOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ApplySinkOffset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.LookAt
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Point                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::LookAt(class USceneComponent* Point, class FName Socket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "LookAt");

	Params::CharaBase_C_LookAt Parms{};

	Parms.Point = Point;
	Parms.Socket = Socket;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.LoadMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::LoadMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "LoadMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.InitializeMaterial
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitializeMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitializeMaterial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.OutLineSwitch
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::OutLineSwitch(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "OutLineSwitch");

	Params::CharaBase_C_OutLineSwitch Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SelectFresnelSwitch
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SelectFresnelSwitch(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SelectFresnelSwitch");

	Params::CharaBase_C_SelectFresnelSwitch Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SelectSwitch
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SelectSwitch(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SelectSwitch");

	Params::CharaBase_C_SelectSwitch Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetEffectBySocket
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystem*                  TargetEffect                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetEffectBySocket(class UParticleSystem* TargetEffect, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetEffectBySocket");

	Params::CharaBase_C_SetEffectBySocket Parms{};

	Parms.TargetEffect = TargetEffect;
	Parms.SocketName = SocketName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetSocketTransform
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       RetValue                                               (Parm, OutParm, IsPlainOldData, NoDestructor)

void ACharaBase_C::GetSocketTransform(class FName SocketName, struct FTransform* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetSocketTransform");

	Params::CharaBase_C_GetSocketTransform Parms{};

	Parms.SocketName = SocketName;

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = std::move(Parms.RetValue);
}


// Function CharaBase.CharaBase_C.Act_Death
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   InOption                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DeadTimingOverride                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   DeadTiming                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::Act_Death(uint8 InOption, bool DeadTimingOverride, float DeadTiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_Death");

	Params::CharaBase_C_Act_Death Parms{};

	Parms.InOption = InOption;
	Parms.DeadTimingOverride = DeadTimingOverride;
	Parms.DeadTiming = DeadTiming;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetActionState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_ACTION_TYPE                     InAction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::GetActionState(E_CHARA_ACTION_TYPE InAction, uint8* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetActionState");

	Params::CharaBase_C_GetActionState Parms{};

	Parms.InAction = InAction;

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBase.CharaBase_C.SetActionState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_ACTION_TYPE                     InAction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetActionState(E_CHARA_ACTION_TYPE InAction, uint8 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetActionState");

	Params::CharaBase_C_SetActionState Parms{};

	Parms.InAction = InAction;
	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsActionRun
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_ACTION_TYPE                     InAction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsActionRun(E_CHARA_ACTION_TYPE InAction, bool* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsActionRun");

	Params::CharaBase_C_IsActionRun Parms{};

	Parms.InAction = InAction;

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBase.CharaBase_C.ExecuteAction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_ACTION_TYPE                     InAction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   InOptionByte                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   InOptionInt                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InOptionFloat                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::ExecuteAction(E_CHARA_ACTION_TYPE InAction, uint8 InOptionByte, int32 InOptionInt, float InOptionFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ExecuteAction");

	Params::CharaBase_C_ExecuteAction Parms{};

	Parms.InAction = InAction;
	Parms.InOptionByte = InOptionByte;
	Parms.InOptionInt = InOptionInt;
	Parms.InOptionFloat = InOptionFloat;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsMotionFinished
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsMotionFinished(E_CHARA_MOTION_ID Param_MotionID, bool* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsMotionFinished");

	Params::CharaBase_C_IsMotionFinished Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBase.CharaBase_C.FootGround
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsHit                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::FootGround(bool* IsHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "FootGround");

	Params::CharaBase_C_FootGround Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsHit != nullptr)
		*IsHit = Parms.IsHit;
}


// Function CharaBase.CharaBase_C.MoveFunc
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::MoveFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MoveFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.MoveTo
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          To                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::MoveTo(float Time, const struct FVector& To)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MoveTo");

	Params::CharaBase_C_MoveTo Parms{};

	Parms.Time = Time;
	Parms.To = std::move(To);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.CallEvent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CallEvent(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CallEvent");

	Params::CharaBase_C_CallEvent Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.DirFunc
// (Private, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::DirFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "DirFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.DirTo
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InterpValue                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          To                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::DirTo(float InterpValue, const struct FVector& To)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "DirTo");

	Params::CharaBase_C_DirTo Parms{};

	Parms.InterpValue = InterpValue;
	Parms.To = std::move(To);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.Act_RunToUnit
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharaBase_C*                     TargetUnit                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DirInterp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_CHARA_MOTION_ID                       FinishedMotion                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Offset_Dest_Deg                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::Act_RunToUnit(class ACharaBase_C* TargetUnit, float Time, float DirInterp, E_CHARA_MOTION_ID FinishedMotion, float Offset_Dest_Deg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_RunToUnit");

	Params::CharaBase_C_Act_RunToUnit Parms{};

	Parms.TargetUnit = TargetUnit;
	Parms.Time = Time;
	Parms.DirInterp = DirInterp;
	Parms.FinishedMotion = FinishedMotion;
	Parms.Offset_Dest_Deg = Offset_Dest_Deg;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.UpdateAction
// (Private, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::UpdateAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Act_BackStep
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   AvoidDirection                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::Act_BackStep(uint8 AvoidDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_BackStep");

	Params::CharaBase_C_Act_BackStep Parms{};

	Parms.AvoidDirection = AvoidDirection;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.UpdateRunToUnit
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::UpdateRunToUnit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateRunToUnit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.UpdateBackStep
// (Private, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::UpdateBackStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateBackStep");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.GetNowMotionID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::GetNowMotionID(E_CHARA_MOTION_ID* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetNowMotionID");

	Params::CharaBase_C_GetNowMotionID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBase.CharaBase_C.ResetScalarParam
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ParamNames                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ACharaBase_C::ResetScalarParam(TArray<class FName>& ParamNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetScalarParam");

	Params::CharaBase_C_ResetScalarParam Parms{};

	Parms.ParamNames = std::move(ParamNames);

	UObject::ProcessEvent(Func, &Parms);

	ParamNames = std::move(Parms.ParamNames);
}


// Function CharaBase.CharaBase_C.SetScalarParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ParamNames                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   Val                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetScalarParam(TArray<class FName>& ParamNames, float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetScalarParam");

	Params::CharaBase_C_SetScalarParam Parms{};

	Parms.ParamNames = std::move(ParamNames);
	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);

	ParamNames = std::move(Parms.ParamNames);
}


// Function CharaBase.CharaBase_C.Act_Revive
// (Private, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Act_Revive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_Revive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetAuraEffect
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystem*                  EffectTemplate                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetAuraEffect(class UParticleSystem* EffectTemplate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetAuraEffect");

	Params::CharaBase_C_SetAuraEffect Parms{};

	Parms.EffectTemplate = EffectTemplate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetParticleTemplate
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystemComponent*         TargetParticleSys                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UParticleSystem*                  Template                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Scale                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RelativeScale                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetParticleTemplate(class UParticleSystemComponent*& TargetParticleSys, class UParticleSystem* Template, float Scale, bool RelativeScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetParticleTemplate");

	Params::CharaBase_C_SetParticleTemplate Parms{};

	Parms.TargetParticleSys = TargetParticleSys;
	Parms.Template = Template;
	Parms.Scale = Scale;
	Parms.RelativeScale = RelativeScale;

	UObject::ProcessEvent(Func, &Parms);

	TargetParticleSys = Parms.TargetParticleSys;
}


// Function CharaBase.CharaBase_C.SetAura
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_AURA_TYPE                       Param_Aura                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetAura(E_CHARA_AURA_TYPE Param_Aura)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetAura");

	Params::CharaBase_C_SetAura Parms{};

	Parms.Param_Aura = Param_Aura;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.RemoveAura
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_AURA_TYPE                       Param_Aura                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::RemoveAura(E_CHARA_AURA_TYPE Param_Aura)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "RemoveAura");

	Params::CharaBase_C_RemoveAura Parms{};

	Parms.Param_Aura = Param_Aura;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.AdaptAura
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::AdaptAura()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "AdaptAura");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.GetValidIdolMotionIDs
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<E_CHARA_MOTION_ID>               IDs                                                    (Parm, OutParm)

void ACharaBase_C::GetValidIdolMotionIDs(TArray<E_CHARA_MOTION_ID>* IDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetValidIdolMotionIDs");

	Params::CharaBase_C_GetValidIdolMotionIDs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IDs != nullptr)
		*IDs = std::move(Parms.IDs);
}


// Function CharaBase.CharaBase_C.Act_RunToLocation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          DestLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LookLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DirInterp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_CHARA_MOTION_ID                       FinishedMotion                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::Act_RunToLocation(const struct FVector& DestLocation, const struct FVector& LookLocation, float Time, float DirInterp, E_CHARA_MOTION_ID FinishedMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_RunToLocation");

	Params::CharaBase_C_Act_RunToLocation Parms{};

	Parms.DestLocation = std::move(DestLocation);
	Parms.LookLocation = std::move(LookLocation);
	Parms.Time = Time;
	Parms.DirInterp = DirInterp;
	Parms.FinishedMotion = FinishedMotion;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.AdjustValidMotionID
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_CHARA_MOTION_ID                       ValidMotionID                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::AdjustValidMotionID(E_CHARA_MOTION_ID Param_MotionID, E_CHARA_MOTION_ID* ValidMotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "AdjustValidMotionID");

	Params::CharaBase_C_AdjustValidMotionID Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (ValidMotionID != nullptr)
		*ValidMotionID = Parms.ValidMotionID;
}


// Function CharaBase.CharaBase_C.ApplyBadStatus
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Status                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsNoCureEffect                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsLacerationDamage                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::ApplyBadStatus(int32 Status, bool IsNoCureEffect, bool IsLacerationDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ApplyBadStatus");

	Params::CharaBase_C_ApplyBadStatus Parms{};

	Parms.Status = Status;
	Parms.IsNoCureEffect = IsNoCureEffect;
	Parms.IsLacerationDamage = IsLacerationDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ParalyzeMotionCtrl
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ParalyzeMotionCtrl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ParalyzeMotionCtrl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetBodyIKEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetBodyIKEnable(bool Enable, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetBodyIKEnable");

	Params::CharaBase_C_SetBodyIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetNotifyApplyHit
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// E_ANIM_NOTIFY_APPLY_HIT_TYPE            NotifyType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetNotifyApplyHit(bool IsNotified, E_ANIM_NOTIFY_APPLY_HIT_TYPE NotifyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetNotifyApplyHit");

	Params::CharaBase_C_SetNotifyApplyHit Parms{};

	Parms.IsNotified = IsNotified;
	Parms.NotifyType = NotifyType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsNotifyApplyHit
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<E_ANIM_NOTIFY_APPLY_HIT_TYPE>    NotifyType                                             (Parm, OutParm)

void ACharaBase_C::IsNotifyApplyHit(bool* IsNotified, TArray<E_ANIM_NOTIFY_APPLY_HIT_TYPE>* NotifyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsNotifyApplyHit");

	Params::CharaBase_C_IsNotifyApplyHit Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;

	if (NotifyType != nullptr)
		*NotifyType = std::move(Parms.NotifyType);
}


// Function CharaBase.CharaBase_C.ToggleDitherEnable
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ToggleDitherEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ToggleDitherEnable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.IsDitherEnable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsEnable                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsDitherEnable(bool* IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsDitherEnable");

	Params::CharaBase_C_IsDitherEnable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsEnable != nullptr)
		*IsEnable = Parms.IsEnable;
}


// Function CharaBase.CharaBase_C.SetDitherEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnable                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetDitherEnable(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetDitherEnable");

	Params::CharaBase_C_SetDitherEnable Parms{};

	Parms.IsEnable = IsEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetAllVisibility
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetAllVisibility(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetAllVisibility");

	Params::CharaBase_C_SetAllVisibility Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.Act_RunToLocation_NoDir
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DirInterp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_CHARA_MOTION_ID                       FinishedMotion                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::Act_RunToLocation_NoDir(const struct FVector& Location, float Time, float DirInterp, E_CHARA_MOTION_ID FinishedMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_RunToLocation_NoDir");

	Params::CharaBase_C_Act_RunToLocation_NoDir Parms{};

	Parms.Location = std::move(Location);
	Parms.Time = Time;
	Parms.DirInterp = DirInterp;
	Parms.FinishedMotion = FinishedMotion;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.BattlePlayMotion
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_IsUseDuration                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseBlendTimeOverride                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTimeOverride                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BattlePlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool Param_IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BattlePlayMotion");

	Params::CharaBase_C_BattlePlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;
	Parms.Param_IsUseDuration = Param_IsUseDuration;
	Parms.Duration = Duration;
	Parms.IsUseBlendTimeOverride = IsUseBlendTimeOverride;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.UpdateFreeze
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewBadStatus                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::UpdateFreeze(int32 NewBadStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateFreeze");

	Params::CharaBase_C_UpdateFreeze Parms{};

	Parms.NewBadStatus = NewBadStatus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.MoveWorldOffset
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          DeltaVec                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::MoveWorldOffset(const struct FVector& DeltaVec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MoveWorldOffset");

	Params::CharaBase_C_MoveWorldOffset Parms{};

	Parms.DeltaVec = std::move(DeltaVec);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ApplyBattleCollisionResponse
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsBattleSetting                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::ApplyBattleCollisionResponse(bool IsBattleSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ApplyBattleCollisionResponse");

	Params::CharaBase_C_ApplyBattleCollisionResponse Parms{};

	Parms.IsBattleSetting = IsBattleSetting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsSameMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsSameMotion(E_CHARA_MOTION_ID Param_MotionID, bool* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsSameMotion");

	Params::CharaBase_C_IsSameMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBase.CharaBase_C.HasValidMotion
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetVal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::HasValidMotion(E_CHARA_MOTION_ID Param_MotionID, bool* RetVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "HasValidMotion");

	Params::CharaBase_C_HasValidMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (RetVal != nullptr)
		*RetVal = Parms.RetVal;
}


// Function CharaBase.CharaBase_C.IsCompletelyDead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    RetVal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsCompletelyDead(bool* RetVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsCompletelyDead");

	Params::CharaBase_C_IsCompletelyDead Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetVal != nullptr)
		*RetVal = Parms.RetVal;
}


// Function CharaBase.CharaBase_C.EventPlayMotion
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Animation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Loop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::EventPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "EventPlayMotion");

	Params::CharaBase_C_EventPlayMotion Parms{};

	Parms.Animation = Animation;
	Parms.Loop = Loop;
	Parms.BlendTime = BlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.EventSetMotionRateScale
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   MotionRateScale                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::EventSetMotionRateScale(float MotionRateScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "EventSetMotionRateScale");

	Params::CharaBase_C_EventSetMotionRateScale Parms{};

	Parms.MotionRateScale = MotionRateScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.CalcEffectScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   RetVal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CalcEffectScale(float* RetVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CalcEffectScale");

	Params::CharaBase_C_CalcEffectScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetVal != nullptr)
		*RetVal = Parms.RetVal;
}


// Function CharaBase.CharaBase_C.ControlTargetEffect
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ControlTargetEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ControlTargetEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.InvokeLegIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InvokeLegIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InvokeLegIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.InvokeHeadIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InvokeHeadIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InvokeHeadIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.InvokeEyeIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InvokeEyeIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InvokeEyeIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.InvokeBodyIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InvokeBodyIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InvokeBodyIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetLookAtIKEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IncludeEyeIK                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetLookAtIKEnable(bool Enable, bool Immediately, bool IncludeEyeIK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetLookAtIKEnable");

	Params::CharaBase_C_SetLookAtIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;
	Parms.IncludeEyeIK = IncludeEyeIK;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InvokeLookAtIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IncludeEyeIK                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::InvokeLookAtIKImmediately(bool IncludeEyeIK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InvokeLookAtIKImmediately");

	Params::CharaBase_C_InvokeLookAtIKImmediately Parms{};

	Parms.IncludeEyeIK = IncludeEyeIK;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InitializeExpression
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitializeExpression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitializeExpression");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.UpdateExpression
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::UpdateExpression(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateExpression");

	Params::CharaBase_C_UpdateExpression Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetMumbleEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetMumbleEnable(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetMumbleEnable");

	Params::CharaBase_C_SetMumbleEnable Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.Act_Summon
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentStatus                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsInBattle                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::Act_Summon(int32 CurrentStatus, bool IsInBattle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_Summon");

	Params::CharaBase_C_Act_Summon Parms{};

	Parms.CurrentStatus = CurrentStatus;
	Parms.IsInBattle = IsInBattle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.Act_Return
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   PlayRate                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::Act_Return(float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_Return");

	Params::CharaBase_C_Act_Return Parms{};

	Parms.PlayRate = PlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InvokeFloatingIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InvokeFloatingIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InvokeFloatingIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.ResetSink
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Rate                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::ResetSink(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetSink");

	Params::CharaBase_C_ResetSink Parms{};

	Parms.Rate = Rate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetDitherDistance
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Distance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InterpSec                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetDitherDistance(float Distance, float InterpSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetDitherDistance");

	Params::CharaBase_C_SetDitherDistance Parms{};

	Parms.Distance = Distance;
	Parms.InterpSec = InterpSec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ResetDitherDistance
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InterpSec                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::ResetDitherDistance(float InterpSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetDitherDistance");

	Params::CharaBase_C_ResetDitherDistance Parms{};

	Parms.InterpSec = InterpSec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.UpdateDither
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Delta_Time                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::UpdateDither(float Delta_Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "UpdateDither");

	Params::CharaBase_C_UpdateDither Parms{};

	Parms.Delta_Time = Delta_Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.isParalyzed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_IsParalyzed                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsParalyzed(bool* Param_IsParalyzed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "isParalyzed");

	Params::CharaBase_C_IsParalyzed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_IsParalyzed != nullptr)
		*Param_IsParalyzed = Parms.Param_IsParalyzed;
}


// Function CharaBase.CharaBase_C.SetParalyzed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsParalyzed                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetParalyzed(bool IsParalyzed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetParalyzed");

	Params::CharaBase_C_SetParalyzed Parms{};

	Parms.IsParalyzed = IsParalyzed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetDitherRate
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Rate                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InterpSec                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetDitherRate(float Rate, float InterpSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetDitherRate");

	Params::CharaBase_C_SetDitherRate Parms{};

	Parms.Rate = Rate;
	Parms.InterpSec = InterpSec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ResetDitherRate
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InterpSec                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::ResetDitherRate(float InterpSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetDitherRate");

	Params::CharaBase_C_ResetDitherRate Parms{};

	Parms.InterpSec = InterpSec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ClearNotifyMotionHead
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ClearNotifyMotionHead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ClearNotifyMotionHead");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.IsNotifyMotionHead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsNotifyMotionHead(bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsNotifyMotionHead");

	Params::CharaBase_C_IsNotifyMotionHead Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function CharaBase.CharaBase_C.MoveAfterAnimEndCallback
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::MoveAfterAnimEndCallback(E_CHARA_MOTION_ID Param_MotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "MoveAfterAnimEndCallback");

	Params::CharaBase_C_MoveAfterAnimEndCallback Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetCurrentSurfaceStatusMaterial
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<E_BAD_STATUS>                    CurrentSurface                                         (Parm, OutParm)

void ACharaBase_C::GetCurrentSurfaceStatusMaterial(TArray<E_BAD_STATUS>* CurrentSurface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetCurrentSurfaceStatusMaterial");

	Params::CharaBase_C_GetCurrentSurfaceStatusMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentSurface != nullptr)
		*CurrentSurface = std::move(Parms.CurrentSurface);
}


// Function CharaBase.CharaBase_C.SetVectorParam
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ParamNames                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FLinearColor                     Val                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetVectorParam(TArray<class FName>& ParamNames, struct FLinearColor& Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetVectorParam");

	Params::CharaBase_C_SetVectorParam Parms{};

	Parms.ParamNames = std::move(ParamNames);
	Parms.Val = std::move(Val);

	UObject::ProcessEvent(Func, &Parms);

	ParamNames = std::move(Parms.ParamNames);
	Val = std::move(Parms.Val);
}


// Function CharaBase.CharaBase_C.WatchOnesStepBegin
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::WatchOnesStepBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "WatchOnesStepBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.WatchOnesStepEnd
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::WatchOnesStepEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "WatchOnesStepEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetMeshRelativeScale
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewScale                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   NewBoundScale                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetMeshRelativeScale(float NewScale, float NewBoundScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetMeshRelativeScale");

	Params::CharaBase_C_SetMeshRelativeScale Parms{};

	Parms.NewScale = NewScale;
	Parms.NewBoundScale = NewBoundScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetMeshRelativeScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::GetMeshRelativeScale(float* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetMeshRelativeScale");

	Params::CharaBase_C_GetMeshRelativeScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = Parms.Scale;
}


// Function CharaBase.CharaBase_C.PerchBegin
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::PerchBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PerchBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.PerchEnd
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::PerchEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PerchEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SpawnMaterialAnimDecalAttached
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInstance*                DecalMaterial                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSetting                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          DecalSize                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OffsetLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AttachPointName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OverrideLifeSec                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EAttachLocation                         LocationType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsCastOnlyStaticMesh                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UMaterialAnimDecalComponent_C*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UMaterialAnimDecalComponent_C* ACharaBase_C::SpawnMaterialAnimDecalAttached(class UMaterialInstance* DecalMaterial, TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, float OverrideLifeSec, EAttachLocation LocationType, const struct FRotator& Rotation, bool IsCastOnlyStaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SpawnMaterialAnimDecalAttached");

	Params::CharaBase_C_SpawnMaterialAnimDecalAttached Parms{};

	Parms.DecalMaterial = DecalMaterial;
	Parms.MaterialAnimSetting = std::move(MaterialAnimSetting);
	Parms.DecalSize = std::move(DecalSize);
	Parms.OffsetLocation = std::move(OffsetLocation);
	Parms.AttachPointName = AttachPointName;
	Parms.OverrideLifeSec = OverrideLifeSec;
	Parms.LocationType = LocationType;
	Parms.Rotation = std::move(Rotation);
	Parms.IsCastOnlyStaticMesh = IsCastOnlyStaticMesh;

	UObject::ProcessEvent(Func, &Parms);

	MaterialAnimSetting = std::move(Parms.MaterialAnimSetting);

	return Parms.ReturnValue;
}


// Function CharaBase.CharaBase_C.InitializeBoneTrans
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitializeBoneTrans()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitializeBoneTrans");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.InvalidIKBegin
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::InvalidIKBegin(class FName Param_Name, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InvalidIKBegin");

	Params::CharaBase_C_InvalidIKBegin Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InvalidIKEnd
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::InvalidIKEnd(class FName Param_Name, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InvalidIKEnd");

	Params::CharaBase_C_InvalidIKEnd Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.CreateBadStatusPSComp
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UParticleSystemComponent*         PSComp                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CreateBadStatusPSComp(class UParticleSystemComponent** PSComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CreateBadStatusPSComp");

	Params::CharaBase_C_CreateBadStatusPSComp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PSComp != nullptr)
		*PSComp = Parms.PSComp;
}


// Function CharaBase.CharaBase_C.CommonEffectOff
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::CommonEffectOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CommonEffectOff");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.AttachClockingParticleSystem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystem*                  EmitterTemplate                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AttachPointName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Scale                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EAttachLocation                         LocationType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsCastShadow                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bAutoDestroy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::AttachClockingParticleSystem(class UParticleSystem* EmitterTemplate, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, bool IsCastShadow, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "AttachClockingParticleSystem");

	Params::CharaBase_C_AttachClockingParticleSystem Parms{};

	Parms.EmitterTemplate = EmitterTemplate;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.LocationType = LocationType;
	Parms.IsCastShadow = IsCastShadow;
	Parms.bAutoDestroy = bAutoDestroy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetCharaPlayRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   PlayRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::GetCharaPlayRate(float* PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetCharaPlayRate");

	Params::CharaBase_C_GetCharaPlayRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayRate != nullptr)
		*PlayRate = Parms.PlayRate;
}


// Function CharaBase.CharaBase_C.ControlEffectPlayRate
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ControlEffectPlayRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ControlEffectPlayRate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.GetCurrentTime
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Time                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::GetCurrentTime(float* Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetCurrentTime");

	Params::CharaBase_C_GetCurrentTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Time != nullptr)
		*Time = Parms.Time;
}


// Function CharaBase.CharaBase_C.SetRunToUnitMotion
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_Motion                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetRunToUnitMotion(E_CHARA_MOTION_ID Param_Motion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetRunToUnitMotion");

	Params::CharaBase_C_SetRunToUnitMotion Parms{};

	Parms.Param_Motion = Param_Motion;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetNotifyDeadTiming
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetNotifyDeadTiming(bool IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetNotifyDeadTiming");

	Params::CharaBase_C_SetNotifyDeadTiming Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsNotifyDeadTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsNotifyDeadTiming(bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsNotifyDeadTiming");

	Params::CharaBase_C_IsNotifyDeadTiming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function CharaBase.CharaBase_C.DamageAnimEndCallBack
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::DamageAnimEndCallBack(E_CHARA_MOTION_ID Param_MotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "DamageAnimEndCallBack");

	Params::CharaBase_C_DamageAnimEndCallBack Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.CalcBattleCameraScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   RetVal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CalcBattleCameraScale(float* RetVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CalcBattleCameraScale");

	Params::CharaBase_C_CalcBattleCameraScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetVal != nullptr)
		*RetVal = Parms.RetVal;
}


// Function CharaBase.CharaBase_C.InitializeBounds
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitializeBounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitializeBounds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.RemoveAuraImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::RemoveAuraImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "RemoveAuraImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.InitializeBadStatus
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitializeBadStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitializeBadStatus");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.PushCue_RunToLocation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          DestLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LookLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DirInterp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::PushCue_RunToLocation(const struct FVector& DestLocation, const struct FVector& LookLocation, float Time, float DirInterp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PushCue_RunToLocation");

	Params::CharaBase_C_PushCue_RunToLocation Parms{};

	Parms.DestLocation = std::move(DestLocation);
	Parms.LookLocation = std::move(LookLocation);
	Parms.Time = Time;
	Parms.DirInterp = DirInterp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsEmptyCue_RunToLocation
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsEmpty                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsEmptyCue_RunToLocation(bool* IsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsEmptyCue_RunToLocation");

	Params::CharaBase_C_IsEmptyCue_RunToLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsEmpty != nullptr)
		*IsEmpty = Parms.IsEmpty;
}


// Function CharaBase.CharaBase_C.PopCue_RunToLocation
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsValid                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FCharaMoveParam                  MoveParam                                              (Parm, OutParm)
// float                                   DirInterp                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::PopCue_RunToLocation(bool* IsValid, struct FCharaMoveParam* MoveParam, float* DirInterp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "PopCue_RunToLocation");

	Params::CharaBase_C_PopCue_RunToLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	if (MoveParam != nullptr)
		*MoveParam = std::move(Parms.MoveParam);

	if (DirInterp != nullptr)
		*DirInterp = Parms.DirInterp;
}


// Function CharaBase.CharaBase_C.SetNotifySkillFire
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetNotifySkillFire(bool IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetNotifySkillFire");

	Params::CharaBase_C_SetNotifySkillFire Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsNotifySkillFire
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsNotifySkillFire(bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsNotifySkillFire");

	Params::CharaBase_C_IsNotifySkillFire Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function CharaBase.CharaBase_C.Act_Fade
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsFadeOut                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   InterpSec                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::Act_Fade(bool IsFadeOut, float InterpSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_Fade");

	Params::CharaBase_C_Act_Fade Parms{};

	Parms.IsFadeOut = IsFadeOut;
	Parms.InterpSec = InterpSec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetScalarParamByArray
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMaterialInstanceDynamic*> Material                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FName>                     ParamNames                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   Val                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetScalarParamByArray(TArray<class UMaterialInstanceDynamic*>& Material, TArray<class FName>& ParamNames, float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetScalarParamByArray");

	Params::CharaBase_C_SetScalarParamByArray Parms{};

	Parms.Material = std::move(Material);
	Parms.ParamNames = std::move(ParamNames);
	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);

	Material = std::move(Parms.Material);
	ParamNames = std::move(Parms.ParamNames);
}


// Function CharaBase.CharaBase_C.SetVectorParamByArray
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMaterialInstanceDynamic*> Material                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FName>                     ParamNames                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FLinearColor                     Val                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetVectorParamByArray(TArray<class UMaterialInstanceDynamic*>& Material, TArray<class FName>& ParamNames, struct FLinearColor& Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetVectorParamByArray");

	Params::CharaBase_C_SetVectorParamByArray Parms{};

	Parms.Material = std::move(Material);
	Parms.ParamNames = std::move(ParamNames);
	Parms.Val = std::move(Val);

	UObject::ProcessEvent(Func, &Parms);

	Material = std::move(Parms.Material);
	ParamNames = std::move(Parms.ParamNames);
	Val = std::move(Parms.Val);
}


// Function CharaBase.CharaBase_C.RetrieveDMIs
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>                           ElementNo                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class UMaterialInstanceDynamic*> Materials                                              (Parm, OutParm)

void ACharaBase_C::RetrieveDMIs(TArray<int32>& ElementNo, TArray<class UMaterialInstanceDynamic*>* Materials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "RetrieveDMIs");

	Params::CharaBase_C_RetrieveDMIs Parms{};

	Parms.ElementNo = std::move(ElementNo);

	UObject::ProcessEvent(Func, &Parms);

	ElementNo = std::move(Parms.ElementNo);

	if (Materials != nullptr)
		*Materials = std::move(Parms.Materials);
}


// Function CharaBase.CharaBase_C.CalcMaterialAnimSettingSec
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSetting                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   Sec                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CalcMaterialAnimSettingSec(TArray<struct FMaterialAnimSetting_T>& MaterialAnimSetting, float* Sec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CalcMaterialAnimSettingSec");

	Params::CharaBase_C_CalcMaterialAnimSettingSec Parms{};

	Parms.MaterialAnimSetting = std::move(MaterialAnimSetting);

	UObject::ProcessEvent(Func, &Parms);

	MaterialAnimSetting = std::move(Parms.MaterialAnimSetting);

	if (Sec != nullptr)
		*Sec = Parms.Sec;
}


// Function CharaBase.CharaBase_C.InitAnimNotifyEffectData
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitAnimNotifyEffectData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitAnimNotifyEffectData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.GetPreviousMotionID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::GetPreviousMotionID(E_CHARA_MOTION_ID* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetPreviousMotionID");

	Params::CharaBase_C_GetPreviousMotionID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBase.CharaBase_C.SetNowMotionID
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       MotionIDCurrent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetNowMotionID(E_CHARA_MOTION_ID MotionIDCurrent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetNowMotionID");

	Params::CharaBase_C_SetNowMotionID Parms{};

	Parms.MotionIDCurrent = MotionIDCurrent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetPreviousMotionID
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetPreviousMotionID(E_CHARA_MOTION_ID Param_MotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetPreviousMotionID");

	Params::CharaBase_C_SetPreviousMotionID Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetAlreadyChangeEnableEffect
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             IsChanged                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetAlreadyChangeEnableEffect(class FName IsChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetAlreadyChangeEnableEffect");

	Params::CharaBase_C_SetAlreadyChangeEnableEffect Parms{};

	Parms.IsChanged = IsChanged;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetAlreadyChangeEnableEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsChahged                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::GetAlreadyChangeEnableEffect(class FName Key, bool* IsChahged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetAlreadyChangeEnableEffect");

	Params::CharaBase_C_GetAlreadyChangeEnableEffect Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (IsChahged != nullptr)
		*IsChahged = Parms.IsChahged;
}


// Function CharaBase.CharaBase_C.SetAlreadyChangeEnableDecal
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetAlreadyChangeEnableDecal(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetAlreadyChangeEnableDecal");

	Params::CharaBase_C_SetAlreadyChangeEnableDecal Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetAlreadyChangeEnableDecal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsChanged                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::GetAlreadyChangeEnableDecal(class FName Key, bool* IsChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetAlreadyChangeEnableDecal");

	Params::CharaBase_C_GetAlreadyChangeEnableDecal Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (IsChanged != nullptr)
		*IsChanged = Parms.IsChanged;
}


// Function CharaBase.CharaBase_C.SetMotionIsUseDuration
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_IsUseDuration                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetMotionIsUseDuration(bool Param_IsUseDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetMotionIsUseDuration");

	Params::CharaBase_C_SetMotionIsUseDuration Parms{};

	Parms.Param_IsUseDuration = Param_IsUseDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetMotionDuration
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetMotionDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetMotionDuration");

	Params::CharaBase_C_SetMotionDuration Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetIsUseBlendTime
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsUseBlendTime                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetIsUseBlendTime(bool IsUseBlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetIsUseBlendTime");

	Params::CharaBase_C_SetIsUseBlendTime Parms{};

	Parms.IsUseBlendTime = IsUseBlendTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetBlendTime
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetBlendTime(float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetBlendTime");

	Params::CharaBase_C_SetBlendTime Parms{};

	Parms.BlendTime = BlendTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetParalyzed
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Paralyzed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::GetParalyzed(bool* Paralyzed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetParalyzed");

	Params::CharaBase_C_GetParalyzed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Paralyzed != nullptr)
		*Paralyzed = Parms.Paralyzed;
}


// Function CharaBase.CharaBase_C.IsFreezeMotion
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Param_M_IsFreezeMotion                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsFreezeMotion(bool* Param_M_IsFreezeMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsFreezeMotion");

	Params::CharaBase_C_IsFreezeMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_M_IsFreezeMotion != nullptr)
		*Param_M_IsFreezeMotion = Parms.Param_M_IsFreezeMotion;
}


// Function CharaBase.CharaBase_C.IsUseDuration
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Param_IsUseDuration                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsUseDuration(bool* Param_IsUseDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsUseDuration");

	Params::CharaBase_C_IsUseDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_IsUseDuration != nullptr)
		*Param_IsUseDuration = Parms.Param_IsUseDuration;
}


// Function CharaBase.CharaBase_C.Act_Spawn
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    PlayMotion                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::Act_Spawn(bool PlayMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_Spawn");

	Params::CharaBase_C_Act_Spawn Parms{};

	Parms.PlayMotion = PlayMotion;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetNotifyWarpTiming
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetNotifyWarpTiming(bool IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetNotifyWarpTiming");

	Params::CharaBase_C_SetNotifyWarpTiming Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsNotifyWarpTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsNotifyWarpTiming(bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsNotifyWarpTiming");

	Params::CharaBase_C_IsNotifyWarpTiming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function CharaBase.CharaBase_C.SetDefaultIdleMotion
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Default_Idle                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetDefaultIdleMotion(E_CHARA_MOTION_ID Default_Idle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetDefaultIdleMotion");

	Params::CharaBase_C_SetDefaultIdleMotion Parms{};

	Parms.Default_Idle = Default_Idle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetDefaultIdleMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Idle                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::GetDefaultIdleMotion(E_CHARA_MOTION_ID* Idle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetDefaultIdleMotion");

	Params::CharaBase_C_GetDefaultIdleMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Idle != nullptr)
		*Idle = Parms.Idle;
}


// Function CharaBase.CharaBase_C.BattleMotionAnimEndCallBack
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BattleMotionAnimEndCallBack(E_CHARA_MOTION_ID Param_MotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BattleMotionAnimEndCallBack");

	Params::CharaBase_C_BattleMotionAnimEndCallBack Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InsertBatttlePlayMotionEndCallBack
// (Protected, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InsertBatttlePlayMotionEndCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InsertBatttlePlayMotionEndCallBack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.CheckUpdateIK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ClacIK                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   DeltaRate                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CheckUpdateIK(bool* ClacIK, int32* DeltaRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CheckUpdateIK");

	Params::CharaBase_C_CheckUpdateIK Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ClacIK != nullptr)
		*ClacIK = Parms.ClacIK;

	if (DeltaRate != nullptr)
		*DeltaRate = Parms.DeltaRate;
}


// Function CharaBase.CharaBase_C.IsMaterialSlotPlaying
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MATERIAL_ANIMATION_SLOT         Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPlaying                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsMaterialSlotPlaying(E_CHARA_MATERIAL_ANIMATION_SLOT Slot, bool* IsPlaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsMaterialSlotPlaying");

	Params::CharaBase_C_IsMaterialSlotPlaying Parms{};

	Parms.Slot = Slot;

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlaying != nullptr)
		*IsPlaying = Parms.IsPlaying;
}


// Function CharaBase.CharaBase_C.OnFinishDitherRate
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_ACTION_TYPE                     CharaAction                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::OnFinishDitherRate(E_CHARA_ACTION_TYPE CharaAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "OnFinishDitherRate");

	Params::CharaBase_C_OnFinishDitherRate Parms{};

	Parms.CharaAction = CharaAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.Get BPI_CharaBaseAccessor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TScriptInterface<class IBPI_CharaBaseAccessor_C>DataGetter                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::Get_BPI_CharaBaseAccessor(TScriptInterface<class IBPI_CharaBaseAccessor_C>* DataGetter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Get BPI_CharaBaseAccessor");

	Params::CharaBase_C_Get_BPI_CharaBaseAccessor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DataGetter != nullptr)
		*DataGetter = Parms.DataGetter;
}


// Function CharaBase.CharaBase_C.CalcBadStatusEffectScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float ACharaBase_C::CalcBadStatusEffectScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CalcBadStatusEffectScale");

	Params::CharaBase_C_CalcBadStatusEffectScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CharaBase.CharaBase_C.IsRapidReturnActionNow
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsRapidReturnActionNow(bool* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsRapidReturnActionNow");

	Params::CharaBase_C_IsRapidReturnActionNow Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBase.CharaBase_C.GetCurrentVisibility
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::GetCurrentVisibility(bool* IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetCurrentVisibility");

	Params::CharaBase_C_GetCurrentVisibility Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsVisible != nullptr)
		*IsVisible = Parms.IsVisible;
}


// Function CharaBase.CharaBase_C.Act_RapidSummon
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentStatus                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::Act_RapidSummon(int32 CurrentStatus, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_RapidSummon");

	Params::CharaBase_C_Act_RapidSummon Parms{};

	Parms.CurrentStatus = CurrentStatus;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.Act_RapidReturn
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   PlayRate                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::Act_RapidReturn(float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Act_RapidReturn");

	Params::CharaBase_C_Act_RapidReturn Parms{};

	Parms.PlayRate = PlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetRapidReturnTiming
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetRapidReturnTiming(bool IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetRapidReturnTiming");

	Params::CharaBase_C_SetRapidReturnTiming Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsNotifyRapidReturnTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsNotifyRapidReturnTiming(bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsNotifyRapidReturnTiming");

	Params::CharaBase_C_IsNotifyRapidReturnTiming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function CharaBase.CharaBase_C.SetNotifyDeadVoice
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundAtomCue*                    DeadVoice                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetNotifyDeadVoice(class USoundAtomCue* DeadVoice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetNotifyDeadVoice");

	Params::CharaBase_C_SetNotifyDeadVoice Parms{};

	Parms.DeadVoice = DeadVoice;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetNotifyDeadVoice
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class USoundAtomCue*                    DeadVoice                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::GetNotifyDeadVoice(class USoundAtomCue** DeadVoice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetNotifyDeadVoice");

	Params::CharaBase_C_GetNotifyDeadVoice Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DeadVoice != nullptr)
		*DeadVoice = Parms.DeadVoice;
}


// Function CharaBase.CharaBase_C.GetBadStatusNames
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<E_BAD_STATUS>                    BadStatus                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FName>                     Names                                                  (Parm, OutParm)

void ACharaBase_C::GetBadStatusNames(TArray<E_BAD_STATUS>& BadStatus, TArray<class FName>* Names)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetBadStatusNames");

	Params::CharaBase_C_GetBadStatusNames Parms{};

	Parms.BadStatus = std::move(BadStatus);

	UObject::ProcessEvent(Func, &Parms);

	BadStatus = std::move(Parms.BadStatus);

	if (Names != nullptr)
		*Names = std::move(Parms.Names);
}


// Function CharaBase.CharaBase_C.IsPauseMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Paused                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsPauseMotion(bool* Paused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsPauseMotion");

	Params::CharaBase_C_IsPauseMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Paused != nullptr)
		*Paused = Parms.Paused;
}


// Function CharaBase.CharaBase_C.StackPlayMotion
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Animation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Loop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::StackPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "StackPlayMotion");

	Params::CharaBase_C_StackPlayMotion Parms{};

	Parms.Animation = Animation;
	Parms.Loop = Loop;
	Parms.BlendTime = BlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ResetAllParam
// (Protected, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ResetAllParam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ResetAllParam");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetUplifting
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsUplifting                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetUplifting(bool IsUplifting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetUplifting");

	Params::CharaBase_C_SetUplifting Parms{};

	Parms.IsUplifting = IsUplifting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.ActivateAttachedParticles
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ActivateAttachedParticles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ActivateAttachedParticles");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.DeactivateAttachedParticles
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoDestroyComponent                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::DeactivateAttachedParticles(bool NoDestroyComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "DeactivateAttachedParticles");

	Params::CharaBase_C_DeactivateAttachedParticles Parms{};

	Parms.NoDestroyComponent = NoDestroyComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.RememberMeshAttachedParticles
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::RememberMeshAttachedParticles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "RememberMeshAttachedParticles");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.Cancel_RunToUnit
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::Cancel_RunToUnit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "Cancel_RunToUnit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.GetMeshAttachedParticle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UParticleSystemComponent*> MeshAttachedParticle                                   (Parm, OutParm, ContainsInstancedReference)

void ACharaBase_C::GetMeshAttachedParticle(TArray<class UParticleSystemComponent*>* MeshAttachedParticle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetMeshAttachedParticle");

	Params::CharaBase_C_GetMeshAttachedParticle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MeshAttachedParticle != nullptr)
		*MeshAttachedParticle = std::move(Parms.MeshAttachedParticle);
}


// Function CharaBase.CharaBase_C.CalcMotionBlendTime
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Default                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float ACharaBase_C::CalcMotionBlendTime(float Default)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CalcMotionBlendTime");

	Params::CharaBase_C_CalcMotionBlendTime Parms{};

	Parms.Default = Default;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CharaBase.CharaBase_C.GetCharaMotion
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FCharaMotion                     CharaMotion                                            (Parm, OutParm, NoDestructor)
// bool                                    IsValid                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::GetCharaMotion(E_CHARA_MOTION_ID ID, struct FCharaMotion* CharaMotion, bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetCharaMotion");

	Params::CharaBase_C_GetCharaMotion Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);

	if (CharaMotion != nullptr)
		*CharaMotion = std::move(Parms.CharaMotion);

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;
}


// Function CharaBase.CharaBase_C.CalcUpliftingEffectScale
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   RetVal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CalcUpliftingEffectScale(float* RetVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CalcUpliftingEffectScale");

	Params::CharaBase_C_CalcUpliftingEffectScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetVal != nullptr)
		*RetVal = Parms.RetVal;
}


// Function CharaBase.CharaBase_C.ActivateParticleHolderAttachedParticles
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ActivateParticleHolderAttachedParticles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ActivateParticleHolderAttachedParticles");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetResidentSE
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Activate                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetResidentSE(bool Activate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetResidentSE");

	Params::CharaBase_C_SetResidentSE Parms{};

	Parms.Activate = Activate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsPlayMotion
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPlay                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsPlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool* IsPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsPlayMotion");

	Params::CharaBase_C_IsPlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlay != nullptr)
		*IsPlay = Parms.IsPlay;
}


// Function CharaBase.CharaBase_C.BattleStopMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::BattleStopMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BattleStopMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.CalcHugeBattleCameraScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   RetVal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CalcHugeBattleCameraScale(float* RetVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CalcHugeBattleCameraScale");

	Params::CharaBase_C_CalcHugeBattleCameraScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetVal != nullptr)
		*RetVal = Parms.RetVal;
}


// Function CharaBase.CharaBase_C.InitializeAnimNotify
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitializeAnimNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitializeAnimNotify");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetEnableCollision
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetEnableCollision(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetEnableCollision");

	Params::CharaBase_C_SetEnableCollision Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetCollisionObjectType
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECollisionChannel                       Channel                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetCollisionObjectType(ECollisionChannel Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetCollisionObjectType");

	Params::CharaBase_C_SetCollisionObjectType Parms{};

	Parms.Channel = Channel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.IsCalledAtInstantEvent
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsCalledAtInstantEvent(bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsCalledAtInstantEvent");

	Params::CharaBase_C_IsCalledAtInstantEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;
}


// Function CharaBase.CharaBase_C.IsCharaShaking
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Shaking                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::IsCharaShaking(bool* Shaking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsCharaShaking");

	Params::CharaBase_C_IsCharaShaking Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Shaking != nullptr)
		*Shaking = Parms.Shaking;
}


// Function CharaBase.CharaBase_C.DeactivateBattleSpringArm
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::DeactivateBattleSpringArm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "DeactivateBattleSpringArm");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.ActivateBattleSpringArm
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::ActivateBattleSpringArm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "ActivateBattleSpringArm");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.CallEvent_Battle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::CallEvent_Battle(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CallEvent_Battle");

	Params::CharaBase_C_CallEvent_Battle Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetBattleSpringArmScale
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CalcedScale                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsHugeBattle                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetBattleSpringArmScale(float CalcedScale, bool IsHugeBattle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetBattleSpringArmScale");

	Params::CharaBase_C_SetBattleSpringArmScale Parms{};

	Parms.CalcedScale = CalcedScale;
	Parms.IsHugeBattle = IsHugeBattle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.DestroyAttachedParticles
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::DestroyAttachedParticles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "DestroyAttachedParticles");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetMoveTotalTime
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   TotalTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetMoveTotalTime(float TotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetMoveTotalTime");

	Params::CharaBase_C_SetMoveTotalTime Parms{};

	Parms.TotalTime = TotalTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetParticlePlayRate
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Rate                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetParticlePlayRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetParticlePlayRate");

	Params::CharaBase_C_SetParticlePlayRate Parms{};

	Parms.Rate = Rate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.SetParticleHolderParticlesPlayRate
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Rate                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetParticleHolderParticlesPlayRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetParticleHolderParticlesPlayRate");

	Params::CharaBase_C_SetParticleHolderParticlesPlayRate Parms{};

	Parms.Rate = Rate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.GetValidMotionIDs
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<E_CHARA_MOTION_ID>               CheckIDs                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<E_CHARA_MOTION_ID>               Valid_IDs                                              (Parm, OutParm)

void ACharaBase_C::GetValidMotionIDs(TArray<E_CHARA_MOTION_ID>& CheckIDs, TArray<E_CHARA_MOTION_ID>* Valid_IDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetValidMotionIDs");

	Params::CharaBase_C_GetValidMotionIDs Parms{};

	Parms.CheckIDs = std::move(CheckIDs);

	UObject::ProcessEvent(Func, &Parms);

	CheckIDs = std::move(Parms.CheckIDs);

	if (Valid_IDs != nullptr)
		*Valid_IDs = std::move(Parms.Valid_IDs);
}


// Function CharaBase.CharaBase_C.GetCharaParam
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UCharaParamComponent*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

const class UCharaParamComponent* ACharaBase_C::GetCharaParam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetCharaParam");

	Params::CharaBase_C_GetCharaParam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CharaBase.CharaBase_C.RemoveAllMaterialAnimDecalAttached
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::RemoveAllMaterialAnimDecalAttached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "RemoveAllMaterialAnimDecalAttached");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.SetCharaPlayRateImpl
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Param_M_CharaPlayRate                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::SetCharaPlayRateImpl(float Param_M_CharaPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetCharaPlayRateImpl");

	Params::CharaBase_C_SetCharaPlayRateImpl Parms{};

	Parms.Param_M_CharaPlayRate = Param_M_CharaPlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBase.CharaBase_C.InitializePoseWeightTable
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::InitializePoseWeightTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "InitializePoseWeightTable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.LookAtCalc
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBase_C::LookAtCalc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "LookAtCalc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBase.CharaBase_C.CheckNaviDevil
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    NaviDevil                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::CheckNaviDevil(bool* NaviDevil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CheckNaviDevil");

	Params::CharaBase_C_CheckNaviDevil Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NaviDevil != nullptr)
		*NaviDevil = Parms.NaviDevil;
}


// Function CharaBase.CharaBase_C.SetIsUpdateAnimation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Update                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetIsUpdateAnimation(bool Update, bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetIsUpdateAnimation");

	Params::CharaBase_C_SetIsUpdateAnimation Parms{};

	Parms.Update = Update;

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBase.CharaBase_C.SetAlwaysAutoTransitionAnimationMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Check                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NotUse                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetAlwaysAutoTransitionAnimationMode(bool Check, bool* NotUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetAlwaysAutoTransitionAnimationMode");

	Params::CharaBase_C_SetAlwaysAutoTransitionAnimationMode Parms{};

	Parms.Check = Check;

	UObject::ProcessEvent(Func, &Parms);

	if (NotUse != nullptr)
		*NotUse = Parms.NotUse;
}


// Function CharaBase.CharaBase_C.SetIsUpdateIK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Update                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetIsUpdateIK(bool Update, bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetIsUpdateIK");

	Params::CharaBase_C_SetIsUpdateIK Parms{};

	Parms.Update = Update;

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBase.CharaBase_C.SetAttackAimLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          GrobalLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::SetAttackAimLocation(const struct FVector& GrobalLocation, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "SetAttackAimLocation");

	Params::CharaBase_C_SetAttackAimLocation Parms{};

	Parms.GrobalLocation = std::move(GrobalLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_PlayMapAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_MapAction_Pla603                      Action                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanUse                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_PlayMapAction(E_MapAction_Pla603 Action, bool* CanUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_PlayMapAction");

	Params::CharaBase_C_BI_PlayMapAction Parms{};

	Parms.Action = Action;

	UObject::ProcessEvent(Func, &Parms);

	if (CanUse != nullptr)
		*CanUse = Parms.CanUse;
}


// Function CharaBase.CharaBase_C.BI_EndMapAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanUse                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_EndMapAction(bool* CanUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_EndMapAction");

	Params::CharaBase_C_BI_EndMapAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanUse != nullptr)
		*CanUse = Parms.CanUse;
}


// Function CharaBase.CharaBase_C.BI_IsMapActionPlaying
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsPlaying                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_IsMapActionPlaying(bool* IsPlaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_IsMapActionPlaying");

	Params::CharaBase_C_BI_IsMapActionPlaying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlaying != nullptr)
		*IsPlaying = Parms.IsPlaying;
}


// Function CharaBase.CharaBase_C.BI_SetNPCCollision
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetNPCCollision(bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetNPCCollision");

	Params::CharaBase_C_BI_SetNPCCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBase.CharaBase_C.BI_GetMeshComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   MeshComp                                               (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetMeshComponent(class UMeshComponent** MeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetMeshComponent");

	Params::CharaBase_C_BI_GetMeshComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MeshComp != nullptr)
		*MeshComp = Parms.MeshComp;
}


// Function CharaBase.CharaBase_C.BI_GetPlayRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   PlayRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetPlayRate(float* PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetPlayRate");

	Params::CharaBase_C_BI_GetPlayRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayRate != nullptr)
		*PlayRate = Parms.PlayRate;
}


// Function CharaBase.CharaBase_C.BI_GetEffectScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   EffectScale                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetEffectScale(float* EffectScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetEffectScale");

	Params::CharaBase_C_BI_GetEffectScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EffectScale != nullptr)
		*EffectScale = Parms.EffectScale;
}


// Function CharaBase.CharaBase_C.BI_GetCharaParamComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCharaParamComponent*             Comp                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetCharaParamComponent(class UCharaParamComponent** Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetCharaParamComponent");

	Params::CharaBase_C_BI_GetCharaParamComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Comp != nullptr)
		*Comp = Parms.Comp;
}


// Function CharaBase.CharaBase_C.BI_GetCapsuleComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCapsuleComponent*                Param                                                  (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetCapsuleComponent(class UCapsuleComponent** Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetCapsuleComponent");

	Params::CharaBase_C_BI_GetCapsuleComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param != nullptr)
		*Param = Parms.Param;
}


// Function CharaBase.CharaBase_C.BI_GetActorRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GetActorRotation(struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetActorRotation");

	Params::CharaBase_C_BI_GetActorRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function CharaBase.CharaBase_C.BI_ResetScalarParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ParamNames                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    NoUs                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_ResetScalarParam(TArray<class FName>& ParamNames, bool* NoUs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_ResetScalarParam");

	Params::CharaBase_C_BI_ResetScalarParam Parms{};

	Parms.ParamNames = std::move(ParamNames);

	UObject::ProcessEvent(Func, &Parms);

	ParamNames = std::move(Parms.ParamNames);

	if (NoUs != nullptr)
		*NoUs = Parms.NoUs;
}


// Function CharaBase.CharaBase_C.BI_SetActionState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_ACTION_TYPE                     InAction                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetActionState(const E_CHARA_ACTION_TYPE InAction, uint8 State, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetActionState");

	Params::CharaBase_C_BI_SetActionState Parms{};

	Parms.InAction = InAction;
	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_CreateBadStatusPSComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystemComponent*         PSComp                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_CreateBadStatusPSComp(class UParticleSystemComponent** PSComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_CreateBadStatusPSComp");

	Params::CharaBase_C_BI_CreateBadStatusPSComp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PSComp != nullptr)
		*PSComp = Parms.PSComp;
}


// Function CharaBase.CharaBase_C.BI_BadStatusMaterialOff
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<E_BAD_STATUS>                    OffBadStatus                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_BadStatusMaterialOff(const TArray<E_BAD_STATUS>& OffBadStatus, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_BadStatusMaterialOff");

	Params::CharaBase_C_BI_BadStatusMaterialOff Parms{};

	Parms.OffBadStatus = std::move(OffBadStatus);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_EvtResetBadStatusMaterial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_EvtResetBadStatusMaterial(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_EvtResetBadStatusMaterial");

	Params::CharaBase_C_BI_EvtResetBadStatusMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_EvtResetEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_EvtResetEffect(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_EvtResetEffect");

	Params::CharaBase_C_BI_EvtResetEffect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_BadStatusMaterialOn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<E_BAD_STATUS>                    OnBadStatus                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_BadStatusMaterialOn(TArray<E_BAD_STATUS>& OnBadStatus, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_BadStatusMaterialOn");

	Params::CharaBase_C_BI_BadStatusMaterialOn Parms{};

	Parms.OnBadStatus = std::move(OnBadStatus);

	UObject::ProcessEvent(Func, &Parms);

	OnBadStatus = std::move(Parms.OnBadStatus);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_ResetState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_ResetState(int32 State, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_ResetState");

	Params::CharaBase_C_BI_ResetState Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetNotifyApplyHit
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// E_ANIM_NOTIFY_APPLY_HIT_TYPE            NotifyType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetNotifyApplyHit(bool IsNotified, E_ANIM_NOTIFY_APPLY_HIT_TYPE NotifyType, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetNotifyApplyHit");

	Params::CharaBase_C_BI_SetNotifyApplyHit Parms{};

	Parms.IsNotified = IsNotified;
	Parms.NotifyType = NotifyType;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_InvalidIKEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_InvalidIKEnd(class FName Param_Name, int32 Param_Index, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_InvalidIKEnd");

	Params::CharaBase_C_BI_InvalidIKEnd Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SpawnMaterialAnimDecalAttached
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInstance*                DecalMaterial                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSettings                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          DecalSize                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OffsetLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AttachPointName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OverrideLifeSec                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   LocationType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UMaterialAnimDecalComponent_C*    Comp                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_SpawnMaterialAnimDecalAttached(const class UMaterialInstance*& DecalMaterial, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSettings, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, float OverrideLifeSec, uint8 LocationType, const struct FRotator& Rotation, class UMaterialAnimDecalComponent_C** Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SpawnMaterialAnimDecalAttached");

	Params::CharaBase_C_BI_SpawnMaterialAnimDecalAttached Parms{};

	Parms.DecalMaterial = DecalMaterial;
	Parms.MaterialAnimSettings = std::move(MaterialAnimSettings);
	Parms.DecalSize = std::move(DecalSize);
	Parms.OffsetLocation = std::move(OffsetLocation);
	Parms.AttachPointName = AttachPointName;
	Parms.OverrideLifeSec = OverrideLifeSec;
	Parms.LocationType = LocationType;
	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);

	if (Comp != nullptr)
		*Comp = Parms.Comp;
}


// Function CharaBase.CharaBase_C.BI_GetAlreadyChangeEnableDecal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsChanged                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GetAlreadyChangeEnableDecal(class FName Key, bool* IsChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetAlreadyChangeEnableDecal");

	Params::CharaBase_C_BI_GetAlreadyChangeEnableDecal Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (IsChanged != nullptr)
		*IsChanged = Parms.IsChanged;
}


// Function CharaBase.CharaBase_C.BI_SetAlreadyChangeEnableDecal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetAlreadyChangeEnableDecal(class FName Key, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetAlreadyChangeEnableDecal");

	Params::CharaBase_C_BI_SetAlreadyChangeEnableDecal Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetAlreadyChangeEnableEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsChanged                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GetAlreadyChangeEnableEffect(class FName Key, bool* IsChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetAlreadyChangeEnableEffect");

	Params::CharaBase_C_BI_GetAlreadyChangeEnableEffect Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (IsChanged != nullptr)
		*IsChanged = Parms.IsChanged;
}


// Function CharaBase.CharaBase_C.BI_SetAlreadyChangeEnableEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetAlreadyChangeEnableEffect(class FName Key, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetAlreadyChangeEnableEffect");

	Params::CharaBase_C_BI_SetAlreadyChangeEnableEffect Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_PlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseDuration                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseBlendTimeOverride                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTimeOverride                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_PlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_PlayMotion");

	Params::CharaBase_C_BI_PlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;
	Parms.IsUseDuration = IsUseDuration;
	Parms.Duration = Duration;
	Parms.IsUseBlendTimeOverride = IsUseBlendTimeOverride;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetNotifyDeadTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetNotifyDeadTiming(bool IsNotified, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetNotifyDeadTiming");

	Params::CharaBase_C_BI_SetNotifyDeadTiming Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_InstantMaterialAnimation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MATERIAL_ANIMATION_SLOT         Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           ElementNo                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSettings                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsForward                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsOnlyFirstTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_InstantMaterialAnimation(E_CHARA_MATERIAL_ANIMATION_SLOT Slot, const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSettings, bool IsForward, bool IsOnlyFirstTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_InstantMaterialAnimation");

	Params::CharaBase_C_BI_InstantMaterialAnimation Parms{};

	Parms.Slot = Slot;
	Parms.ElementNo = std::move(ElementNo);
	Parms.MaterialAnimSettings = std::move(MaterialAnimSettings);
	Parms.IsForward = IsForward;
	Parms.IsOnlyFirstTime = IsOnlyFirstTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_AttachClockingParticleSystem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystem*                  EmitterTemplate                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AttachPointName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Scale                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   LocationType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsCastShadow                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    AutoDestroy                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_AttachClockingParticleSystem(const class UParticleSystem*& EmitterTemplate, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, uint8 LocationType, const bool IsCastShadow, const bool AutoDestroy, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_AttachClockingParticleSystem");

	Params::CharaBase_C_BI_AttachClockingParticleSystem Parms{};

	Parms.EmitterTemplate = EmitterTemplate;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.LocationType = LocationType;
	Parms.IsCastShadow = IsCastShadow;
	Parms.AutoDestroy = AutoDestroy;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetNotifySkillFire
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetNotifySkillFire(bool IsNotified, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetNotifySkillFire");

	Params::CharaBase_C_BI_SetNotifySkillFire Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetNotifyWarpTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetNotifyWarpTiming(bool IsNotified, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetNotifyWarpTiming");

	Params::CharaBase_C_BI_SetNotifyWarpTiming Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_PerchEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_PerchEnd(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_PerchEnd");

	Params::CharaBase_C_BI_PerchEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_PerchBegin
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_PerchBegin(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_PerchBegin");

	Params::CharaBase_C_BI_PerchBegin Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_WatchOnesStepEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_WatchOnesStepEnd(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_WatchOnesStepEnd");

	Params::CharaBase_C_BI_WatchOnesStepEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_WatchOnesStepBegin
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_WatchOnesStepBegin(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_WatchOnesStepBegin");

	Params::CharaBase_C_BI_WatchOnesStepBegin Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_InvalidIKBegin
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_InvalidIKBegin(class FName Param_Name, int32 Param_Index, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_InvalidIKBegin");

	Params::CharaBase_C_BI_InvalidIKBegin Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetParticleTemplate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystemComponent*         TargetParticleSys                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UParticleSystem*                  Template                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Scale                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetParticleTemplate(const class UParticleSystemComponent*& TargetParticleSys, class UParticleSystem* Template, float Scale, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetParticleTemplate");

	Params::CharaBase_C_BI_SetParticleTemplate Parms{};

	Parms.TargetParticleSys = TargetParticleSys;
	Parms.Template = Template;
	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetCurrentSurfaceStatusMaterial
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<E_BAD_STATUS>                    CurrentSurface                                         (Parm, OutParm)

void ACharaBase_C::BI_GetCurrentSurfaceStatusMaterial(TArray<E_BAD_STATUS>* CurrentSurface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetCurrentSurfaceStatusMaterial");

	Params::CharaBase_C_BI_GetCurrentSurfaceStatusMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentSurface != nullptr)
		*CurrentSurface = std::move(Parms.CurrentSurface);
}


// Function CharaBase.CharaBase_C.BI_GetActionState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_ACTION_TYPE                     InAction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetActionState(E_CHARA_ACTION_TYPE InAction, uint8* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetActionState");

	Params::CharaBase_C_BI_GetActionState Parms{};

	Parms.InAction = InAction;

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function CharaBase.CharaBase_C.BI_EventPlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Animation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Loop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_EventPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_EventPlayMotion");

	Params::CharaBase_C_BI_EventPlayMotion Parms{};

	Parms.Animation = Animation;
	Parms.Loop = Loop;
	Parms.BlendTime = BlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetCompletelyDead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsDead                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetCompletelyDead(bool IsDead, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetCompletelyDead");

	Params::CharaBase_C_BI_SetCompletelyDead Parms{};

	Parms.IsDead = IsDead;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetAllVisibility
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetAllVisibility(bool IsVisible, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetAllVisibility");

	Params::CharaBase_C_BI_SetAllVisibility Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_InitializeMaterial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_InitializeMaterial(bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_InitializeMaterial");

	Params::CharaBase_C_BI_InitializeMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBase.CharaBase_C.BI_CommonEffectOff
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_CommonEffectOff(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_CommonEffectOff");

	Params::CharaBase_C_BI_CommonEffectOff Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_PauseMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_PauseMotion(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_PauseMotion");

	Params::CharaBase_C_BI_PauseMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_UpdateSurfaceBadStatus
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentStatus                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_UpdateSurfaceBadStatus(int32 CurrentStatus, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_UpdateSurfaceBadStatus");

	Params::CharaBase_C_BI_UpdateSurfaceBadStatus Parms{};

	Parms.CurrentStatus = CurrentStatus;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetScalarParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     Param_Names                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetScalarParam(const TArray<class FName>& Param_Names, float Value, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetScalarParam");

	Params::CharaBase_C_BI_SetScalarParam Parms{};

	Parms.Param_Names = std::move(Param_Names);
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBase.CharaBase_C.BI_SetScalarParamByArray
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMaterialInstanceDynamic*> Material                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FName>                     Param_Names                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   Value                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetScalarParamByArray(const TArray<class UMaterialInstanceDynamic*>& Material, const TArray<class FName>& Param_Names, const float Value, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetScalarParamByArray");

	Params::CharaBase_C_BI_SetScalarParamByArray Parms{};

	Parms.Material = std::move(Material);
	Parms.Param_Names = std::move(Param_Names);
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBase.CharaBase_C.BI_GetSocketTransform
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       RetVal                                                 (Parm, OutParm, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GetSocketTransform(class FName SocketName, struct FTransform* RetVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetSocketTransform");

	Params::CharaBase_C_BI_GetSocketTransform Parms{};

	Parms.SocketName = SocketName;

	UObject::ProcessEvent(Func, &Parms);

	if (RetVal != nullptr)
		*RetVal = std::move(Parms.RetVal);
}


// Function CharaBase.CharaBase_C.BI_IsNotifyDeadTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_IsNotifyDeadTiming(bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_IsNotifyDeadTiming");

	Params::CharaBase_C_BI_IsNotifyDeadTiming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function CharaBase.CharaBase_C.BI_GetMeshRelativeScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetMeshRelativeScale(float* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetMeshRelativeScale");

	Params::CharaBase_C_BI_GetMeshRelativeScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = Parms.Scale;
}


// Function CharaBase.CharaBase_C.BI_SetMeshRelativeScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewScale                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   NewBoundsScale                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetMeshRelativeScale(float NewScale, float NewBoundsScale, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetMeshRelativeScale");

	Params::CharaBase_C_BI_SetMeshRelativeScale Parms{};

	Parms.NewScale = NewScale;
	Parms.NewBoundsScale = NewBoundsScale;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetBadStatusEffectScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetBadStatusEffectScale(float* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetBadStatusEffectScale");

	Params::CharaBase_C_BI_GetBadStatusEffectScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = Parms.Scale;
}


// Function CharaBase.CharaBase_C.BI_SetNotifyRapidReturnTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetNotifyRapidReturnTiming(bool IsNotified, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetNotifyRapidReturnTiming");

	Params::CharaBase_C_BI_SetNotifyRapidReturnTiming Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_IsNotifyRapidReturnTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_IsNotifyRapidReturnTiming(bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_IsNotifyRapidReturnTiming");

	Params::CharaBase_C_BI_IsNotifyRapidReturnTiming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function CharaBase.CharaBase_C.BI_ApplyMaterialParam
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialParameterApplier*        ParamApplier                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_ApplyMaterialParam(class UMaterialParameterApplier* ParamApplier, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_ApplyMaterialParam");

	Params::CharaBase_C_BI_ApplyMaterialParam Parms{};

	Parms.ParamApplier = ParamApplier;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetTimeLineComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_BTL_DEAD_EFFECT                       DeadEffect                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTimelineComponent*               Comp                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetTimeLineComponent(E_BTL_DEAD_EFFECT DeadEffect, class UTimelineComponent** Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetTimeLineComponent");

	Params::CharaBase_C_BI_GetTimeLineComponent Parms{};

	Parms.DeadEffect = DeadEffect;

	UObject::ProcessEvent(Func, &Parms);

	if (Comp != nullptr)
		*Comp = Parms.Comp;
}


// Function CharaBase.CharaBase_C.BI_SetVectorParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     Param_Names                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FLinearColor                     Vector                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetVectorParam(TArray<class FName>& Param_Names, const struct FLinearColor& Vector, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetVectorParam");

	Params::CharaBase_C_BI_SetVectorParam Parms{};

	Parms.Param_Names = std::move(Param_Names);
	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);

	Param_Names = std::move(Parms.Param_Names);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBase.CharaBase_C.BI_LookAt
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Point                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_LookAt(class USceneComponent* Point, class FName Socket, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_LookAt");

	Params::CharaBase_C_BI_LookAt Parms{};

	Parms.Point = Point;
	Parms.Socket = Socket;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetSkeletalMeshComponents
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class USkeletalMeshComponent*>   Meshes                                                 (Parm, OutParm, ContainsInstancedReference)

void ACharaBase_C::BI_GetSkeletalMeshComponents(TArray<class USkeletalMeshComponent*>* Meshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetSkeletalMeshComponents");

	Params::CharaBase_C_BI_GetSkeletalMeshComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Meshes != nullptr)
		*Meshes = std::move(Parms.Meshes);
}


// Function CharaBase.CharaBase_C.BI_SetNotifyDeadVoice
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundAtomCue*                    Voice                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetNotifyDeadVoice(class USoundAtomCue* Voice, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetNotifyDeadVoice");

	Params::CharaBase_C_BI_SetNotifyDeadVoice Parms{};

	Parms.Voice = Voice;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetNotifyDeadVoice
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundAtomCue*                    Voice                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetNotifyDeadVoice(class USoundAtomCue** Voice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetNotifyDeadVoice");

	Params::CharaBase_C_BI_GetNotifyDeadVoice Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Voice != nullptr)
		*Voice = Parms.Voice;
}


// Function CharaBase.CharaBase_C.BI_RetrieveMotionNotifyNames
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_Motion                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>                   Names                                                  (Parm, OutParm)

void ACharaBase_C::BI_RetrieveMotionNotifyNames(E_CHARA_MOTION_ID Param_Motion, TArray<class FString>* Names)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_RetrieveMotionNotifyNames");

	Params::CharaBase_C_BI_RetrieveMotionNotifyNames Parms{};

	Parms.Param_Motion = Param_Motion;

	UObject::ProcessEvent(Func, &Parms);

	if (Names != nullptr)
		*Names = std::move(Parms.Names);
}


// Function CharaBase.CharaBase_C.BI_CalcBattleCameraScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_CalcBattleCameraScale(float* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_CalcBattleCameraScale");

	Params::CharaBase_C_BI_CalcBattleCameraScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = Parms.Scale;
}


// Function CharaBase.CharaBase_C.BI_GetMeshComponents
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMeshComponent*>           Meshes                                                 (Parm, OutParm, ContainsInstancedReference)

void ACharaBase_C::BI_GetMeshComponents(TArray<class UMeshComponent*>* Meshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetMeshComponents");

	Params::CharaBase_C_BI_GetMeshComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Meshes != nullptr)
		*Meshes = std::move(Parms.Meshes);
}


// Function CharaBase.CharaBase_C.BI_PlayDefaultBlink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_PlayDefaultBlink(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_PlayDefaultBlink");

	Params::CharaBase_C_BI_PlayDefaultBlink Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_StopDefaultBlink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_StopDefaultBlink(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_StopDefaultBlink");

	Params::CharaBase_C_BI_StopDefaultBlink Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_StackPlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Animation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Loop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_StackPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_StackPlayMotion");

	Params::CharaBase_C_BI_StackPlayMotion Parms{};

	Parms.Animation = Animation;
	Parms.Loop = Loop;
	Parms.BlendTime = BlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_ResetAllParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_ResetAllParam(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_ResetAllParam");

	Params::CharaBase_C_BI_ResetAllParam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_StopMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_StopMotion(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_StopMotion");

	Params::CharaBase_C_BI_StopMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetMotionComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCharaMotionPlayerComponent*      MotionComponent                                        (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetMotionComponent(class UCharaMotionPlayerComponent** MotionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetMotionComponent");

	Params::CharaBase_C_BI_GetMotionComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MotionComponent != nullptr)
		*MotionComponent = Parms.MotionComponent;
}


// Function CharaBase.CharaBase_C.BI_GetEnableChangeMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnable                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GetEnableChangeMotion(bool* IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetEnableChangeMotion");

	Params::CharaBase_C_BI_GetEnableChangeMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsEnable != nullptr)
		*IsEnable = Parms.IsEnable;
}


// Function CharaBase.CharaBase_C.BI_SetEnableChangeMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetEnableChangeMotion(bool Enable, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetEnableChangeMotion");

	Params::CharaBase_C_BI_SetEnableChangeMotion Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetSkillPerformDuration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsTrue                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetSkillPerformDuration(bool IsTrue, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetSkillPerformDuration");

	Params::CharaBase_C_BI_SetSkillPerformDuration Parms{};

	Parms.IsTrue = IsTrue;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetSkillPerformDuration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsTrue                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GetSkillPerformDuration(bool* IsTrue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetSkillPerformDuration");

	Params::CharaBase_C_BI_GetSkillPerformDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsTrue != nullptr)
		*IsTrue = Parms.IsTrue;
}


// Function CharaBase.CharaBase_C.BI_GetPlayBlink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsPlay                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GetPlayBlink(bool* IsPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetPlayBlink");

	Params::CharaBase_C_BI_GetPlayBlink Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlay != nullptr)
		*IsPlay = Parms.IsPlay;
}


// Function CharaBase.CharaBase_C.BI_PlayBlinkToNotify
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_PlayBlinkToNotify(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_PlayBlinkToNotify");

	Params::CharaBase_C_BI_PlayBlinkToNotify Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_StopBlinkToNotify
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_StopBlinkToNotify(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_StopBlinkToNotify");

	Params::CharaBase_C_BI_StopBlinkToNotify Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetVoiceSkillType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SKILL_TYPE                            Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetVoiceSkillType(E_SKILL_TYPE* Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetVoiceSkillType");

	Params::CharaBase_C_BI_GetVoiceSkillType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Type != nullptr)
		*Type = Parms.Type;
}


// Function CharaBase.CharaBase_C.BI_SetVoiceSkillType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SKILL_TYPE                            Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetVoiceSkillType(E_SKILL_TYPE Type, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetVoiceSkillType");

	Params::CharaBase_C_BI_SetVoiceSkillType Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetElectrification
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetElectrification(bool Enable, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetElectrification");

	Params::CharaBase_C_BI_SetElectrification Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetDitherEnable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetDitherEnable(bool Enable, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetDitherEnable");

	Params::CharaBase_C_BI_SetDitherEnable Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBase.CharaBase_C.BI_SetDitherRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InRate                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InInterpSec                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetDitherRate(float InRate, float InInterpSec, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetDitherRate");

	Params::CharaBase_C_BI_SetDitherRate Parms{};

	Parms.InRate = InRate;
	Parms.InInterpSec = InInterpSec;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBase.CharaBase_C.BI_ResetDitherRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InInterpSec                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_ResetDitherRate(float InInterpSec, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_ResetDitherRate");

	Params::CharaBase_C_BI_ResetDitherRate Parms{};

	Parms.InInterpSec = InInterpSec;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBase.CharaBase_C.BI_SetVoiceSkillAttr
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ATTRIBUTE_TYPE                        SkillAttr                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetVoiceSkillAttr(E_ATTRIBUTE_TYPE SkillAttr, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetVoiceSkillAttr");

	Params::CharaBase_C_BI_SetVoiceSkillAttr Parms{};

	Parms.SkillAttr = SkillAttr;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetVoiceSkillAttr
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ATTRIBUTE_TYPE                        SkillAttr                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetVoiceSkillAttr(E_ATTRIBUTE_TYPE* SkillAttr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetVoiceSkillAttr");

	Params::CharaBase_C_BI_GetVoiceSkillAttr Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkillAttr != nullptr)
		*SkillAttr = Parms.SkillAttr;
}


// Function CharaBase.CharaBase_C.BI_IsPlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPlay                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_IsPlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool* IsPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_IsPlayMotion");

	Params::CharaBase_C_BI_IsPlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlay != nullptr)
		*IsPlay = Parms.IsPlay;
}


// Function CharaBase.CharaBase_C.BI_SetFacial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Facial                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlendTimeOverride                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NotUse                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetFacial(class FName Facial, float BlendTimeOverride, bool* NotUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetFacial");

	Params::CharaBase_C_BI_SetFacial Parms{};

	Parms.Facial = Facial;
	Parms.BlendTimeOverride = BlendTimeOverride;

	UObject::ProcessEvent(Func, &Parms);

	if (NotUse != nullptr)
		*NotUse = Parms.NotUse;
}


// Function CharaBase.CharaBase_C.BI_GetDefaultAnimation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetDefaultAnimation(class UAnimSequenceBase** Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetDefaultAnimation");

	Params::CharaBase_C_BI_GetDefaultAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBase.CharaBase_C.BI_GetAnimInstance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimInstance*                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetAnimInstance(class UAnimInstance** Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetAnimInstance");

	Params::CharaBase_C_BI_GetAnimInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBase.CharaBase_C.BI_InvokeLookAtIKImmediately
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IncludeEyeIK                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_InvokeLookAtIKImmediately(bool IncludeEyeIK, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_InvokeLookAtIKImmediately");

	Params::CharaBase_C_BI_InvokeLookAtIKImmediately Parms{};

	Parms.IncludeEyeIK = IncludeEyeIK;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_IKEnableFlag
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_IK_TYPE_LIST                          Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_IKEnableFlag(E_IK_TYPE_LIST Type, bool Enable, bool Immediately, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_IKEnableFlag");

	Params::CharaBase_C_BI_IKEnableFlag Parms{};

	Parms.Type = Type;
	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_CalcEffectScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_CalcEffectScale(float* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_CalcEffectScale");

	Params::CharaBase_C_BI_CalcEffectScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = Parms.Scale;
}


// Function CharaBase.CharaBase_C.BI_SetVoiceSkillTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SKILL_TARGET                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetVoiceSkillTarget(E_SKILL_TARGET Target, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetVoiceSkillTarget");

	Params::CharaBase_C_BI_SetVoiceSkillTarget Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetVoiceSkillTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SKILL_TARGET                          Target                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetVoiceSkillTarget(E_SKILL_TARGET* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetVoiceSkillTarget");

	Params::CharaBase_C_BI_GetVoiceSkillTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Target != nullptr)
		*Target = Parms.Target;
}


// Function CharaBase.CharaBase_C.BI_GetDefaultIdleMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_Motion                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetDefaultIdleMotion(E_CHARA_MOTION_ID* Param_Motion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetDefaultIdleMotion");

	Params::CharaBase_C_BI_GetDefaultIdleMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Motion != nullptr)
		*Param_Motion = Parms.Param_Motion;
}


// Function CharaBase.CharaBase_C.BI_SetDefaultIdleMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_Motion                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetDefaultIdleMotion(E_CHARA_MOTION_ID Param_Motion, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetDefaultIdleMotion");

	Params::CharaBase_C_BI_SetDefaultIdleMotion Parms{};

	Parms.Param_Motion = Param_Motion;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetEnableCollision
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetEnableCollision(bool Enable, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetEnableCollision");

	Params::CharaBase_C_BI_SetEnableCollision Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetCollisionObjectType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECollisionChannel                       Channel                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetCollisionObjectType(ECollisionChannel Channel, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetCollisionObjectType");

	Params::CharaBase_C_BI_SetCollisionObjectType Parms{};

	Parms.Channel = Channel;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_IsCharaShaking
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Shaking                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_IsCharaShaking(bool* Shaking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_IsCharaShaking");

	Params::CharaBase_C_BI_IsCharaShaking Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Shaking != nullptr)
		*Shaking = Parms.Shaking;
}


// Function CharaBase.CharaBase_C.BI_StopCharaShake
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_StopCharaShake(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_StopCharaShake");

	Params::CharaBase_C_BI_StopCharaShake Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetForceRotate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GetForceRotate(bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetForceRotate");

	Params::CharaBase_C_BI_GetForceRotate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBase.CharaBase_C.BI_BattlePlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseDuration                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseBlendTimeOverride                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTimeOverride                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_BattlePlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_BattlePlayMotion");

	Params::CharaBase_C_BI_BattlePlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;
	Parms.IsUseDuration = IsUseDuration;
	Parms.Duration = Duration;
	Parms.IsUseBlendTimeOverride = IsUseBlendTimeOverride;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_BattleStopMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_BattleStopMotion(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_BattleStopMotion");

	Params::CharaBase_C_BI_BattleStopMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_EnableSilhouette
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnable                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_EnableSilhouette(bool IsEnable, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_EnableSilhouette");

	Params::CharaBase_C_BI_EnableSilhouette Parms{};

	Parms.IsEnable = IsEnable;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_IsSilhouetteEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnabled                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_IsSilhouetteEnabled(bool* IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_IsSilhouetteEnabled");

	Params::CharaBase_C_BI_IsSilhouetteEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsEnabled != nullptr)
		*IsEnabled = Parms.IsEnabled;
}


// Function CharaBase.CharaBase_C.BI_FloatNoRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoRotation                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_FloatNoRotation(bool NoRotation, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_FloatNoRotation");

	Params::CharaBase_C_BI_FloatNoRotation Parms{};

	Parms.NoRotation = NoRotation;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetParentChara
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TScriptInterface<class IBPI_CharaBaseAccessor_C>Parent                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsExist                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_GetParentChara(TScriptInterface<class IBPI_CharaBaseAccessor_C>* Parent, bool* IsExist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetParentChara");

	Params::CharaBase_C_BI_GetParentChara Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Parent != nullptr)
		*Parent = Parms.Parent;

	if (IsExist != nullptr)
		*IsExist = Parms.IsExist;
}


// Function CharaBase.CharaBase_C.BI_CheckIgnoreAtomComp
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAtomComponent*                   IgnoreComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsIgnoreID                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_CheckIgnoreAtomComp(class UAtomComponent*& IgnoreComp, bool* IsIgnoreID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_CheckIgnoreAtomComp");

	Params::CharaBase_C_BI_CheckIgnoreAtomComp Parms{};

	Parms.IgnoreComp = IgnoreComp;

	UObject::ProcessEvent(Func, &Parms);

	IgnoreComp = Parms.IgnoreComp;

	if (IsIgnoreID != nullptr)
		*IsIgnoreID = Parms.IsIgnoreID;
}


// Function CharaBase.CharaBase_C.BI_AddIgnoreAtomComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAtomComponent*                   IgnoreComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_AddIgnoreAtomComp(class UAtomComponent*& IgnoreComp, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_AddIgnoreAtomComp");

	Params::CharaBase_C_BI_AddIgnoreAtomComp Parms{};

	Parms.IgnoreComp = IgnoreComp;

	UObject::ProcessEvent(Func, &Parms);

	IgnoreComp = Parms.IgnoreComp;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_CreateSkeletalMeshComp
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkelMeshComp                                           (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_CreateSkeletalMeshComp(class USkeletalMeshComponent** SkelMeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_CreateSkeletalMeshComp");

	Params::CharaBase_C_BI_CreateSkeletalMeshComp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkelMeshComp != nullptr)
		*SkelMeshComp = Parms.SkelMeshComp;
}


// Function CharaBase.CharaBase_C.BI_DestroySkeletalMeshComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkelMeshComp                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_DestroySkeletalMeshComp(class USkeletalMeshComponent* SkelMeshComp, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_DestroySkeletalMeshComp");

	Params::CharaBase_C_BI_DestroySkeletalMeshComp Parms{};

	Parms.SkelMeshComp = SkelMeshComp;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_RemoveAllMaterialAnimDecalAttached
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_RemoveAllMaterialAnimDecalAttached(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_RemoveAllMaterialAnimDecalAttached");

	Params::CharaBase_C_BI_RemoveAllMaterialAnimDecalAttached Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_CreateSkeletalMeshActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASkeletalMeshActor*               SkelMeshActor                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_CreateSkeletalMeshActor(class ASkeletalMeshActor** SkelMeshActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_CreateSkeletalMeshActor");

	Params::CharaBase_C_BI_CreateSkeletalMeshActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkelMeshActor != nullptr)
		*SkelMeshActor = Parms.SkelMeshActor;
}


// Function CharaBase.CharaBase_C.BI_SetAnimBP
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetAnimBP(class UAnimInstance* AnimInstance, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetAnimBP");

	Params::CharaBase_C_BI_SetAnimBP Parms{};

	Parms.AnimInstance = AnimInstance;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_DestroySkeletalMeshActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASkeletalMeshActor*               SkelActor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_DestroySkeletalMeshActor(class ASkeletalMeshActor* SkelActor, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_DestroySkeletalMeshActor");

	Params::CharaBase_C_BI_DestroySkeletalMeshActor Parms{};

	Parms.SkelActor = SkelActor;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetSkeletalMeshActors
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ASkeletalMeshActor*>       SkelMeshActors                                         (Parm, OutParm)

void ACharaBase_C::BI_GetSkeletalMeshActors(TArray<class ASkeletalMeshActor*>* SkelMeshActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetSkeletalMeshActors");

	Params::CharaBase_C_BI_GetSkeletalMeshActors Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkelMeshActors != nullptr)
		*SkelMeshActors = std::move(Parms.SkelMeshActors);
}


// Function CharaBase.CharaBase_C.BI_DeactivateAttachedParticles
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoDestroyComponent                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_DeactivateAttachedParticles(bool NoDestroyComponent, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_DeactivateAttachedParticles");

	Params::CharaBase_C_BI_DeactivateAttachedParticles Parms{};

	Parms.NoDestroyComponent = NoDestroyComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_ActivateAttachedParticles
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_ActivateAttachedParticles(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_ActivateAttachedParticles");

	Params::CharaBase_C_BI_ActivateAttachedParticles Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_SetVoiceSkillID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SkillId                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_SetVoiceSkillID(int32 SkillId, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_SetVoiceSkillID");

	Params::CharaBase_C_BI_SetVoiceSkillID Parms{};

	Parms.SkillId = SkillId;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.BI_GetVoiceSkillID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SkillId                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::BI_GetVoiceSkillID(int32* SkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_GetVoiceSkillID");

	Params::CharaBase_C_BI_GetVoiceSkillID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkillId != nullptr)
		*SkillId = Parms.SkillId;
}


// Function CharaBase.CharaBase_C.BI_DirectPlayMotion
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                DefaultAnim                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimSequenceBase*                LoopAnim                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MotionBlendTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBase_C::BI_DirectPlayMotion(class UAnimSequenceBase* DefaultAnim, class UAnimSequenceBase* LoopAnim, float MotionBlendTime, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "BI_DirectPlayMotion");

	Params::CharaBase_C_BI_DirectPlayMotion Parms{};

	Parms.DefaultAnim = DefaultAnim;
	Parms.LoopAnim = LoopAnim;
	Parms.MotionBlendTime = MotionBlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBase.CharaBase_C.IsWatchingOnesStep
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ACharaBase_C::IsWatchingOnesStep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsWatchingOnesStep");

	Params::CharaBase_C_IsWatchingOnesStep Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CharaBase.CharaBase_C.IsPerching
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ACharaBase_C::IsPerching() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "IsPerching");

	Params::CharaBase_C_IsPerching Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CharaBase.CharaBase_C.GetMoveParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FCharaMoveParam                  MoveParam                                              (Parm, OutParm)

void ACharaBase_C::GetMoveParam(struct FCharaMoveParam* MoveParam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetMoveParam");

	Params::CharaBase_C_GetMoveParam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MoveParam != nullptr)
		*MoveParam = std::move(Parms.MoveParam);
}


// Function CharaBase.CharaBase_C.GetMoveTotalTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBase_C::GetMoveTotalTime(float* Time) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "GetMoveTotalTime");

	Params::CharaBase_C_GetMoveTotalTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Time != nullptr)
		*Time = Parms.Time;
}


// Function CharaBase.CharaBase_C.CheckPlayAnimNotifyDevilVoice
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EDevilVoiceType                         DevilVoiceType                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ACharaBase_C::CheckPlayAnimNotifyDevilVoice(EDevilVoiceType DevilVoiceType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CheckPlayAnimNotifyDevilVoice");

	Params::CharaBase_C_CheckPlayAnimNotifyDevilVoice Parms{};

	Parms.DevilVoiceType = DevilVoiceType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CharaBase.CharaBase_C.CheckMagatsuhiDevil
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ACharaBase_C::CheckMagatsuhiDevil() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBase_C", "CheckMagatsuhiDevil");

	Params::CharaBase_C_CheckMagatsuhiDevil Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

