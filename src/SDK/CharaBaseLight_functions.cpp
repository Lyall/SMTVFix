#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharaBaseLight

#include "Basic.hpp"

#include "CharaBaseLight_classes.hpp"
#include "CharaBaseLight_parameters.hpp"


namespace SDK
{

// Function CharaBaseLight.CharaBaseLight_C.ExecuteUbergraph_CharaBaseLight
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::ExecuteUbergraph_CharaBaseLight(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "ExecuteUbergraph_CharaBaseLight");

	Params::CharaBaseLight_C_ExecuteUbergraph_CharaBaseLight Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetForceUpdateLookAt
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsForceUpdate                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetForceUpdateLookAt(bool IsForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetForceUpdateLookAt");

	Params::CharaBaseLight_C_BI_SetForceUpdateLookAt Parms{};

	Parms.IsForceUpdate = IsForceUpdate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_ForceDisableLimitLookAt
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Disable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_ForceDisableLimitLookAt(bool Disable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_ForceDisableLimitLookAt");

	Params::CharaBaseLight_C_BI_ForceDisableLimitLookAt Parms{};

	Parms.Disable = Disable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetLimitLookAtRange
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetLimitLookAtRange(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetLimitLookAtRange");

	Params::CharaBaseLight_C_BI_SetLimitLookAtRange Parms{};

	Parms.IsActive = IsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.TempHidden
// (BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::TempHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "TempHidden");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "ReceiveEndPlay");

	Params::CharaBaseLight_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GuestBattleInitialize
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dither100                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GuestBattleInitialize(bool Dither100)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GuestBattleInitialize");

	Params::CharaBaseLight_C_BI_GuestBattleInitialize Parms{};

	Parms.Dither100 = Dither100;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.OnTransformUpdatedForIK
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Teleport                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::OnTransformUpdatedForIK(bool Teleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "OnTransformUpdatedForIK");

	Params::CharaBaseLight_C_OnTransformUpdatedForIK Parms{};

	Parms.Teleport = Teleport;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.PostEvaluateAnimation
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::PostEvaluateAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "PostEvaluateAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.UpdateAnimation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::UpdateAnimation(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "UpdateAnimation");

	Params::CharaBaseLight_C_UpdateAnimation Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.InitializeAnimation
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::InitializeAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InitializeAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "ReceiveTick");

	Params::CharaBaseLight_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ACharaBaseLight_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_PlayStartEffect
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::BI_PlayStartEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_PlayStartEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.StopDefaultBlink
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::StopDefaultBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "StopDefaultBlink");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.PlayDefaultBlink
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::PlayDefaultBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "PlayDefaultBlink");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetDevilRootMotion
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetDevilRootMotion(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetDevilRootMotion");

	Params::CharaBaseLight_C_BI_SetDevilRootMotion Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.StopLipSync
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::StopLipSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "StopLipSync");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_AdjustMeshScale
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsReset                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_AdjustMeshScale(bool IsReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_AdjustMeshScale");

	Params::CharaBaseLight_C_BI_AdjustMeshScale Parms{};

	Parms.IsReset = IsReset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.PlayLipSync
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCharaLipSync*                    Param_PlayLipSync                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsLoop                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::PlayLipSync(class UCharaLipSync* Param_PlayLipSync, bool IsLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "PlayLipSync");

	Params::CharaBaseLight_C_PlayLipSync Parms{};

	Parms.Param_PlayLipSync = Param_PlayLipSync;
	Parms.IsLoop = IsLoop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetLipClearDelay
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_SetLipClearDelay(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetLipClearDelay");

	Params::CharaBaseLight_C_BI_SetLipClearDelay Parms{};

	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetHeadIKSpeed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Speed                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_SetHeadIKSpeed(float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetHeadIKSpeed");

	Params::CharaBaseLight_C_BI_SetHeadIKSpeed Parms{};

	Parms.Speed = Speed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.StopSpeakingMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::StopSpeakingMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "StopSpeakingMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.PlaySpeakingMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::PlaySpeakingMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "PlaySpeakingMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_TempToggleCameraDitherState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ForceDitherOff                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_TempToggleCameraDitherState(bool ForceDitherOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_TempToggleCameraDitherState");

	Params::CharaBaseLight_C_BI_TempToggleCameraDitherState Parms{};

	Parms.ForceDitherOff = ForceDitherOff;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GuestBattleFinalize
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::BI_GuestBattleFinalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GuestBattleFinalize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.찏鉅법_0__UpdateFunc
// (BlueprintEvent)

void ACharaBaseLight_C::_______0__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "찏鉅법_0__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.찏鉅법_0__FinishedFunc
// (BlueprintEvent)

void ACharaBaseLight_C::_______0__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "찏鉅법_0__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.PlayMotion
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_IsUseDuration                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseBlendTimeOverride                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTimeOverride                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::PlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool Param_IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "PlayMotion");

	Params::CharaBaseLight_C_PlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;
	Parms.Param_IsUseDuration = Param_IsUseDuration;
	Parms.Duration = Duration;
	Parms.IsUseBlendTimeOverride = IsUseBlendTimeOverride;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.StopMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::StopMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "StopMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.PauseMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::PauseMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "PauseMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.ResumeMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::ResumeMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "ResumeMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.SetLegIKEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetLegIKEnable(bool Enable, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetLegIKEnable");

	Params::CharaBaseLight_C_SetLegIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.SetHeadIKEnable
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetHeadIKEnable(bool Enable, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetHeadIKEnable");

	Params::CharaBaseLight_C_SetHeadIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.SetEyeIKEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetEyeIKEnable(bool Enable, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetEyeIKEnable");

	Params::CharaBaseLight_C_SetEyeIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.InitializeIK
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::InitializeIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InitializeIK");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.UpdateIK
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::UpdateIK(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "UpdateIK");

	Params::CharaBaseLight_C_UpdateIK Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.UpdateSink
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UCharaSinkTesterInterface_C*>Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FVector                          Offset                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::UpdateSink(float DeltaTime, TArray<class UCharaSinkTesterInterface_C*>& Array, struct FVector* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "UpdateSink");

	Params::CharaBaseLight_C_UpdateSink Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function CharaBaseLight.CharaBaseLight_C.ApplySinkOffset
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::ApplySinkOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "ApplySinkOffset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.LookAt
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Point                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::LookAt(class USceneComponent* Point, class FName Socket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "LookAt");

	Params::CharaBaseLight_C_LookAt Parms{};

	Parms.Point = Point;
	Parms.Socket = Socket;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.LoadMotion
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::LoadMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "LoadMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.IsMotionFinished
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::IsMotionFinished(E_CHARA_MOTION_ID Param_MotionID, bool* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "IsMotionFinished");

	Params::CharaBaseLight_C_IsMotionFinished Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBaseLight.CharaBaseLight_C.GetNowMotionID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::GetNowMotionID(E_CHARA_MOTION_ID* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "GetNowMotionID");

	Params::CharaBaseLight_C_GetNowMotionID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBaseLight.CharaBaseLight_C.GetValidIdolMotionIDs
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<E_CHARA_MOTION_ID>               IDs                                                    (Parm, OutParm)

void ACharaBaseLight_C::GetValidIdolMotionIDs(TArray<E_CHARA_MOTION_ID>* IDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "GetValidIdolMotionIDs");

	Params::CharaBaseLight_C_GetValidIdolMotionIDs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IDs != nullptr)
		*IDs = std::move(Parms.IDs);
}


// Function CharaBaseLight.CharaBaseLight_C.AdjustValidMotionID
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_CHARA_MOTION_ID                       ValidMotionID                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::AdjustValidMotionID(E_CHARA_MOTION_ID Param_MotionID, E_CHARA_MOTION_ID* ValidMotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "AdjustValidMotionID");

	Params::CharaBaseLight_C_AdjustValidMotionID Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (ValidMotionID != nullptr)
		*ValidMotionID = Parms.ValidMotionID;
}


// Function CharaBaseLight.CharaBaseLight_C.SetBodyIKEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetBodyIKEnable(bool Enable, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetBodyIKEnable");

	Params::CharaBaseLight_C_SetBodyIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.IsSameMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::IsSameMotion(E_CHARA_MOTION_ID Param_MotionID, bool* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "IsSameMotion");

	Params::CharaBaseLight_C_IsSameMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBaseLight.CharaBaseLight_C.HasValidMotion
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetVal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::HasValidMotion(E_CHARA_MOTION_ID Param_MotionID, bool* RetVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "HasValidMotion");

	Params::CharaBaseLight_C_HasValidMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (RetVal != nullptr)
		*RetVal = Parms.RetVal;
}


// Function CharaBaseLight.CharaBaseLight_C.EventPlayMotion
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Animation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Loop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::EventPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "EventPlayMotion");

	Params::CharaBaseLight_C_EventPlayMotion Parms{};

	Parms.Animation = Animation;
	Parms.Loop = Loop;
	Parms.BlendTime = BlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.EventSetMotionRateScale
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   MotionRateScale                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::EventSetMotionRateScale(float MotionRateScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "EventSetMotionRateScale");

	Params::CharaBaseLight_C_EventSetMotionRateScale Parms{};

	Parms.MotionRateScale = MotionRateScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.InvokeLegIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::InvokeLegIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InvokeLegIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.InvokeHeadIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::InvokeHeadIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InvokeHeadIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.InvokeEyeIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::InvokeEyeIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InvokeEyeIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.InvokeBodyIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::InvokeBodyIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InvokeBodyIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.SetLookAtIKEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IncludeEyeIK                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetLookAtIKEnable(bool Enable, bool Immediately, bool IncludeEyeIK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetLookAtIKEnable");

	Params::CharaBaseLight_C_SetLookAtIKEnable Parms{};

	Parms.Enable = Enable;
	Parms.Immediately = Immediately;
	Parms.IncludeEyeIK = IncludeEyeIK;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.InvokeLookAtIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IncludeEyeIK                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::InvokeLookAtIKImmediately(bool IncludeEyeIK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InvokeLookAtIKImmediately");

	Params::CharaBaseLight_C_InvokeLookAtIKImmediately Parms{};

	Parms.IncludeEyeIK = IncludeEyeIK;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.InitializeExpression
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::InitializeExpression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InitializeExpression");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.UpdateExpression
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::UpdateExpression(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "UpdateExpression");

	Params::CharaBaseLight_C_UpdateExpression Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.SetMumbleEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetMumbleEnable(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetMumbleEnable");

	Params::CharaBaseLight_C_SetMumbleEnable Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.InvokeFloatingIKImmediately
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::InvokeFloatingIKImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InvokeFloatingIKImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.ResetSink
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::ResetSink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "ResetSink");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.WatchOnesStepBegin
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::WatchOnesStepBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "WatchOnesStepBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.WatchOnesStepEnd
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::WatchOnesStepEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "WatchOnesStepEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.PerchBegin
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::PerchBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "PerchBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.PerchEnd
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::PerchEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "PerchEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.InitializeBoneTrans
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::InitializeBoneTrans()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InitializeBoneTrans");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.InvalidIKBegin
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::InvalidIKBegin(class FName Param_Name, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InvalidIKBegin");

	Params::CharaBaseLight_C_InvalidIKBegin Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.InvalidIKEnd
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::InvalidIKEnd(class FName Param_Name, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "InvalidIKEnd");

	Params::CharaBaseLight_C_InvalidIKEnd Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.GetPreviousMotionID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       RetValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::GetPreviousMotionID(E_CHARA_MOTION_ID* RetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "GetPreviousMotionID");

	Params::CharaBaseLight_C_GetPreviousMotionID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RetValue != nullptr)
		*RetValue = Parms.RetValue;
}


// Function CharaBaseLight.CharaBaseLight_C.SetNowMotionID
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       MotionIDCurrent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::SetNowMotionID(E_CHARA_MOTION_ID MotionIDCurrent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetNowMotionID");

	Params::CharaBaseLight_C_SetNowMotionID Parms{};

	Parms.MotionIDCurrent = MotionIDCurrent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.SetPreviousMotionID
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::SetPreviousMotionID(E_CHARA_MOTION_ID Param_MotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetPreviousMotionID");

	Params::CharaBaseLight_C_SetPreviousMotionID Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.SetMotionIsUseDuration
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_IsUseDuration                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetMotionIsUseDuration(bool Param_IsUseDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetMotionIsUseDuration");

	Params::CharaBaseLight_C_SetMotionIsUseDuration Parms{};

	Parms.Param_IsUseDuration = Param_IsUseDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.SetMotionDuration
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::SetMotionDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetMotionDuration");

	Params::CharaBaseLight_C_SetMotionDuration Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.SetIsUseBlendTime
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsUseBlendTime                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetIsUseBlendTime(bool IsUseBlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetIsUseBlendTime");

	Params::CharaBaseLight_C_SetIsUseBlendTime Parms{};

	Parms.IsUseBlendTime = IsUseBlendTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.SetBlendTime
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::SetBlendTime(float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetBlendTime");

	Params::CharaBaseLight_C_SetBlendTime Parms{};

	Parms.BlendTime = BlendTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.GetParalyzed
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Paralyzed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::GetParalyzed(bool* Paralyzed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "GetParalyzed");

	Params::CharaBaseLight_C_GetParalyzed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Paralyzed != nullptr)
		*Paralyzed = Parms.Paralyzed;
}


// Function CharaBaseLight.CharaBaseLight_C.IsFreezeMotion
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Param_M_IsFreezeMotion                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::IsFreezeMotion(bool* Param_M_IsFreezeMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "IsFreezeMotion");

	Params::CharaBaseLight_C_IsFreezeMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_M_IsFreezeMotion != nullptr)
		*Param_M_IsFreezeMotion = Parms.Param_M_IsFreezeMotion;
}


// Function CharaBaseLight.CharaBaseLight_C.IsUseDuration
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Param_IsUseDuration                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::IsUseDuration(bool* Param_IsUseDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "IsUseDuration");

	Params::CharaBaseLight_C_IsUseDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_IsUseDuration != nullptr)
		*Param_IsUseDuration = Parms.Param_IsUseDuration;
}


// Function CharaBaseLight.CharaBaseLight_C.SetDefaultIdleMotion
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Default_Idle                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::SetDefaultIdleMotion(E_CHARA_MOTION_ID Default_Idle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetDefaultIdleMotion");

	Params::CharaBaseLight_C_SetDefaultIdleMotion Parms{};

	Parms.Default_Idle = Default_Idle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.GetDefaultIdleMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_CHARA_MOTION_ID                       Idle                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::GetDefaultIdleMotion(E_CHARA_MOTION_ID* Idle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "GetDefaultIdleMotion");

	Params::CharaBaseLight_C_GetDefaultIdleMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Idle != nullptr)
		*Idle = Parms.Idle;
}


// Function CharaBaseLight.CharaBaseLight_C.CheckUpdateIK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ClacIK                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   DeltaRate                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::CheckUpdateIK(bool* ClacIK, int32* DeltaRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "CheckUpdateIK");

	Params::CharaBaseLight_C_CheckUpdateIK Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ClacIK != nullptr)
		*ClacIK = Parms.ClacIK;

	if (DeltaRate != nullptr)
		*DeltaRate = Parms.DeltaRate;
}


// Function CharaBaseLight.CharaBaseLight_C.GetSocketTransform
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::GetSocketTransform(class FName SocketName, struct FTransform* Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "GetSocketTransform");

	Params::CharaBaseLight_C_GetSocketTransform Parms{};

	Parms.SocketName = SocketName;

	UObject::ProcessEvent(Func, &Parms);

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);
}


// Function CharaBaseLight.CharaBaseLight_C.StackPlayMotion
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Animation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Loop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::StackPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "StackPlayMotion");

	Params::CharaBaseLight_C_StackPlayMotion Parms{};

	Parms.Animation = Animation;
	Parms.Loop = Loop;
	Parms.BlendTime = BlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.SetAllVisibility
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetAllVisibility(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetAllVisibility");

	Params::CharaBaseLight_C_SetAllVisibility Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharaBaseLight.CharaBaseLight_C.LookAtCalc
// (Public, BlueprintCallable, BlueprintEvent)

void ACharaBaseLight_C::LookAtCalc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "LookAtCalc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharaBaseLight.CharaBaseLight_C.SetIsUpdateAnimation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Update                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetIsUpdateAnimation(bool Update, bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetIsUpdateAnimation");

	Params::CharaBaseLight_C_SetIsUpdateAnimation Parms{};

	Parms.Update = Update;

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBaseLight.CharaBaseLight_C.SetAlwaysAutoTransitionAnimationMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Check                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NotUse                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetAlwaysAutoTransitionAnimationMode(bool Check, bool* NotUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetAlwaysAutoTransitionAnimationMode");

	Params::CharaBaseLight_C_SetAlwaysAutoTransitionAnimationMode Parms{};

	Parms.Check = Check;

	UObject::ProcessEvent(Func, &Parms);

	if (NotUse != nullptr)
		*NotUse = Parms.NotUse;
}


// Function CharaBaseLight.CharaBaseLight_C.SetIsUpdateIK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Update                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::SetIsUpdateIK(bool Update, bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "SetIsUpdateIK");

	Params::CharaBaseLight_C_SetIsUpdateIK Parms{};

	Parms.Update = Update;

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetNPCCollision
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetNPCCollision(bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetNPCCollision");

	Params::CharaBaseLight_C_BI_SetNPCCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetMeshComponents
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMeshComponent*>           Meshes                                                 (Parm, OutParm, ContainsInstancedReference)

void ACharaBaseLight_C::BI_GetMeshComponents(TArray<class UMeshComponent*>* Meshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetMeshComponents");

	Params::CharaBaseLight_C_BI_GetMeshComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Meshes != nullptr)
		*Meshes = std::move(Parms.Meshes);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_CalcBattleCameraScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_CalcBattleCameraScale(float* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_CalcBattleCameraScale");

	Params::CharaBaseLight_C_BI_CalcBattleCameraScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = Parms.Scale;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_RetrieveMotionNotifyNames
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_Motion                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>                   Names                                                  (Parm, OutParm)

void ACharaBaseLight_C::BI_RetrieveMotionNotifyNames(E_CHARA_MOTION_ID Param_Motion, TArray<class FString>* Names)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_RetrieveMotionNotifyNames");

	Params::CharaBaseLight_C_BI_RetrieveMotionNotifyNames Parms{};

	Parms.Param_Motion = Param_Motion;

	UObject::ProcessEvent(Func, &Parms);

	if (Names != nullptr)
		*Names = std::move(Parms.Names);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetNotifyDeadVoice
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundAtomCue*                    Voice                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetNotifyDeadVoice(class USoundAtomCue** Voice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetNotifyDeadVoice");

	Params::CharaBaseLight_C_BI_GetNotifyDeadVoice Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Voice != nullptr)
		*Voice = Parms.Voice;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetNotifyDeadVoice
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundAtomCue*                    Voice                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetNotifyDeadVoice(class USoundAtomCue* Voice, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetNotifyDeadVoice");

	Params::CharaBaseLight_C_BI_SetNotifyDeadVoice Parms{};

	Parms.Voice = Voice;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetSkeletalMeshComponents
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class USkeletalMeshComponent*>   Meshes                                                 (Parm, OutParm, ContainsInstancedReference)

void ACharaBaseLight_C::BI_GetSkeletalMeshComponents(TArray<class USkeletalMeshComponent*>* Meshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetSkeletalMeshComponents");

	Params::CharaBaseLight_C_BI_GetSkeletalMeshComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Meshes != nullptr)
		*Meshes = std::move(Parms.Meshes);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_LookAt
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Point                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_LookAt(class USceneComponent* Point, class FName Socket, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_LookAt");

	Params::CharaBaseLight_C_BI_LookAt Parms{};

	Parms.Point = Point;
	Parms.Socket = Socket;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetVectorParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     Param_Names                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FLinearColor                     Vector                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetVectorParam(TArray<class FName>& Param_Names, const struct FLinearColor& Vector, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetVectorParam");

	Params::CharaBaseLight_C_BI_SetVectorParam Parms{};

	Parms.Param_Names = std::move(Param_Names);
	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);

	Param_Names = std::move(Parms.Param_Names);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetTimeLineComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_BTL_DEAD_EFFECT                       DeadEffect                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTimelineComponent*               Comp                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetTimeLineComponent(E_BTL_DEAD_EFFECT DeadEffect, class UTimelineComponent** Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetTimeLineComponent");

	Params::CharaBaseLight_C_BI_GetTimeLineComponent Parms{};

	Parms.DeadEffect = DeadEffect;

	UObject::ProcessEvent(Func, &Parms);

	if (Comp != nullptr)
		*Comp = Parms.Comp;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_ApplyMaterialParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialParameterApplier*        ParamApplier                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_ApplyMaterialParam(class UMaterialParameterApplier* ParamApplier, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_ApplyMaterialParam");

	Params::CharaBaseLight_C_BI_ApplyMaterialParam Parms{};

	Parms.ParamApplier = ParamApplier;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_IsNotifyRapidReturnTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_IsNotifyRapidReturnTiming(bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_IsNotifyRapidReturnTiming");

	Params::CharaBaseLight_C_BI_IsNotifyRapidReturnTiming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetNotifyRapidReturnTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetNotifyRapidReturnTiming(bool IsNotified, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetNotifyRapidReturnTiming");

	Params::CharaBaseLight_C_BI_SetNotifyRapidReturnTiming Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetBadStatusEffectScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetBadStatusEffectScale(float* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetBadStatusEffectScale");

	Params::CharaBaseLight_C_BI_GetBadStatusEffectScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = Parms.Scale;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetMeshRelativeScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewScale                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   NewBoundsScale                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetMeshRelativeScale(float NewScale, float NewBoundsScale, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetMeshRelativeScale");

	Params::CharaBaseLight_C_BI_SetMeshRelativeScale Parms{};

	Parms.NewScale = NewScale;
	Parms.NewBoundsScale = NewBoundsScale;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetMeshRelativeScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetMeshRelativeScale(float* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetMeshRelativeScale");

	Params::CharaBaseLight_C_BI_GetMeshRelativeScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = Parms.Scale;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_IsNotifyDeadTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_IsNotifyDeadTiming(bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_IsNotifyDeadTiming");

	Params::CharaBaseLight_C_BI_IsNotifyDeadTiming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetSocketTransform
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       RetVal                                                 (Parm, OutParm, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GetSocketTransform(class FName SocketName, struct FTransform* RetVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetSocketTransform");

	Params::CharaBaseLight_C_BI_GetSocketTransform Parms{};

	Parms.SocketName = SocketName;

	UObject::ProcessEvent(Func, &Parms);

	if (RetVal != nullptr)
		*RetVal = std::move(Parms.RetVal);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetScalarParamByArray
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMaterialInstanceDynamic*> Material                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FName>                     Param_Names                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   Value                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetScalarParamByArray(const TArray<class UMaterialInstanceDynamic*>& Material, const TArray<class FName>& Param_Names, const float Value, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetScalarParamByArray");

	Params::CharaBaseLight_C_BI_SetScalarParamByArray Parms{};

	Parms.Material = std::move(Material);
	Parms.Param_Names = std::move(Param_Names);
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetScalarParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     Param_Names                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetScalarParam(const TArray<class FName>& Param_Names, float Value, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetScalarParam");

	Params::CharaBaseLight_C_BI_SetScalarParam Parms{};

	Parms.Param_Names = std::move(Param_Names);
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_UpdateSurfaceBadStatus
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentStatus                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_UpdateSurfaceBadStatus(int32 CurrentStatus, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_UpdateSurfaceBadStatus");

	Params::CharaBaseLight_C_BI_UpdateSurfaceBadStatus Parms{};

	Parms.CurrentStatus = CurrentStatus;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_PauseMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_PauseMotion(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_PauseMotion");

	Params::CharaBaseLight_C_BI_PauseMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_CommonEffectOff
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_CommonEffectOff(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_CommonEffectOff");

	Params::CharaBaseLight_C_BI_CommonEffectOff Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_InitializeMaterial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_InitializeMaterial(bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_InitializeMaterial");

	Params::CharaBaseLight_C_BI_InitializeMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetAllVisibility
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetAllVisibility(bool IsVisible, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetAllVisibility");

	Params::CharaBaseLight_C_BI_SetAllVisibility Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetCompletelyDead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsDead                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetCompletelyDead(bool IsDead, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetCompletelyDead");

	Params::CharaBaseLight_C_BI_SetCompletelyDead Parms{};

	Parms.IsDead = IsDead;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_EventPlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Animation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Loop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_EventPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_EventPlayMotion");

	Params::CharaBaseLight_C_BI_EventPlayMotion Parms{};

	Parms.Animation = Animation;
	Parms.Loop = Loop;
	Parms.BlendTime = BlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetActionState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_ACTION_TYPE                     InAction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetActionState(E_CHARA_ACTION_TYPE InAction, uint8* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetActionState");

	Params::CharaBaseLight_C_BI_GetActionState Parms{};

	Parms.InAction = InAction;

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetCurrentSurfaceStatusMaterial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<E_BAD_STATUS>                    CurrentSurface                                         (Parm, OutParm)

void ACharaBaseLight_C::BI_GetCurrentSurfaceStatusMaterial(TArray<E_BAD_STATUS>* CurrentSurface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetCurrentSurfaceStatusMaterial");

	Params::CharaBaseLight_C_BI_GetCurrentSurfaceStatusMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentSurface != nullptr)
		*CurrentSurface = std::move(Parms.CurrentSurface);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetParticleTemplate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystemComponent*         TargetParticleSys                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UParticleSystem*                  Template                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Scale                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetParticleTemplate(const class UParticleSystemComponent*& TargetParticleSys, class UParticleSystem* Template, float Scale, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetParticleTemplate");

	Params::CharaBaseLight_C_BI_SetParticleTemplate Parms{};

	Parms.TargetParticleSys = TargetParticleSys;
	Parms.Template = Template;
	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_InvalidIKBegin
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_InvalidIKBegin(class FName Param_Name, int32 Param_Index, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_InvalidIKBegin");

	Params::CharaBaseLight_C_BI_InvalidIKBegin Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_WatchOnesStepBegin
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_WatchOnesStepBegin(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_WatchOnesStepBegin");

	Params::CharaBaseLight_C_BI_WatchOnesStepBegin Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_WatchOnesStepEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_WatchOnesStepEnd(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_WatchOnesStepEnd");

	Params::CharaBaseLight_C_BI_WatchOnesStepEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_PerchBegin
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_PerchBegin(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_PerchBegin");

	Params::CharaBaseLight_C_BI_PerchBegin Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_PerchEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_PerchEnd(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_PerchEnd");

	Params::CharaBaseLight_C_BI_PerchEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetNotifyWarpTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetNotifyWarpTiming(bool IsNotified, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetNotifyWarpTiming");

	Params::CharaBaseLight_C_BI_SetNotifyWarpTiming Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetNotifySkillFire
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetNotifySkillFire(bool IsNotified, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetNotifySkillFire");

	Params::CharaBaseLight_C_BI_SetNotifySkillFire Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_AttachClockingParticleSystem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystem*                  EmitterTemplate                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AttachPointName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Scale                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   LocationType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsCastShadow                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    AutoDestroy                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_AttachClockingParticleSystem(const class UParticleSystem*& EmitterTemplate, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, uint8 LocationType, const bool IsCastShadow, const bool AutoDestroy, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_AttachClockingParticleSystem");

	Params::CharaBaseLight_C_BI_AttachClockingParticleSystem Parms{};

	Parms.EmitterTemplate = EmitterTemplate;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.LocationType = LocationType;
	Parms.IsCastShadow = IsCastShadow;
	Parms.AutoDestroy = AutoDestroy;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_InstantMaterialAnimation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MATERIAL_ANIMATION_SLOT         Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           ElementNo                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSettings                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsForward                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsOnlyFirstTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_InstantMaterialAnimation(E_CHARA_MATERIAL_ANIMATION_SLOT Slot, const TArray<int32>& ElementNo, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSettings, bool IsForward, bool IsOnlyFirstTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_InstantMaterialAnimation");

	Params::CharaBaseLight_C_BI_InstantMaterialAnimation Parms{};

	Parms.Slot = Slot;
	Parms.ElementNo = std::move(ElementNo);
	Parms.MaterialAnimSettings = std::move(MaterialAnimSettings);
	Parms.IsForward = IsForward;
	Parms.IsOnlyFirstTime = IsOnlyFirstTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetNotifyDeadTiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetNotifyDeadTiming(bool IsNotified, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetNotifyDeadTiming");

	Params::CharaBaseLight_C_BI_SetNotifyDeadTiming Parms{};

	Parms.IsNotified = IsNotified;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_PlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseDuration                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseBlendTimeOverride                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTimeOverride                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_PlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_PlayMotion");

	Params::CharaBaseLight_C_BI_PlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;
	Parms.IsUseDuration = IsUseDuration;
	Parms.Duration = Duration;
	Parms.IsUseBlendTimeOverride = IsUseBlendTimeOverride;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetAlreadyChangeEnableEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetAlreadyChangeEnableEffect(class FName Key, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetAlreadyChangeEnableEffect");

	Params::CharaBaseLight_C_BI_SetAlreadyChangeEnableEffect Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetAlreadyChangeEnableEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsChanged                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GetAlreadyChangeEnableEffect(class FName Key, bool* IsChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetAlreadyChangeEnableEffect");

	Params::CharaBaseLight_C_BI_GetAlreadyChangeEnableEffect Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (IsChanged != nullptr)
		*IsChanged = Parms.IsChanged;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetAlreadyChangeEnableDecal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetAlreadyChangeEnableDecal(class FName Key, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetAlreadyChangeEnableDecal");

	Params::CharaBaseLight_C_BI_SetAlreadyChangeEnableDecal Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetAlreadyChangeEnableDecal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsChanged                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GetAlreadyChangeEnableDecal(class FName Key, bool* IsChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetAlreadyChangeEnableDecal");

	Params::CharaBaseLight_C_BI_GetAlreadyChangeEnableDecal Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	if (IsChanged != nullptr)
		*IsChanged = Parms.IsChanged;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SpawnMaterialAnimDecalAttached
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInstance*                DecalMaterial                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FMaterialAnimSetting_T>   MaterialAnimSettings                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          DecalSize                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OffsetLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AttachPointName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OverrideLifeSec                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   LocationType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UMaterialAnimDecalComponent_C*    Comp                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_SpawnMaterialAnimDecalAttached(const class UMaterialInstance*& DecalMaterial, const TArray<struct FMaterialAnimSetting_T>& MaterialAnimSettings, const struct FVector& DecalSize, const struct FVector& OffsetLocation, class FName AttachPointName, float OverrideLifeSec, uint8 LocationType, const struct FRotator& Rotation, class UMaterialAnimDecalComponent_C** Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SpawnMaterialAnimDecalAttached");

	Params::CharaBaseLight_C_BI_SpawnMaterialAnimDecalAttached Parms{};

	Parms.DecalMaterial = DecalMaterial;
	Parms.MaterialAnimSettings = std::move(MaterialAnimSettings);
	Parms.DecalSize = std::move(DecalSize);
	Parms.OffsetLocation = std::move(OffsetLocation);
	Parms.AttachPointName = AttachPointName;
	Parms.OverrideLifeSec = OverrideLifeSec;
	Parms.LocationType = LocationType;
	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);

	if (Comp != nullptr)
		*Comp = Parms.Comp;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_InvalidIKEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_InvalidIKEnd(class FName Param_Name, int32 Param_Index, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_InvalidIKEnd");

	Params::CharaBaseLight_C_BI_InvalidIKEnd Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetNotifyApplyHit
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsNotified                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// E_ANIM_NOTIFY_APPLY_HIT_TYPE            NotifyType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetNotifyApplyHit(bool IsNotified, E_ANIM_NOTIFY_APPLY_HIT_TYPE NotifyType, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetNotifyApplyHit");

	Params::CharaBaseLight_C_BI_SetNotifyApplyHit Parms{};

	Parms.IsNotified = IsNotified;
	Parms.NotifyType = NotifyType;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_ResetState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_ResetState(int32 State, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_ResetState");

	Params::CharaBaseLight_C_BI_ResetState Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_CreateBadStatusPSComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystemComponent*         PSComp                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_CreateBadStatusPSComp(class UParticleSystemComponent** PSComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_CreateBadStatusPSComp");

	Params::CharaBaseLight_C_BI_CreateBadStatusPSComp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PSComp != nullptr)
		*PSComp = Parms.PSComp;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetActionState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_ACTION_TYPE                     InAction                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetActionState(const E_CHARA_ACTION_TYPE InAction, uint8 State, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetActionState");

	Params::CharaBaseLight_C_BI_SetActionState Parms{};

	Parms.InAction = InAction;
	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_EvtResetBadStatusMaterial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_EvtResetBadStatusMaterial(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_EvtResetBadStatusMaterial");

	Params::CharaBaseLight_C_BI_EvtResetBadStatusMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_EvtResetEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_EvtResetEffect(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_EvtResetEffect");

	Params::CharaBaseLight_C_BI_EvtResetEffect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_BadStatusMaterialOff
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<E_BAD_STATUS>                    OffBadStatus                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_BadStatusMaterialOff(const TArray<E_BAD_STATUS>& OffBadStatus, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_BadStatusMaterialOff");

	Params::CharaBaseLight_C_BI_BadStatusMaterialOff Parms{};

	Parms.OffBadStatus = std::move(OffBadStatus);

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_BadStatusMaterialOn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<E_BAD_STATUS>                    OnBadStatus                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_BadStatusMaterialOn(TArray<E_BAD_STATUS>& OnBadStatus, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_BadStatusMaterialOn");

	Params::CharaBaseLight_C_BI_BadStatusMaterialOn Parms{};

	Parms.OnBadStatus = std::move(OnBadStatus);

	UObject::ProcessEvent(Func, &Parms);

	OnBadStatus = std::move(Parms.OnBadStatus);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_ResetScalarParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ParamNames                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    NoUs                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_ResetScalarParam(TArray<class FName>& ParamNames, bool* NoUs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_ResetScalarParam");

	Params::CharaBaseLight_C_BI_ResetScalarParam Parms{};

	Parms.ParamNames = std::move(ParamNames);

	UObject::ProcessEvent(Func, &Parms);

	ParamNames = std::move(Parms.ParamNames);

	if (NoUs != nullptr)
		*NoUs = Parms.NoUs;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetActorRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GetActorRotation(struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetActorRotation");

	Params::CharaBaseLight_C_BI_GetActorRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetCapsuleComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCapsuleComponent*                Param                                                  (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetCapsuleComponent(class UCapsuleComponent** Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetCapsuleComponent");

	Params::CharaBaseLight_C_BI_GetCapsuleComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param != nullptr)
		*Param = Parms.Param;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetCharaParamComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCharaParamComponent*             Comp                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetCharaParamComponent(class UCharaParamComponent** Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetCharaParamComponent");

	Params::CharaBaseLight_C_BI_GetCharaParamComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Comp != nullptr)
		*Comp = Parms.Comp;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetEffectScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   EffectScale                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetEffectScale(float* EffectScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetEffectScale");

	Params::CharaBaseLight_C_BI_GetEffectScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EffectScale != nullptr)
		*EffectScale = Parms.EffectScale;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetPlayRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   PlayRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetPlayRate(float* PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetPlayRate");

	Params::CharaBaseLight_C_BI_GetPlayRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayRate != nullptr)
		*PlayRate = Parms.PlayRate;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetMeshComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   MeshComp                                               (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetMeshComponent(class UMeshComponent** MeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetMeshComponent");

	Params::CharaBaseLight_C_BI_GetMeshComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MeshComp != nullptr)
		*MeshComp = Parms.MeshComp;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_PlayDefaultBlink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_PlayDefaultBlink(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_PlayDefaultBlink");

	Params::CharaBaseLight_C_BI_PlayDefaultBlink Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_StopDefaultBlink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_StopDefaultBlink(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_StopDefaultBlink");

	Params::CharaBaseLight_C_BI_StopDefaultBlink Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_StackPlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Animation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Loop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_StackPlayMotion(class UAnimSequenceBase* Animation, bool Loop, float BlendTime, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_StackPlayMotion");

	Params::CharaBaseLight_C_BI_StackPlayMotion Parms{};

	Parms.Animation = Animation;
	Parms.Loop = Loop;
	Parms.BlendTime = BlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_ResetAllParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_ResetAllParam(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_ResetAllParam");

	Params::CharaBaseLight_C_BI_ResetAllParam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_StopMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_StopMotion(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_StopMotion");

	Params::CharaBaseLight_C_BI_StopMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetMotionComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCharaMotionPlayerComponent*      MotionComponent                                        (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetMotionComponent(class UCharaMotionPlayerComponent** MotionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetMotionComponent");

	Params::CharaBaseLight_C_BI_GetMotionComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MotionComponent != nullptr)
		*MotionComponent = Parms.MotionComponent;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetEnableChangeMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnable                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GetEnableChangeMotion(bool* IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetEnableChangeMotion");

	Params::CharaBaseLight_C_BI_GetEnableChangeMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsEnable != nullptr)
		*IsEnable = Parms.IsEnable;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetEnableChangeMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetEnableChangeMotion(bool Enable, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetEnableChangeMotion");

	Params::CharaBaseLight_C_BI_SetEnableChangeMotion Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetSkillPerformDuration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsTrue                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetSkillPerformDuration(bool IsTrue, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetSkillPerformDuration");

	Params::CharaBaseLight_C_BI_SetSkillPerformDuration Parms{};

	Parms.IsTrue = IsTrue;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetSkillPerformDuration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsTrue                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GetSkillPerformDuration(bool* IsTrue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetSkillPerformDuration");

	Params::CharaBaseLight_C_BI_GetSkillPerformDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsTrue != nullptr)
		*IsTrue = Parms.IsTrue;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetPlayBlink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsPlay                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GetPlayBlink(bool* IsPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetPlayBlink");

	Params::CharaBaseLight_C_BI_GetPlayBlink Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlay != nullptr)
		*IsPlay = Parms.IsPlay;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_PlayBlinkToNotify
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_PlayBlinkToNotify(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_PlayBlinkToNotify");

	Params::CharaBaseLight_C_BI_PlayBlinkToNotify Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_StopBlinkToNotify
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_StopBlinkToNotify(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_StopBlinkToNotify");

	Params::CharaBaseLight_C_BI_StopBlinkToNotify Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetVoiceSkillType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SKILL_TYPE                            Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetVoiceSkillType(E_SKILL_TYPE Type, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetVoiceSkillType");

	Params::CharaBaseLight_C_BI_SetVoiceSkillType Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetVoiceSkillType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SKILL_TYPE                            Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetVoiceSkillType(E_SKILL_TYPE* Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetVoiceSkillType");

	Params::CharaBaseLight_C_BI_GetVoiceSkillType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Type != nullptr)
		*Type = Parms.Type;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetElectrification
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetElectrification(bool Enable, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetElectrification");

	Params::CharaBaseLight_C_BI_SetElectrification Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetDitherEnable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetDitherEnable(bool Enable, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetDitherEnable");

	Params::CharaBaseLight_C_BI_SetDitherEnable Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetDitherRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InRate                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InInterpSec                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetDitherRate(float InRate, float InInterpSec, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetDitherRate");

	Params::CharaBaseLight_C_BI_SetDitherRate Parms{};

	Parms.InRate = InRate;
	Parms.InInterpSec = InInterpSec;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_ResetDitherRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InInterpSec                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    No_Use                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_ResetDitherRate(float InInterpSec, bool* No_Use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_ResetDitherRate");

	Params::CharaBaseLight_C_BI_ResetDitherRate Parms{};

	Parms.InInterpSec = InInterpSec;

	UObject::ProcessEvent(Func, &Parms);

	if (No_Use != nullptr)
		*No_Use = Parms.No_Use;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetVoiceSkillAttr
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ATTRIBUTE_TYPE                        SkillAttr                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetVoiceSkillAttr(E_ATTRIBUTE_TYPE SkillAttr, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetVoiceSkillAttr");

	Params::CharaBaseLight_C_BI_SetVoiceSkillAttr Parms{};

	Parms.SkillAttr = SkillAttr;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetVoiceSkillAttr
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ATTRIBUTE_TYPE                        SkillAttr                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetVoiceSkillAttr(E_ATTRIBUTE_TYPE* SkillAttr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetVoiceSkillAttr");

	Params::CharaBaseLight_C_BI_GetVoiceSkillAttr Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkillAttr != nullptr)
		*SkillAttr = Parms.SkillAttr;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_IsPlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPlay                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_IsPlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool* IsPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_IsPlayMotion");

	Params::CharaBaseLight_C_BI_IsPlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlay != nullptr)
		*IsPlay = Parms.IsPlay;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetFacial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Facial                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlendTimeOverride                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NotUse                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetFacial(class FName Facial, float BlendTimeOverride, bool* NotUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetFacial");

	Params::CharaBaseLight_C_BI_SetFacial Parms{};

	Parms.Facial = Facial;
	Parms.BlendTimeOverride = BlendTimeOverride;

	UObject::ProcessEvent(Func, &Parms);

	if (NotUse != nullptr)
		*NotUse = Parms.NotUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetDefaultAnimation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetDefaultAnimation(class UAnimSequenceBase** Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetDefaultAnimation");

	Params::CharaBaseLight_C_BI_GetDefaultAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetAnimInstance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimInstance*                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetAnimInstance(class UAnimInstance** Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetAnimInstance");

	Params::CharaBaseLight_C_BI_GetAnimInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_InvokeLookAtIKImmediately
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IncludeEyeIK                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_InvokeLookAtIKImmediately(bool IncludeEyeIK, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_InvokeLookAtIKImmediately");

	Params::CharaBaseLight_C_BI_InvokeLookAtIKImmediately Parms{};

	Parms.IncludeEyeIK = IncludeEyeIK;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_IKEnableFlag
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_IK_TYPE_LIST                          Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Immediately                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_IKEnableFlag(E_IK_TYPE_LIST Type, bool Enable, bool Immediately, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_IKEnableFlag");

	Params::CharaBaseLight_C_BI_IKEnableFlag Parms{};

	Parms.Type = Type;
	Parms.Enable = Enable;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_CalcEffectScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_CalcEffectScale(float* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_CalcEffectScale");

	Params::CharaBaseLight_C_BI_CalcEffectScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = Parms.Scale;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetVoiceSkillTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SKILL_TARGET                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetVoiceSkillTarget(E_SKILL_TARGET Target, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetVoiceSkillTarget");

	Params::CharaBaseLight_C_BI_SetVoiceSkillTarget Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetVoiceSkillTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SKILL_TARGET                          Target                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetVoiceSkillTarget(E_SKILL_TARGET* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetVoiceSkillTarget");

	Params::CharaBaseLight_C_BI_GetVoiceSkillTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Target != nullptr)
		*Target = Parms.Target;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetDefaultIdleMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_Motion                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetDefaultIdleMotion(E_CHARA_MOTION_ID* Param_Motion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetDefaultIdleMotion");

	Params::CharaBaseLight_C_BI_GetDefaultIdleMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Motion != nullptr)
		*Param_Motion = Parms.Param_Motion;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetDefaultIdleMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_Motion                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetDefaultIdleMotion(E_CHARA_MOTION_ID Param_Motion, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetDefaultIdleMotion");

	Params::CharaBaseLight_C_BI_SetDefaultIdleMotion Parms{};

	Parms.Param_Motion = Param_Motion;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetEnableCollision
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetEnableCollision(bool Enable, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetEnableCollision");

	Params::CharaBaseLight_C_BI_SetEnableCollision Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetCollisionObjectType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECollisionChannel                       Channel                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetCollisionObjectType(ECollisionChannel Channel, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetCollisionObjectType");

	Params::CharaBaseLight_C_BI_SetCollisionObjectType Parms{};

	Parms.Channel = Channel;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_IsCharaShaking
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Shaking                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_IsCharaShaking(bool* Shaking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_IsCharaShaking");

	Params::CharaBaseLight_C_BI_IsCharaShaking Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Shaking != nullptr)
		*Shaking = Parms.Shaking;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_StopCharaShake
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_StopCharaShake(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_StopCharaShake");

	Params::CharaBaseLight_C_BI_StopCharaShake Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetForceRotate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GetForceRotate(bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetForceRotate");

	Params::CharaBaseLight_C_BI_GetForceRotate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_BattlePlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CHARA_MOTION_ID                       Param_MotionID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseDuration                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsUseBlendTimeOverride                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlendTimeOverride                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_BattlePlayMotion(E_CHARA_MOTION_ID Param_MotionID, bool IsUseDuration, float Duration, bool IsUseBlendTimeOverride, float BlendTimeOverride, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_BattlePlayMotion");

	Params::CharaBaseLight_C_BI_BattlePlayMotion Parms{};

	Parms.Param_MotionID = Param_MotionID;
	Parms.IsUseDuration = IsUseDuration;
	Parms.Duration = Duration;
	Parms.IsUseBlendTimeOverride = IsUseBlendTimeOverride;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_BattleStopMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_BattleStopMotion(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_BattleStopMotion");

	Params::CharaBaseLight_C_BI_BattleStopMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_EnableSilhouette
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnable                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_EnableSilhouette(bool IsEnable, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_EnableSilhouette");

	Params::CharaBaseLight_C_BI_EnableSilhouette Parms{};

	Parms.IsEnable = IsEnable;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_IsSilhouetteEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnabled                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_IsSilhouetteEnabled(bool* IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_IsSilhouetteEnabled");

	Params::CharaBaseLight_C_BI_IsSilhouetteEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsEnabled != nullptr)
		*IsEnabled = Parms.IsEnabled;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_FloatNoRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoRotation                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_FloatNoRotation(bool NoRotation, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_FloatNoRotation");

	Params::CharaBaseLight_C_BI_FloatNoRotation Parms{};

	Parms.NoRotation = NoRotation;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetParentChara
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TScriptInterface<class IBPI_CharaBaseAccessor_C>Parent                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsExist                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_GetParentChara(TScriptInterface<class IBPI_CharaBaseAccessor_C>* Parent, bool* IsExist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetParentChara");

	Params::CharaBaseLight_C_BI_GetParentChara Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Parent != nullptr)
		*Parent = Parms.Parent;

	if (IsExist != nullptr)
		*IsExist = Parms.IsExist;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_AddIgnoreAtomComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAtomComponent*                   IgnoreComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_AddIgnoreAtomComp(class UAtomComponent*& IgnoreComp, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_AddIgnoreAtomComp");

	Params::CharaBaseLight_C_BI_AddIgnoreAtomComp Parms{};

	Parms.IgnoreComp = IgnoreComp;

	UObject::ProcessEvent(Func, &Parms);

	IgnoreComp = Parms.IgnoreComp;

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_CheckIgnoreAtomComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAtomComponent*                   IgnoreComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsIgnoreID                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_CheckIgnoreAtomComp(class UAtomComponent*& IgnoreComp, bool* IsIgnoreID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_CheckIgnoreAtomComp");

	Params::CharaBaseLight_C_BI_CheckIgnoreAtomComp Parms{};

	Parms.IgnoreComp = IgnoreComp;

	UObject::ProcessEvent(Func, &Parms);

	IgnoreComp = Parms.IgnoreComp;

	if (IsIgnoreID != nullptr)
		*IsIgnoreID = Parms.IsIgnoreID;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_CreateSkeletalMeshComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkelMeshComp                                           (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_CreateSkeletalMeshComp(class USkeletalMeshComponent** SkelMeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_CreateSkeletalMeshComp");

	Params::CharaBaseLight_C_BI_CreateSkeletalMeshComp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkelMeshComp != nullptr)
		*SkelMeshComp = Parms.SkelMeshComp;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_DestroySkeletalMeshComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkelMeshComp                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_DestroySkeletalMeshComp(class USkeletalMeshComponent* SkelMeshComp, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_DestroySkeletalMeshComp");

	Params::CharaBaseLight_C_BI_DestroySkeletalMeshComp Parms{};

	Parms.SkelMeshComp = SkelMeshComp;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_RemoveAllMaterialAnimDecalAttached
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_RemoveAllMaterialAnimDecalAttached(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_RemoveAllMaterialAnimDecalAttached");

	Params::CharaBaseLight_C_BI_RemoveAllMaterialAnimDecalAttached Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_CreateSkeletalMeshActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASkeletalMeshActor*               SkelMeshActor                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_CreateSkeletalMeshActor(class ASkeletalMeshActor** SkelMeshActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_CreateSkeletalMeshActor");

	Params::CharaBaseLight_C_BI_CreateSkeletalMeshActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkelMeshActor != nullptr)
		*SkelMeshActor = Parms.SkelMeshActor;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetAnimBP
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetAnimBP(class UAnimInstance* AnimInstance, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetAnimBP");

	Params::CharaBaseLight_C_BI_SetAnimBP Parms{};

	Parms.AnimInstance = AnimInstance;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_DestroySkeletalMeshActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASkeletalMeshActor*               SkelActor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_DestroySkeletalMeshActor(class ASkeletalMeshActor* SkelActor, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_DestroySkeletalMeshActor");

	Params::CharaBaseLight_C_BI_DestroySkeletalMeshActor Parms{};

	Parms.SkelActor = SkelActor;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetSkeletalMeshActors
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ASkeletalMeshActor*>       SkelMeshActors                                         (Parm, OutParm)

void ACharaBaseLight_C::BI_GetSkeletalMeshActors(TArray<class ASkeletalMeshActor*>* SkelMeshActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetSkeletalMeshActors");

	Params::CharaBaseLight_C_BI_GetSkeletalMeshActors Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkelMeshActors != nullptr)
		*SkelMeshActors = std::move(Parms.SkelMeshActors);
}


// Function CharaBaseLight.CharaBaseLight_C.BI_DeactivateAttachedParticles
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoDestroyComponent                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_DeactivateAttachedParticles(bool NoDestroyComponent, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_DeactivateAttachedParticles");

	Params::CharaBaseLight_C_BI_DeactivateAttachedParticles Parms{};

	Parms.NoDestroyComponent = NoDestroyComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_ActivateAttachedParticles
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_ActivateAttachedParticles(bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_ActivateAttachedParticles");

	Params::CharaBaseLight_C_BI_ActivateAttachedParticles Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_SetVoiceSkillID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SkillId                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_SetVoiceSkillID(int32 SkillId, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_SetVoiceSkillID");

	Params::CharaBaseLight_C_BI_SetVoiceSkillID Parms{};

	Parms.SkillId = SkillId;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_GetVoiceSkillID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SkillId                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ACharaBaseLight_C::BI_GetVoiceSkillID(int32* SkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_GetVoiceSkillID");

	Params::CharaBaseLight_C_BI_GetVoiceSkillID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkillId != nullptr)
		*SkillId = Parms.SkillId;
}


// Function CharaBaseLight.CharaBaseLight_C.BI_DirectPlayMotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                DefaultAnim                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimSequenceBase*                LoopAnim                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MotionBlendTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartOffsetTime                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoUse                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ACharaBaseLight_C::BI_DirectPlayMotion(class UAnimSequenceBase* DefaultAnim, class UAnimSequenceBase* LoopAnim, float MotionBlendTime, float StartOffsetTime, bool* NoUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "BI_DirectPlayMotion");

	Params::CharaBaseLight_C_BI_DirectPlayMotion Parms{};

	Parms.DefaultAnim = DefaultAnim;
	Parms.LoopAnim = LoopAnim;
	Parms.MotionBlendTime = MotionBlendTime;
	Parms.StartOffsetTime = StartOffsetTime;

	UObject::ProcessEvent(Func, &Parms);

	if (NoUse != nullptr)
		*NoUse = Parms.NoUse;
}


// Function CharaBaseLight.CharaBaseLight_C.IsWatchingOnesStep
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ACharaBaseLight_C::IsWatchingOnesStep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "IsWatchingOnesStep");

	Params::CharaBaseLight_C_IsWatchingOnesStep Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CharaBaseLight.CharaBaseLight_C.IsPerching
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ACharaBaseLight_C::IsPerching() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "IsPerching");

	Params::CharaBaseLight_C_IsPerching Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CharaBaseLight.CharaBaseLight_C.GetGazeTargetType
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EGazeTargetType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

EGazeTargetType ACharaBaseLight_C::GetGazeTargetType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "GetGazeTargetType");

	Params::CharaBaseLight_C_GetGazeTargetType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function CharaBaseLight.CharaBaseLight_C.GetGazeTargetLocation
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ACharaBaseLight_C::GetGazeTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharaBaseLight_C", "GetGazeTargetLocation");

	Params::CharaBaseLight_C_GetGazeTargetLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

