#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Gimic_Chest_Piece

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "E_MapGimmickHideReason_structs.hpp"
#include "Project_structs.hpp"
#include "Engine_structs.hpp"
#include "MapEventHit_Type_SHitSphere_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_Gimic_Chest_Piece.BP_Gimic_Chest_Piece_C
// 0x0140 (0x04D8 - 0x0398)
class ABP_Gimic_Chest_Piece_C final : public AMapEventHit_Type_SHitSphere_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_BP_Gimic_Chest_Piece_C;             // 0x0398(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class USceneComponent*                        LineScene;                                         // 0x03A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        LineRotScene;                                      // 0x03A8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UDecalComponent*                        Decal;                                             // 0x03B0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DecalScene;                                        // 0x03B8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBPC_MapGimmickAreaEntry_C*             BPC_MapGimmickAreaEntry;                           // 0x03C0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	float                                         Timeline_DecalFadeIn_Alpha_EF5D0CE44288822228F2F18F102449EB; // 0x03C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            Timeline_DecalFadeIn__Direction_EF5D0CE44288822228F2F18F102449EB; // 0x03CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_A08D[0x3];                                     // 0x03CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     Timeline_DecalFadeIn;                              // 0x03D0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                _______1___Track_2_AFBFF8C34AA0C6CE0AAE0FA9AD7AC26A; // 0x03D8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         _______1_Alpha_AFBFF8C34AA0C6CE0AAE0FA9AD7AC26A;   // 0x03E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ETimelineDirection                            _______1__Direction_AFBFF8C34AA0C6CE0AAE0FA9AD7AC26A; // 0x03E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_A08E[0x7];                                     // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     _______1;                                          // 0x03F0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         PieceId;                                           // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsGetEnd;                                          // 0x03FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A08F[0x3];                                     // 0x03FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPieceData                             PieceData;                                         // 0x0400(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	bool                                          IsEnd;                                             // 0x040C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsNew;                                             // 0x040D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsGetLock;                                         // 0x040E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A090[0x1];                                     // 0x040F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             EvtDis_End;                                        // 0x0410(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             EvtDis_StartCollect;                               // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          IsSaveData;                                        // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A091[0x3];                                     // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapEventID;                                        // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             EvtDis_EndCollectEffect;                           // 0x0438(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         PrevNum;                                           // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_A092[0x4];                                     // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             EvtDis_EndInfo;                                    // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          IsSpawnPiece;                                      // 0x0460(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	bool                                          HaveLimitOver;                                     // 0x0461(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          MovePiece;                                         // 0x0462(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          Moving;                                            // 0x0463(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsDecalView;                                       // 0x0464(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          InfoOnly;                                          // 0x0465(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	uint8                                         Pad_A093[0x2];                                     // 0x0466(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TakaraSaveID;                                      // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_A094[0x4];                                     // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TakaraActor;                                       // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         TakaraAfterFlag;                                   // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AreaIN;                                            // 0x047C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          WallCheck;                                         // 0x047D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          ReqReborn;                                         // 0x047E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A095[0x1];                                     // 0x047F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DecalDMI;                                          // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FLinearColor                           DecalCollor;                                       // 0x0488(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         HideReason;                                        // 0x0498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         PrevMiitsu;                                        // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        MainPS;                                            // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        LinePS;                                            // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         PrevUpliftingGauge;                                // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          OnceInitParticle;                                  // 0x04B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A096[0x3];                                     // 0x04B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               MainParticleComp;                                  // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystemComponent*               LineParticleComp;                                  // 0x04C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          EndCureHP;                                         // 0x04C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          StopTime;                                          // 0x04C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A097[0x6];                                     // 0x04CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_DG_RoomRotator_C*                   RoomRotator;                                       // 0x04D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void EvtDis_End__DelegateSignature();
	void EvtDis_StartCollect__DelegateSignature();
	void EvtDis_EndCollectEffect__DelegateSignature();
	void EvtDis_EndInfo__DelegateSignature();
	void ExecuteUbergraph_BP_Gimic_Chest_Piece(int32 EntryPoint);
	void BndEvt__BP_Gimic_Chest_Piece_SphereHit_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void ParticleStopCheck();
	void BPI_SetStopTime(bool Param_StopTime);
	void OnRotateFinished(bool IsSkipped);
	void OnRotateStarted();
	void GetGodPointPiece(bool Get, bool Info);
	void GetHpCurePiece();
	void GetMpCurePiece();
	void BPI_HideGimmick(E_MapGimmickHideReason Param_HideReason);
	void BPI_ShowGimmick(E_MapGimmickHideReason Param_HideReason);
	void GetMagatsuhiPiece();
	void DecalFadeIn();
	void DecalFadeOut();
	void SilentMoon();
	void WaitSilentMoon();
	void CallUnPause_();
	void EvtDis_EndNotInfo_Event();
	void EvtDis_EndInfo_Event();
	void EvtDis_Hide_();
	void EvtDis_Show_();
	void EndCollectEffect();
	void StartCollectEffect();
	void OverlapPiece();
	void EventHitAction();
	void OpenNotHaveItemInfo();
	void GetMakkaPiece(bool Get, bool Info);
	void GetItemPiece(bool Get, bool Info);
	void OnLoaded_000CEC1647E4F09283905AA617AF2AAC(TSubclassOf<class UObject> Loaded);
	void Timeline_DecalFadeIn__UpdateFunc();
	void Timeline_DecalFadeIn__FinishedFunc();
	void _______1__UpdateFunc();
	void _______1__FinishedFunc();
	void InitEffect();
	void RebornPiece();
	void EndPiece();
	void CureHp();
	void CureMp();
	void SpawnCureEffect(E_PIECE_TYPE PieceType);
	void GetTargetLocation(struct FVector* Location);
	void GetPlayerHPMPMax(E_PLAYER_TYPE PlayerType, int32* HpMax, int32* MpMax);
	void GetNkmHPMPMax(int32 NkmIndex, int32* HpMax, int32* MpMax);
	void SetPieceData(const struct FPieceData& Param_PieceData);
	void TriggerSilentMoon();
	void CheckHaveLimitOver(const struct FPieceData& Param_PieceData, bool* LimitOver, int32* GetNum);
	void ShowDecal(bool Show, bool Execution);
	void Stop_MovePiece();
	void InitDecal();
	void ShowMainParticle(bool Show);
	void ShowLineParticle(bool Show);
	bool SetRoomRotator(class ADG_RoomRotator* Param_RoomRotator);
	class ADG_RoomRotator* GetRoomRotator();
	void ReceiveBeginPlay();
	void UserConstructionScript();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_Gimic_Chest_Piece_C">();
	}
	static class ABP_Gimic_Chest_Piece_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_Gimic_Chest_Piece_C>();
	}
};
static_assert(alignof(ABP_Gimic_Chest_Piece_C) == 0x000008, "Wrong alignment on ABP_Gimic_Chest_Piece_C");
static_assert(sizeof(ABP_Gimic_Chest_Piece_C) == 0x0004D8, "Wrong size on ABP_Gimic_Chest_Piece_C");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, UberGraphFrame_BP_Gimic_Chest_Piece_C) == 0x000398, "Member 'ABP_Gimic_Chest_Piece_C::UberGraphFrame_BP_Gimic_Chest_Piece_C' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, LineScene) == 0x0003A0, "Member 'ABP_Gimic_Chest_Piece_C::LineScene' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, LineRotScene) == 0x0003A8, "Member 'ABP_Gimic_Chest_Piece_C::LineRotScene' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, Decal) == 0x0003B0, "Member 'ABP_Gimic_Chest_Piece_C::Decal' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, DecalScene) == 0x0003B8, "Member 'ABP_Gimic_Chest_Piece_C::DecalScene' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, BPC_MapGimmickAreaEntry) == 0x0003C0, "Member 'ABP_Gimic_Chest_Piece_C::BPC_MapGimmickAreaEntry' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, Timeline_DecalFadeIn_Alpha_EF5D0CE44288822228F2F18F102449EB) == 0x0003C8, "Member 'ABP_Gimic_Chest_Piece_C::Timeline_DecalFadeIn_Alpha_EF5D0CE44288822228F2F18F102449EB' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, Timeline_DecalFadeIn__Direction_EF5D0CE44288822228F2F18F102449EB) == 0x0003CC, "Member 'ABP_Gimic_Chest_Piece_C::Timeline_DecalFadeIn__Direction_EF5D0CE44288822228F2F18F102449EB' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, Timeline_DecalFadeIn) == 0x0003D0, "Member 'ABP_Gimic_Chest_Piece_C::Timeline_DecalFadeIn' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, _______1___Track_2_AFBFF8C34AA0C6CE0AAE0FA9AD7AC26A) == 0x0003D8, "Member 'ABP_Gimic_Chest_Piece_C::_______1___Track_2_AFBFF8C34AA0C6CE0AAE0FA9AD7AC26A' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, _______1_Alpha_AFBFF8C34AA0C6CE0AAE0FA9AD7AC26A) == 0x0003E4, "Member 'ABP_Gimic_Chest_Piece_C::_______1_Alpha_AFBFF8C34AA0C6CE0AAE0FA9AD7AC26A' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, _______1__Direction_AFBFF8C34AA0C6CE0AAE0FA9AD7AC26A) == 0x0003E8, "Member 'ABP_Gimic_Chest_Piece_C::_______1__Direction_AFBFF8C34AA0C6CE0AAE0FA9AD7AC26A' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, _______1) == 0x0003F0, "Member 'ABP_Gimic_Chest_Piece_C::_______1' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, PieceId) == 0x0003F8, "Member 'ABP_Gimic_Chest_Piece_C::PieceId' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, IsGetEnd) == 0x0003FC, "Member 'ABP_Gimic_Chest_Piece_C::IsGetEnd' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, PieceData) == 0x000400, "Member 'ABP_Gimic_Chest_Piece_C::PieceData' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, IsEnd) == 0x00040C, "Member 'ABP_Gimic_Chest_Piece_C::IsEnd' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, IsNew) == 0x00040D, "Member 'ABP_Gimic_Chest_Piece_C::IsNew' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, IsGetLock) == 0x00040E, "Member 'ABP_Gimic_Chest_Piece_C::IsGetLock' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, EvtDis_End) == 0x000410, "Member 'ABP_Gimic_Chest_Piece_C::EvtDis_End' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, EvtDis_StartCollect) == 0x000420, "Member 'ABP_Gimic_Chest_Piece_C::EvtDis_StartCollect' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, IsSaveData) == 0x000430, "Member 'ABP_Gimic_Chest_Piece_C::IsSaveData' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, MapEventID) == 0x000434, "Member 'ABP_Gimic_Chest_Piece_C::MapEventID' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, EvtDis_EndCollectEffect) == 0x000438, "Member 'ABP_Gimic_Chest_Piece_C::EvtDis_EndCollectEffect' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, PrevNum) == 0x000448, "Member 'ABP_Gimic_Chest_Piece_C::PrevNum' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, EvtDis_EndInfo) == 0x000450, "Member 'ABP_Gimic_Chest_Piece_C::EvtDis_EndInfo' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, IsSpawnPiece) == 0x000460, "Member 'ABP_Gimic_Chest_Piece_C::IsSpawnPiece' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, HaveLimitOver) == 0x000461, "Member 'ABP_Gimic_Chest_Piece_C::HaveLimitOver' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, MovePiece) == 0x000462, "Member 'ABP_Gimic_Chest_Piece_C::MovePiece' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, Moving) == 0x000463, "Member 'ABP_Gimic_Chest_Piece_C::Moving' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, IsDecalView) == 0x000464, "Member 'ABP_Gimic_Chest_Piece_C::IsDecalView' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, InfoOnly) == 0x000465, "Member 'ABP_Gimic_Chest_Piece_C::InfoOnly' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, TakaraSaveID) == 0x000468, "Member 'ABP_Gimic_Chest_Piece_C::TakaraSaveID' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, TakaraActor) == 0x000470, "Member 'ABP_Gimic_Chest_Piece_C::TakaraActor' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, TakaraAfterFlag) == 0x000478, "Member 'ABP_Gimic_Chest_Piece_C::TakaraAfterFlag' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, AreaIN) == 0x00047C, "Member 'ABP_Gimic_Chest_Piece_C::AreaIN' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, WallCheck) == 0x00047D, "Member 'ABP_Gimic_Chest_Piece_C::WallCheck' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, ReqReborn) == 0x00047E, "Member 'ABP_Gimic_Chest_Piece_C::ReqReborn' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, DecalDMI) == 0x000480, "Member 'ABP_Gimic_Chest_Piece_C::DecalDMI' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, DecalCollor) == 0x000488, "Member 'ABP_Gimic_Chest_Piece_C::DecalCollor' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, HideReason) == 0x000498, "Member 'ABP_Gimic_Chest_Piece_C::HideReason' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, PrevMiitsu) == 0x00049C, "Member 'ABP_Gimic_Chest_Piece_C::PrevMiitsu' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, MainPS) == 0x0004A0, "Member 'ABP_Gimic_Chest_Piece_C::MainPS' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, LinePS) == 0x0004A8, "Member 'ABP_Gimic_Chest_Piece_C::LinePS' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, PrevUpliftingGauge) == 0x0004B0, "Member 'ABP_Gimic_Chest_Piece_C::PrevUpliftingGauge' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, OnceInitParticle) == 0x0004B4, "Member 'ABP_Gimic_Chest_Piece_C::OnceInitParticle' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, MainParticleComp) == 0x0004B8, "Member 'ABP_Gimic_Chest_Piece_C::MainParticleComp' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, LineParticleComp) == 0x0004C0, "Member 'ABP_Gimic_Chest_Piece_C::LineParticleComp' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, EndCureHP) == 0x0004C8, "Member 'ABP_Gimic_Chest_Piece_C::EndCureHP' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, StopTime) == 0x0004C9, "Member 'ABP_Gimic_Chest_Piece_C::StopTime' has a wrong offset!");
static_assert(offsetof(ABP_Gimic_Chest_Piece_C, RoomRotator) == 0x0004D0, "Member 'ABP_Gimic_Chest_Piece_C::RoomRotator' has a wrong offset!");

}

