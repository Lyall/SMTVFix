#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Project

#include "Basic.hpp"

#include "InputCore_structs.hpp"
#include "Engine_structs.hpp"
#include "MovieScene_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "MovieSceneTracks_structs.hpp"
#include "KawaiiPhysics_structs.hpp"
#include "Slate_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Enum Project.E_CHARA_MOTION_ID
// NumValues: 0x0064
enum class E_CHARA_MOTION_ID : uint8
{
	NONE                                     = 0,
	IDLE01                                   = 1,
	IDLE02                                   = 2,
	DAMAGE                                   = 3,
	DYING                                    = 4,
	DYING_END                                = 5,
	ATTACK                                   = 6,
	SKILL_INITIAL                            = 7,
	SKILL_INITIAL2                           = 8,
	SKILL_INITIAL3                           = 9,
	SKILL_INITIAL4                           = 10,
	SKILL_INITIAL5                           = 11,
	SKILL_INITIAL6                           = 12,
	SKILL_INITIAL7                           = 13,
	SKILL_INITIAL8                           = 14,
	SKILL_INITIAL9                           = 15,
	SKILL_INITIAL10                          = 16,
	RUN                                      = 17,
	TALK                                     = 18,
	TALK_YES                                 = 19,
	TALK_NO                                  = 20,
	TALK_YOROSHIKU                           = 21,
	HEAVY_DAMAGE                             = 22,
	COMMAND                                  = 23,
	EX_MOTION_0                              = 24,
	EX_MOTION_1                              = 25,
	EX_MOTION_2                              = 26,
	EX_MOTION_3                              = 27,
	EX_MOTION_4                              = 28,
	EX_MOTION_5                              = 29,
	EX_MOTION_6                              = 30,
	EX_MOTION_7                              = 31,
	EX_MOTION_8                              = 32,
	EX_MOTION_9                              = 33,
	PLA_BACKSTEP                             = 34,
	PLA_VICTORY_0                            = 35,
	PLA_VICTORY_1                            = 36,
	PLA_GUARD_BEGIN                          = 37,
	PLA_GUARD_END                            = 38,
	PLA_DODGE_BEGIN                          = 39,
	PLA_DODGE_END                            = 40,
	PLA_EX_SKILL_0                           = 41,
	PLA_EX_SKILL_1                           = 42,
	PLA_EX_SKILL_2                           = 43,
	PLA_EX_SKILL_3                           = 44,
	PLA_EX_SKILL_4                           = 45,
	PLA_EX_SKILL_5                           = 46,
	PLA_EX_SKILL_6                           = 47,
	PLA_EX_SKILL_7                           = 48,
	PLA_EX_SKILL_8                           = 49,
	PLA_EX_SKILL_9                           = 50,
	PLA_EX_SKILL_10                          = 51,
	PLA_EX_SKILL_11                          = 52,
	PLA_EX_SKILL_12                          = 53,
	PLA_EX_SKILL_13                          = 54,
	PLA_EX_SKILL_14                          = 55,
	PLA_EX_SKILL_15                          = 56,
	PLA_EX_SKILL_16                          = 57,
	PLA_EX_SKILL_17                          = 58,
	PLA_EX_SKILL_18                          = 59,
	PLA_EX_SKILL_19                          = 60,
	PLA_USE_ATTACK_ITEM                      = 61,
	PLA_USE_SUPPORT_ITEM                     = 62,
	PLA_USE_RANGED_ATTACK_SKILL              = 63,
	PLA_USE_CLOSE_SWORD_SKILL                = 64,
	PLA_USE_CLOSE_FIST_SKILL                 = 65,
	PLA_USE_SUPPORT_SKILL                    = 66,
	PLA_DEAD                                 = 67,
	SKILL_MAGATSUHI_NEKORYU                  = 68,
	SKILL_MAGATSUHI_BAKUEN                   = 69,
	SKILL_MAGATSUHI_FROST                    = 70,
	SKILL_MAGATSUHI_SHINRAI                  = 71,
	SKILL_MAGATSUHI_KYOSEN                   = 72,
	SKILL_MAGATSUHI_TEMBATSU                 = 73,
	SKILL_MAGATSUHI_NOROI                    = 74,
	SKILL_MAGATSUHI_HARVEST                  = 75,
	SKILL_MAGATSUHI_KYUSHO                   = 76,
	SKILL_MAGATSUHI_YONKI                    = 77,
	SKILL_MAGATSUHI_SHITEN                   = 78,
	SKILL_MAGATSUHI_YOSEI                    = 79,
	SKILL_MAGATSUHI_JUNAN                    = 80,
	SKILL_MAGATSUHI_TENSHI                   = 81,
	SKILL_MAGATSUHI_JUNZAI                   = 82,
	SKILL_MAGATSUHI_DANA                     = 83,
	SKILL_MAGATSUHI_RYORAN                   = 84,
	SKILL_MAGATSUHI_QADISTU                  = 85,
	SKILL_MAGATSUHI_COLLUPSE                 = 86,
	SKILL_MAGATSUHI_CHAOS                    = 87,
	GARDEN_WAIT_1                            = 88,
	GARDEN_WAIT_2                            = 89,
	GARDEN_WAIT_3                            = 90,
	GARDEN_WAIT_4                            = 91,
	GARDEN_WAIT_5                            = 92,
	GARDEN_SIT_1                             = 93,
	GARDEN_SIT_2                             = 94,
	GARDEN_SIT_3                             = 95,
	GARDEN_SIT_4                             = 96,
	GARDEN_SIT_5                             = 97,
	LEVEL_UP                                 = 98,
	E_CHARA_MOTION_MAX                       = 99,
};

// Enum Project.EBgmScene
// NumValues: 0x0017
enum class EBgmScene : uint8
{
	Map                                      = 0,
	Battle                                   = 1,
	Event                                    = 2,
	EventSimple                              = 3,
	EventTalk                                = 4,
	EventMission                             = 5,
	CampMenu                                 = 6,
	CampMenuUnite                            = 7,
	AutoMap                                  = 8,
	Title                                    = 9,
	SoundTest                                = 10,
	Annin                                    = 11,
	Ryuketsu                                 = 12,
	ShopGustave                              = 13,
	MapMagatsuka                             = 14,
	Loading                                  = 15,
	DevilTalk                                = 16,
	Result                                   = 17,
	PillarTeleport                           = 18,
	CampMenuUnite_Silence                    = 19,
	Garden                                   = 20,
	BootMenu                                 = 21,
	EBgmScene_MAX                            = 22,
};

// Enum Project.EAchievementFlag
// NumValues: 0x0031
enum class EAchievementFlag : uint8
{
	ACH_FLAG_001                             = 0,
	ACH_FLAG_002                             = 1,
	ACH_FLAG_003                             = 2,
	ACH_FLAG_004                             = 3,
	ACH_FLAG_005                             = 4,
	ACH_FLAG_006                             = 5,
	ACH_FLAG_007                             = 6,
	ACH_FLAG_008                             = 7,
	ACH_FLAG_009                             = 8,
	ACH_FLAG_010                             = 9,
	ACH_FLAG_011                             = 10,
	ACH_FLAG_012                             = 11,
	ACH_FLAG_013                             = 12,
	ACH_FLAG_014                             = 13,
	ACH_FLAG_015                             = 14,
	ACH_FLAG_016                             = 15,
	ACH_FLAG_017                             = 16,
	ACH_FLAG_018                             = 17,
	ACH_FLAG_019                             = 18,
	ACH_FLAG_020                             = 19,
	ACH_FLAG_021                             = 20,
	ACH_FLAG_022                             = 21,
	ACH_FLAG_023                             = 22,
	ACH_FLAG_024                             = 23,
	ACH_FLAG_025                             = 24,
	ACH_FLAG_026                             = 25,
	ACH_FLAG_027                             = 26,
	ACH_FLAG_028                             = 27,
	ACH_FLAG_029                             = 28,
	ACH_FLAG_030                             = 29,
	ACH_FLAG_031                             = 30,
	ACH_FLAG_032                             = 31,
	ACH_FLAG_033                             = 32,
	ACH_FLAG_034                             = 33,
	ACH_FLAG_035                             = 34,
	ACH_FLAG_036                             = 35,
	ACH_FLAG_037                             = 36,
	ACH_FLAG_038                             = 37,
	ACH_FLAG_039                             = 38,
	ACH_FLAG_040                             = 39,
	ACH_FLAG_041                             = 40,
	ACH_FLAG_042                             = 41,
	ACH_FLAG_043                             = 42,
	ACH_FLAG_044                             = 43,
	ACH_FLAG_045                             = 44,
	ACH_FLAG_046                             = 45,
	ACH_FLAG_047                             = 46,
	ACH_FLAG_MAX                             = 47,
	ACH_FLAG_000                             = 48,
};

// Enum Project.EActivityTaskID
// NumValues: 0x0022
enum class EActivityTaskID : uint8
{
	Activity                                 = 0,
	Task_01                                  = 1,
	Task_02                                  = 2,
	Task_03                                  = 3,
	Task_04                                  = 4,
	Task_05                                  = 5,
	Task_06                                  = 6,
	Task_07                                  = 7,
	Task_08                                  = 8,
	Task_09                                  = 9,
	Task_10                                  = 10,
	Task_11                                  = 11,
	Task_12                                  = 12,
	Task_13                                  = 13,
	Task_14                                  = 14,
	Task_15                                  = 15,
	Task_16                                  = 16,
	Task_17                                  = 17,
	Task_18                                  = 18,
	Task_19                                  = 19,
	Task_20                                  = 20,
	Task_21                                  = 21,
	Task_22                                  = 22,
	Task_23                                  = 23,
	Task_24                                  = 24,
	Task_25                                  = 25,
	Task_26                                  = 26,
	Task_27                                  = 27,
	Task_28                                  = 28,
	Task_29                                  = 29,
	Task_30                                  = 30,
	Task_31                                  = 31,
	Task_MAX                                 = 32,
	EActivityTaskID_MAX                      = 33,
};

// Enum Project.EActivityType
// NumValues: 0x0004
enum class EActivityType : uint8
{
	Act_None                                 = 0,
	Act_OldRoute                             = 1,
	Act_NewRoute                             = 2,
	Act_MAX                                  = 3,
};

// Enum Project.ECameraAnimationSpace
// NumValues: 0x0003
enum class ECameraAnimationSpace : uint8
{
	ComponentSpace                           = 0,
	WorldSpace                               = 1,
	ECameraAnimationSpace_MAX                = 2,
};

// Enum Project.E_ANIM_NOTIFY_APPLY_HIT_TYPE
// NumValues: 0x0009
enum class E_ANIM_NOTIFY_APPLY_HIT_TYPE : uint8
{
	E_APPLY_HIT_DEFAULT                      = 0,
	E_APPLY_HIT_WITHOUT_NUMERIC              = 1,
	E_APPLY_HIT_EFFECT_ONLY                  = 2,
	E_APPLY_HIT_NUMERIC_ONLY                 = 3,
	E_APPLY_HIT_MOTION_ONLY                  = 4,
	E_APPLY_HIT_AVOID_TIMING                 = 5,
	E_APPLY_HIT_WITHOUT_NUMERIC_AND_SHAKE    = 6,
	E_APPLY_HIT_DUMMY                        = 7,
	E_APPLY_HIT_MAX                          = 8,
};

// Enum Project.E_AI_HOJO_CHECK_TYPE
// NumValues: 0x0008
enum class E_AI_HOJO_CHECK_TYPE : uint8
{
	Invalid                                  = 0,
	Up                                       = 1,
	Down                                     = 2,
	Block                                    = 3,
	EraseKja                                 = 4,
	EraseNda                                 = 5,
	MagicDonum                               = 6,
	E_AI_HOJO_CHECK_MAX                      = 7,
};

// Enum Project.E_BTL_TARGET_TYPE
// NumValues: 0x0004
enum class E_BTL_TARGET_TYPE : uint8
{
	E_BTL_TARGET_ONE                         = 0,
	E_BTL_TARGET_GROUP                       = 1,
	E_BTL_TARGET_ALL                         = 2,
	E_BTL_TARGET_MAX                         = 3,
};

// Enum Project.E_AttibuteType_Kind
// NumValues: 0x0005
enum class E_AttibuteType_Kind : uint8
{
	E_AttibuteType_Kind_None                 = 0,
	E_AttibuteType_Kind_Phisics              = 1,
	E_AttibuteType_Kind_Magics               = 2,
	E_AttibuteType_Kind_All                  = 3,
	E_AttibuteType_Kind_MAX                  = 4,
};

// Enum Project.E_BATTLECHARAPANELFLAG
// NumValues: 0x000A
enum class E_BATTLECHARAPANELFLAG : uint8
{
	CPLAYER                                  = 0,
	CPLAYERDEVIL                             = 1,
	CPLAYERDEVIIL_EVENT                      = 2,
	CFREE                                    = 3,
	CEMPTY                                   = 4,
	CBATTLEIN                                = 5,
	CSTOCK                                   = 6,
	CSUMMONED                                = 7,
	CENEMY                                   = 8,
	E_MAX                                    = 9,
};

// Enum Project.E_BATTLECHARAPANELCTRL_GSTATUS
// NumValues: 0x0019
enum class E_BATTLECHARAPANELCTRL_GSTATUS : uint8
{
	E_BATTLECHARAPANELCTRL_INIT              = 0,
	E_BATTLECHARAPANELCTRL_MOVESRC           = 1,
	E_BATTLECHARAPANELCTRL_MOVEDST           = 2,
	E_BATTLECHARAPANELCTRL_MOVEPROC          = 3,
	E_BATTLECHARAPANELCTRL_MOVEANIMEWAIT     = 4,
	E_BATTLECHARAPANELCTRL_MOVEEND           = 5,
	E_BATTLECHARAPANELCTRL_SETDIALOG_ERROR   = 6,
	E_BATTLECHARAPANELCTRL_WAIT_DIALOG       = 7,
	E_BATTLECHARAPANELCTRL_SELECTDIALOG_ON   = 8,
	E_BATTLECHARAPANELCTRL_WAIT_CLOSEDIALOG  = 9,
	E_BATTLECHARAPANELCTRL_SINIT             = 10,
	E_BATTLECHARAPANELCTRL_SMOVESRC          = 11,
	E_BATTLECHARAPANELCTRL_SSTATUS           = 12,
	E_BATTLECHARAPANELCTRL_SEND              = 13,
	E_BATTLECHARAPANELCTRL_CSINIT            = 14,
	E_BATTLECHARAPANELCTRL_CSMOVESRC         = 15,
	E_BATTLECHARAPANELCTRL_CSSELECT          = 16,
	E_BATTLECHARAPANELCTRL_CSEND             = 17,
	E_BATTLECHARAPANELCTRL_CSSTATUSDETAILINIT = 18,
	E_BATTLECHARAPANELCTRL_CSSTATUSDETAIL    = 19,
	E_BATTLECHARAPANELCTRL_SSTATUSDETAILINIT = 20,
	E_BATTLECHARAPANELCTRL_SSTATUSDETAIL     = 21,
	E_BATTLECHARAPANELCTRL_STATUSDETAILINIT  = 22,
	E_BATTLECHARAPANELCTRL_STATUSDETAIL      = 23,
	E_BATTLECHARAPANELCTRL_MAX               = 24,
};

// Enum Project.E_BATTLECHARAPANELBASE
// NumValues: 0x0008
enum class E_BATTLECHARAPANELBASE : uint8
{
	E_BATTLECHARAPANELBASE_NONE              = 0,
	BATTLELISTMAX                            = 4,
	CENEMYLISTMAX                            = 6,
	STOCKLISTMAX                             = 32,
	BSUMMONLISTMAX                           = 16,
	CLISTMAX                                 = 22,
	CPARTYLISTMAX                            = 44,
	E_MAX                                    = 45,
};

// Enum Project.E_BTL_EVT_TYPE
// NumValues: 0x0004
enum class E_BTL_EVT_TYPE : uint8
{
	E_BTL_EVT_TYPE_NONE                      = 0,
	E_BTL_EVT_TYPE_SEAMLESS                  = 1,
	E_BTL_EVT_TYPE_FADE                      = 2,
	E_BTL_EVT_TYPE_MAX                       = 3,
};

// Enum Project.E_BTL_EVT_COND
// NumValues: 0x000D
enum class E_BTL_EVT_COND : uint8
{
	E_BTL_EVT_COND_NONE                      = 0,
	E_BTL_EVT_COND_FLAG_ON                   = 1,
	E_BTL_EVT_COND_FLAG_OFF                  = 2,
	E_BTL_EVT_COND_HERO_HP_DOWN              = 3,
	E_BTL_EVT_COND_ENEMY_HP_DOWN             = 4,
	E_BTL_EVT_COND_TURN_AFTER                = 5,
	E_BTL_EVT_COND_TURN_BEFORE               = 6,
	E_BTL_EVT_COND_EVENT_INDEX               = 7,
	E_BTL_EVT_COND_WIN_SUCCESS               = 8,
	E_BTL_EVT_COND_WIN_FAILED                = 9,
	E_BTL_EVT_COND_DOWN                      = 10,
	E_BTL_EVT_COND_DEVIL_ID                  = 11,
	E_BTL_EVT_COND_MAX                       = 12,
};

// Enum Project.E_BTL_EVT_RESULT
// NumValues: 0x0004
enum class E_BTL_EVT_RESULT : uint8
{
	E_BTL_EVT_RESULT_NONE                    = 0,
	E_BTL_EVT_RESULT_CONTINUE                = 1,
	E_BTL_EVT_RESULT_GOTO_RESULT             = 2,
	E_BTL_EVT_RESULT_MAX                     = 3,
};

// Enum Project.E_BTL_EVT
// NumValues: 0x0007
enum class E_BTL_EVT : uint8
{
	E_BTL_EVT_NONE                           = 0,
	E_BTL_EVT_TRIG_ON                        = 1,
	E_BTL_EVT_LOADING                        = 2,
	E_BTL_EVT_READY                          = 3,
	E_BTL_EVT_PLAYING                        = 4,
	E_BTL_EVT_FINISHED                       = 5,
	E_BTL_EVT_MAX                            = 6,
};

// Enum Project.E_BTL_EVT_POINT
// NumValues: 0x0009
enum class E_BTL_EVT_POINT : uint8
{
	BATTLE_START                             = 0,
	DAMAGED                                  = 1,
	PLAYER_TURN_START                        = 2,
	ENEMY_TURN_START                         = 3,
	BATTLE_END                               = 4,
	GAMEOVER                                 = 5,
	PLAYER_TURN_END                          = 6,
	ENEMY_TURN_END                           = 7,
	E_BTL_EVT_MAX                            = 8,
};

// Enum Project.E_BTL_TALK
// NumValues: 0x000A
enum class E_BTL_TALK : uint8
{
	E_BTL_TALK_SCOUT                         = 0,
	E_BTL_TALK_SUSPEND                       = 1,
	E_BTL_TALK_GIVE                          = 2,
	E_BTL_TALK_WORSHIP                       = 3,
	E_BTL_TALK_BLACLMAIL                     = 4,
	E_BTL_TALK_BUSINESS                      = 5,
	E_BTL_TALK_BOSS                          = 6,
	E_BTL_TALK_STRAY                         = 7,
	E_BTL_TALK_BEGLIFE                       = 8,
	E_BTL_TALK_MAX                           = 9,
};

// Enum Project.E_BTL_FIELD_TYPE
// NumValues: 0x0003
enum class E_BTL_FIELD_TYPE : uint8
{
	E_BTL_FIELD_TYPE_FREE                    = 0,
	E_BTL_FIELD_TYPE_6x6                     = 1,
	E_BTL_FIELD_TYPE_MAX                     = 2,
};

// Enum Project.E_BTL_EXTEND_ACTION
// NumValues: 0x0003
enum class E_BTL_EXTEND_ACTION : uint8
{
	E_BTL_EXTEND_ACTION_BUDDY_BATK           = 0,
	E_BTL_EXTEND_ACTION_BUDDY_MATK           = 1,
	E_BTL_EXTEND_ACTION_BUDDY_MAX            = 2,
};

// Enum Project.E_BTL_EFFECT_FORM
// NumValues: 0x0007
enum class E_BTL_EFFECT_FORM : uint8
{
	E_BTL_EFFECT_FORM_NORMAL                 = 0,
	E_BTL_EFFECT_FORM_BEAM                   = 1,
	E_BTL_EFFECT_FORM_BALL                   = 2,
	E_BTL_EFFECT_FORM_ABSORB                 = 3,
	E_BTL_EFFECT_FORM_ZIGZAG                 = 4,
	E_BTL_EFFECT_FORM_DIRECTIONAL            = 5,
	E_BTL_EFFECT_FORM_MAX                    = 6,
};

// Enum Project.E_BTL_EFFECT_TYPE
// NumValues: 0x0003
enum class E_BTL_EFFECT_TYPE : uint8
{
	E_BTL_EFFECT_TYPE_NORMAL                 = 0,
	E_BTL_EFFECT_TYPE_DIRECTIONAL            = 1,
	E_BTL_EFFECT_TYPE_MAX                    = 2,
};

// Enum Project.E_BTL_SKILL_ACTION_AID
// NumValues: 0x0004
enum class E_BTL_SKILL_ACTION_AID : uint8
{
	E_BTL_SKILL_ACTION_AID_NONE              = 0,
	E_BTL_SKILL_ACTION_AID_VALID             = 1,
	E_BTL_SKILL_ACTION_AID_INVALID           = 2,
	E_BTL_SKILL_ACTION_AID_MAX               = 3,
};

// Enum Project.E_BTL_EXTEND_ACTION_STATE
// NumValues: 0x0004
enum class E_BTL_EXTEND_ACTION_STATE : uint8
{
	E_BTL_EXTEND_ACTION_STATE_NONE           = 0,
	E_BTL_EXTEND_ACTION_STATE_IDLE           = 1,
	E_BTL_EXTEND_ACTION_STATE_HIT            = 2,
	E_BTL_EXTEND_ACTION_STATE_MAX            = 3,
};

// Enum Project.E_BTL_SKILL_ACTION_STATE
// NumValues: 0x000A
enum class E_BTL_SKILL_ACTION_STATE : uint8
{
	E_BTL_SKILL_ACTION_STATE_INTRODUCTION    = 0,
	E_BTL_SKILL_ACTION_STATE_HIT             = 1,
	E_BTL_SKILL_ACTION_STATE_CRITICAL        = 2,
	E_BTL_SKILL_ACTION_STATE_UPDATE_STATE    = 3,
	E_BTL_SKILL_ACTION_STATE_COUNTER         = 4,
	E_BTL_SKILL_ACTION_STATE_DEAD            = 5,
	E_BTL_SKILL_ACTION_STATE_IDLE            = 6,
	E_BTL_SKILL_ACTION_STATE_FINISH          = 7,
	E_BTL_SKILL_ACTION_STATE_FINALIZE        = 8,
	E_BTL_SKILL_ACTION_STATE_MAX             = 9,
};

// Enum Project.ONCE_TYPE
// NumValues: 0x0006
enum class EONCE_TYPE : uint8
{
	E_HP                                     = 0,
	E_MP                                     = 1,
	E_BST                                    = 2,
	E_MAX_KAJYA                              = 3,
	E_MIN_NDA                                = 4,
	E_MAX                                    = 5,
};

// Enum Project.ONCE_STATE
// NumValues: 0x0004
enum class EONCE_STATE : uint8
{
	E_NONE                                   = 0,
	E_RUN                                    = 1,
	E_END                                    = 2,
	E_MAX                                    = 3,
};

// Enum Project.MAGATSUHI_ITEM_ABILITY
// NumValues: 0x0006
enum class EMAGATSUHI_ITEM_ABILITY : uint8
{
	E_LUC                                    = 0,
	E_AGI                                    = 1,
	E_VIT                                    = 2,
	E_MGI                                    = 3,
	E_STR                                    = 4,
	E_MAX                                    = 5,
};

// Enum Project.E_AI_AFFINITY
// NumValues: 0x0006
enum class E_AI_AFFINITY : uint8
{
	E_WEAK                                   = 0,
	E_NORMAL                                 = 1,
	E_UNKNOWN                                = 2,
	E_RESIST                                 = 3,
	E_BLOCK                                  = 4,
	E_MAX                                    = 5,
};

// Enum Project.E_BTL_TUTORIAL_TYPE
// NumValues: 0x0008
enum class E_BTL_TUTORIAL_TYPE : uint8
{
	E_FIRST_TUTORIAL                         = 0,
	E_MAGATSUHI_SKILLL_TUTORIAL              = 1,
	E_BAD_STATUS_TUTORIAL                    = 2,
	E_GUEST_TUTORIAL                         = 3,
	E_RENZOKU_ENCOUNT_TURORIAL               = 4,
	E_MUD_TURORIAL                           = 5,
	E_DARKNESS_TURORIAL                      = 6,
	E_MAX                                    = 7,
};

// Enum Project.E_BTL_TUTORIAL
// NumValues: 0x000E
enum class E_BTL_TUTORIAL : uint8
{
	E_DISP_PRESSTURN_BATTLE_WINDOW           = 0,
	E_MASK_EXXEPT_SKILL                      = 1,
	E_DISP_SKILL_WINDOW                      = 2,
	E_SELECT_ATTACK_ONLY                     = 3,
	E_DISP_ATTR_WINDOW                       = 4,
	E_SELECT_SKILL_ONLY                      = 5,
	E_DISP_PRESSICON_WINDOW                  = 6,
	E_DISP_MAGATSUHI_SKILL_WINDOW            = 7,
	E_DISP_BAD_STATUS_WINDOW                 = 8,
	E_DISP_GUEST_WINDOW                      = 9,
	E_DISP_RENZOKU_ENCOUNT_WINDOW            = 10,
	E_DISP_MUD_WINDOW                        = 11,
	E_DISP_DARKNESS_WINDOW                   = 12,
	E_MAX                                    = 13,
};

// Enum Project.E_BTL_SKILL_CHECK
// NumValues: 0x0011
enum class E_BTL_SKILL_CHECK : uint8
{
	E_HP_CURE                                = 0,
	E_MP_CURE                                = 1,
	E_BST_CURE                               = 2,
	E_RECOME                                 = 3,
	E_KAJYANDA                               = 4,
	E_CHARGE                                 = 5,
	E_KARN                                   = 6,
	E_BST                                    = 7,
	E_ANALYZE                                = 8,
	E_DAMAGE_CUT                             = 9,
	E_PROVOKE                                = 10,
	E_AID_DELETE                             = 11,
	E_ADD_GAUGE                              = 12,
	E_PREV_TURN_AVOID                        = 13,
	E_PASS                                   = 14,
	E_PRESS_ICON                             = 15,
	E_MAX                                    = 16,
};

// Enum Project.E_BTL_DIFF
// NumValues: 0x000C
enum class E_BTL_DIFF : uint8
{
	E_DAMAGE_ENEMY                           = 0,
	E_HIT_PLAEYER_ATTACK                     = 1,
	E_DAMAGE_TAKE_ENEMY                      = 2,
	E_HIT_ENEMY_ATTACK                       = 3,
	E_ESCAPE_SUCCESS                         = 4,
	E_PLAEYER_CRITICAL                       = 5,
	E_HIT_BST_PLAYER                         = 6,
	E_HIT_BST_ENEMY                          = 7,
	E_HIT_DEATH_PLAYER                       = 8,
	E_HIT_DEATH_ENEMY                        = 9,
	E_PLAYER_FIRST                           = 10,
	E_MAX                                    = 11,
};

// Enum Project.E_BTL_UPLIFTING_TYPE
// NumValues: 0x000F
enum class E_BTL_UPLIFTING_TYPE : uint8
{
	E_BTL_UPLIFTING_TYPE_RANDVALUE           = 0,
	E_BTL_UPLIFTING_TYPE_WEAK                = 1,
	E_BTL_UPLIFTING_TYPE_COMBO               = 2,
	E_BTL_UPLIFTING_TYPE_CRITICAL            = 3,
	E_BTL_UPLIFTING_TYPE_MISS                = 4,
	E_BTL_UPLIFTING_TYPE_BLOCK               = 5,
	E_BTL_UPLIFTING_TYPE_ABSORB              = 6,
	E_BTL_UPLIFTING_TYPE_REFLEX              = 7,
	E_BTL_UPLIFTING_TYPE_MAPATTACK           = 8,
	E_BTL_UPLIFTING_TYPE_TAISEI              = 9,
	E_BTL_UPLIFTING_TYPE_DEFENSE             = 10,
	E_BTL_UPLIFTING_TYPE_TURNEND             = 11,
	E_BTL_UPLIFTING_TYPE_BTLSTART            = 12,
	E_BTL_UPLIFTING_TYPE_SELECT_DEFENSE      = 13,
	E_BTL_UPLIFTING_TYPE_MAX                 = 14,
};

// Enum Project.E_BTL_PRESS_TYPE
// NumValues: 0x0023
enum class E_BTL_PRESS_TYPE : uint8
{
	E_BTL_PRESS_TYPE_NORMAL                  = 0,
	E_BTL_PRESS_TYPE_WAIT                    = 1,
	E_BTL_PRESS_TYPE_WEAK                    = 2,
	E_BTL_PRESS_TYPE_CRITICAL                = 3,
	E_BTL_PRESS_TYPE_BADMISS                 = 4,
	E_BTL_PRESS_TYPE_SKILLPRESS2             = 5,
	E_BTL_PRESS_TYPE_MISS                    = 6,
	E_BTL_PRESS_TYPE_BLOCK                   = 7,
	E_BTL_PRESS_TYPE_REFLEX                  = 8,
	E_BTL_PRESS_TYPE_ABSORB                  = 9,
	E_BTL_PRESS_TYPE_MUD                     = 10,
	E_BTL_PRESS_TYPE_ESC                     = 11,
	E_BTL_PRESS_TYPE_RETURN                  = 12,
	E_BTL_PRESS_TYPE_SUMMON                  = 13,
	E_BTL_PRESS_TYPE_TALK_OK                 = 14,
	E_BTL_PRESS_TYPE_TALK_OK2                = 15,
	E_BTL_PRESS_TYPE_TALK_NG1                = 16,
	E_BTL_PRESS_TYPE_TALK_NG2                = 17,
	E_BTL_PRESS_TYPE_TURN                    = 18,
	E_BTL_PRESS_TYPE_ADD1                    = 19,
	E_BTL_PRESS_TYPE_ADD2                    = 20,
	E_BTL_PRESS_TYPE_ADD3                    = 21,
	E_BTL_PRESS_TYPE_ADD4                    = 22,
	E_BTL_PRESS_TYPE_SUB1                    = 23,
	E_BTL_PRESS_TYPE_SUB2                    = 24,
	E_BTL_PRESS_TYPE_SUB3                    = 25,
	E_BTL_PRESS_TYPE_SUB4                    = 26,
	E_BTL_PRESS_TYPE_ADD1_ITEM               = 27,
	E_BTL_PRESS_TYPE_ADDMAX_ITEM             = 28,
	E_BTL_PRESS_TYPE_TURNSTART               = 29,
	E_BTL_PRESS_TYPE_SETMAX                  = 30,
	E_BTL_PRESS_TYPE_BACKUP                  = 31,
	E_BTL_PRESS_TYPE_BACKUP_ADDED            = 32,
	E_BTL_PRESS_TYPE_NOT                     = 33,
	E_BTL_PRESS_TYPE_MAX                     = 34,
};

// Enum Project.E_BTL_PRESSICON_TYPE
// NumValues: 0x0003
enum class E_BTL_PRESSICON_TYPE : uint8
{
	E_BTL_PRESSICON_TYPE_NORMAL              = 0,
	E_BTL_PRESSICON_TYPE_HALF                = 1,
	E_BTL_PRESSICON_TYPE_MAX                 = 2,
};

// Enum Project.E_AID
// NumValues: 0x0006
enum class E_AID : uint8
{
	E_AID_BATK                               = 0,
	E_AID_MATK                               = 1,
	E_AID_ESC                                = 2,
	E_AID_DEF                                = 3,
	E_AID_HIT                                = 4,
	E_MAX                                    = 5,
};

// Enum Project.E_BTL_AI_TAR
// NumValues: 0x0032
enum class E_BTL_AI_TAR : uint8
{
	E_BTL_AI_TAR_NON                         = 0,
	E_BTL_AI_TAR_AI                          = 1,
	E_BTL_AI_TAR_RND                         = 2,
	E_BTL_AI_TAR_HPMIN                       = 3,
	E_BTL_AI_TAR_HPMAX                       = 4,
	E_BTL_AI_TAR_BAD                         = 5,
	E_BTL_AI_TAR_NOTBAD                      = 6,
	E_BTL_AI_TAR_ID                          = 7,
	E_BTL_AI_TAR_NOTID                       = 8,
	E_BTL_AI_TAR_MINE                        = 9,
	E_BTL_AI_TAR_MYAI                        = 10,
	E_BTL_AI_TAR_HPRATE                      = 11,
	E_BTL_AI_TAR_PARTY_INDEX                 = 12,
	E_BTL_AI_TAR_NOT_PARTY_INDEX             = 13,
	E_BTL_AI_TAR_AISHOU_PLUS                 = 14,
	E_BTL_AI_TAR_AISHOU_NOTPLUS              = 15,
	E_BTL_AI_TAR_AISHOU_FLAT                 = 16,
	E_BTL_AI_TAR_AISHOU_NOTFLAT              = 17,
	E_BTL_AI_TAR_AISHOU_MINUS                = 18,
	E_BTL_AI_TAR_AISHOU_NOTMINUS             = 19,
	E_BTL_AI_TAR_REC_COUNTER                 = 20,
	E_BTL_AI_TAR_REC_CRITICAL                = 21,
	E_BTL_AI_TAR_NOT_CRITICAL                = 22,
	E_BTL_AI_TAR_HOJO_MIN                    = 23,
	E_BTL_AI_TAR_HOJO_MAX                    = 24,
	E_BTL_AI_TAR_NOTBAD2                     = 25,
	E_BTL_AI_TAR_REFLEX                      = 26,
	E_BTL_AI_TAR_ABSORB                      = 27,
	E_BTL_AI_TAR_BLOCK                       = 28,
	E_BTL_AI_TAR_NOTREFLEX                   = 29,
	E_BTL_AI_TAR_NOTABSORB                   = 30,
	E_BTL_AI_TAR_NOTBLOCK                    = 31,
	E_BTL_AI_TAR_GUARD                       = 32,
	E_BTL_AI_TAR_NOTGUARD                    = 33,
	E_BTL_AI_TAR_TETORA                      = 34,
	E_BTL_AI_TAR_NOTTETORA                   = 35,
	E_BTL_AI_TAR_MAKARA                      = 36,
	E_BTL_AI_TAR_NOTMAKARA                   = 37,
	E_BTL_AI_TAR_AUTOBATTLE                  = 38,
	E_BTL_AI_TAR_HOJO_AI                     = 39,
	E_BTL_AI_TAR_SMART                       = 40,
	E_BTL_AI_TAR_HP_RATIO_MIN                = 41,
	E_BTL_AI_TAR_HP_RATIO_MAX                = 42,
	E_BTL_AI_TAR_EN_ANALYZE                  = 43,
	E_BTL_AI_TAR_WEAK                        = 44,
	E_BTL_AI_TAR_VALID_SKILL                 = 45,
	E_BTL_AI_TAR_RENZOKU_SKILL               = 46,
	E_BTL_AI_TAR_PROVOKE                     = 47,
	E_BTL_AI_TAR_EN_ANALYZE2                 = 48,
	E_BTL_AI_TAR_MAX                         = 49,
};

// Enum Project.E_AI_ATK_TYPE
// NumValues: 0x0003
enum class E_AI_ATK_TYPE : uint8
{
	E_AI_ATK_TYPE_PHYSICAL                   = 0,
	E_AI_ATK_TYPE_MASICAL                    = 1,
	E_AI_ATK_TYPE_MAX                        = 2,
};

// Enum Project.E_EFFICACY_BD
// NumValues: 0x0005
enum class E_EFFICACY_BD : uint8
{
	E_EFFICACY_BD_ATTACK                     = 0,
	E_EFFICACY_BD_MAGIC                      = 1,
	E_EFFICACY_BD_DEFENCE                    = 2,
	E_EFFICACY_BD_SPEED                      = 3,
	E_EFFICACY_BD_MAX                        = 4,
};

// Enum Project.E_BTL_AI_AREA
// NumValues: 0x0005
enum class E_BTL_AI_AREA : uint8
{
	E_BTL_AI_AREA_ONE                        = 0,
	E_BTL_AI_AREA_GROUP                      = 1,
	E_BTL_AI_AREA_ALL                        = 2,
	E_BTL_AI_AREA_SELF                       = 3,
	E_BTL_AI_AREA_MAX                        = 4,
};

// Enum Project.E_BTL_CNT
// NumValues: 0x0097
enum class E_BTL_CNT : uint8
{
	E_BTL_CNT_DMG                            = 0,
	E_BTL_CNT_DMG_1ACTION                    = 1,
	E_BTL_CNT_DMG_NUM                        = 2,
	E_BTL_CNT_DMG_CHAR                       = 3,
	E_BTL_CNT_ACTION                         = 4,
	E_BTL_CNT_ALL_ACTION                     = 5,
	E_BTL_CNT_AI0                            = 6,
	E_BTL_CNT_AI1                            = 7,
	E_BTL_CNT_AI2                            = 8,
	E_BTL_CNT_BATK                           = 9,
	E_BTL_CNT_MATK                           = 10,
	E_BTL_CNT_ESC                            = 11,
	E_BTL_CNT_DEF                            = 12,
	E_BTL_CNT_HIT                            = 13,
	E_BTL_CNT_MATK_3TURN                     = 14,
	E_BTL_CNT_BATKx2                         = 15,
	E_BTL_CNT_MATKx2                         = 16,
	E_BTL_CNT_BATKx1_5                       = 17,
	E_BTL_CNT_MATKx1_5                       = 18,
	E_BTL_CNT_ATKx10                         = 19,
	E_BTL_CNT_CRITICAL_ABS                   = 20,
	E_BTL_CNT_ATTACK_REF                     = 21,
	E_BTL_CNT_MAGIC_REF                      = 22,
	E_BTL_CNT_TETORAJYA                      = 23,
	E_BTL_CNT_CHANGE_WEAK                    = 24,
	E_BTL_CNT_KUI                            = 25,
	E_BTL_CNT_BST_DEF                        = 26,
	E_BTL_CNT_ESC_UP                         = 27,
	E_BTL_CNT_NOMP_TURN                      = 28,
	E_BTL_CNT_DAMAGE0_TURN                   = 29,
	E_BTL_CNT_PROVOKE_3TURN                  = 30,
	E_BTL_CNT_ESC_UP_B                       = 31,
	E_BTL_CNT_ESC_UP_M                       = 32,
	E_BTL_CNT_WEAK_ABS                       = 33,
	E_BTL_CNT_DAMAGE_CUT                     = 34,
	E_BTL_CNT_DAMAGE_CUT_90                  = 35,
	E_BTL_CNT_BLOCK_DEKAJA                   = 36,
	E_BTL_CNT_RECx2                          = 37,
	E_BTL_CNT_HPUP_RATE                      = 38,
	E_BTL_CNT_KANTUU                         = 39,
	E_BTL_CNT_BATK_MATK                      = 40,
	E_BTL_CNT_BATK_MATK_4                    = 41,
	E_BTL_CNT_ALLATK_CRITICAL                = 42,
	E_BTL_CNT_FORCE_AVOID                    = 43,
	E_BTL_CNT_RENZOKU_SKILL                  = 44,
	E_BTL_CNT_WEAK_AID_CNT                   = 45,
	E_BTL_CNT_BATK_CNT                       = 46,
	E_BTL_CNT_MATK_CNT                       = 47,
	E_BTL_CNT_ESC_CNT                        = 48,
	E_BTL_CNT_DEF_CNT                        = 49,
	E_BTL_CNT_HIT_CNT                        = 50,
	E_BTL_CNT_AUTOHIT                        = 51,
	E_BTL_CNT_AUTOESC                        = 52,
	E_BTL_CNT_CRITICAL                       = 53,
	E_BTL_CNT_COMBO_HIT                      = 54,
	E_BTL_CNT_POISON                         = 55,
	E_BTL_CNT_CONFUSE                        = 56,
	E_BTL_CNT_CHARM                          = 57,
	E_BTL_CNT_SLEEP                          = 58,
	E_BTL_CNT_CLOSE                          = 59,
	E_BTL_CNT_DAZZLE                         = 60,
	E_BTL_CNT_MUD                            = 61,
	E_BTL_CNT_DARKNESS                       = 62,
	E_BTL_CNT_POISON_TURN                    = 63,
	E_BTL_CNT_CONFUSE_TURN                   = 64,
	E_BTL_CNT_CHARM_TURN                     = 65,
	E_BTL_CNT_SLEEP_TURN                     = 66,
	E_BTL_CNT_CLOSE_TURN                     = 67,
	E_BTL_CNT_DAZZLE_TURN                    = 68,
	E_BTL_CNT_MUD_TURN                       = 69,
	E_BTL_CNT_DARKNESS_TURN                  = 70,
	E_BTL_CNT_POISON_LEVEL                   = 71,
	E_BTL_CNT_DARKNESS_LEVEL                 = 72,
	E_BTL_CNT_SLIP_DAM                       = 73,
	E_BTL_CNT_SLIP_DAM_2                     = 74,
	E_BTL_CNT_REFLEX_PHISICS                 = 75,
	E_BTL_CNT_ABSORB_PHISICS                 = 76,
	E_BTL_CNT_BLOCK_PHISICS                  = 77,
	E_BTL_CNT_REFLEX_FIRE                    = 78,
	E_BTL_CNT_ABSORB_FIRE                    = 79,
	E_BTL_CNT_BLOCK_FIRE                     = 80,
	E_BTL_CNT_REFLEX_ICE                     = 81,
	E_BTL_CNT_ABSORB_ICE                     = 82,
	E_BTL_CNT_BLOCK_ICE                      = 83,
	E_BTL_CNT_REFLEX_THUNDER                 = 84,
	E_BTL_CNT_ABSORB_THUNDER                 = 85,
	E_BTL_CNT_BLOCK_THUNDER                  = 86,
	E_BTL_CNT_REFLEX_WIND                    = 87,
	E_BTL_CNT_ABSORB_WIND                    = 88,
	E_BTL_CNT_BLOCK_WIND                     = 89,
	E_BTL_CNT_REFLEX_LIGHT                   = 90,
	E_BTL_CNT_ABSORB_LIGHT                   = 91,
	E_BTL_CNT_BLOCK_LIGHT                    = 92,
	E_BTL_CNT_REFLEX_DARK                    = 93,
	E_BTL_CNT_ABSORB_DARK                    = 94,
	E_BTL_CNT_BLOCK_DARK                     = 95,
	E_BTL_CNT_BATK_COUNT                     = 96,
	E_BTL_CNT_MATK_COUNT                     = 97,
	E_BTL_CNT_ESC_COUNT                      = 98,
	E_BTL_CNT_DEF_COUNT                      = 99,
	E_BTL_CNT_HIT_COUNT                      = 100,
	E_BTL_CNT_RHISICS_BARRIER_TURN           = 101,
	E_BTL_CNT_FIRE_BARRIER_TURN              = 102,
	E_BTL_CNT_ICE_BARRIER_TURN               = 103,
	E_BTL_CNT_THUNDER_BARRIER_TURN           = 104,
	E_BTL_CNT_WIND_BARRIER_TURN              = 105,
	E_BTL_CNT_LIGHT_BARRIER_TURN             = 106,
	E_BTL_CNT_DARK_BARRIER_TURN              = 107,
	E_BTL_CNT_TETORAJYA_TURN                 = 108,
	E_BTL_CNT_FORCE_AVOID_TURN               = 109,
	E_BTL_CNT_MAGATSUHI_KANTUU               = 110,
	E_BTL_CNT_MAGATSUHI_HIT                  = 111,
	E_BTL_CNT_MAGATSUHI_BST_HIT              = 112,
	E_BTL_CNT_MAGATSUHI_ADVERSITY            = 113,
	E_BTL_CNT_MAGATSUHI_COST1                = 114,
	E_BTL_CNT_MAGATSUHI_AID_RATE             = 115,
	E_BTL_CNT_MAGATSUHI_MAX_HIT              = 116,
	E_BTL_CNT_MAGATSUHI_TALK_FAILED_BLOCK    = 117,
	E_BTL_CNT_MAGATSUHI_COST_ATTACK_UP       = 118,
	E_BTL_CNT_MAGATSUHI_EXP_UP               = 119,
	E_BTL_CNT_MAGATSUHI_MAKKA_UP             = 120,
	E_BTL_CNT_MAGATSUHI_TEKISEI_MAX          = 121,
	E_BTL_CNT_MAGATSUHI_CHAGE_NO_CANCEL      = 122,
	E_BTL_CNT_MAGATSUHI_WEAK_DAMAGE_UP       = 123,
	E_BTL_CNT_MAGATSUHI_ITEM_DROP            = 124,
	E_BTL_CNT_MAGATSUHI_NOPRESS_CHANGE_PASS  = 125,
	E_BTL_CNT_MAGATSUHI_PRESS_HALF           = 126,
	E_BTL_CNT_MAGATSUHI_ENEMY_KILLED_PRESS_ADD = 127,
	E_BTL_CNT_BOSS_PARAM_00                  = 128,
	E_BTL_CNT_BOSS_PARAM_01                  = 129,
	E_BTL_CNT_CONSIDERED_BATKx2              = 130,
	E_DOWN                                   = 131,
	E_RECEIVE_CRITICAL_OR_WEAK               = 132,
	E_UPLIFTING_OFF_TURN                     = 133,
	E_UPLIFTING_OFF_TURN_KANTUU              = 134,
	E_UPLIFTING_OFF_TURN_ONLY                = 135,
	E_HIT_CNT_TURN                           = 136,
	E_TAISEI_BLOCK_CNT_TURN                  = 137,
	E_HIT_KAJYA_ACTION                       = 138,
	E_HIT_NNDA_ACTION                        = 139,
	E_DMG_TURN                               = 140,
	E_RELEASE_CHARGE                         = 141,
	E_CURRENT_TURN_AVOID                     = 142,
	E_PREV_TURN_AVOID                        = 143,
	E_RENZOKU_SKILL_CNT                      = 144,
	E_RENZOKU_SKILL_PRESS_CNT                = 145,
	E_ALL_AID_UP                             = 146,
	E_DAMEGED_VALUE                          = 147,
	E_BTL_CNT_MAX                            = 148,
	E_BTL_CNT_INVALID                        = 149,
	E_MAX                                    = 150,
};

// Enum Project.E_BTL_AREA_TYPE
// NumValues: 0x0004
enum class E_BTL_AREA_TYPE : uint8
{
	E_BTL_AREA_ONE                           = 0,
	E_BTL_AREA_GROUP                         = 1,
	E_BTL_AREA_ALL                           = 2,
	E_BTL_AREA_MAX                           = 3,
};

// Enum Project.E_BTL_WEAPON_TYPE
// NumValues: 0x0004
enum class E_BTL_WEAPON_TYPE : uint8
{
	E_BTL_WEAPON_NON                         = 0,
	E_BTL_WEAPON_SWORD                       = 1,
	E_BTL_WEAPON_GUN                         = 2,
	E_BTL_WEAPON_MAX                         = 3,
};

// Enum Project.E_BTL_COMM_TYPE
// NumValues: 0x001B
enum class E_BTL_COMM_TYPE : uint8
{
	E_BTL_COMM_NONE                          = 0,
	E_BTL_COMM_ATTACK                        = 1,
	E_BTL_COMM_SKILL                         = 2,
	E_BTL_COMM_LEGIONSKILL                   = 3,
	E_BTL_COMM_ESCAPE                        = 4,
	E_BTL_COMM_DEFENCE                       = 5,
	E_BTL_COMM_WAIT                          = 6,
	E_BTL_COMM_TALK                          = 7,
	E_BTL_COMM_ITEM                          = 8,
	E_BTL_COMM_SUMMON                        = 9,
	E_BTL_COMM_SUMMON2                       = 10,
	E_BTL_COMM_RETURN                        = 11,
	E_BTL_COMM_CALL                          = 12,
	E_BTL_COMM_UNITE                         = 13,
	E_BTL_COMM_ANALYZE                       = 14,
	E_BTL_COMM_BADWAIT                       = 15,
	E_BTL_COMM_SKIP                          = 16,
	E_BTL_COMM_DAMAGE                        = 17,
	E_BTL_COMM_UNION                         = 18,
	E_BTL_COMM_PARTNER_WAIT                  = 19,
	E_BTL_COMM_PARTNER_SUMMON_FAILED         = 20,
	E_BTL_COMM_CHANGE_ACTOR                  = 21,
	E_BTL_COMM_EXCHANGE_HERO                 = 22,
	E_BTL_COMM_AUTO_ON                       = 23,
	E_BTL_COMM_UNION_BREAK                   = 24,
	E_BTL_COMM_UPLIFTING                     = 25,
	E_BTL_COMM_MAX                           = 26,
};

// Enum Project.E_BTL_COMMAND_ACT
// NumValues: 0x0011
enum class E_BTL_COMMAND_ACT : uint8
{
	E_BTL_COMMAND_ACT_SKILL_0                = 0,
	E_BTL_COMMAND_ACT_SKILL_1                = 1,
	E_BTL_COMMAND_ACT_SKILL_2                = 2,
	E_BTL_COMMAND_ACT_SKILL_3                = 3,
	E_BTL_COMMAND_ACT_SKILL_4                = 4,
	E_BTL_COMMAND_ACT_SKILL_5                = 5,
	E_BTL_COMMAND_ACT_SKILL_6                = 6,
	E_BTL_COMMAND_ACT_SKILL_7                = 7,
	E_BTL_COMMAND_ACT_ATTACK                 = 8,
	E_BTL_COMMAND_ACT_DEFENSE                = 9,
	E_BTL_COMMAND_ACT_TALK                   = 10,
	E_BTL_COMMAND_ACT_ITEM                   = 11,
	E_BTL_COMMAND_ACT_SUMMON                 = 12,
	E_BTL_COMMAND_ACT_BUF0                   = 13,
	E_BTL_COMMAND_ACT_BUF1                   = 14,
	E_BTL_COMMAND_ACT_BUF2                   = 15,
	E_BTL_COMMAND_ACT_MAX                    = 16,
};

// Enum Project.E_BTL_CYCLE_TYPE
// NumValues: 0x0005
enum class E_BTL_CYCLE_TYPE : uint8
{
	E_BTL_CYCLE_AID                          = 0,
	E_BTL_CYCLE_MEGAMI                       = 1,
	E_BTL_CYCLE_MOON_AGE                     = 2,
	E_BTL_CYCLE_SLIP_DAMAGE                  = 3,
	E_BTL_CYCLE_MAX                          = 4,
};

// Enum Project.E_BTL_CHAR_TYPE
// NumValues: 0x000C
enum class E_BTL_CHAR_TYPE : uint8
{
	E_BTL_CHAR_EMPTY                         = 0,
	E_BTL_CHAR_HERO                          = 1,
	E_BTL_CHAR_NKM                           = 2,
	E_BTL_CHAR_ENEMY                         = 3,
	E_BTL_CHAR_NPC                           = 4,
	E_BTL_CHAR_PARTNER                       = 5,
	E_BTL_CHAR_UNION_HERO                    = 6,
	E_BTL_CHAR_BUDDY                         = 7,
	E_BTL_CHAR_BOY                           = 8,
	E_BTL_CHAR_AOGAMI                        = 9,
	E_BTL_CHAR_HAYATARO                      = 10,
	E_BTL_CHAR_MAX                           = 11,
};

// Enum Project.E_BTL_EXTRA_WAIT
// NumValues: 0x0007
enum class E_BTL_EXTRA_WAIT : uint8
{
	E_BTL_EXTRA_WAIT_STAN                    = 0,
	E_BTL_EXTRA_WAIT_SLEEP                   = 1,
	E_BTL_EXTRA_WAIT_FREEZE                  = 2,
	E_BTL_EXTRA_WAIT_STONE                   = 3,
	E_BTL_EXTRA_WAIT_ESCAPE_FAILED           = 4,
	E_BTL_EXTRA_WAIT_MUD                     = 5,
	E_BTL_EXTRA_WAIT_MAX                     = 6,
};

// Enum Project.E_BTL_BOSS_FLAG
// NumValues: 0x0020
enum class E_BTL_BOSS_FLAG : uint8
{
	E_INVALID                                = 0,
	E_BOSS                                   = 1,
	E_NOT_ORDER                              = 2,
	E_DEAD_WITH_BOSS                         = 3,
	E_TARGET_SELECT_WHEN_ALONE               = 4,
	E_TARGET_SELECT_BLOCK_BOSS               = 5,
	E_TAKE_AWAY_ALL_CHAGE                    = 6,
	E_TAKEN_CHAGE                            = 7,
	E_TARGET_SELECT_ELECTRIFICATION          = 8,
	E_BLOCK_ELECTRIFICATION                  = 9,
	E_IMMORTALITY                            = 10,
	E_DOWN                                   = 11,
	E_BOSS_DOWN_UNTIL_NOT_ORDER              = 12,
	E_BOSS_DOWN_UNTIL_NOT_SELECT             = 13,
	E_ABSOLUTE_BLOCK                         = 14,
	E_CHANGE_TAISEI                          = 15,
	E_BOSS_FIRE_WEAK                         = 16,
	E_BOSS_ICE_WEAK                          = 17,
	E_HP_HALF                                = 18,
	E_BOSS_ALL_WEAK                          = 19,
	E_DEAD_WITH_MODECHANGE                   = 20,
	E_SHARE_OPEN_AISHOU                      = 21,
	E_SHARE_HP_RATE                          = 22,
	E_TURNEND_RETURN                         = 23,
	E_DEAD_HP0                               = 24,
	E_NO_NEAR_DEATH_MOTION                   = 25,
	E_NOT_SELECT                             = 26,
	E_NOT_ADD_PRESS                          = 27,
	E_TURNSTART_RETURN                       = 28,
	E_DEAD_WHITE_OUT                         = 29,
	E_PROVKE_NOT_SELECT                      = 30,
	E_MAX                                    = 31,
};

// Enum Project.E_BTL_PARTY_STAT2
// NumValues: 0x0016
enum class E_BTL_PARTY_STAT2 : uint8
{
	E_BTL_PARTY_STAT2_REF_BARRIER            = 0,
	E_BTL_PARTY_STAT2_CHK_DMG_CHAR           = 1,
	E_BTL_PARTY_STAT2_HIT                    = 2,
	E_BTL_PARTY_STAT2_HP1_UI                 = 3,
	E_BTL_PARTY_STAT2_NOTACT                 = 4,
	E_BTL_PARTY_STAT2_REC_COUNTER            = 5,
	E_BTL_PARTY_STAT2_TRUE_DAMAGE            = 6,
	E_BTL_PARTY_STAT2_UNIT_ACTIVE            = 7,
	E_BTL_PARTY_STAT2_ACT_COUNTER            = 8,
	E_BTL_PARTY_STAT2_ACT_PRE_CHECK          = 9,
	E_BTL_PARTY_STAT2_DEL_ELECTRIFICATION    = 10,
	E_BTL_PARTY_STAT2_REQ_DEAD               = 11,
	E_BTL_PARTY_STAT2_REQ_RETURN             = 12,
	E_BTL_PARTY_STAT2_REQ_RESULT             = 13,
	E_BTL_PARTY_STAT2_DONE_RESULT            = 14,
	E_BTL_PARTY_STAT2_DISABLED_AISHOU        = 15,
	E_BTL_PARTY_STAT2_NOT_ACTION             = 16,
	E_BTL_PARTY_STAT2_ENEMY_RETURN           = 17,
	E_BTL_PARTY_STAT2_GUEST                  = 18,
	E_BTL_PARTY_STAT2_MAGATSUHI_DEVIL        = 19,
	E_BTL_PARTY_STAT2_DISABLED_AISHOU2       = 20,
	E_BTL_PARTY_STAT2_MAX                    = 21,
};

// Enum Project.E_BTL_PARTY_STAT
// NumValues: 0x0021
enum class E_BTL_PARTY_STAT : uint8
{
	E_BTL_PARTY_STAT_EXIST                   = 0,
	E_BTL_PARTY_STAT_HERO                    = 1,
	E_BTL_PARTY_STAT_NAKAMA                  = 2,
	E_BTL_PARTY_STAT_ENEMY                   = 3,
	E_BTL_PARTY_STAT_PARTNER                 = 4,
	E_BTL_PARTY_STAT_ACTEND                  = 5,
	E_BTL_PARTY_STAT_LOST                    = 6,
	E_BTL_PARTY_STAT_STOCK                   = 7,
	E_BTL_PARTY_STAT_LEADER                  = 8,
	E_BTL_PARTY_STAT_BOY                     = 9,
	E_BTL_PARTY_STAT_AOGAMI                  = 10,
	E_BTL_PARTY_STAT_ACTEND_FINISHED         = 11,
	E_BTL_PARTY_STAT_CRITICAL                = 12,
	E_BTL_PARTY_STAT_KUIUSE                  = 13,
	E_BTL_PARTY_STAT_KUIUSE2                 = 14,
	E_BTL_PARTY_STAT_BUDDY                   = 15,
	E_BTL_PARTY_STAT_UNION_HERO              = 16,
	E_BTL_PARTY_STAT_ENEMY_SUMMON            = 17,
	E_BTL_PARTY_STAT_HIT_TARGET              = 18,
	E_BTL_PARTY_STAT_APPLY_UNIT_STATE        = 19,
	E_BTL_PARTY_STAT_DEFENSE                 = 20,
	E_BTL_PARTY_STAT_TALKED_BEGLIFE          = 21,
	E_BTL_PARTY_STAT_NEXTACT                 = 22,
	E_BTL_PARTY_STAT_FUJIMI                  = 23,
	E_BTL_PARTY_STAT_CANCEL_DEAD             = 24,
	E_BTL_PARTY_STAT_NO_DESTROY_MODEL        = 25,
	E_BTL_PARTY_STAT_ITEM_DROP               = 26,
	E_BTL_PARTY_STAT_DEAD_EVENT              = 27,
	E_BTL_PARTY_STAT_CHECKED_BEGLIFE         = 28,
	E_BTL_PARTY_STAT_CANACT                  = 29,
	E_BTL_PARTY_STAT_AVOID                   = 30,
	E_BTL_PARTY_STAT_MISS                    = 31,
	E_BTL_PARTY_STAT_MAX                     = 32,
};

// Enum Project.E_BTL_ENCOUNT_SPAWN
// NumValues: 0x0004
enum class E_BTL_ENCOUNT_SPAWN : uint8
{
	E_BTL_ENCOUNT_SPAWN_DEFAULT              = 0,
	E_BTL_ENCOUNT_SPAWN_NO_ENEMY             = 1,
	E_BTL_ENCOUNT_SPAWN_NO_SPAWN             = 2,
	E_BTL_ENCOUNT_SPAWN_MAX                  = 3,
};

// Enum Project.E_BTL_ENCOUNT_TYPE
// NumValues: 0x0005
enum class E_BTL_ENCOUNT_TYPE : uint8
{
	E_BTL_ENCOUNT_TYPE_DEFAULT               = 0,
	E_BTL_ENCOUNT_TYPE_EVT                   = 1,
	E_BTL_ENCOUNT_TYPE_SUB                   = 2,
	E_BTL_ENCOUNT_TYPE_MAOU                  = 3,
	E_BTL_ENCOUNT_TYPE_MAX                   = 4,
};

// Enum Project.E_BTL_UTIL_ICON_TYPE
// NumValues: 0x0009
enum class E_BTL_UTIL_ICON_TYPE : uint8
{
	E_BTL_UTIL_ICON_TYPE_RESIST              = 0,
	E_BTL_UTIL_ICON_TYPE_GUARD               = 1,
	E_BTL_UTIL_ICON_TYPE_COMBO               = 2,
	E_BTL_UTIL_ICON_TYPE_WEAK                = 3,
	E_BTL_UTIL_ICON_TYPE_MISS                = 4,
	E_BTL_UTIL_ICON_TYPE_BLOCK               = 5,
	E_BTL_UTIL_ICON_TYPE_CRITICAL            = 6,
	E_BTL_UTIL_ICON_TYPE_NONE                = 7,
	E_BTL_UTIL_ICON_TYPE_MAX                 = 8,
};

// Enum Project.E_BTL_FINISHED_STATE
// NumValues: 0x0004
enum class E_BTL_FINISHED_STATE : uint8
{
	E_BTL_FINISHED_STATE_NORMAL              = 0,
	E_BTL_FINISHED_STATE_CONTINUE            = 1,
	E_BTL_FINISHED_STATE_TITLE               = 2,
	E_BTL_FINISHED_STATE_MAX                 = 3,
};

// Enum Project.E_BTL_EXTRA_ACTION
// NumValues: 0x0014
enum class E_BTL_EXTRA_ACTION : uint8
{
	E_BTL_EXTACT_NONE                        = 0,
	E_BTL_EXTACT_END_VERTIGO                 = 1,
	E_BTL_EXTACT_END_CONFUSE                 = 2,
	E_BTL_EXTACT_END_CHARM                   = 3,
	E_BTL_EXTACT_END_SLEEP                   = 4,
	E_BTL_EXTACT_END_FREEZE                  = 5,
	E_BTL_EXTACT_END_SHOCK                   = 6,
	E_BTL_EXTACT_END_STONE                   = 7,
	E_BTL_EXTACT_ACT_CONFUSE_00              = 8,
	E_BTL_EXTACT_ACT_CONFUSE_01              = 9,
	E_BTL_EXTACT_ACT_CHARM_00                = 10,
	E_BTL_EXTACT_ACT_CHARM_01                = 11,
	E_BTL_EXTACT_ACT_CHARM_02                = 12,
	E_BTL_EXTACT_MISS_CLOSE                  = 13,
	E_BTL_EXTACT_MISS_DAZZLE                 = 14,
	E_BTL_EXTACT_DAM_LACERATION              = 15,
	E_BTL_EXTACT_ACT_MUD                     = 16,
	E_BTL_EXTACT_ACT_DARKNESS                = 17,
	E_BTL_EXTACT_ACT_NOT_ENOUGH_MP           = 18,
	E_BTL_EXTACT_MAX                         = 19,
};

// Enum Project.E_SUMMON_TYPE
// NumValues: 0x0004
enum class E_SUMMON_TYPE : uint8
{
	E_SUMMON_TYPE_EXCHANGE                   = 0,
	E_SUMMON_TYPE_RETURN                     = 1,
	E_SUMMON_TYPE_SUMMON                     = 2,
	E_SUMMON_TYPE_MAX                        = 3,
};

// Enum Project.E_PARTNER_CHK_ACT
// NumValues: 0x0004
enum class E_PARTNER_CHK_ACT : uint8
{
	E_PARTNER_CHK_ACT_REC_E_DAM              = 0,
	E_PARTNER_CHK_ACT_HERO_B_ATK             = 1,
	E_PARTNER_CHK_ACT_HERO_M_ATK             = 2,
	E_PARTNER_CHK_ACT_MAX                    = 3,
};

// Enum Project.E_AI_SERCH_AID
// NumValues: 0x0005
enum class E_AI_SERCH_AID : uint8
{
	E_AI_SERCH_AID_ATTACK                    = 0,
	E_AI_SERCH_AID_MAGIC                     = 1,
	E_AI_SERCH_AID_DEFENCE                   = 2,
	E_AI_SERCH_AID_SPEED                     = 3,
	E_AI_SERCH_AID_MAX                       = 4,
};

// Enum Project.E_BTL_PANEL_CTRL
// NumValues: 0x0017
enum class E_BTL_PANEL_CTRL : uint8
{
	E_BTL_PANEL_CTRL_ADD_HP                  = 0,
	E_BTL_PANEL_CTRL_ADD_MP                  = 1,
	E_BTL_PANEL_CTRL_ADD_BST                 = 2,
	E_BTL_PANEL_CTRL_SET_HP                  = 3,
	E_BTL_PANEL_CTRL_SET_MP                  = 4,
	E_BTL_PANEL_CTRL_SET_BST                 = 5,
	E_BTL_PANEL_CTRL_SET_MAXHP               = 6,
	E_BTL_PANEL_CTRL_SET_MAXMP               = 7,
	E_BTL_PANEL_CTRL_SET_EMPTY               = 8,
	E_BTL_PANEL_CTRL_SET_ACTOR               = 9,
	E_BTL_PANEL_CTRL_SET_TARGET              = 10,
	E_BTL_PANEL_CTRL_SET_ACT_END             = 11,
	E_BTL_PANEL_CTRL_SET_TURN_CHANGE         = 12,
	E_BTL_PANEL_CTPL_SET_HP_FORECAST         = 13,
	E_BTL_PANEL_CTPL_SET_MP_FORECAST         = 14,
	E_BTL_PANEL_CTRL_SET_VIRTUAL_ORDER       = 15,
	E_BTL_PANEL_CTRL_SET_AID_PARAM           = 16,
	E_BTL_PANEL_CTRL_OOMAGATOKI              = 17,
	E_BTL_PANEL_CTRL_DEAD_KUISHIBARI         = 18,
	E_BTL_PANEL_CTRL_UPDATE_BST              = 19,
	E_BTL_PANEL_CTRL_SET_VISIBILITY          = 20,
	E_BTL_PANEL_CTRL_COST_MP                 = 21,
	E_BTL_PANEL_MAX                          = 22,
};

// Enum Project.E_BTL_SKILL_CAM_TYPE
// NumValues: 0x0008
enum class E_BTL_SKILL_CAM_TYPE : uint8
{
	E_BTL_SKILL_CAM_TYPE_ACTOR               = 0,
	E_BTL_SKILL_CAM_TYPE_TARGET              = 1,
	E_BTL_SKILL_CAM_TYPE_ORIGIN              = 2,
	E_BTL_SKILL_CAM_TYPE_ACTOR_ALL           = 3,
	E_BTL_SKILL_CAM_TYPE_TARGET_ALL          = 4,
	E_BTL_SKILL_CAM_TYPE_REFLECTION          = 5,
	E_BTL_SKILL_CAM_TYPE_REFLECTION_ALL      = 6,
	E_BTL_SKILL_CAM_TYPE_MAX                 = 7,
};

// Enum Project.E_BTL_CAM_TYPE
// NumValues: 0x0014
enum class E_BTL_CAM_TYPE : uint8
{
	E_BTL_CAM_TYPE_NONE                      = 0,
	E_BTL_CAM_TYPE_TURN_PREV_P               = 1,
	E_BTL_CAM_TYPE_TURN_PREV_E               = 2,
	E_BTL_CAM_TYPE_COMMAND                   = 3,
	E_BTL_CAM_TYPE_START                     = 4,
	E_BTL_CAM_TYPE_RESULT                    = 5,
	E_BTL_CAM_TYPE_TARGET                    = 6,
	E_BTL_CAM_TYPE_RECAM                     = 7,
	E_BTL_CAM_TYPE_BADSTATUS                 = 8,
	E_BTL_CAM_TYPE_BADSTATUS_ONE             = 9,
	E_BTL_CAM_TYPE_FUSION                    = 10,
	E_BTL_CAM_TYPE_COMMAND_BACK              = 11,
	E_BTL_CAM_TYPE_COMMAND_FRONT             = 12,
	E_BTL_CAM_TYPE_SUMMON_SINGLE             = 13,
	E_BTL_CAM_TYPE_SUMMON_ALL                = 14,
	E_BTL_CAM_TYPE_ESCAPE                    = 15,
	E_BTL_CAM_TYPE_N_COMMAND                 = 16,
	E_BTL_CAM_TYPE_N_COMMAND_MENU            = 17,
	E_BTL_CAM_TYPE_TIAMAT_HEAD               = 18,
	E_BTL_CAM_TYPE_MAX                       = 19,
};

// Enum Project.E_KUISHIBARI_LEVEL
// NumValues: 0x000A
enum class E_KUISHIBARI_LEVEL : uint8
{
	E_KUISHIBARI_LEVEL_NONE                  = 0,
	E_KUISHIBARI_LEVEL_HPONE                 = 1,
	E_KUISHIBARI_LEVEL_HPFULL                = 2,
	E_KUISHIBARI_LEVEL_HPONEGIFT             = 3,
	E_KUISHIBARI_LEVEL_HPFULL_ITEM           = 4,
	E_KUISHIBARI_LEVEL_HERO_HPFULL_STOCK     = 5,
	E_KUISHIBARI_LEVEL_HPFULL_STOCK          = 6,
	E_KUISHIBARI_LEVEL_HPONE_RAND            = 7,
	E_KUISHIBARI_LEVEL_HPFULL_ABS            = 8,
	E_KUISHIBARI_LEVEL_MAX                   = 9,
};

// Enum Project.E_BTL_TALK_RET
// NumValues: 0x0005
enum class E_BTL_TALK_RET : uint8
{
	E_BTL_TALK_RET_NONE                      = 0,
	E_BTL_TALK_RET_CONTINUE                  = 1,
	E_BTL_TALK_RET_E_ESCAPE                  = 2,
	E_BTL_TALK_RET_P_ESCAPE                  = 3,
	E_BTL_TALK_RET_MAX                       = 4,
};

// Enum Project.E_BTL_TASK_ONE_STATE
// NumValues: 0x0004
enum class E_BTL_TASK_ONE_STATE : uint8
{
	E_BTL_TASK_ONE_STATE_WAIT                = 0,
	E_BTL_TASK_ONE_STATE_RUN                 = 1,
	E_BTL_TASK_ONE_STATE_FINISH              = 2,
	E_BTL_TASK_ONE_STATE_MAX                 = 3,
};

// Enum Project.E_BTL_STATE_DEBUG_2
// NumValues: 0x0020
enum class E_BTL_STATE_DEBUG_2 : uint8
{
	E_BTL_STAT_DEBUG_2_D_POA                 = 0,
	E_CHARM_START                            = 1,
	E_CHARM_CURE                             = 2,
	E_CHARM_AID                              = 3,
	BTL_STAT_DEBUG_2_ENEMYFIRST              = 4,
	BTL_STAT_DEBUG_2_PLAYERFIRST             = 5,
	E_CHARM_WAIT                             = 6,
	E_CONFUSE_START                          = 7,
	E_CONFUSE_FF                             = 8,
	BTL_STAT_DEBUG_2_ALLMISS                 = 9,
	E_CONFUSE_WAIT                           = 10,
	E_NOT_CURE_BST_TIMEOUT                   = 11,
	E_BSTCALC_LOOP_100                       = 12,
	E_ITEMDROP_LOOP_100                      = 13,
	E_BTL_STAT_DEBUG_2_NOPRESS               = 14,
	BTL_STAT_DEBUG_2_ALLHANSYA               = 15,
	BTL_STAT_DEBUG_2_ALLABS                  = 16,
	BTL_STAT_DEBUG_2_ALLBLOCK                = 17,
	BTL_STAT_DEBUG_2_NODAMAGE                = 18,
	BTL_STAT_DEBUG_2_ALL_SKILL               = 19,
	E_CAN_USE_SURELY_RECOME                  = 20,
	MERCY_TALK_100                           = 21,
	E_ALL_USE_SKILL                          = 22,
	E_NODAMAGE_ONLY_HERO                     = 23,
	E_NO_UPLIFTING_GAUGE                     = 24,
	E_COUNTER100                             = 25,
	E_AUTO_LOG_ON                            = 26,
	E_FORCE_RENZOKU_ENCOUNT                  = 27,
	E_NOT_FORCE_RENZOKU_ENCOUNT              = 28,
	E_FORCE_CHALLENGE_MODE                   = 29,
	E_AI_LOG                                 = 30,
	E_BTL_STATE_DEBUG_MAX                    = 31,
};

// Enum Project.E_BTL_STATE_DEBUG
// NumValues: 0x0021
enum class E_BTL_STATE_DEBUG : uint8
{
	E_BTL_STAT_DEBUG                         = 0,
	E_BTL_STAT_DEBUG_PROVOKE100              = 1,
	E_BTL_STAT_DAM0_ENEMY                    = 2,
	E_BTL_STAT_DAM0_PLAYER                   = 3,
	E_BTL_STAT_DEBUG_NOCHANGE                = 4,
	E_BTL_STAT_DAMAGE99999                   = 5,
	E_BTL_STAT_SKILLDEBUG                    = 6,
	E_BTL_STAT_NOT_BST_TUTORIAL              = 7,
	E_BTL_STAT_DEBUG_PC_MODE                 = 8,
	E_BTL_STAT_DEBUGLOG_ON                   = 9,
	E_BTL_STAT_NO_DEATH                      = 10,
	E_BTL_STAT_PARTNER_ACT100                = 11,
	E_BTL_STAT_CYCLELOG_ON                   = 12,
	E_BTL_STAT_BUSTUP_ON                     = 13,
	E_BTL_STAT_DEBUG_NO_COST                 = 14,
	E_BTL_STAT_DEBUG_SKIP_RESULT             = 15,
	E_BTL_STAT_DEBUG_WAIT_DEBUG_MENU         = 16,
	E_BTL_STAT_DEBUG_OPEN_DEBUG_MENU         = 17,
	E_BTL_STAT_DEBUG_HIT_E                   = 18,
	E_BTL_STAT_DEBUG_HIT_P                   = 19,
	E_BTL_STAT_DEBUG_CHANGE_UNIT             = 20,
	E_BTL_STAT_DEBUG_TALK_BEGLIFE            = 21,
	E_BTL_STAT_DEBUG_ESCAPE_OK               = 22,
	E_BTL_STAT_DEBUG_ESCAPE_NG               = 23,
	E_BTL_STAT_DEBUG_CRITICAL_E              = 24,
	E_BTL_STAT_DEBUG_CRITICAL_P              = 25,
	E_BTL_STAT_DEBUG_NOBST_E                 = 26,
	E_BTL_STAT_DEBUG_NOBST_P                 = 27,
	E_BTL_STAT_DEBUG_BST100_E                = 28,
	E_BTL_STAT_DEBUG_BST100_P                = 29,
	E_BTL_STAT_DEBUG_AVOID_E                 = 30,
	E_BTL_STAT_DEBUG_AVOID_P                 = 31,
	E_BTL_STAT_MAX                           = 32,
};

// Enum Project.E_BTL_STAT_2
// NumValues: 0x0021
enum class E_BTL_STAT_2 : uint8
{
	E_BTL_STAT_2_NEXT_HIT_UP                 = 0,
	E_BTL_STAT_2_NEXT_CRI_UP                 = 1,
	E_BTL_STAT_2_TURN_FIRST_ACT_P            = 2,
	E_BTL_STAT_2_INOCHIGOI_CALC              = 3,
	E_BTL_STAT_2_UPLIFTING_TURN              = 4,
	E_BTL_STAT_2_CANCEL_SKILLINFO            = 5,
	E_BTL_STAT_2_UPLIFTING_OFF               = 6,
	E_BTL_STAT_2_EVENT                       = 7,
	E_BTL_STAT_2_START_CHARM_OR_CONFUSE      = 8,
	E_BTL_STAT_2_ENEMY_MAGATSUHI_OFF         = 9,
	E_BTL_STAT_2_NOT_CHANGE_ORDER            = 10,
	E_BTL_STAT_2_ACT_PRE_CAM_CHANGE          = 11,
	E_BTL_STAT_2_SHARE_HP_RATE               = 12,
	E_BTL_STAT_2_ENEMYTURNEND_SKILL          = 13,
	E_BTL_STAT_2_EVENT_2                     = 14,
	E_BTL_STAT_2_TURN_CHK_EFFECT             = 15,
	E_BTL_STAT_2_KEEP_SKILL_MENU             = 16,
	E_BTL_STAT_2_TURN_CHK_BST_ACT_END        = 17,
	E_BTL_STAT_2_TURN_CHK_PREV               = 18,
	E_BTL_STAT_2_TURN_CHK_CURE               = 19,
	E_BTL_STAT_2_TURN_CHK_BST_CURE           = 20,
	E_BTL_STAT_2_TURN_CHK_BST_DAM            = 21,
	E_BTL_STAT_2_TURN_CHK_BST_DAM2           = 22,
	E_BTL_STAT_2_CHANGE_ACTOR                = 23,
	E_BTL_STAT_2_COUNTER_TURN_CHANGE         = 24,
	E_BTL_STAT_2_FAILED_ESCAPE               = 25,
	E_BTL_STAT_2_COUNTER_TURN_CHANGE_EFT_END = 26,
	E_BTL_STAT_2_RE_CHANGE_ACTOR             = 27,
	E_BTL_STAT_2_ACT_EXHANGE                 = 28,
	E_BTL_STAT_2_DEL_ALL_ELECTRIFICATION     = 29,
	E_BTL_STAT_2_PRESS_ICON_FULL             = 30,
	E_BTL_STAT_2_REQ_ALL_RETURN              = 31,
	E_BTL_STAT_2_MAX                         = 32,
};

// Enum Project.E_BTL_STAT
// NumValues: 0x0021
enum class E_BTL_STAT : uint8
{
	E_BTL_STAT_BOSS                          = 0,
	E_BTL_STAT_NOORDER                       = 1,
	E_BTL_STAT_ENEMYFIRST                    = 2,
	E_BTL_STAT_ENEMYTURN                     = 3,
	E_BTL_STAT_PLAYERFIRST                   = 4,
	E_BTL_STAT_TALK_SCOUT_SUCCESS            = 5,
	E_BTL_STAT_ENEMYPRESET                   = 6,
	E_BTL_STAT_AUTO                          = 7,
	E_BTL_STAT_WEAK_AUTO                     = 8,
	E_BTL_STAT_GOTO_TITLE                    = 9,
	E_BTL_STAT_PRESS_PLUS                    = 10,
	E_BTL_STAT_STOP_TARSEL                   = 11,
	E_BTL_STAT_ONCE_SUMMON_KAJYA             = 12,
	E_BTL_STAT_NOTACT_GUEST                  = 13,
	E_BTL_STAT_TURN_REC_READY                = 14,
	E_BTL_STAT_TURN_REC                      = 15,
	E_BTL_STAT_RENZOKU_ENCOUNT_TUTORIAL      = 16,
	E_BTL_STAT_TURNCHANGE                    = 17,
	E_BTL_STAT_SYSTEMATIC                    = 18,
	E_BTL_STAT_MUD_TUTORIAL                  = 19,
	E_BTL_STAT_DARKNESS_TUTORIAL             = 20,
	E_BTL_STAT_ORDER_ENCOUNT                 = 21,
	E_BTL_STAT_NOT_CRITICAL                  = 22,
	E_BTL_STAT_SET_MAGATSUHI_DEVIL_DATA      = 23,
	E_BTL_STAT_SET_NEXT_ORDER                = 24,
	E_BTL_STAT_GUEST_ENTRY_EVENT             = 25,
	E_BTL_STAT_ENEMIES_TRUE_DAMAGE           = 26,
	E_BTL_STAT_PRESSICON_TURNSTART           = 27,
	E_BTL_STAT_RENZOKU_ENCOUNT_ENEMY         = 28,
	E_BTL_STAT_RENZOKU_ENCOUNT_TURN          = 29,
	E_BTL_STAT_ADD_PRESSICON_ENEMY_KILLED    = 30,
	E_BTL_STAT_NOPRESS                       = 31,
	E_BTL_STAT_MAX                           = 32,
};

// Enum Project.E_BTL_SIDE
// NumValues: 0x0005
enum class E_BTL_SIDE : uint8
{
	E_BTL_SIDE_PLAYER                        = 0,
	E_BTL_SIDE_ENEMY                         = 1,
	E_BTL_SIDE_MAX                           = 2,
	E_BTL_SIDE_NPC                           = 3,
	E_BTL_SIDE_INVALID                       = 4,
};

// Enum Project.E_BTL_SEQ
// NumValues: 0x0006
enum class E_BTL_SEQ : uint8
{
	E_BTL_SEQ_IDLE                           = 0,
	E_BTL_SEQ_INITIALIZE                     = 1,
	E_BTL_SEQ_RUNNING                        = 2,
	E_BTL_SEQ_TEST                           = 3,
	E_BTL_SEQ_TEST_RUNNING                   = 4,
	E_BTL_SEQ_MAX                            = 5,
};

// Enum Project.E_BTL_TASK_COM
// NumValues: 0x0053
enum class E_BTL_TASK_COM : uint8
{
	E_BTL_TASK_COM_NONE                      = 0,
	E_BTL_TASK_COM_SKILLEFF                  = 1,
	E_BTL_TASK_COM_BADSTAT                   = 2,
	E_BTL_TASK_COM_TEST_1                    = 3,
	E_BTL_TASK_COM_TEST_2                    = 4,
	E_BTL_TASK_COM_TEST_3                    = 5,
	E_BTL_TASK_COM_TEST_4                    = 6,
	E_BTL_TASK_COM_TEST_5                    = 7,
	E_BTL_TASK_COM_DMGMOT                    = 8,
	E_BTL_TASK_COM_NUMEFF                    = 9,
	E_BTL_TASK_COM_HPMP                      = 10,
	E_BTL_TASK_COM_CAM_FIX                   = 11,
	E_BTL_TASK_COM_DELTA_TIME_WAIT           = 12,
	E_BTL_TASK_COM_DEAD_FADE                 = 13,
	E_BTL_TASK_COM_INFO_SET_SKILL            = 14,
	E_BTL_TASK_COM_DIR_TO_TARGET             = 15,
	E_BTL_TASK_COM_SKILL_EFFECT              = 16,
	E_BTL_TASK_COM_CAM_RAIL                  = 17,
	E_BTL_TASK_COM_AID                       = 18,
	E_BTL_TASK_COM_CAM_TARGET_UNIT           = 19,
	E_BTL_TASK_COM_CAM_FOVY                  = 20,
	E_BTL_TASK_COM_CAM_RAIL_SKILL            = 21,
	E_BTL_TASK_COM_SET_UNIT_MOTION           = 22,
	E_BTL_TASK_COM_PLAY_EFFECT               = 23,
	E_BTL_TASK_COM_PLAY_CAM_SHAKE            = 24,
	E_BTL_TASK_COM_RADIAL_BLUR               = 25,
	E_BTL_TASK_COM_UNIT_BACKSTEP             = 26,
	E_BTL_TASK_COM_UNIT_ATTACK               = 27,
	E_BTL_TASK_COM_MESSAGE                   = 28,
	E_BTL_TASK_COM_PARTY_PANEL               = 29,
	E_BTL_TASK_COM_TALK_PARTY_IN             = 30,
	E_BTL_TASK_COM_APPLY_UNIT_MODEL_STATE    = 31,
	E_BTL_TASK_COM_SKILL_INFO_MESS           = 32,
	E_BTL_TASK_COM_SUMMON                    = 33,
	E_BTL_TASK_COM_SUMMON_AFTER              = 34,
	E_BTL_TASK_COM_LOAD_UNIT_MODEL           = 35,
	E_BTL_TASK_COM_UNION_EFFECT              = 36,
	E_BTL_TASK_COM_PLAYER_RECOME             = 37,
	E_BTL_TASK_COM_PLAYER_RECOME_AFTER       = 38,
	E_BTL_TASK_COM_UNIT_ACTION               = 39,
	E_BTL_TASK_COM_UNITE_EXEC                = 40,
	E_BTL_TASK_COM_SWITCH_COMMAND            = 41,
	E_BTL_TASK_COM_BLANK_EXIST               = 42,
	E_BTL_TASK_COM_PLAY_SE                   = 43,
	E_BTL_TASK_COM_PLAY_ANIM_CAMERA          = 44,
	E_BTL_TASK_COM_CALL_SUMMON               = 45,
	E_BTL_TASK_COM_CALL_SKILL_EVENT          = 46,
	E_BTL_TASK_COM_UNIT_MOVE                 = 47,
	E_BTL_TASK_COM_DISPLAY_FADE              = 48,
	E_BTL_TASK_COM_ADD_DECAL                 = 49,
	E_BTL_TASK_COM_ADD_HIT_LIGHT             = 50,
	E_BTL_TASK_COM_ADD_SKILL_LIGHT           = 51,
	E_BTL_TASK_COM_UNION_BREAK               = 52,
	E_BTL_TASK_COM_EXTACT_MESS               = 53,
	E_BTL_TASK_COM_ADD_DECAL_TO_EFFECT       = 54,
	E_BTL_TASK_COM_UNIT_SHAKE                = 55,
	E_BTL_TASK_COM_UTIL_ICON                 = 56,
	E_BTL_TASK_COM_PLAY_SE_UNIT_ATTACH       = 57,
	E_BTL_TASK_COM_ADD_MAGGAUGE              = 58,
	E_BTL_TASK_COM_ADD_REICHI_POINT          = 59,
	E_BTL_TASK_COM_ADD_PlayAbsorptionEffect  = 60,
	E_BTL_TASK_COM_BEGIN_HIT_STOP            = 61,
	E_BTL_TASK_COM_ADD_CAMERA_DOF            = 62,
	E_BTL_TASK_COM_PRESSICON                 = 63,
	E_BTL_TASK_COM_UPLIFTING                 = 64,
	E_BTL_TASK_COM_FIRST_SETTING             = 65,
	E_BTL_TASK_COM_HOME_SIDE_ALL             = 66,
	E_BTL_TASK_COM_VISIBILITY_SIDE_ALL       = 67,
	E_BTL_TASK_COM_SET_ACTOR_TRANSFORM       = 68,
	E_BTL_TASK_COM_SUMMON_TSUKUYOMI          = 69,
	E_BTL_TASK_COM_DRAW_PLAYER_UPLIFTING_GAUGE = 70,
	E_BTL_TASK_COM_NFO_MESS_BY_LABEL         = 71,
	E_BTL_TASK_COM_CALL_CAMERA_CURRENT_FORCE = 72,
	E_BTL_TASK_COM_STOP_ALL_SE               = 73,
	E_BTL_TASK_COM_IGNORE_SKILL_SKIP         = 74,
	E_BTL_TASK_COM_STOP_ALL_PARTICLE         = 75,
	E_BTL_TASK_COM_OPEN_TUTORIAL_WINDOW      = 76,
	E_BTL_TASK_COM_UNIT_SCALE_RESET          = 77,
	E_BTL_TASK_COM_CTRL_POST_PROCESS         = 78,
	E_BTL_TASK_COM_RESET_CHARA_PARTICLE      = 79,
	E_BTL_TASK_COM_UNLOCK_ACHIEVEMENT        = 80,
	E_BTL_TASK_COM_CTRL_CHARA_MATERIAL       = 81,
	E_BTL_TASK_COM_MAX                       = 82,
};

// Enum Project.E_BTL_REFLECT_RES_TYPE
// NumValues: 0x0014
enum class E_BTL_REFLECT_RES_TYPE : uint8
{
	E_BTL_REFLECT_RES_HIT                    = 0,
	E_BTL_REFLECT_RES_REFLEX                 = 1,
	E_BTL_REFLECT_RES_ABSORB                 = 2,
	E_BTL_REFLECT_RES_BLOCK                  = 3,
	E_BTL_REFLECT_RES_AVOID                  = 4,
	E_BTL_REFLECT_RES_MISS                   = 5,
	E_BTL_REFLECT_RES_SUMMON                 = 6,
	E_BTL_REFLECT_RES_RETURN                 = 7,
	E_BTL_REFLECT_RES_ANALYZE                = 8,
	E_BTL_REFLECT_RES_ESCAPE                 = 9,
	E_BTL_REFLECT_RES_MAKA                   = 10,
	E_BTL_REFLECT_RES_ENE_ESC                = 11,
	E_BTL_REFLECT_RES_PRESS                  = 12,
	E_BTL_REFLECT_RES_PRESS_ITEM             = 13,
	E_BTL_REFLECT_RES_MAKABEAM               = 14,
	E_BTL_REFLECT_RES_NOTACT                 = 15,
	E_BTL_REFLECT_RES_NOTKOUKA               = 16,
	E_BTL_REFLECT_RES_FLAG_MISS              = 17,
	E_BTL_REFLECT_RES_BSTBLOCK               = 18,
	E_BTL_REFLECT_RES_MAX                    = 19,
};

// Enum Project.E_BTL_SWITCH_COMMAND
// NumValues: 0x0003
enum class E_BTL_SWITCH_COMMAND : uint8
{
	E_BTL_SWITCH_COMMAND_UNIT_PRALYZE        = 0,
	E_BTL_SWITCH_COMMAND_EN_HPBAR_UPDATE     = 1,
	E_BTL_SWITCH_COMMAND_MAX                 = 2,
};

// Enum Project.E_BTL_NUMEFF
// NumValues: 0x0007
enum class E_BTL_NUMEFF : uint8
{
	E_BTL_NUMEFF_HP_DAMAGE                   = 0,
	E_BTL_NUMEFF_MP_DAMAGE                   = 1,
	E_BTL_NUMEFF_HP_CURE                     = 2,
	E_BTL_NUMEFF_MP_CURE                     = 3,
	E_BTL_NUMEFF_HPMP_DAMAGE                 = 4,
	E_BTL_NUMEFF_HPMP_CURE                   = 5,
	E_BTL_NUMEFF_MAX                         = 6,
};

// Enum Project.E_BTL_END
// NumValues: 0x0012
enum class E_BTL_END : uint8
{
	E_BTL_END_NONE                           = 0,
	E_BTL_END_ENEMY_0                        = 1,
	E_BTL_END_GAMEOVER                       = 2,
	E_BTL_END_GUEST_DEAD                     = 3,
	E_BTL_END_ESCAPE_PLAYER                  = 4,
	E_BTL_END_ESCAPE_ENEMY                   = 5,
	E_BTL_END_RENZOKU                        = 6,
	E_BTL_END_STONE                          = 7,
	E_BTL_END_EVENT                          = 8,
	E_BTL_END_ENDING                         = 9,
	E_BTL_END_TALK                           = 10,
	E_BTL_END_SCR_RESULT                     = 11,
	E_BTL_END_SCR_NORESULT                   = 12,
	E_BTL_END_WIN_FAILD                      = 13,
	E_BTL_END_WIN_SUCCESS                    = 14,
	E_BTL_END_TALK_PLAYER_ESCAPE             = 15,
	E_BTL_END_GOTO_TITLE                     = 16,
	E_BTL_END_MAX                            = 17,
};

// Enum Project.E_BTL_SYMBOL_ENCOUNT
// NumValues: 0x0004
enum class E_BTL_SYMBOL_ENCOUNT : uint8
{
	E_BTL_SYMBOL_ENCOUNT_NORMAL              = 0,
	E_BTL_SYMBOL_ENCOUNT_PLAYER_ATTACK       = 1,
	E_BTL_SYMBOL_ENCOUNT_ENEMY_BACK          = 2,
	E_BTL_SYMBOL_ENCOUNT_MAX                 = 3,
};

// Enum Project.E_BTL_DEAD_EFFECT
// NumValues: 0x000D
enum class E_BTL_DEAD_EFFECT : uint8
{
	E_BTL_DEAD_EFFECT_NORMAL                 = 0,
	E_BTL_DEAD_EFFECT_FIRE                   = 1,
	E_BTL_DEAD_EFFECT_ICE                    = 2,
	E_BTL_DEAD_EFFECT_THUNDER                = 3,
	E_BTL_DEAD_EFFECT_WIND                   = 4,
	E_BTL_DEAD_EFFECT_LIGHT                  = 5,
	E_BTL_DEAD_EFFECT_DARK                   = 6,
	E_BTL_DEAD_EFFECT_ALL                    = 7,
	E_BTL_DEAD_EFFECT_VARTICAL               = 8,
	E_BTL_DEAD_EFFECT_HORIZONAL              = 9,
	E_BTL_DEAD_EFFECT_PHYSICS                = 10,
	E_BTL_DEAD_EFFECT_STONE                  = 11,
	E_BTL_DEAD_EFFECT_MAX                    = 12,
};

// Enum Project.E_BTL_DAMAGE_HIT_TYPE
// NumValues: 0x0007
enum class E_BTL_DAMAGE_HIT_TYPE : uint8
{
	E_BTL_DAMAGE_NORMAL                      = 0,
	E_BTL_DAMAGE_CRITICAL                    = 1,
	E_BTL_DAMAGE_WEAK                        = 2,
	E_BTL_DAMAGE_TAISEI                      = 3,
	E_BTL_DAMAGE_MISS                        = 4,
	E_BTL_DAMAGE_DEATHHIT                    = 5,
	E_BTL_DAMAGE_MAX                         = 6,
};

// Enum Project.E_BTL_CURE
// NumValues: 0x0004
enum class E_BTL_CURE : uint8
{
	E_BTL_CURE_NORMAL                        = 0,
	E_BTL_CURE_DRAIN                         = 1,
	E_BTL_CURE_ABSORB                        = 2,
	E_BTL_CURE_MAX                           = 3,
};

// Enum Project.E_BTL_AI_STATE
// NumValues: 0x0004
enum class E_BTL_AI_STATE : uint8
{
	E_BTL_AI_STATE_NONE                      = 0,
	E_BTL_AI_STATE_START                     = 1,
	E_BTL_AI_STATE_FINISH                    = 2,
	E_BTL_AI_STATE_MAX                       = 3,
};

// Enum Project.E_BTL_ACT_TYPE
// NumValues: 0x0009
enum class E_BTL_ACT_TYPE : uint8
{
	E_BTL_ACT_TYPE_NORMAL                    = 0,
	E_BTL_ACT_TYPE_CONFUSE                   = 1,
	E_BTL_ACT_TYPE_CHARM                     = 2,
	E_BTL_ACT_TYPE_BUDDY                     = 3,
	E_BTL_ACT_TYPE_COUNTER                   = 4,
	E_BTL_ACT_TYPE_PARTNER                   = 5,
	E_BTL_ACT_TYPE_DEADSCRIPT                = 6,
	E_BTL_ACT_TYPE_WEAKDMG_AID               = 7,
	E_BTL_ACT_TYPE_MAX                       = 8,
};

// Enum Project.E_BTL_ACT_STAT
// NumValues: 0x001C
enum class E_BTL_ACT_STAT : uint8
{
	E_BTL_ACT_STAT_EFFLOAD                   = 0,
	E_BTL_ACT_STAT_NEXTSEQ                   = 1,
	E_BTL_ACT_STAT_DAZZLE_CHANGE             = 2,
	E_BTL_ACT_STAT_CLOSE_EXEC                = 3,
	E_BTL_ACT_STAT_COMM_BEFORE               = 4,
	E_BTL_ACT_STAT_BADSTATUS                 = 5,
	E_BTL_ACT_STAT_LOCK                      = 6,
	E_BTL_ACT_STAT_AUTO                      = 7,
	E_BTL_ACT_STAT_ATTACKUP                  = 8,
	E_BTL_ACT_STAT_MISS_BLOCK_ABS            = 9,
	E_BTL_ACT_STAT_STOCKSEL                  = 10,
	E_BTL_ACT_STAT_CANCEL                    = 11,
	E_BTL_ACT_STAT_WEAK_AUTO                 = 12,
	E_BTL_ACT_STAT_ESC_SKILL                 = 13,
	E_BTL_ACT_STAT_CHANGE_ACTOR              = 14,
	E_BTL_ACT_STAT_NO_ACT_FINISH             = 15,
	E_BTL_ACT_STAT_POISONDEAD                = 16,
	E_BTL_ACT_STAT_USED_PRESSITEM            = 17,
	E_BTL_ACT_STAT_COUNTER_AFTER             = 18,
	E_BTL_ACT_STAT_NAKAMA_WAIT               = 19,
	E_BTL_ACT_STAT_NOT_SUMMON                = 20,
	E_BTL_ACT_STAT_BUTUATK                   = 21,
	E_BTL_ACT_STAT_EXCHANGE_HERO             = 22,
	E_BTL_ACT_STAT_KAIFUKU                   = 23,
	E_BTL_ACT_STAT_MAGIC                     = 24,
	E_BTL_ACT_STAT_ITEM                      = 25,
	E_BTL_ACT_STAT_SUMMON                    = 26,
	E_BTL_ACT_STAT_MAX                       = 27,
};

// Enum Project.E_BTL_ACT_SEQ
// NumValues: 0x002F
enum class E_BTL_ACT_SEQ : uint8
{
	E_BTL_ACT_SEQ_NON                        = 0,
	E_BTL_ACT_SEQ_COMM                       = 1,
	E_BTL_ACT_SEQ_AI                         = 2,
	E_BTL_ACT_SEQ_DEBUG_AI                   = 3,
	E_BTL_ACT_SEQ_PARTNER_NKM                = 4,
	E_BTL_ACT_SEQ_BAD                        = 5,
	E_BTL_ACT_SEQ_TARSEL                     = 6,
	E_BTL_ACT_SEQ_STKSEL                     = 7,
	E_BTL_ACT_SEQ_SMN_SEL                    = 8,
	E_BTL_ACT_SEQ_CHECK_UNITE                = 9,
	E_BTL_ACT_SEQ_UNITE_SUMMON               = 10,
	E_BTL_ACT_SEQ_READY                      = 11,
	E_BTL_ACT_SEQ_SKILL                      = 12,
	E_BTL_ACT_SEQ_SKILL_ACTION               = 13,
	E_BTL_ACT_SEQ_TALK                       = 14,
	E_BTL_ACT_SEQ_TALKRESULT                 = 15,
	E_BTL_ACT_SEQ_BADWAIT                    = 16,
	E_BTL_ACT_SEQ_HEROWAIT                   = 17,
	E_BTL_ACT_SEQ_TURNPREVSKILL_WAIT         = 18,
	E_BTL_ACT_SEQ_CLOSEWAIT                  = 19,
	E_BTL_ACT_SEQ_WAIT                       = 20,
	E_BTL_ACT_SEQ_ESCAPE                     = 21,
	E_BTL_ACT_SEQ_RETURN                     = 22,
	E_BTL_ACT_SEQ_WEAKDMG_AID                = 23,
	E_BTL_ACT_SEQ_ANALYZE                    = 24,
	E_BTL_ACT_SEQ_CONTINUE                   = 25,
	E_BTL_ACT_SEQ_INVISIBLE                  = 26,
	E_BTL_ACT_SEQ_EVENT_ACTSTART             = 27,
	E_BTL_ACT_SEQ_RESERVE1                   = 28,
	E_BTL_ACT_SEQ_RESERVE2                   = 29,
	E_BTL_ACT_SEQ_DEADSCRIPT                 = 30,
	E_BTL_ACT_SEQ_UNION_BREAK_SELF           = 31,
	E_BTL_ACT_SEQ_CHECK7                     = 32,
	E_BTL_ACT_SEQ_EVENT_ACTEND               = 33,
	E_BTL_ACT_SEQ_POST                       = 34,
	E_BTL_ACT_SEQ_ACTOR_CHANGE               = 35,
	E_BTL_ACT_SEQ_CHECK1                     = 36,
	E_BTL_ACT_SEQ_CHECK2                     = 37,
	E_BTL_ACT_SEQ_CHECK3                     = 38,
	E_BTL_ACT_SEQ_END                        = 39,
	E_BTL_ACT_SEQ_COUNTER_WAIT               = 40,
	E_BTL_ACT_SEQ_PARTNER_WAIT               = 41,
	E_BTL_ACT_SEQ_BUDDY_WAIT                 = 42,
	E_BTL_ACT_SEQ_UNION_WAIT                 = 43,
	E_BTL_ACT_SEQ_AUTO_PASS                  = 44,
	E_BTL_ACT_SEQ_INVALID                    = 45,
	E_BTL_ACT_SEQ_MAX                        = 46,
};

// Enum Project.E_SKILL_TEKISEI_CATEGORY
// NumValues: 0x000E
enum class E_SKILL_TEKISEI_CATEGORY : uint8
{
	E_SKILL_TEKISEI_CATEGORY_PHISICS         = 0,
	E_SKILL_TEKISEI_CATEGORY_FIRE            = 1,
	E_SKILL_TEKISEI_CATEGORY_ICE             = 2,
	E_SKILL_TEKISEI_CATEGORY_THUNDER         = 3,
	E_SKILL_TEKISEI_CATEGORY_WIND            = 4,
	E_SKILL_TEKISEI_CATEGORY_LIGHT           = 5,
	E_SKILL_TEKISEI_CATEGORY_DARK            = 6,
	E_SKILL_TEKISEI_CATEGORY_ALL             = 7,
	E_SKILL_TEKISEI_CATEGORY_NODAMAGE_ATK    = 8,
	E_SKILL_TEKISEI_CATEGORY_AID             = 9,
	E_SKILL_TEKISEI_CATEGORY_RECOVERY_HP     = 10,
	E_SKILL_TEKISEI_CATEGORY_RECOVERY_NA     = 11,
	E_SKILL_TEKISEI_CATEGORY_MAX             = 12,
	E_SKILL_TEKISEI_CATEGORY_INVALID         = 13,
};

// Enum Project.E_ATTRIBUTE_TYPE
// NumValues: 0x0021
enum class E_ATTRIBUTE_TYPE : uint8
{
	E_ATTRIBUTE_TYPE_PHISICS                 = 0,
	E_ATTRIBUTE_TYPE_FIRE                    = 1,
	E_ATTRIBUTE_TYPE_ICE                     = 2,
	E_ATTRIBUTE_TYPE_THUNDER                 = 3,
	E_ATTRIBUTE_TYPE_WIND                    = 4,
	E_ATTRIBUTE_TYPE_LIGHT                   = 5,
	E_ATTRIBUTE_TYPE_DARK                    = 6,
	E_ATTRIBUTE_TYPE_ALL                     = 7,
	E_ATTRIBUTE_TYPE_POISON                  = 8,
	E_ATTRIBUTE_TYPE_VERTIGO                 = 9,
	E_ATTRIBUTE_TYPE_CONFUSE                 = 10,
	E_ATTRIBUTE_TYPE_CHARM                   = 11,
	E_ATTRIBUTE_TYPE_SLEEP                   = 12,
	E_ATTRIBUTE_TYPE_CLOSE                   = 13,
	E_ATTRIBUTE_TYPE_STRAY                   = 14,
	E_ATTRIBUTE_TYPE_BURN                    = 15,
	E_ATTRIBUTE_TYPE_FREEZE                  = 16,
	E_ATTRIBUTE_TYPE_SHOCK                   = 17,
	E_ATTRIBUTE_TYPE_LACERATION              = 18,
	E_ATTRIBUTE_TYPE_STONE                   = 19,
	E_ATTRIBUTE_TYPE_DAZZLE                  = 20,
	E_ATTRIBUTE_TYPE_MUD                     = 21,
	E_ATTRIBUTE_TYPE_DARKNESS                = 22,
	E_ATTRIBUTE_TYPE_RECV02                  = 23,
	E_ATTRIBUTE_TYPE_RECV03                  = 24,
	E_ATTRIBUTE_TYPE_RECV04                  = 25,
	E_ATTRIBUTE_TYPE_RECV05                  = 26,
	E_ATTRIBUTE_TYPE_RECV06                  = 27,
	E_ATTRIBUTE_TYPE_MAX                     = 28,
	E_ATTRIBUTE_TYPE_RECOVERLY               = 29,
	E_ATTRIBUTE_TYPE_ALL_ATK                 = 30,
	E_ATTRIBUTE_TYPE_MAGIC                   = 31,
	E_ATTRIBUTE_TYPE_INVALID                 = 32,
};

// Enum Project.E_BTL_ATTR
// NumValues: 0x0005
enum class E_BTL_ATTR : uint8
{
	E_BTL_LOW                                = 0,
	E_BTL_NEUTRAL                            = 1,
	E_BTL_CHAOS                              = 2,
	E_BTL_ATTR_MAX                           = 3,
	E_BTL_MAX                                = 4,
};

// Enum Project.E_BTL_STEP
// NumValues: 0x0025
enum class E_BTL_STEP : uint8
{
	E_BTL_STEP_NONE                          = 0,
	E_BTL_STEP_DEBUG1                        = 1,
	E_BTL_STEP_READY                         = 2,
	E_BTL_STEP_PRE                           = 3,
	E_BTL_STEP_ENCOUNT                       = 4,
	E_BTL_STEP_START_EVENT                   = 5,
	E_BTL_STEP_TURN_CHANGE                   = 6,
	E_BTL_STEP_TURN_START_EVENT              = 7,
	E_BTL_STEP_UPLIFTING_TURN                = 8,
	E_BTL_STEP_ENEMY_TURNSTART_RETURN        = 9,
	E_BTL_STEP_PRESS_PRE                     = 10,
	E_BTL_STEP_ACTION_PRE                    = 11,
	E_BTL_STEP_ACTION                        = 12,
	E_BTL_STEP_ACTION_EVENT                  = 13,
	E_BTL_STEP_ACTION_AFTER                  = 14,
	E_BTL_STEP_CHECK_END                     = 15,
	E_BTL_STEP_CHECK_TURN                    = 16,
	E_BTL_STEP_TURN_END                      = 17,
	E_BTL_STEP_TURN_END_EVENT                = 18,
	E_BTL_STEP_ENEMY_UPLIFTING               = 19,
	E_BTL_STEP_ENEMY_TURNEND_RETURN          = 20,
	E_BTL_STEP_RENZOKU                       = 21,
	E_BTL_STEP_INOCHIGOI                     = 22,
	E_BTL_STEP_MERCY_TALK                    = 23,
	E_BTL_STEP_END_EVENT                     = 24,
	E_BTL_STEP_POST                          = 25,
	E_BTL_STEP_RESULT                        = 26,
	E_BTL_STEP_TALK_END_FRIEND               = 27,
	E_BTL_STEP_ESCAPE                        = 28,
	E_BTL_STEP_GAMEOVER                      = 29,
	E_BTL_STEP_END                           = 30,
	E_BTL_STEP_FINISH_WAIT                   = 31,
	E_BTL_STEP_DEBUG2                        = 32,
	E_BTL_STEP_EDITOR                        = 33,
	E_BTL_STEP_VALID_MAX                     = 34,
	E_BTL_STEP_INVALID                       = 35,
	E_BTL_STEP_MAX                           = 36,
};

// Enum Project.E_BENEFIT_ROUTE
// NumValues: 0x0007
enum class E_BENEFIT_ROUTE : uint8
{
	E_BENEFIT_ROUTE_PLAY                     = 0,
	E_BENEFIT_ROUTE_LAW                      = 1,
	E_BENEFIT_ROUTE_CHAOS                    = 2,
	E_BENEFIT_ROUTE_NEWTRAL                  = 3,
	E_BENEFIT_ROUTE_NEWTRAL_EX               = 4,
	E_BENEFIT_ROUTE_ALL                      = 5,
	E_BENEFIT_ROUTE_MAX                      = 6,
};

// Enum Project.E_CHARAPANEL_SUPPORTICON_TYPE
// NumValues: 0x0022
enum class E_CHARAPANEL_SUPPORTICON_TYPE : uint8
{
	CP_SUPPORTICON_TYPE_NONE                 = 0,
	CP_SUPPORTICON_TYPE_ATTACK_UP1           = 1,
	CP_SUPPORTICON_TYPE_ATTACK_UP2           = 2,
	CP_SUPPORTICON_TYPE_DEFENCE_UP1          = 3,
	CP_SUPPORTICON_TYPE_DEFENCE_UP2          = 4,
	CP_SUPPORTICON_TYPE_AVOID_UP1            = 5,
	CP_SUPPORTICON_TYPE_AVOID_UP2            = 6,
	CP_SUPPORTICON_TYPE_ATTACK_DOWN1         = 7,
	CP_SUPPORTICON_TYPE_ATTACK_DOWN2         = 8,
	CP_SUPPORTICON_TYPE_DEFENCE_DOWN1        = 9,
	CP_SUPPORTICON_TYPE_DEFENCE_DOWN2        = 10,
	CP_SUPPORTICON_TYPE_AVOID_DOWN1          = 11,
	CP_SUPPORTICON_TYPE_AVOID_DOWN2          = 12,
	CP_SUPPORTICON_TYPE_REFLECTION_PHYSICS   = 13,
	CP_SUPPORTICON_TYPE_REFLECTION_MAGIC     = 14,
	CP_SUPPORTICON_TYPE_AVOIDDEATH           = 15,
	CP_SUPPORTICON_TYPE_CHARGE_PHYSICS       = 16,
	CP_SUPPORTICON_TYPE_CHARGE_MAGIC         = 17,
	CP_SUPPORTICON_TYPE_CHARGE_CRITICAL      = 18,
	CP_SUPPORTICON_TYPE_CHARGE_RECOVERY      = 19,
	CP_SUPPORTICON_TYPE_CHARGE_DISABLE       = 20,
	CP_SUPPORTICON_TYPE_PROVOKE              = 21,
	CP_SUPPORTICON_TYPE_BARRIER_PHYSICS      = 22,
	CP_SUPPORTICON_TYPE_BARRIER_FIRE         = 23,
	CP_SUPPORTICON_TYPE_BARRIER_ICE          = 24,
	CP_SUPPORTICON_TYPE_BARRIER_THUNDER      = 25,
	CP_SUPPORTICON_TYPE_BARRIER_WIND         = 26,
	CP_SUPPORTICON_TYPE_BARRIER_LIGHT        = 27,
	CP_SUPPORTICON_TYPE_BARRIER_DARK         = 28,
	CP_SUPPORTICON_TYPE_BARRIER_ALLCUT       = 29,
	CP_SUPPORTICON_TYPE_MAGATOKI             = 30,
	CP_SUPPORTICON_TYPE_RENGEKI              = 31,
	CP_SUPPORTICON_TYPE_A_AVOID              = 32,
	CP_SUPPORTICON_TYPE_MAX                  = 33,
};

// Enum Project.E_TITLE_TOP_SELECTION
// NumValues: 0x0008
enum class E_TITLE_TOP_SELECTION : uint8
{
	E_TITLE_TOP_SELECTION_NEWGAME            = 0,
	E_TITLE_TOP_SELECTION_LOADGAME           = 1,
	E_TITLE_TOP_SELECTION_OPTIONS            = 2,
	E_TITLE_TOP_SELECTION_COPYRIGHT          = 3,
	E_TITLE_TOP_SELECTION_CONVERT            = 4,
	E_TITLE_TOP_SELECTION_END                = 5,
	E_TITLE_TOP_SELECTION_TIMEOUT            = 6,
	E_TITLE_TOP_SELECTION_MAX                = 7,
};

// Enum Project.E_BTN_HELP_UI_STATE
// NumValues: 0x0006
enum class E_BTN_HELP_UI_STATE : uint8
{
	NOT_ACTIVE                               = 0,
	FRAME_IN                                 = 1,
	ACTIVE                                   = 2,
	FRAME_OUT                                = 3,
	FRAME_OUT_CHANGE                         = 4,
	E_BTN_HELP_UI_MAX                        = 5,
};

// Enum Project.E_BTN_HELP_MSG_TYPE
// NumValues: 0x0087
enum class E_BTN_HELP_MSG_TYPE : uint8
{
	E_BTN_HELP_MSG_TYPE_NONE                 = 0,
	E_BTN_HELP_MSG_TYPE_ACTION               = 1,
	E_BTN_HELP_MSG_TYPE_CANCEL               = 2,
	E_BTN_HELP_MSG_TYPE_COMMENT              = 3,
	E_BTN_HELP_MSG_TYPE_SKILL_VIEW           = 4,
	E_BTN_HELP_MSG_TYPE_CHANGE               = 5,
	E_BTN_HELP_MSG_TYPE_SUMMON               = 6,
	E_BTN_HELP_MSG_TYPE_SORT                 = 7,
	E_BTN_HELP_MSG_TYPE_STATUS               = 8,
	E_BTN_HELP_MSG_TYPE_DELETE               = 9,
	E_BTN_HELP_MSG_TYPE_C_CLOSE              = 10,
	E_BTN_HELP_MSG_TYPE_CHANGE_TAB           = 11,
	E_BTN_HELP_MSG_TYPE_AUTO                 = 12,
	E_BTN_HELP_MSG_TYPE_SKIP                 = 13,
	E_BTN_HELP_MSG_TYPE_BACKLOG              = 14,
	E_BTN_HELP_MSG_TYPE_ESCAPE               = 15,
	E_BTN_HELP_MSG_TYPE_END                  = 16,
	E_BTN_HELP_MSG_TYPE_SUGGEST              = 17,
	E_BTN_HELP_MSG_TYPE_SOZAI                = 18,
	E_BTN_HELP_MSG_TYPE_SEARCH               = 19,
	E_BTN_HELP_MSG_TYPE_SKILL_LIB            = 20,
	E_BTN_HELP_MSG_TYPE_ENTRY_ALL            = 21,
	E_BTN_HELP_MSG_TYPE_ORIGIN               = 22,
	E_BTN_HELP_MSG_TYPE_CUSTOM               = 23,
	E_BTN_HELP_MSG_TYPE_ALL                  = 24,
	E_BTN_HELP_MSG_TYPE_SKIP2                = 25,
	E_BTN_HELP_MSG_TYPE_RESET                = 26,
	E_BTN_HELP_MSG_TYPE_INHERIT_SKILL        = 27,
	E_BTN_HELP_MSG_TYPE_EXIT                 = 28,
	E_BTN_HELP_MSG_TYPE_CAMP                 = 29,
	E_BTN_HELP_MSG_TYPE_BACK                 = 30,
	E_BTN_HELP_MSG_TYPE_ALLREMOVE            = 31,
	E_BTN_HELP_MSG_TYPE_MASTER               = 32,
	E_BTN_HELP_MSG_TYPE_LEARNING             = 33,
	E_BTN_HELP_MSG_TYPE_NAHOBINO             = 34,
	E_BTN_HELP_MSG_TYPE_DAUBLE               = 35,
	E_BTN_HELP_MSG_TYPE_PARAM_SET            = 36,
	E_BTN_HELP_MSG_TYPE_HERO_CHANGE          = 37,
	E_BTN_HELP_MSG_TYPE_MAG_INJECT           = 38,
	E_BTN_HELP_MSG_TYPE_SPEEDDOWN            = 39,
	E_BTN_HELP_MSG_TYPE_OLDCAMP_START        = 40,
	E_BTN_HELP_MSG_TYPE_OPEN_CONDITION       = 41,
	E_BTN_HELP_MSG_TYPE_APPLY                = 42,
	E_BTN_HELP_MSG_TYPE_ASCENDING            = 43,
	E_BTN_HELP_MSG_TYPE_DESCENDING           = 44,
	E_BTN_HELP_MSG_TYPE_ALLBUY               = 45,
	E_BTN_HELP_MSG_TYPE_ZOOM                 = 46,
	E_BTN_HELP_MSG_TYPE_AUTOMAP_RESET        = 47,
	E_BTN_HELP_MSG_TYPE_ICON_HELP            = 48,
	E_BTN_HELP_MSG_TYPE_MAP_SELECT           = 49,
	E_BTN_HELP_MSG_TYPE_PLACE_NAME           = 50,
	E_BTN_HELP_MSG_TYPE_FAST_FORWARD         = 51,
	E_BTN_HELP_MSG_TYPE_NOT_SKILL_ADD        = 52,
	E_BTN_HELP_MSG_TYPE_MW_OFF               = 53,
	E_BTN_HELP_MSG_TYPE_AUTO_BATTLE          = 54,
	E_BTN_HELP_MSG_TYPE_AUTO_BATTLE_END      = 55,
	E_BTN_HELP_MSG_TYPE_STATUS_CHECK         = 56,
	E_BTN_HELP_MSG_TYPE_STATUS_DISPLAY       = 57,
	E_BTN_HELP_MSG_TYPE_OPTION               = 58,
	E_BTN_HELP_MSG_TYPE_INITIALIZE           = 59,
	E_BTN_HELP_MSG_TYPE_BASIC_INFORMASION    = 60,
	E_BTN_HELP_MSG_TYPE_PREVIOUS_PAGE        = 61,
	E_BTN_HELP_MSG_TYPE_NEXT_PAGE            = 62,
	E_BTN_HELP_MSG_TYPE_SKILL_CHECK          = 63,
	E_BTN_HELP_MSG_TYPE_BULK_RECOVERY        = 64,
	E_BTN_HELP_MSG_TYPE_CHECK_LOG            = 65,
	E_BTN_HELP_MSG_TYPE_JUMP                 = 66,
	E_BTN_HELP_MSG_TYPE_ATTACK               = 67,
	E_BTN_HELP_MSG_TYPE_AUTOMAP              = 68,
	E_BTN_HELP_MSG_TYPE_CONFIRMATION_PURPOSE = 69,
	E_BTN_HELP_MSG_TYPE_SAVE                 = 70,
	E_BTN_HELP_MSG_TYPE_LOAD                 = 71,
	E_BTN_HELP_MSG_TYPE_ROTATION             = 72,
	E_BTN_HELP_MSG_TYPE_DISPLAY_ON           = 73,
	E_BTN_HELP_MSG_TYPE_DISPLAY_OFF          = 74,
	E_BTN_HELP_MSG_TYPE_COMMENTARY           = 75,
	E_BTN_HELP_MSG_TYPE_OTHER_INFO           = 76,
	E_BTN_HELP_MSG_TYPE_PARTY_SORT           = 77,
	E_BTN_HELP_MSG_TYPE_TURN_TO_NEXT         = 78,
	E_BTN_HELP_MSG_TYPE_SCROLL               = 79,
	E_BTN_HELP_MSG_TYPE_NEXT_AREA            = 80,
	E_BTN_HELP_MSG_TYPE_PREV_AREA            = 81,
	E_BTN_HELP_MSG_TYPE_PLACE_ON             = 82,
	E_BTN_HELP_MSG_TYPE_PLACE_OFF            = 83,
	E_BTN_HELP_MSG_TYPE_STATUS_LIST          = 84,
	E_BTN_HELP_MSG_TYPE_DETAILED_CONFIRMATION = 85,
	E_BTN_HELP_MSG_TYPE_ASCENDIN_AND_DESCENDING = 86,
	E_BTN_HELP_MSG_TYPE_COMPATIBILITY        = 87,
	E_BTN_HELP_MSG_TYPE_AUTO_HEAL            = 88,
	E_BTN_HELP_MSG_TYPE_TRAPORT              = 89,
	E_BTN_HELP_MSG_TYPE_ESTOMA               = 90,
	E_BTN_HELP_MSG_TYPE_TOP_CAMERA           = 91,
	E_BTN_HELP_MSG_TYPE_FUSION               = 92,
	E_BTN_HELP_MSG_TYPE_SKILL_VIEW1          = 93,
	E_BTN_HELP_MSG_TYPE_SKILL_VIEW2          = 94,
	E_BTN_HELP_MSG_TYPE_PREVIOUS_STOCK       = 95,
	E_BTN_HELP_MSG_TYPE_NEXT_STOCK           = 96,
	E_BTN_HELP_MSG_TYPE_SKILL_INHERIT        = 97,
	E_BTN_HELP_MSG_TYPE_MAGATUHI_SKILL       = 98,
	E_BTN_HELP_MSG_TYPE_SKILL_INHERIT_CANCEL = 99,
	E_BTN_HELP_MSG_TYPE_DATA_CHANGE          = 100,
	E_BTN_HELP_MSG_TYPE_MOVE_CAMERA          = 101,
	E_BTN_HELP_MSG_TYPE_ICON_ON              = 102,
	E_BTN_HELP_MSG_TYPE_ICON_OFF             = 103,
	E_BTN_HELP_MSG_TYPE_SAVE_SHORTCUT        = 104,
	E_BTN_HELP_MSG_TYPE_FREECAM_BEGIN        = 105,
	E_BTN_HELP_MSG_TYPE_FREECAM_END          = 106,
	E_BTN_HELP_MSG_TYPE_FREECAM_V_UP         = 107,
	E_BTN_HELP_MSG_TYPE_FREECAM_V_DOWN       = 108,
	E_BTN_HELP_MSG_TYPE_FREECAM_MOVE         = 109,
	E_BTN_HELP_MSG_TYPE_FREECAM_ROTATION     = 110,
	E_BTN_HELP_MSG_TYPE_INITIALIZE_ONE       = 111,
	E_BTN_HELP_MSG_TYPE_INITIALIZE_ALL       = 112,
	E_BTN_HELP_MSG_TYPE_DETAIL_DESCRIPTION   = 113,
	E_BTN_HELP_MSG_TYPE_KEY_CHANGE           = 114,
	E_BTN_HELP_MSG_TYPE_MISSON_DESTINATION   = 115,
	E_BTN_HELP_MSG_TYPE_SHOP_UTSUSEMI_SKILL  = 116,
	E_BTN_HELP_MSG_TYPE_GARDEN_TRIBUTE       = 117,
	E_BTN_HELP_MSG_TYPE_MOVIE_SKIP           = 118,
	E_BTN_HELP_MSG_TYPE_CAMP_HELP_SELECT     = 119,
	E_BTN_HELP_MSG_TYPE_CAMP_UTSUSEMI_SKILL_SEARCH = 120,
	E_BTN_HELP_MSG_TYPE_KAMUI_ON_OFF         = 121,
	E_BTN_HELP_MSG_TYPE_OPTION_UNSET         = 122,
	E_BTN_HELP_MSG_TYPE_QUEST_INTERRUPTION   = 123,
	E_BTN_HELP_MSG_TYPE_TOP_CAMERA_RESET     = 124,
	E_BTN_HELP_MSG_TYPE_MISSON_REPORT_PLACE  = 125,
	E_BTN_HELP_MSG_TYPE_LARGEMAP_FREECAM     = 126,
	E_BTN_HELP_MSG_TYPE_FREECAM_FASTMOVE     = 127,
	E_BTN_HELP_MSG_TYPE_FREECAM_SLOWMOVE     = 128,
	E_BTN_HELP_MSG_TYPE_CAMP_MULTIPLE_ITEM   = 129,
	E_BTN_HELP_MSG_TYPE_SET_LANDMARK         = 130,
	E_BTN_HELP_MSG_TYPE_CHECK_MAGATSURO      = 131,
	E_BTN_HELP_MSG_TYPE_SET_LANDMARK_CANCEL  = 132,
	E_BTN_HELP_MSG_TYPE_SET_LANDMARK_PUT     = 133,
	E_BTN_HELP_MSG_TYPE_MAX                  = 134,
};

// Enum Project.E_BTN_HELP_SET
// NumValues: 0x00C5
enum class E_BTN_HELP_SET : uint8
{
	E_BTN_HELP_SET_DUMMY                     = 0,
	E_BTN_HELP_SET_CAMP_COMMON_MESSEL        = 1,
	E_BTN_HELP_SET_CAMP_TOP                  = 2,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL          = 3,
	E_BTL_HELP_SET_CAMP_TAR_SEL              = 4,
	E_BTN_HELP_SET_CAMP_SUMMON               = 5,
	E_BTN_HELP_SET_CAMP_SORT                 = 6,
	E_BTN_HELP_SET_CAMP_STATUS               = 7,
	E_BTN_HELP_SET_CAMP_STATUS_PARAM_SET_ON  = 8,
	E_BTN_HELP_SET_CAMP_STATUS_DOUBLE        = 9,
	E_BTN_HELP_SET_CAMP_STATUS_NAHOBINO      = 10,
	E_BTN_HELP_SET_CAMP_STATUS_PARAM_SET     = 11,
	E_BTN_HELP_SET_CAMP_DEVIL_COMMENT_VIEW   = 12,
	E_BTN_HELP_SET_CAMP_SKILL_SKILL_SEL      = 13,
	E_BTN_HELP_SET_CAMP_SKILL_TAR_SEL        = 14,
	E_BTN_HELP_SET_CAMP_ITEM_ITEM_SEL        = 15,
	E_BTN_HELP_SET_CAMP_ITEM_TAR_SEL         = 16,
	E_BTN_HELP_SET_CAMP_PROPERTY_LIST_SEL    = 17,
	E_BTN_HELP_SET_CAMP_SKILL_LIB_LIST_MASTER = 18,
	E_BTN_HELP_SET_CAMP_SKILL_LIB_LIST_LEARNING = 19,
	E_BTN_HELP_SET_CAMP_LOG_NONE             = 20,
	E_BTN_HELP_SET_CAMP_LOG_LIST_SEL         = 21,
	E_BTN_HELP_SET_CAMP_LOG_LIST_SEL_ACT     = 22,
	E_BTN_HELP_SET_CAMP_LOG_MES_SEL          = 23,
	E_BTN_HELP_SET_EVENT_NORMAL              = 24,
	E_BTN_HELP_SET_EVENT_CHOICE              = 25,
	E_BTN_HELP_SET_BTL_CHARA_SELECT          = 26,
	E_BTN_HELP_SET_BTL_SUMMON_1              = 27,
	E_BTN_HELP_SET_BTL_SUMMON_1_END          = 28,
	E_BTN_HELP_SET_BTL_SUMMON_2              = 29,
	E_BTN_HELP_SET_BTL_CONDITION             = 30,
	E_BTN_HELP_SET_BTL_CONDITION_STATUS      = 31,
	E_BTN_HELP_SET_BTL_CONDITION_SKILLVIEW   = 32,
	E_BTN_HELP_SET_BTL_STATUS_HERO_CHANGE    = 33,
	E_BTN_HELP_SET_UNITE_PANEL_STATUS        = 34,
	E_BTN_HELP_SET_UNITE_PANEL_SKILL1        = 35,
	E_BTN_HELP_SET_UNITE_PANEL_SKILL2        = 36,
	E_BTN_HELP_SET_UNITE_PANEL_STATUS_STOCK  = 37,
	E_BTN_HELP_SET_UNITE_PANEL_SKILL1_STOCK  = 38,
	E_BTN_HELP_SET_UNITE_PANEL_SKILL2_STOCK  = 39,
	E_BTN_HELP_SET_UNITE_PANEL_STATUS_PAGE   = 40,
	E_BTN_HELP_SET_UNITE_PANEL_SKILL1_PAGE   = 41,
	E_BTN_HELP_SET_UNITE_PANEL_SKILL2_PAGE   = 42,
	E_BTN_HELP_SET_UNITE_UTSUSEMI_SKILL      = 43,
	E_BTN_HELP_SET_UNITE_UTSUSEMI_DEFENCE    = 44,
	E_BTN_HELP_SET_UNITE_UTSUSEMI_SKILL_PAGE = 45,
	E_BTN_HELP_SET_UNITE_UTSUSEMI_DEFENCE_PAGE = 46,
	E_BTN_HELP_SET_FACILITY_COMMON           = 47,
	E_BTN_HELP_SET_FACILITY_TOP              = 48,
	E_BTN_HELP_SET_FACILITY_SHOP_BUY         = 49,
	E_BTN_HELP_SET_SYS_TUTORIAL              = 50,
	E_BTN_HELP_SET_MAP_DOUBLE                = 51,
	E_BTN_HELP_SET_MAP_NAHOBINO              = 52,
	E_BTN_HELP_SET_MAP_MAG_INJECT            = 53,
	E_BTN_HELP_SET_MIMAN_TOP                 = 54,
	E_BTN_HELP_SET_MIMAN_MENU_COMMON         = 55,
	E_BTN_HELP_SET_NEW_CAMP_TOP              = 56,
	E_BTN_HELP_SET_SORT_APPLY                = 57,
	E_BTN_HELP_SET_SORT_ASCENDING            = 58,
	E_BTN_HELP_SET_SORT_DESCENDING           = 59,
	E_BTN_HELP_SET_SHOP_BUY                  = 60,
	E_BTN_HELP_SET_SHOP_SELL_RELIC           = 61,
	E_BTN_HELP_SET_AUTOMAP                   = 62,
	E_BTN_HELP_SET_TOKYO_LARGEMAP_PLACE_OFF  = 63,
	E_BTN_HELP_SET_RESULT_LEVELUP            = 64,
	E_BTN_HELP_SET_RESULT_SKILL              = 65,
	E_BTN_HELP_SET_RESULT_POINT              = 66,
	E_BTN_HELP_SET_MESSAGE_WINDOW            = 67,
	E_BTN_HELP_SET_COMMAAD_SELECT            = 68,
	E_BTN_HELP_SET_SKILL_ITEM_TARGET_SELECT  = 69,
	E_BTN_HELP_SET_CHARACTER_ACTION          = 70,
	E_BTN_HELP_SET_SUMMON_TARGET_SELECT_SCROLL = 71,
	E_BTN_HELP_SET_STATUS_CHECK_SCROLL       = 72,
	E_BTN_HELP_SET_STATUS_OPTION             = 73,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_SRC_SKILLVIEW1_SCROLL = 74,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_SRC_SKILLVIEW2_SCROLL = 75,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_DST_SKILLVIEW1_SCROLL = 76,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_DST_SKILLVIEW2_SCROLL = 77,
	E_BTN_HELP_SET_CAMP_ANALYZE_SCROLL_SKILLVIEW1 = 78,
	E_BTN_HELP_SET_CAMP_ANALYZE_SCROLL_SKILLVIEW2 = 79,
	E_BTN_HELP_SET_CAMP_ANALYZE_SKILLVIWE1   = 80,
	E_BTN_HELP_SET_CAMP_ANALYZE_SKILLVIWE2   = 81,
	E_BTN_HELP_SET_CAMP_ANALYZE_EMPTY_SKILLVIWE1 = 82,
	E_BTN_HELP_SET_CAMP_ANALYZE_EMPTY_SKILLVIWE2 = 83,
	E_BTN_HELP_SET_CAMP_UTSUSEMI_SCROLL_BASE = 84,
	E_BTN_HELP_SET_CAMP_UTSUSEMI_BASE        = 85,
	E_BTN_HELP_SET_CAMP_UTSUSEMI_SKILL_RET   = 86,
	E_BTN_HELP_SET_RECOVERY_FACILITY_BASE_SCROLL = 87,
	E_BTN_HELP_SET_RECOVERY_FACILITY_SKILL_SCROLL = 88,
	E_BTN_HELP_SET_CAMP_QUEST                = 89,
	E_BTN_HELP_SET_MAP_FREE                  = 90,
	E_BTN_HELP_SET_TOKYO_MAP_FREE            = 91,
	E_BTN_HELP_SET_AUTOMAP_BAN_MAP_FREE      = 92,
	E_BTN_HELP_SET_NO_TRAPORT_MAP_FREE       = 93,
	E_BTN_HELP_SET_CAMP_AUTOMAP_BAN_MAP_FREE = 94,
	E_BTN_HELP_SET_CAMP_BAN_TOKYO_LARGEMAP_PLACE_OFF = 95,
	E_BTN_HELP_SET_SAVELOAD_SAVE             = 96,
	E_BTN_HELP_SET_SAVELOAD_LOAD             = 97,
	E_BTN_HELP_SET_CAMP_PARTY_STATUS_SKIL    = 98,
	E_BTN_HELP_SET_CAMP_PARTY_STATUS_SKIL_SORT = 99,
	E_BTN_HELP_SET_CAMP_PARTY_STATUS_OTHER_INFO = 100,
	E_BTN_HELP_SET_CAMP_PARTY_STATUS_COMMENTARYL = 101,
	E_BTN_HELP_SET_CAMP_PARTY_APPRECIATION   = 102,
	E_BTN_HELP_SET_CAMP_ANALYZE_STATUS_SKILL = 103,
	E_BTN_HELP_SET_RESULT_TOP_NEXT           = 104,
	E_BTN_HELP_SET_TOKYO_LARGEMAP_PLACE_ON   = 105,
	E_BTN_HELP_SET_CAMP_BAN_TOKYO_LARGEMAP_PLACE_ON = 106,
	E_BTN_HELP_SET_SORT_ASCENDING_AND_DESCENDING = 107,
	E_BTN_HELP_SET_CAMP_UTSUSEMI_SCROLL_SKILL = 108,
	E_BTN_HELP_SET_CAMP_UTSUSEMI_SKILL       = 109,
	E_BTN_HELP_SET_SKILL_ITEM_TARGET_SELECT_NEXT = 110,
	E_BTN_HELP_SET_SAVELOAD_SAVE_ON_THE_WAT  = 111,
	E_BTN_HELP_SET_UNITE_SKILLINHERIT_END    = 112,
	E_BTN_HELP_SET_UNITE_RESULT_DEVIL        = 113,
	E_BTN_HELP_SET_BIBLE_VIEW_STATUS         = 114,
	E_BTN_HELP_SET_BIBLE_VIEW_SKILL1         = 115,
	E_BTN_HELP_SET_BIBLE_VIEW_SKILL2         = 116,
	E_BTN_HELP_SET_BIBLE_VIEW_STATUS_PAGE    = 117,
	E_BTN_HELP_SET_BIBLE_VIEW_SKILL1_PAGE    = 118,
	E_BTN_HELP_SET_BIBLE_VIEW_SKILL2_PAGE    = 119,
	E_BTN_HELP_SET_BIBLE_ENTRY_STATUS        = 120,
	E_BTN_HELP_SET_BIBLE_ENTRY_SKILL1        = 121,
	E_BTN_HELP_SET_BIBLE_ENTRY_SKILL2        = 122,
	E_BTN_HELP_SET_BIBLE_ENTRY_STATUS_PAGE   = 123,
	E_BTN_HELP_SET_BIBLE_ENTRY_SKILL1_PAGE   = 124,
	E_BTN_HELP_SET_BIBLE_ENTRY_SKILL2_PAGE   = 125,
	E_BTN_HELP_SET_BIBLE_EMPTY_STATUS        = 126,
	E_BTN_HELP_SET_BIBLE_EMPTY_SKILL1        = 127,
	E_BTN_HELP_SET_BIBLE_EMPTY_SKILL2        = 128,
	E_BTN_HELP_SET_UNITE_SP_PANEL_STATUS     = 129,
	E_BTN_HELP_SET_UNITE_SP_PANEL_SKILL1     = 130,
	E_BTN_HELP_SET_UNITE_SP_PANEL_SKILL2     = 131,
	E_BTN_HELP_SET_UNITE_RESULT_DEVIL_SKILL  = 132,
	E_BTN_HELP_SET_UNITE_RESULT_DEVIL_OTHER_INFO = 133,
	E_BTN_HELP_SET_UNITE_RESULT_DEVIL_COMMENTARYL = 134,
	E_BTN_HELP_SET_BTL_STATUS_LIST           = 135,
	E_BTN_HELP_SET_CAMP_TOP_SCROLL           = 136,
	E_BTN_HELP_SET_CAMP_SKILL_SKILL_SEL_SCROLL = 137,
	E_BTN_HELP_SET_CAMP_SKILL_TAR_SEL_SCROLL = 138,
	E_BTN_HELP_SET_CAMP_ITEM_ITEM_SEL_SCROLL = 139,
	E_BTN_HELP_SET_CAMP_ITEM_ITEM_SEL_EMPTY_SCROLL = 140,
	E_BTN_HELP_SET_CAMP_ITEM_TAR_SEL_SCROLL  = 141,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_SRC_BASICINFO_SCROLL = 142,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_DST_BASICINFO_SCROLL = 143,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_SRC_SKILLVIEW1 = 144,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_SRC_SKILLVIEW2 = 145,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_SRC_BASICINFO = 146,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_DST_SKILLVIEW1 = 147,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_DST_SKILLVIEW2 = 148,
	E_BTN_HELP_SET_CAMP_PARTY_PANEL_DST_BASICINFO = 149,
	E_BTN_HELP_SET_CAMP_ANALYZE_SCROLL_BASICINFO = 150,
	E_BTN_HELP_SET_CAMP_ANALYZE_BASICINFO    = 151,
	E_BTN_HELP_SET_RECOVERY_FACILITY_MAGATUHISKILL_SCROLL = 152,
	E_BTN_HELP_SET_RECOVERY_FACILITY_BASE    = 153,
	E_BTN_HELP_SET_SUMMON_TARGET_SELECT_MAGATUHISKILL_SCROLL = 154,
	E_BTN_HELP_SET_STATUS_CHECK              = 155,
	E_BTN_HELP_SET_BTL_TAR_SEL_STOCK_SKILLVIEW1_SCROLL = 156,
	E_BTN_HELP_SET_BTL_TAR_SEL_STOCK_SKILLVIEW2_SCROLL = 157,
	E_BTN_HELP_SET_BTL_TAR_SEL_STOCK_BASICINFO_SCROLL = 158,
	E_BTN_HELP_SET_BTL_TAR_SEL_STOCK_SKILLVIEW1 = 159,
	E_BTN_HELP_SET_BTL_TAR_SEL_STOCK_SKILLVIEW2 = 160,
	E_BTN_HELP_SET_BTL_TAR_SEL_STOCK_BASICINFO = 161,
	E_BTN_HELP_SET_BTL_CHANGE_SRC_SKILLVIEW1_SCROLL = 162,
	E_BTN_HELP_SET_BTL_CHANGE_SRC_SKILLVIEW2_SCROLL = 163,
	E_BTN_HELP_SET_BTL_CHANGE_SRC_BASICINFO_SCROLL = 164,
	E_BTN_HELP_SET_BTL_CHANGE_DST_SKILLVIEW1_SCROLL = 165,
	E_BTN_HELP_SET_BTL_CHANGE_DST_SKILLVIEW2_SCROLL = 166,
	E_BTN_HELP_SET_BTL_CHANGE_DST_BACICINFO_SCROLL = 167,
	E_BTN_HELP_SET_BTL_CHANGE_SRC_SKILLVIEW1 = 168,
	E_BTN_HELP_SET_BTL_CHANGE_SRC_SKILLVIEW2 = 169,
	E_BTN_HELP_SET_BTL_CHANGE_SRC_BACICINFO  = 170,
	E_BTN_HELP_SET_BTL_CHANGE_DST_SKILLVIEW1 = 171,
	E_BTN_HELP_SET_BTL_CHANGE_DST_SKILLVIEW2 = 172,
	E_BTN_HELP_SET_BTL_CHANGE_DST_BACICINFO  = 173,
	E_BTN_HELP_SET_BTL_STATUS_CHECK_SCROLL   = 174,
	E_BTN_HELP_SET_BTL_STATUS_CHECK          = 175,
	E_BTN_HELP_SET_RECOVERY_FACILITY_SKILLVIEW1_SCROLL = 176,
	E_BTN_HELP_SET_RECOVERY_FACILITY_SKILLVIEW2_SCROLL = 177,
	E_BTN_HELP_SET_RECOVERY_FACILITY_BACICINFO_SCROLL = 178,
	E_BTN_HELP_SET_RECOVERY_FACILITY_SKILLVIEW1 = 179,
	E_BTN_HELP_SET_RECOVERY_FACILITY_SKILLVIEW2 = 180,
	E_BTN_HELP_SET_RECOVERY_FACILITY_BACICINFO = 181,
	E_BTN_HELP_FUSION_STATUS_SKILL           = 182,
	E_BTN_HELP_FUSION_STATUS_OTHER_INFO      = 183,
	E_BTN_HELP_FUSION_STATUS_COMMENTAARY     = 184,
	E_BTN_HELP_SET_CAMP_ANALYZE_NONE_SKILLVIEW1 = 185,
	E_BTN_HELP_SET_CAMP_ANALYZE_NONE_SKILLVIEW2 = 186,
	E_BTN_HELP_SET_CAMP_ANALYZE_NONE_BASICINFO = 187,
	E_BTN_HELP_SET_TOKYO_LARGEMAP_PLACE_OFF_LOCK_AUTOHEAL = 188,
	E_BTN_HELP_SET_TOKYO_LARGEMAP_PLACE_ON_LOCK_AUTOHEAL = 189,
	E_BTN_HELP_SET_GARDEN_NO_TRAPORT         = 190,
	E_BTN_HELP_SET_GARDEN                    = 191,
	E_BTN_HELP_SET_GARDEN_FREECAM            = 192,
	E_BTN_HELP_SET_MOVIE_SKIP                = 193,
	E_BTN_HELP_SET_CAMP_HELP_SELECT          = 194,
	E_BTN_HELP_SET_QUEST_INTERRUPTION        = 195,
	E_MAX                                    = 196,
};

// Enum Project.E_BTN_HELP_MAPPING_KEY_TYPE
// NumValues: 0x0033
enum class E_BTN_HELP_MAPPING_KEY_TYPE : uint8
{
	None                                     = 0,
	Utl_Action                               = 1,
	Utl_Cancel                               = 2,
	Utl_Up                                   = 3,
	Utl_Down                                 = 4,
	Utl_Left                                 = 5,
	Utl_Right                                = 6,
	Utl_UpDown                               = 7,
	Utl_FaceTop                              = 8,
	Utl_FaceLeft                             = 9,
	Utl_ShoulderLeft                         = 10,
	Utl_ShoulderRight                        = 11,
	Utl_TriggerLeft                          = 12,
	Utl_TriggerRight                         = 13,
	Utl_SpecialLeft                          = 14,
	Utl_SpecialRight                         = 15,
	Utl_RStickUp                             = 16,
	Utl_RStickDown                           = 17,
	Utl_RStickUpDown                         = 18,
	Utl_StickButtonRight                     = 19,
	Utl_MouseAction                          = 20,
	Utl_MouseCancel                          = 21,
	Utl_MovieSkip                            = 22,
	KeyConfig_Delete                         = 23,
	Map_Action                               = 24,
	Map_Attack                               = 25,
	Map_CampOpen                             = 26,
	Map_ActionJump                           = 27,
	Map_CameraReset                          = 28,
	Map_Traport                              = 29,
	Map_AutoHeal                             = 30,
	Map_Dash                                 = 31,
	Map_Dash_R                               = 32,
	Map_AutoMap                              = 33,
	Map_ViewDown                             = 34,
	Map_ToggleAutoRun                        = 35,
	Map_Estoma                               = 36,
	Map_Save                                 = 37,
	MoveForward                              = 38,
	MoveRight                                = 39,
	MoveForwardRight                         = 40,
	LookUp                                   = 41,
	LookRight                                = 42,
	LookUpRight                              = 43,
	Automap_ScrollUp                         = 44,
	Automap_ScrollRight                      = 45,
	Automap_ScrollUpRight                    = 46,
	GardenMoveUp                             = 47,
	GardenMoveRight                          = 48,
	AutoMapZoom                              = 49,
	E_BTN_HELP_MAPPING_KEY_MAX               = 50,
};

// Enum Project.E_BTN_HELP_KEYBOARD_ICON_BG_TYPE
// NumValues: 0x0004
enum class E_BTN_HELP_KEYBOARD_ICON_BG_TYPE : uint8
{
	KEYBOARD_ICON_BG_LEFT                    = 0,
	KEYBOARD_ICON_BG_CENTER                  = 1,
	KEYBOARD_ICON_BG_RIGHT                   = 2,
	KEYBOARD_ICON_BG_MAX                     = 3,
};

// Enum Project.E_BTN_HELP_MOUSE_ICON_TYPE
// NumValues: 0x0007
enum class E_BTN_HELP_MOUSE_ICON_TYPE : uint8
{
	RIGHT_MOUSE_BUTTON                       = 0,
	LEFT_MOUSE_BUTTON                        = 1,
	MIDDLE_MOUSE_BUTTON                      = 2,
	THUMB_MOUSE_BUTTON_2                     = 3,
	THUMB_MOUSE_BUTTON                       = 4,
	NOT_MOUSE_BUTTON                         = 5,
	E_BTN_HELP_MOUSE_ICON_MAX                = 6,
};

// Enum Project.E_BTN_ICON_SIZE
// NumValues: 0x0005
enum class E_BTN_ICON_SIZE : uint8
{
	SIZE_32                                  = 0,
	SIZE_36                                  = 1,
	SIZE_40                                  = 2,
	SIZE_48                                  = 3,
	SIZE_MAX_0                               = 4,
};

// Enum Project.E_BTN_HELP_POS_TYPE
// NumValues: 0x0003
enum class E_BTN_HELP_POS_TYPE : uint8
{
	DEFAULT                                  = 0,
	FIELD                                    = 1,
	E_BTN_HELP_POS_MAX                       = 2,
};

// Enum Project.E_BTN_HELP_DIR
// NumValues: 0x0003
enum class E_BTN_HELP_DIR : uint8
{
	DIR_HORIZONTAL                           = 0,
	DIR_VERTICAL                             = 1,
	DIR_MAX                                  = 2,
};

// Enum Project.E_CAMERA_PLAYER_TYPE
// NumValues: 0x0003
enum class E_CAMERA_PLAYER_TYPE : uint8
{
	E_NAHOBINO                               = 0,
	E_SYONEN                                 = 1,
	E_MAX                                    = 2,
};

// Enum Project.E_CAMERA_MAP_TYPE
// NumValues: 0x0008
enum class E_CAMERA_MAP_TYPE : uint8
{
	E_DEFAULT                                = 0,
	E_DAATH                                  = 1,
	E_DUNGEON                                = 2,
	E_TOKYO                                  = 3,
	E_SP_AREA1                               = 4,
	E_SP_AREA2                               = 5,
	E_SP_AREA3                               = 6,
	E_MAX                                    = 7,
};

// Enum Project.E_CAMERA_PATH_INPUT_KEY_MODE
// NumValues: 0x0003
enum class E_CAMERA_PATH_INPUT_KEY_MODE : uint8
{
	DEFAULT                                  = 0,
	SEGMENT_RATIO                            = 1,
	E_CAMERA_PATH_INPUT_KEY_MAX              = 2,
};

// Enum Project.E_CAMPCHARAPANEL_ENEMYTYPE
// NumValues: 0x0003
enum class E_CAMPCHARAPANEL_ENEMYTYPE : uint8
{
	NORMAL                                   = 0,
	BOSS                                     = 1,
	E_CAMPCHARAPANEL_MAX                     = 2,
};

// Enum Project.E_CAMPCHARAPANELFLAG
// NumValues: 0x0009
enum class E_CAMPCHARAPANELFLAG : uint8
{
	CPLAYER                                  = 0,
	CPLAYERDEVIL                             = 1,
	CPLAYERDEVIIL_EVENT                      = 2,
	CFREE                                    = 3,
	CEMPTY                                   = 4,
	CBATTLEIN                                = 5,
	CSTOCK                                   = 6,
	CSUMMONED                                = 7,
	E_MAX                                    = 8,
};

// Enum Project.E_CAMPCHARAPANEL_SORTTYPE
// NumValues: 0x0004
enum class E_CAMPCHARAPANEL_SORTTYPE : uint8
{
	PARTYPANEL                               = 0,
	ANALYZE                                  = 1,
	UTSUSEMI                                 = 2,
	E_CAMPCHARAPANEL_MAX                     = 3,
};

// Enum Project.E_CAMPCHARAPANELCTRL_GSTATUS
// NumValues: 0x003D
enum class E_CAMPCHARAPANELCTRL_GSTATUS : uint8
{
	E_CAMPCHARAPANELCTRL_INIT                = 0,
	E_CAMPCHARAPANELCTRL_MOVESRC             = 1,
	E_CAMPCHARAPANELCTRL_MOVEDST             = 2,
	E_CAMPCHARAPANELCTRL_MOVEPROC            = 3,
	E_CAMPCHARAPANELCTRL_MOVEANIMEWAIT       = 4,
	E_CAMPCHARAPANELCTRL_MOVEEND             = 5,
	E_CAMPCHARAPANELCTRL_SETDIALOG_ERROR     = 6,
	E_CAMPCHARAPANELCTRL_WAIT_DIALOG         = 7,
	E_CAMPCHARAPANELCTRL_SELECTDIALOG_ON     = 8,
	E_CAMPCHARAPANELCTRL_SELECT_DELETECHARA  = 9,
	E_CAMPCHARAPANELCTRL_DELETECHARA         = 10,
	E_CAMPCHARAPANELCTRL_DELETECHARAANIME    = 11,
	E_CAMPCHARAPANELCTRL_WAIT_CLOSEDIALOG    = 12,
	E_CAMPCHARAPANELCTRL_CREATE_TARGETSELECT_ITEM = 13,
	E_CAMPCHARAPANELCTRL_TARGETSELECT_ITEM   = 14,
	E_CAMPCHARAPANELCTRL_MIITSUPOINT_ADD     = 15,
	E_CAMPCHARAPANELCTRL_SET_ITEMMESSAGE     = 16,
	E_CAMPCHARAPANELCTRL_WAIT_ITEMMESSAGE    = 17,
	E_CAMPCHARAPANELCTRL_USE_ITEM            = 18,
	E_CAMPCHARAPANELCTRL_WAIT_ENDITEM        = 19,
	E_CAMPCHARAPANELCTRL_ENDITEM             = 20,
	E_CAMPCHARAPANELCTRL_CREATE_TARGETSELECT_SKILL = 21,
	E_CAMPCHARAPANELCTRL_TARGETSELECT_SKILL  = 22,
	E_CAMPCHARAPANELCTRL_SET_SKILLMESSAGE    = 23,
	E_CAMPCHARAPANELCTRL_WAIT_SKILLMESSAGE   = 24,
	E_CAMPCHARAPANELCTRL_USE_SKILL           = 25,
	E_CAMPCHARAPANELCTRL_WAIT_ENDSKILL       = 26,
	E_CAMPCHARAPANELCTRL_ENDSKILL            = 27,
	E_CAMPCHARAPANELCTRL_ANALYZEMOVECURSOR   = 28,
	E_CAMPCHARAPANELCTRL_ANALYZEMOVEEND      = 29,
	E_CAMPCHARAPANELCTRL_UTSUSEMIMOVECURSOR  = 30,
	E_CAMPCHARAPANELCTRL_UTSUSEMISKILLLIST   = 31,
	E_CAMPCHARAPANELCTRL_UTSUSEMIMOVEEND     = 32,
	E_CAMPCHARAPANELCTRL_PARTYSTATUSDETAILINIT = 33,
	E_CAMPCHARAPANELCTRL_PARTYSTATUSDETAIL   = 34,
	E_CAMPCHARAPANELCTRL_CALCSORTPANEL       = 35,
	E_CAMPCHARAPANELCTRL_SORTSELECTPANEL     = 36,
	E_CAMPCHARAPANELCTRL_SORTPANEL           = 37,
	E_CAMPCHARAPANELCTRL_CHANGESORTPANEL     = 38,
	E_CAMPCHARAPANELCTRL_CALCSORTANALYZE     = 39,
	E_CAMPCHARAPANELCTRL_SORTSELECTANALYZE   = 40,
	E_CAMPCHARAPANELCTRL_SORTANALYZE         = 41,
	E_CAMPCHARAPANELCTRL_CHANGESORTANALYZE   = 42,
	E_CAMPCHARAPANELCTRL_CALCSORTUTSUSEMI    = 43,
	E_CAMPCHARAPANELCTRL_SORTSELECTUTSUSEMI  = 44,
	E_CAMPCHARAPANELCTRL_SORTUTSUSEMI        = 45,
	E_CAMPCHARAPANELCTRL_CHANGESORTUTSUSEMI  = 46,
	E_CAMPCHARAPANELCTRL_ANALYZESTATUSDETAILINIT = 47,
	E_CAMPCHARAPANELCTRL_ANALYZESTATUSDETAIL = 48,
	E_CAMPCHARAPANELCTRL_ITEMTARGETSTATUSDETAILINIT = 49,
	E_CAMPCHARAPANELCTRL_ITEMTARGETSTATUSDETAIL = 50,
	E_CAMPCHARAPANELCTRL_SKILLTARGETSTATUSDETAILINIT = 51,
	E_CAMPCHARAPANELCTRL_SKILLTARGETSTATUSDETAIL = 52,
	E_CAMPCHARAPANELCTRL_TOEXTRACT_CALCSORTUTSUSEMI = 53,
	E_CAMPCHARAPANELCTRL_TOEXTRACT_SORTSELECTUTSUSEMI = 54,
	E_CAMPCHARAPANELCTRL_TOEXTRACT_SORTUTSUSEMI = 55,
	E_CAMPCHARAPANELCTRL_TOEXTRACT_CHANGESORTUTSUSEMI = 56,
	E_CAMPCHARAPANELCTRL_USE_ITEM_LEVELUP    = 57,
	E_CAMPCHARAPANELCTRL_USE_ITEM_CHANGEPARAMETER = 58,
	E_CAMPCHARAPANELCTRL_MULTIPLE_SELECTION_ITEM = 59,
	E_CAMPCHARAPANELCTRL_MAX                 = 60,
};

// Enum Project.E_CAMPCHARAPANELBASE
// NumValues: 0x0004
enum class E_CAMPCHARAPANELBASE : uint8
{
	E_CAMPCHARAPANELBASE_NONE                = 0,
	CLISTMAX                                 = 16,
	CPARTYLISTMAX                            = 36,
	E_MAX                                    = 37,
};

// Enum Project.E_CAMP_COMMAND_ID
// NumValues: 0x000D
enum class E_CAMP_COMMAND_ID : uint8
{
	E_CAMP_COMMAND_ID_DAMMY                  = 0,
	E_CAMP_COMMAND_ID_SKILL                  = 1,
	E_CAMP_COMMAND_ID_SKILL_LIB              = 2,
	E_CAMP_COMMAND_ID_ITEM                   = 3,
	E_CAMP_COMMAND_ID_PARTY                  = 4,
	E_CAMP_COMMAND_ID_PROPERTY               = 5,
	E_CAMP_COMMAND_ID_PARTNER                = 6,
	E_CAMP_COMMAND_ID_QUEST                  = 7,
	E_CAMP_COMMAND_ID_DATA_BASE              = 8,
	E_CAMP_COMMAND_ID_CHARACTERS             = 9,
	E_CMAP_COMMAND_ID_UNIT                   = 10,
	E_CAMP_COMMAND_ID_DDS                    = 11,
	E_MAX                                    = 12,
};

// Enum Project.E_CAMP_DEBUG_UPDATE_TASK_TYPE
// NumValues: 0x0004
enum class E_CAMP_DEBUG_UPDATE_TASK_TYPE : uint8
{
	E_CAMP_DEBUG_UPDATE_TASK_TYPE_NONE       = 0,
	E_CAMP_DEBUG_UPDATE_TASK_TYPE_SKILL_LIB  = 1,
	E_CAMP_DEBUG_UPDATE_TASK_TYPE_PROPERTY   = 2,
	E_CAMP_DEBUG_UPDATE_TASK_TYPE_MAX        = 3,
};

// Enum Project.E_DATALOG_TYPE
// NumValues: 0x0007
enum class E_DATALOG_TYPE : uint8
{
	E_DATALOG_TYPE_PERSON                    = 0,
	E_DATALOG_TYPE_MAT                       = 1,
	E_DATALOG_TYPE_PLACE                     = 2,
	E_DATALOG_TYPE_DEVIL                     = 3,
	E_DATALOG_TYPE_ETC                       = 4,
	E_DATALOG_TYPE_NONE                      = 5,
	E_DATALOG_TYPE_MAX                       = 6,
};

// Enum Project.E_CAMPHELPCTRL_GSTATUS
// NumValues: 0x0006
enum class E_CAMPHELPCTRL_GSTATUS : uint8
{
	E_CAMPHELPCTRL_INIT                      = 0,
	E_CAMPHELPCTRL_MOVECURSOR                = 1,
	E_CAMPHELPCTRL_END                       = 2,
	E_CAMPHELPCTRL_FADEOUT                   = 3,
	E_CAMPHELPCTRL_TUTORIAL                  = 4,
	E_CAMPHELPCTRL_MAX                       = 5,
};

// Enum Project.E_CAMPHELPLIST_CONDITIONTYPE
// NumValues: 0x000E
enum class E_CAMPHELPLIST_CONDITIONTYPE : uint8
{
	TUTORIAL_OPEN                            = 0,
	JYAKYOU_OPEN                             = 1,
	UNLOCKING_DEVILFUSION                    = 2,
	NAHOBINO                                 = 3,
	UNLOCKING_SAFETY                         = 4,
	LOCKING_SEFETY                           = 5,
	DLC_SAFETY                               = 6,
	DLC_MAKKA                                = 7,
	DLC_EXP                                  = 8,
	DLC_MIITSU                               = 9,
	DLC_JP_VOICE                             = 10,
	DLC_EN_VOICE                             = 11,
	DLC_OPEN_RESERVE                         = 12,
	MAX                                      = 255,
};

// Enum Project.E_CAMPHELPLIST_HELPTYPE
// NumValues: 0x0007
enum class E_CAMPHELPLIST_HELPTYPE : uint8
{
	CATEGORY_0                               = 0,
	CATEGORY_1                               = 1,
	CATEGORY_2                               = 2,
	CATEGORY_3                               = 3,
	CATEGORY_4                               = 4,
	UNUSED_CATEGORY                          = 255,
	E_CAMPHELPLIST_MAX                       = 256,
};

// Enum Project.E_CAMPHELPLIST_CANSELTYPE
// NumValues: 0x0003
enum class E_CAMPHELPLIST_CANSELTYPE : uint8
{
	NORMAL                                   = 0,
	ERROR_TYPE                               = 1,
	E_CAMPHELPLIST_MAX                       = 2,
};

// Enum Project.E_CAMPHELPLIST_ANIMETYPE
// NumValues: 0x0004
enum class E_CAMPHELPLIST_ANIMETYPE : uint8
{
	CURSOR                                   = 0,
	NORMAL                                   = 1,
	NOT                                      = 2,
	E_CAMPHELPLIST_MAX                       = 3,
};

// Enum Project.E_CAMP_ITEM_TAB
// NumValues: 0x0004
enum class E_CAMP_ITEM_TAB : uint8
{
	E_CAMP_ITEM_TAB_USE                      = 0,
	E_CAMP_ITEM_TAB_RELIC                    = 1,
	E_CAMP_ITEM_TAB_IMPORT                   = 2,
	E_CAMP_ITEM_TAB_MAX                      = 3,
};

// Enum Project.E_CAMPITEMLIST_ITEMTYPE
// NumValues: 0x0004
enum class E_CAMPITEMLIST_ITEMTYPE : uint8
{
	USE                                      = 0,
	RELIC                                    = 1,
	IMPORTANT                                = 2,
	E_CAMPITEMLIST_MAX                       = 3,
};

// Enum Project.E_CAMPITEMLIST_CANSELTYPE
// NumValues: 0x0006
enum class E_CAMPITEMLIST_CANSELTYPE : uint8
{
	NORMAL                                   = 0,
	ERROR_TYPE                               = 1,
	PILLAR                                   = 2,
	ESTMA                                    = 3,
	RIBERAMA                                 = 4,
	E_CAMPITEMLIST_MAX                       = 5,
};

// Enum Project.E_CAMPITEMLIST_ANIMETYPE
// NumValues: 0x0004
enum class E_CAMPITEMLIST_ANIMETYPE : uint8
{
	CURSOR                                   = 0,
	NORMAL                                   = 1,
	NOT                                      = 2,
	E_CAMPITEMLIST_MAX                       = 3,
};

// Enum Project.E_DEFENCE_RESISTANCE
// NumValues: 0x0007
enum class E_DEFENCE_RESISTANCE : uint8
{
	E_DEFENCE_RESISTANCE_WEAK                = 0,
	E_DEFENCE_RESISTANCE_NORMAL              = 1,
	E_DEFENCE_RESISTANCE_RESIST              = 2,
	E_DEFENCE_RESISTANCE_BLOCK               = 3,
	E_DEFENCE_RESISTANCE_REFRECT             = 4,
	E_DEFENCE_RESISTANCE_ABSORB              = 5,
	E_DEFENCE_RESISTANCE_MAX                 = 6,
};

// Enum Project.E_PARTY_PANEL_TYPE
// NumValues: 0x0004
enum class E_PARTY_PANEL_TYPE : uint8
{
	E_PARTY_PANEL_TYPE_PLAYER                = 0,
	E_PARTY_PANEL_TYPE_BTL_PARTY             = 1,
	E_PARTY_PANEL_TYPE_STOCK                 = 2,
	E_PARTY_PANEL_TYPE_MAX                   = 3,
};

// Enum Project.E_PARTY_PANEL_FLAG
// NumValues: 0x0007
enum class E_PARTY_PANEL_FLAG : uint8
{
	E_PARTY_PANEL_FLAG_NONE                  = 0,
	E_PARTY_PANEL_FLAG_ALL_SELECT            = 1,
	E_PARTY_PANEL_FLAG_PARTY_SELECT          = 2,
	E_PARTY_PANEL_FLAG_STOCK_SELECT          = 3,
	E_PARTY_PANEL_FLAG_CHANGE                = 4,
	E_PARTY_PANEL_FLAG_DELETE                = 5,
	E_PARTY_PANEL_FLAG_MAX                   = 6,
};

// Enum Project.E_CAMP_QUEST_PROGRESS_STATE
// NumValues: 0x0004
enum class E_CAMP_QUEST_PROGRESS_STATE : uint8
{
	IN_PROGRESS                              = 0,
	REPORTABLE                               = 1,
	COMPLETED                                = 2,
	E_CAMP_QUEST_PROGRESS_MAX                = 3,
};

// Enum Project.E_CAMP_QUEST_USE_KEY
// NumValues: 0x000D
enum class E_CAMP_QUEST_USE_KEY : uint8
{
	NONE                                     = 0,
	CANCEL                                   = 1,
	UP                                       = 2,
	DOWN                                     = 3,
	LEFT                                     = 4,
	RIGHT                                    = 5,
	TAB_L                                    = 6,
	TAB_R                                    = 7,
	RS_UP                                    = 8,
	RS_DOWN                                  = 9,
	MAP                                      = 10,
	PURPOSE                                  = 11,
	E_CAMP_QUEST_USE_MAX                     = 12,
};

// Enum Project.E_CAMP_QUEST_INPUT_TYPE
// NumValues: 0x0004
enum class E_CAMP_QUEST_INPUT_TYPE : uint8
{
	NONE                                     = 0,
	TRIGGER                                  = 1,
	REPEAT                                   = 2,
	E_CAMP_QUEST_INPUT_MAX                   = 3,
};

// Enum Project.E_CAMPSKILLLIST_CANSELTYPE
// NumValues: 0x0005
enum class E_CAMPSKILLLIST_CANSELTYPE : uint8
{
	NORMAL                                   = 0,
	ERROR_TYPE                               = 1,
	ESTMA                                    = 2,
	RIBERAMA                                 = 3,
	E_CAMPSKILLLIST_MAX                      = 4,
};

// Enum Project.E_CAMPSKILLLIST_ANIMETYPE
// NumValues: 0x0004
enum class E_CAMPSKILLLIST_ANIMETYPE : uint8
{
	CURSOR                                   = 0,
	NORMAL                                   = 1,
	NOT                                      = 2,
	E_CAMPSKILLLIST_MAX                      = 3,
};

// Enum Project.E_CAMPTOPMENUNO
// NumValues: 0x0008
enum class E_CAMPTOPMENUNO : uint8
{
	SKILLS                                   = 0,
	ITEMS                                    = 1,
	UTSUSEMI                                 = 2,
	PARTY                                    = 3,
	QUEST                                    = 4,
	ANALYZE                                  = 5,
	SYSTEM                                   = 6,
	E_MAX                                    = 7,
};

// Enum Project.E_CAMP_TOPMENU_TYPE
// NumValues: 0x0009
enum class E_CAMP_TOPMENU_TYPE : uint8
{
	E_CAMP_TOPMENU_TYPE_SKILL                = 0,
	E_CAMP_TOPMENU_TYPE_ITEM                 = 1,
	E_CAMP_TOPMENU_TYPE_PARTY                = 2,
	E_CAMP_TOPMENU_TYPE_GOD                  = 3,
	E_CAMP_TOPMENU_TYPE_MISSION              = 4,
	E_CAMP_TOPMENU_TYPE_DDS                  = 5,
	E_CAMP_TOPMENU_TYPE_DATABASE             = 6,
	E_CAMP_TOPMENU_TYPE_JAKYO                = 7,
	E_CAMP_TOPMENU_TYPE_MAX                  = 8,
};

// Enum Project.E_CAMP_ITEM_FLAG
// NumValues: 0x0004
enum class E_CAMP_ITEM_FLAG : uint8
{
	E_CAMP_ITEM_FLAG_NONE                    = 0,
	E_CAMP_ITEM_FLAG_SEL_ITEM                = 1,
	E_CAMP_ITEM_FLAG_SEL_PARTY               = 2,
	E_CAMP_ITEM_FLAG_MAX                     = 3,
};

// Enum Project.E_CAMP_SKILL_FLAG
// NumValues: 0x0007
enum class E_CAMP_SKILL_FLAG : uint8
{
	E_CAMP_SKILL_FLAG_NONE                   = 0,
	E_CAMP_SKILL_FLAG_SEL_SKILL              = 1,
	E_CAMP_SKILL_FLAG_SEL_PARTY              = 2,
	E_CAMP_SKILL_FLAG_SET_SKILL              = 3,
	E_CMAP_SKILL_FLAG_CHARA_ONE              = 4,
	E_CAMP_SKILL_FLAG_PARTY_ALL              = 5,
	E_MAX                                    = 6,
};

// Enum Project.E_CAMP_STEP
// NumValues: 0x0014
enum class E_CAMP_STEP : uint8
{
	E_CAMP_STEP_NONE                         = 0,
	E_CAMP_STEP_SEL_COMMAND                  = 1,
	E_CAMP_STEP_SKILL                        = 2,
	E_CAMP_STEP_SKILL_LIB                    = 3,
	E_CAMP_STEP_ITEM                         = 4,
	E_CAMP_STEP_PARTY                        = 5,
	E_CAMP_STEP_PROPERTY                     = 6,
	E_CAMP_STEP_PARTNER                      = 7,
	E_CAMP_STEP_QUEST                        = 8,
	E_CAMP_STEP_DATA_BASE                    = 9,
	E_CAMP_STEP_CHARACTERS                   = 10,
	E_CAMP_STEP_UNIT                         = 11,
	E_CAMP_STEP_DDS                          = 12,
	E_CAMP_STEP_PARTY_SEL                    = 13,
	E_CAMP_STEP_CAM_CHRA_VIEW                = 14,
	E_CAMP_STEP_GIFT                         = 15,
	E_CAMP_STEP_STATUS                       = 16,
	E_CAMP_STEP_FORCEEND                     = 17,
	E_CAMP_STEP_END                          = 18,
	E_CAMP_STEP_MAX                          = 19,
};

// Enum Project.E_CATEGORY_CURSOR_MOVE_DIRECTION
// NumValues: 0x0003
enum class E_CATEGORY_CURSOR_MOVE_DIRECTION : uint8
{
	LEFT                                     = 0,
	RIGHT                                    = 1,
	E_CATEGORY_CURSOR_MOVE_MAX               = 2,
};

// Enum Project.E_CATEGORY_FRAMEIN_TYPE
// NumValues: 0x0004
enum class E_CATEGORY_FRAMEIN_TYPE : uint8
{
	DEFAULT                                  = 0,
	IN_LEFT                                  = 1,
	IN_RIGHT                                 = 2,
	E_CATEGORY_FRAMEIN_MAX                   = 3,
};

// Enum Project.E_CATEGORY_UI_STATE
// NumValues: 0x0006
enum class E_CATEGORY_UI_STATE : uint8
{
	NOT_ACTIVE                               = 0,
	FAME_IN                                  = 1,
	FRAME_OUT                                = 2,
	KEY_WAITING                              = 3,
	SLIDE                                    = 4,
	E_CATEGORY_UI_MAX                        = 5,
};

// Enum Project.E_CATEGORY_TYPE
// NumValues: 0x001F
enum class E_CATEGORY_TYPE : uint8
{
	NONE                                     = 0,
	DEVIL_BOSS                               = 1,
	DEVIL_ALL                                = 2,
	DEVIL_COMMON                             = 3,
	DEVIL_NEW                                = 4,
	DEVIL_OLD                                = 5,
	DEVIL_CUSTOM                             = 6,
	DEVIL_ORIGINAL                           = 7,
	ITEM_COMMON                              = 8,
	ITEM_KEY                                 = 9,
	ITEM_TRESURE                             = 10,
	ITEM_UTSUSEMI                            = 11,
	QUEST_MAIN                               = 12,
	QUEST_SUB                                = 13,
	UNKNOWN                                  = 14,
	KAMUI_HADOU                              = 15,
	KAMUI_HUKUIN                             = 16,
	KAMUI_KAKUSEI                            = 17,
	KAMUI_BANSYOU                            = 18,
	OPTION1                                  = 19,
	OPTION2                                  = 20,
	OPTION3                                  = 21,
	OPTION4                                  = 22,
	OPTION5                                  = 23,
	OPTION6                                  = 24,
	HELP1                                    = 25,
	HELP2                                    = 26,
	HELP3                                    = 27,
	HELP4                                    = 28,
	HELP5                                    = 29,
	E_CATEGORY_MAX                           = 30,
};

// Enum Project.E_CATEGORY_PATTERN
// NumValues: 0x000E
enum class E_CATEGORY_PATTERN : uint8
{
	NONE                                     = 0,
	SHOP_BUY_MASK                            = 1,
	SHOP_BUY                                 = 2,
	SHOP_SELL                                = 3,
	ITEM                                     = 4,
	QUEST                                    = 5,
	ANALYZE                                  = 6,
	DEVIL_BOOK                               = 7,
	DEVIL_WRITE                              = 8,
	KAMUI                                    = 9,
	OPTION                                   = 10,
	HELP                                     = 11,
	OPTION_PC                                = 12,
	E_CATEGORY_MAX                           = 13,
};

// Enum Project.E_AVOID_DIRECTION
// NumValues: 0x0004
enum class E_AVOID_DIRECTION : uint8
{
	AVOID_BACK                               = 0,
	AVOID_RIGHT                              = 1,
	AVOID_LEFT                               = 2,
	AVOID_MAX                                = 3,
};

// Enum Project.E_CHARA_TILT
// NumValues: 0x0003
enum class E_CHARA_TILT : uint8
{
	RUN_TO_TARGET                            = 0,
	ATTACK_TARGET                            = 1,
	E_CHARA_MAX                              = 2,
};

// Enum Project.E_CHARA_BAD_STATUS_APPEAR
// NumValues: 0x0005
enum class E_CHARA_BAD_STATUS_APPEAR : uint8
{
	E_APPEAR_ON_HIT                          = 0,
	E_APPEAR_ON_LOOP                         = 1,
	E_APPEAR_ON_CURE                         = 2,
	E_APPEAR_ON_DAMAGE                       = 3,
	E_APPEAR_MAX                             = 4,
};

// Enum Project.E_CHARA_AURA_TYPE
// NumValues: 0x0006
enum class E_CHARA_AURA_TYPE : uint8
{
	AURA_NONE                                = 0,
	AURA_CHARGE                              = 1,
	AURA_VIGILANCE                           = 2,
	AURA_KAISHIN                             = 3,
	AURA_BUNSHIN                             = 4,
	MAX                                      = 5,
};

// Enum Project.E_CHARA_ACTION_TYPE
// NumValues: 0x000F
enum class E_CHARA_ACTION_TYPE : uint8
{
	DEATH                                    = 0,
	RUN_TO_UNIT                              = 1,
	BACK_STEP                                = 2,
	KNOCK_BACK                               = 3,
	CHANGE_STATUS                            = 4,
	REVIVE                                   = 5,
	FUSION_PREPARE                           = 6,
	SUMMON                                   = 7,
	RETURN                                   = 8,
	FADE                                     = 9,
	SPAWN                                    = 10,
	RAPID_SUMMON                             = 11,
	RAPID_RETURN                             = 12,
	BATTLE_SUMMON                            = 13,
	MAX                                      = 14,
};

// Enum Project.E_CHARA_ANIMATION_MODE
// NumValues: 0x0005
enum class E_CHARA_ANIMATION_MODE : uint8
{
	DEFAULT                                  = 0,
	STATE_MACHINE                            = 1,
	MONTAGE                                  = 2,
	EVENT_MOTION                             = 3,
	E_CHARA_ANIMATION_MAX                    = 4,
};

// Enum Project.E_CHARA_LIP_ID
// NumValues: 0x0008
enum class E_CHARA_LIP_ID : uint8
{
	DEFAULT                                  = 0,
	JPN_A                                    = 1,
	JPN_I                                    = 2,
	JPN_U                                    = 3,
	JPN_E                                    = 4,
	JPN_O                                    = 5,
	JPN_N                                    = 6,
	E_CHARA_LIP_MAX                          = 7,
};

// Enum Project.E_CHARA_LID_ID
// NumValues: 0x0003
enum class E_CHARA_LID_ID : uint8
{
	DEFAULT                                  = 0,
	CLOSE                                    = 1,
	E_CHARA_LID_MAX                          = 2,
};

// Enum Project.E_CHARAPANELBASE
// NumValues: 0x0007
enum class E_CHARAPANELBASE : uint8
{
	E_CHARAPANELBASE_BADSTATUS_MAX           = 2,
	E_CHARAPANELBASE_SUPPORT_MAX             = 8,
	E_CHARAPASNELBASE_PANELTYPE_NORMAL       = 0,
	E_CHARAPASNELBASE_PANELTYPE_STOCK_EMPTY  = 1,
	E_CHARAPASNELBASE_PANELTYPE_PARTY_EMPTY  = 2,
	E_CHARAPASNELBASE_PANELTYPE_NON          = 3,
	E_MAX                                    = 9,
};

// Enum Project.ECharaStampMovementState
// NumValues: 0x0005
enum class ECharaStampMovementState : uint8
{
	NotLanding                               = 0,
	Walk                                     = 1,
	Run                                      = 2,
	Dash                                     = 3,
	ECharaStampMovementState_MAX             = 4,
};

// Enum Project.E_INIT_SETTING_TYPE
// NumValues: 0x0004
enum class E_INIT_SETTING_TYPE : uint8
{
	E_LEVEL                                  = 0,
	E_MAKKA                                  = 1,
	E_STOCK_NUM                              = 2,
	E_MAX                                    = 3,
};

// Enum Project.E_CAMERA_SIDE_LR_TYPE
// NumValues: 0x0005
enum class E_CAMERA_SIDE_LR_TYPE : uint8
{
	E_LR_CAMERA_LEFT                         = 0,
	E_LR_CAMERA_RIGHT                        = 1,
	E_LR_CAMERA_CENTER1                      = 2,
	E_LR_CAMERA_CENTER2                      = 3,
	E_LR_CAMERA_MAX                          = 4,
};

// Enum Project.E_CAMERA_SIDE_BF_TYPE
// NumValues: 0x0003
enum class E_CAMERA_SIDE_BF_TYPE : uint8
{
	E_BF_CAMERA_BACK                         = 0,
	E_BF_CAMERA_FRONT                        = 1,
	E_BF_CAMERA_MAX                          = 2,
};

// Enum Project.E_RIG_RAIL_COORDINATE_TYPE
// NumValues: 0x0003
enum class E_RIG_RAIL_COORDINATE_TYPE : uint8
{
	E_RIG_RAIL_COORDINATE_WORLD              = 0,
	E_RIG_RAIL_COORDINATE_LOCAL              = 1,
	E_RIG_RAIL_COORDINATE_MAX                = 2,
};

// Enum Project.E_RIG_RAIL_ORIGIN_TYPE
// NumValues: 0x0003
enum class E_RIG_RAIL_ORIGIN_TYPE : uint8
{
	E_RIG_RAIL_ORIGIN_BATTLE                 = 0,
	E_RIG_RAIL_ORIGIN_CHARACTOR              = 1,
	E_RIG_RAIL_ORIGIN_MAX                    = 2,
};

// Enum Project.EInputIgnoreReason
// NumValues: 0x0006
enum class EInputIgnoreReason : uint8
{
	Battle                                   = 0,
	Event                                    = 1,
	MapAction                                = 2,
	MapGimmick                               = 3,
	MapPause                                 = 4,
	EInputIgnoreReason_MAX                   = 5,
};

// Enum Project.E_DEBUG_MENU_FLAG
// NumValues: 0x0002
enum class E_DEBUG_MENU_FLAG : uint8
{
	E_DEBUG_MENU_FLAG_BTLAILOG_ON            = 0,
	E_DEBUG_MENU_FLAG_BTLAILOG_MAX           = 1,
};

// Enum Project.E_D_MENU_NAME_CHANGE_TYPE
// NumValues: 0x0007
enum class E_D_MENU_NAME_CHANGE_TYPE : uint8
{
	E_NAME_CHANGE_TYPE_NONE                  = 0,
	E_NAME_CHANGE_TYPE_SKILL                 = 1,
	E_NAME_CHANGE_TYPE_ITEM                  = 2,
	E_NAME_CHANGE_TYPE_DEVIL                 = 3,
	E_NAME_CHANGE_TYPE_CHARA                 = 4,
	E_NAME_CHANGE_TYPE_SELF                  = 5,
	E_NAME_CHANGE_TYPE_MAX                   = 6,
};

// Enum Project.E_D_MENU_TYPE
// NumValues: 0x0009
enum class E_D_MENU_TYPE : uint8
{
	E_D_MENU_TYPE_NONE                       = 0,
	E_D_MENU_TYPE_FUNC_OBJ                   = 1,
	E_D_MENU_TYPE_CHECK_BOX                  = 2,
	E_D_MENU_TYPE_JUMP_PAGE                  = 3,
	E_D_MENU_TYPE_TEXT                       = 4,
	E_D_MENU_TYPE_PARAM                      = 5,
	E_D_MENU_TYPE_PULL_DOWN                  = 6,
	E_D_MENU_TYPE_NAME_CHANGE                = 7,
	E_D_MENU_TYPE_MAX                        = 8,
};

// Enum Project.E_ENEMY_TARGET
// NumValues: 0x0004
enum class E_ENEMY_TARGET : uint8
{
	E_ENEMY_TARGET_NORMAL                    = 0,
	E_ENEMY_TARGET_ONLY                      = 1,
	E_ENEMY_TARGET_HIDDEN                    = 2,
	E_ENEMY_TARGET_MAX                       = 3,
};

// Enum Project.EDevilVoiceType
// NumValues: 0x0026
enum class EDevilVoiceType : uint8
{
	EDevilVoiceType_None                     = 0,
	IdleA                                    = 1,
	IdleB                                    = 2,
	Damage                                   = 3,
	Dead                                     = 4,
	Attack                                   = 5,
	Escape                                   = 7,
	Find                                     = 10,
	Move_Found                               = 11,
	Move_NotFound                            = 12,
	Skill_Physical                           = 21,
	Skill_Magic                              = 22,
	Skill_Support                            = 23,
	Skill_Unique                             = 31,
	Skill_Unique2                            = 32,
	Skill_Unique3                            = 33,
	Skill_Unique4                            = 34,
	FightingSpirit                           = 41,
	DevilTalk_Positive                       = 51,
	DevilTalk_Negative                       = 52,
	DevilTalk_Intimidation                   = 53,
	DevilTalk_Thought                        = 54,
	DevilTalk_Bearish                        = 55,
	DevilTalk_Call                           = 56,
	DevilTalk_Together                       = 57,
	DevilTalk_Disappointment                 = 58,
	DevilTalk_Yorosiku                       = 61,
	NPCTalk_Positive1                        = 71,
	NPCTalk_Positive2                        = 72,
	NPCTalk_Negative1                        = 73,
	NPCTalk_Negative2                        = 74,
	NPCTalk_Intimidation                     = 75,
	NPCTalk_Thought                          = 76,
	NPCTalk_Bearish                          = 77,
	NPCTalk_Call                             = 78,
	NPCTalk_Together                         = 79,
	NPCTalk_Disappointment                   = 80,
	EDevilVoiceType_MAX                      = 81,
};

// Enum Project.DG_ActorVisibilityVolumeState
// NumValues: 0x0004
enum class EDG_ActorVisibilityVolumeState : uint8
{
	DAVV_Show                                = 0,
	DAVV_Hide                                = 1,
	DAVV_None                                = 2,
	DAVV_MAX                                 = 3,
};

// Enum Project.E_DG_ROOM_ROTATOR_CAMERA_STATE
// NumValues: 0x0006
enum class E_DG_ROOM_ROTATOR_CAMERA_STATE : uint8
{
	E_IDLE                                   = 0,
	E_EASE_IN                                = 1,
	E_ROTATING                               = 2,
	E_FALLING                                = 3,
	E_EASE_OUT                               = 4,
	E_MAX                                    = 5,
};

// Enum Project.E_DG_ROOM_ROTATOR_STATE
// NumValues: 0x0004
enum class E_DG_ROOM_ROTATOR_STATE : uint8
{
	E_NONE                                   = 0,
	E_ROTATING_X                             = 1,
	E_ROTATING_Y                             = 2,
	E_MAX                                    = 3,
};

// Enum Project.E_BTL_ENEMY_FIELD
// NumValues: 0x0004
enum class E_BTL_ENEMY_FIELD : uint8
{
	E_BTL_ENEMY_FIELD_6x6                    = 0,
	E_BTL_ENEMY_FIELD_7x7                    = 1,
	E_BTL_ENEMY_FIELD_8x8                    = 2,
	E_BTL_ENEMY_FIELD_MAX                    = 3,
};

// Enum Project.E_MITAMA_ENCOUNT
// NumValues: 0x0006
enum class E_MITAMA_ENCOUNT : uint8
{
	E_MITAMA_ENCOUNT_NONE                    = 0,
	E_MITAMA_ENCOUNT_MAKKA                   = 1,
	E_MITAMA_ENCOUNT_HERO                    = 2,
	E_MITAMA_ENCOUNT_NKM                     = 3,
	E_MITAMA_ENCOUNT_MIITSU                  = 4,
	E_MITAMA_ENCOUNT_MAX                     = 5,
};

// Enum Project.E_EVTBTL_WIN_COND
// NumValues: 0x0005
enum class E_EVTBTL_WIN_COND : uint8
{
	E_EVTBTL_WIN_COND_NONE                   = 0,
	E_EVTBTL_WIN_COND_DEFAULT                = 1,
	E_EVTBTL_WIN_COND_LEADER                 = 2,
	E_EVTBTL_WIN_COND_TURN_KILL              = 3,
	E_EVTBTL_WIN_COND_MAX                    = 4,
};

// Enum Project.E_EVT_ENCOUNT_TYPE
// NumValues: 0x0005
enum class E_EVT_ENCOUNT_TYPE : uint8
{
	E_EVT_ENCOUNT_DEFAULT                    = 0,
	E_EVT_ENCOUNT_SUB                        = 1,
	E_EVT_ENCOUNT_MAOU                       = 2,
	E_EVT_ENCOUNT_ROOM_BOSS                  = 3,
	E_EVT_ENCOUNT_MAX                        = 4,
};

// Enum Project.E_FACILITY_TYPE
// NumValues: 0x0006
enum class E_FACILITY_TYPE : uint8
{
	E_FACILITY_SHOP                          = 0,
	E_FACILITY_MIMAN                         = 1,
	E_FACILITY_MIMAN_EXIT                    = 2,
	E_FACILITY_MIMAN_HEAL_SPOT               = 3,
	E_FACILITY_MIMAN_EXCHANGE                = 4,
	E_FACILITY_MAX                           = 5,
};

// Enum Project.E_OldNewRoute
// NumValues: 0x0004
enum class E_OldNewRoute : uint8
{
	E_CommonRoute                            = 0,
	E_OldRoute                               = 1,
	E_NewRoute                               = 2,
	E_MAX                                    = 3,
};

// Enum Project.E_NAVI_DEVIL
// NumValues: 0x0015
enum class E_NAVI_DEVIL : uint8
{
	E_NAVI_DEVIL_NONE                        = 0,
	E_NAVI_DEVIL_DEV059_PIXIE                = 1,
	E_NAVI_DEVIL_DEV114_AITVARAS             = 2,
	E_NAVI_DEVIL_DEV057_JACKOLANTERN         = 3,
	E_NAVI_DEVIL_DEV273_DECARABIA            = 4,
	E_NAVI_DEVIL_DEV280_YATAGARASU           = 5,
	E_NAVI_DEVIL_DEV333_KAHAKU               = 6,
	E_NAVI_DEVIL_DEV038_AMANOZAKO            = 7,
	E_NAVI_DEVIL_DEV128_CIRONNUP             = 8,
	E_NAVI_DEVIL_DEV289_MOSHOBOU             = 9,
	E_NAVI_DEVIL_DEV060_NAHOBIHO             = 10,
	E_NAVI_DEVIL_DEV355_ALICE                = 11,
	E_NAVI_DEVIL_DEV387_AMABIE               = 12,
	E_NAVI_DEVIL_DEV191_CYBELE               = 13,
	E_NAVI_DEVIL_DEV316_IPPONDATARA          = 14,
	E_NAVI_DEVIL_DEV144_BAGS                 = 15,
	E_NAVI_DEVIL_DEV304_MERMAID              = 16,
	E_NAVI_DEVIL_DEV067_LILIM                = 17,
	E_NAVI_DEVIL_DEV214_SUKUNAHIKONA         = 18,
	E_NAVI_DEVIL_DEV044_AGATHION             = 19,
	E_NAVI_DEVIL_MAX                         = 20,
};

// Enum Project.E_GOD_PARAM
// NumValues: 0x0007
enum class E_GOD_PARAM : uint8
{
	E_GOD_PARAM_NONE                         = 0,
	E_GOD_PARAM_SOUZOU                       = 1,
	E_GOD_PARAM_TENPEN                       = 2,
	E_GOD_PARAM_HAGYOU                       = 3,
	E_GOD_PARAM_TYOUJOU                      = 4,
	E_GOD_PARAM_KYUSAI                       = 5,
	E_GOD_PARAM_MAX                          = 6,
};

// Enum Project.E_GAMEOVER_RESULT
// NumValues: 0x0004
enum class E_GAMEOVER_RESULT : uint8
{
	E_GAMEOVER_RESULT_NONE                   = 0,
	E_GAMEOVER_RESULT_LOAD                   = 1,
	E_GAMEOVER_RESULT_TITLE                  = 2,
	E_GAMEOVER_RESULT_MAX                    = 3,
};

// Enum Project.E_ABILITYNAME_TYPE
// NumValues: 0x0008
enum class E_ABILITYNAME_TYPE : uint8
{
	E_ABILITYNAME_MAXHP                      = 0,
	E_ABILITYNAME_MAXMP                      = 1,
	E_ABILITYNAME_STR                        = 2,
	E_ABILITYNAME_VIT                        = 3,
	E_ABILITYNAME_MGI                        = 4,
	E_ABILITYNAME_AGI                        = 5,
	E_ABILITYNAME_LUC                        = 6,
	E_ABILITYNAME_MAX                        = 7,
};

// Enum Project.E_ABILITY_TYPE
// NumValues: 0x0006
enum class E_ABILITY_TYPE : uint8
{
	E_ABILITY_STR                            = 0,
	E_ABILITY_VIT                            = 1,
	E_ABILITY_MGI                            = 2,
	E_ABILITY_AGI                            = 3,
	E_ABILITY_LUC                            = 4,
	E_ABILITY_MAX                            = 5,
};

// Enum Project.E_PLAYER_TYPE
// NumValues: 0x0004
enum class E_PLAYER_TYPE : uint8
{
	E_PLAYER_BOY                             = 0,
	E_PLAYER_AOGAMI                          = 1,
	E_PLAYER_NAHOBINO                        = 2,
	E_PLAYER_MAX                             = 3,
};

// Enum Project.E_LEARN_SKILL_TYPE
// NumValues: 0x0003
enum class E_LEARN_SKILL_TYPE : uint8
{
	E_LEARN_SKILL_DEFAULT                    = 0,
	E_LEARN_SKILL_LIB                        = 1,
	E_LEARN_SKILL_MAX                        = 2,
};

// Enum Project.E_GAME_DIFFICULTY
// NumValues: 0x0005
enum class E_GAME_DIFFICULTY : uint8
{
	E_GAME_EASY                              = 0,
	E_GAME_NORMAL                            = 1,
	E_GAME_HARD                              = 2,
	E_GAME_VERYHARD                          = 3,
	E_GAME_MAX                               = 4,
};

// Enum Project.E_GAME_START_MODE
// NumValues: 0x0005
enum class E_GAME_START_MODE : uint8
{
	E_GAME_START_MODE_NEW_GAME               = 0,
	E_GAME_START_MODE_RENEWAL                = 1,
	E_GAME_START_MODE_REINCARNATION          = 2,
	E_GAME_START_MODE_CREATION               = 3,
	E_GAME_START_MODE_MAX                    = 4,
};

// Enum Project.E_ALIGNMENT
// NumValues: 0x0007
enum class E_ALIGNMENT : uint8
{
	E_ALIGNMENT_NEUTRAL                      = 0,
	E_ALIGNMENT_LAW                          = 1,
	E_ALIGNMENT_CHAOS                        = 2,
	E_ALIGNMENT_NEUTRAL_EX                   = 3,
	E_ALIGNMENT_TAO                          = 4,
	E_ALIGNMENT_YOKO                         = 5,
	E_ALIGNMENT_MAX                          = 6,
};

// Enum Project.E_MOON_AGE
// NumValues: 0x0011
enum class E_MOON_AGE : uint8
{
	E_MOON_AGE_SILENT                        = 0,
	E_MOON_AGE_1_8                           = 1,
	E_MOON_AGE_2_8                           = 2,
	E_MOON_AGE_3_8                           = 3,
	E_MOON_AGE_HALF                          = 4,
	E_MOON_AGE_5_8                           = 5,
	E_MOON_AGE_6_8                           = 6,
	E_MOON_AGE_7_8                           = 7,
	E_MOON_AGE_FULL                          = 8,
	E_MOON_AGE_7_8_REV                       = 9,
	E_MOON_AGE_6_8_REV                       = 10,
	E_MOON_AGE_5_8_REV                       = 11,
	E_MOON_AGE_HALF_REV                      = 12,
	E_MOON_AGE_3_8_REV                       = 13,
	E_MOON_AGE_2_8_REV                       = 14,
	E_MOON_AGE_1_8_REV                       = 15,
	E_MOON_AGE_MAX                           = 16,
};

// Enum Project.E_PARTNER_ID
// NumValues: 0x0005
enum class E_PARTNER_ID : uint8
{
	E_PARTNER_ID_LAW                         = 0,
	E_PARTNER_ID_CHAOS                       = 1,
	E_PARTNER_ID_MAX                         = 2,
	E_PARTNER_ID_INVALID                     = 3,
	E_PARTNER_ID_INVALID_MAX                 = 4,
};

// Enum Project.E_GROUP_ID
// NumValues: 0x0034
enum class E_GROUP_ID : uint8
{
	E_GROUP_ID_DUMMY                         = 0,
	E_GROUP_ID_SHINREI                       = 1,
	E_GROUP_ID_DAITENSHI                     = 2,
	E_GROUP_ID_MEGAMI                        = 3,
	E_GROUP_ID_REICHO                        = 4,
	E_GROUP_ID_TENSHI                        = 5,
	E_GROUP_ID_YOUMA                         = 6,
	E_GROUP_ID_JASHIN                        = 7,
	E_GROUP_ID_KYOUCHO                       = 8,
	E_GROUP_ID_REIKEN                        = 9,
	E_GROUP_ID_MAJIN                         = 10,
	E_GROUP_ID_GUNSHIN                       = 11,
	E_GROUP_ID_SHINJUU                       = 12,
	E_GROUP_ID_SEIJUU                        = 13,
	E_GROUP_ID_GENMA                         = 14,
	E_GROUP_ID_SEIREI                        = 15,
	E_GROUP_ID_MITAMA                        = 16,
	E_GROUP_ID_YOUSEI                        = 17,
	E_GROUP_ID_MAJUU                         = 18,
	E_GROUP_ID_CHIREI                        = 19,
	E_GROUP_ID_MAHITO                        = 20,
	E_GROUP_ID_JAKI                          = 21,
	E_GROUP_ID_YOUJUU                        = 22,
	E_GROUP_ID_HAKAISHIN                     = 23,
	E_GROUP_ID_ZIBOSHIN                      = 24,
	E_GROUP_ID_RYUUJIN                       = 25,
	E_GROUP_ID_KISHIN                        = 26,
	E_GROUP_ID_KUNITSUKAMI                   = 27,
	E_GROUP_ID_KIJO                          = 28,
	E_GROUP_ID_YOUKI                         = 29,
	E_GROUP_ID_DATENSHI                      = 30,
	E_GROUP_ID_YAMA                          = 31,
	E_GROUP_ID_RYUUO                         = 32,
	E_GROUP_ID_MAO                           = 33,
	E_GROUP_ID_JARYU                         = 34,
	E_GROUP_ID_YUKI                          = 35,
	E_GROUP_ID_GEDO                          = 36,
	E_GROUP_ID_KONTONO                       = 37,
	E_GROUP_ID_DAIMAO                        = 38,
	E_GROUP_ID_TYOUJIN                       = 39,
	E_GROUP_ID_NAHOBINO                      = 40,
	E_GROUP_ID_JINZOUMAJIN                   = 41,
	E_GROUP_ID_JISHOU                        = 42,
	E_GROUP_ID_SHISEIJO                      = 43,
	GROUP_ID_HISHIN                          = 44,
	GROUP_ID_CHINJYU                         = 45,
	GROUP_ID_NYOMA                           = 46,
	GROUP_ID_NINGEN                          = 47,
	GROUP_ID_GENTENSHI                       = 48,
	GROUP_ID_KYODAIREI                       = 49,
	E_GROUP_ID_MAX                           = 50,
	E_GROUP_MAX                              = 51,
};

// Enum Project.E_CHAR_GL_FLAG
// NumValues: 0x0004
enum class E_CHAR_GL_FLAG : uint8
{
	E_CHAR_GL_FLAG_NONE                      = 0,
	E_CHAR_GL_FLAG_ENTRY                     = 1,
	E_CHAR_GL_FLAG_BATTLE_UNIT               = 2,
	E_CHAR_GL_FLAG_MAX                       = 3,
};

// Enum Project.E_ENDURE_TYPE
// NumValues: 0x0017
enum class E_ENDURE_TYPE : uint8
{
	E_ENDURE_TYPE_NONE                       = 0,
	E_ENDURE_TYPE_PHYSICAL                   = 1,
	E_ENDURE_TYPE_FIRE                       = 2,
	E_ENDURE_TYPE_ICE                        = 3,
	E_ENDURE_TYPE_THUNDER                    = 4,
	E_ENDURE_TYPE_WIND                       = 5,
	E_ENDURE_TYPE_LIGHT                      = 6,
	E_ENDURE_TYPE_DARK                       = 7,
	E_ENDURE_TYPE_ALL                        = 8,
	E_ENDURE_TYPE_POISON                     = 9,
	E_ENDURE_TYPE_VERTIGO                    = 10,
	E_ENDURE_TYPE_CONFUSE                    = 11,
	E_ENDURE_TYPE_CHARM                      = 12,
	E_ENDURE_TYPE_SLEEP                      = 13,
	E_ENDURE_TYPE_CLOSE                      = 14,
	E_ENDURE_TYPE_STRAY                      = 15,
	E_ENDURE_TYPE_BURN                       = 16,
	E_ENDURE_TYPE_FREEZE                     = 17,
	E_ENDURE_TYPE_SHOCK                      = 18,
	E_ENDURE_TYPE_LACERATION                 = 19,
	E_ENDURE_TYPE_STONE                      = 20,
	E_ENDURE_TYPE_DAZZLE                     = 21,
	E_ENDURE_TYPE_MAX                        = 22,
};

// Enum Project.E_ENDUREWEAK_TYPE
// NumValues: 0x0007
enum class E_ENDUREWEAK_TYPE : uint8
{
	E_ENDUREWEAK_TYPE_NORMAL                 = 0,
	E_ENDUREWEAK_TYPE_BLOCK                  = 1,
	E_ENDUREWEAK_TYPE_WEAK                   = 2,
	E_ENDUREWEAK_TYPE_REFLEX                 = 3,
	E_ENDUREWEAK_TYPE_ABSORB                 = 4,
	E_ENDUREWEAK_TYPE_ENDURE                 = 5,
	E_ENDUREWEAK_TYPE_MAX                    = 6,
};

// Enum Project.E_CHAR_ATTR_TYPE
// NumValues: 0x0007
enum class E_CHAR_ATTR_TYPE : uint8
{
	E_CHAR_ATTR_TYPE_NONE                    = 0,
	E_CHAR_ATTR_TYPE_NEUTRAL                 = 1,
	E_CHAR_ATTR_TYPE_LIGHT                   = 2,
	E_CHAR_ATTR_TYPE_DARK                    = 3,
	E_CHAR_ATTR_TYPE_LAW                     = 4,
	E_CHAR_ATTR_TYPE_CHAOS                   = 5,
	E_CHAR_ATTR_TYPE_MAX                     = 6,
};

// Enum Project.E_BST_TYPE
// NumValues: 0x0004
enum class E_BST_TYPE : uint8
{
	E_BST_TYPE_ATTR                          = 0,
	E_BST_TYPE_ABNORMAL                      = 1,
	E_BST_TYPE_ETC                           = 2,
	E_BST_TYPE_MAX                           = 3,
};

// Enum Project.E_BAD_STATUS
// NumValues: 0x0012
enum class E_BAD_STATUS : uint8
{
	E_BAD_STATUS_NONE                        = 0,
	E_BAD_STATUS_DEAD                        = 1,
	E_BAD_STATUS_POISON                      = 2,
	E_BAD_STATUS_STAN                        = 3,
	E_BAD_STATUS_CONFUSE                     = 4,
	E_BAD_STATUS_CHARM                       = 5,
	E_BAD_STATUS_SLEEP                       = 6,
	E_BAD_STATUS_CLOSE                       = 7,
	E_BAD_STATUS_STRAY                       = 8,
	E_BAD_STATUS_STONE                       = 9,
	E_BAD_STATUS_DAZZLE                      = 10,
	E_BAD_STATUS_BURN                        = 11,
	E_BAD_STATUS_FREEZE                      = 12,
	E_BAD_STATUS_SHOCK                       = 13,
	E_BAD_STATUS_LACERATION                  = 14,
	E_BAD_STATUS_MUD                         = 15,
	E_BAD_STATUS_DARKNESS                    = 16,
	E_BAD_STATUS_MAX                         = 17,
};

// Enum Project.E_MAP_OBJ_BATTLE_TYPE
// NumValues: 0x0005
enum class E_MAP_OBJ_BATTLE_TYPE : uint8
{
	E_MAP_OBJ_BATTLE_TYPE_NO_OBJ             = 0,
	E_MAP_OBJ_BATTLE_TYPE_NOTHING            = 1,
	E_MAP_OBJ_BATTLE_TYPE_HIDDEN             = 2,
	E_MAP_OBJ_BATTLE_TYPE_DITHER             = 3,
	E_MAP_OBJ_BATTLE_TYPE_MAX                = 4,
};

// Enum Project.E_GARDENPLAYER_FADETYPE
// NumValues: 0x0003
enum class E_GARDENPLAYER_FADETYPE : uint8
{
	E_ANTEN                                  = 0,
	E_MEITEN                                 = 1,
	E_MAX                                    = 2,
};

// Enum Project.E_GARDEN_FC_DEVIL_COL_TYPE
// NumValues: 0x0005
enum class E_GARDEN_FC_DEVIL_COL_TYPE : uint8
{
	E_TYPE_A                                 = 0,
	E_TYPE_B                                 = 1,
	E_TYPE_C                                 = 2,
	E_TYPE_LL                                = 3,
	E_TYPE_MAX                               = 4,
};

// Enum Project.E_GARDEN_FREE_CAMERA_STATE
// NumValues: 0x0007
enum class E_GARDEN_FREE_CAMERA_STATE : uint8
{
	None                                     = 0,
	Deactive                                 = 1,
	ActiveRequested                          = 2,
	Active                                   = 3,
	ToggleRequested                          = 4,
	DeactiveRequested                        = 5,
	MAX                                      = 6,
};

// Enum Project.E_GARDEN_TROPHY_COUNTER_TYPE
// NumValues: 0x0003
enum class E_GARDEN_TROPHY_COUNTER_TYPE : uint8
{
	E_TRIBUTE                                = 0,
	E_TRUST                                  = 1,
	E_MAX                                    = 2,
};

// Enum Project.E_GARDEN_TALK_TYPE
// NumValues: 0x0005
enum class E_GARDEN_TALK_TYPE : uint8
{
	E_TRUST                                  = 0,
	E_POWERUP                                = 1,
	E_ITEM                                   = 2,
	E_QUEST                                  = 3,
	E_MAX                                    = 4,
};

// Enum Project.E_ENEMY_TYPE
// NumValues: 0x0005
enum class E_ENEMY_TYPE : uint8
{
	E_NORMAL                                 = 0,
	E_SPECIAL                                = 1,
	E_BOSS                                   = 2,
	E_MAGATSUHI                              = 3,
	E_MAX                                    = 4,
};

// Enum Project.E_GARDEN_SPAWN_AREA
// NumValues: 0x0003
enum class E_GARDEN_SPAWN_AREA : uint8
{
	E_GROUND                                 = 0,
	E_WATER                                  = 1,
	E_MAX                                    = 2,
};

// Enum Project.E_GARDEN_SPAWN_ANIMATION
// NumValues: 0x0003
enum class E_GARDEN_SPAWN_ANIMATION : uint8
{
	E_STAND                                  = 0,
	E_CHAIR                                  = 1,
	E_MAX                                    = 2,
};

// Enum Project.E_GARDEN_SPAWN_SIZE
// NumValues: 0x0003
enum class E_GARDEN_SPAWN_SIZE : uint8
{
	E_ALL                                    = 0,
	E_SMALL                                  = 1,
	E_MAX                                    = 2,
};

// Enum Project.E_GARDEN_SYS_TEXT
// NumValues: 0x0004
enum class E_GARDEN_SYS_TEXT : uint8
{
	GDN_SYS_ERROR                            = 0,
	GDN_SYS_REWARD_STATS                     = 1,
	GDN_SYS_REWARD_POTENTIAL                 = 2,
	GDN_SYS_MAX                              = 3,
};

// Enum Project.E_GARDEN_CHAT_MSG_TYPE
// NumValues: 0x0005
enum class E_GARDEN_CHAT_MSG_TYPE : uint8
{
	E_GARDEN_CHAT_COND_NONE                  = 0,
	E_GARDEN_CHAT_COND_GARDENAREA            = 1,
	E_GARDEN_CHAT_COND_PROGRESS              = 2,
	E_GARDEN_CHAT_COND_SPOT                  = 3,
	E_GARDEN_CHAT_COND_MAX                   = 4,
};

// Enum Project.E_GARDEN_MSG_USE_TYPE
// NumValues: 0x0004
enum class E_GARDEN_MSG_USE_TYPE : uint8
{
	MSG_NONE                                 = 0,
	MSG_SPT                                  = 1,
	MSG_UNQ                                  = 2,
	MSG_MAX                                  = 3,
};

// Enum Project.E_GARDEN_BALANCE_TARGET
// NumValues: 0x003A
enum class E_GARDEN_BALANCE_TARGET : uint8
{
	DESIRE_POINT_BTL_NORM                    = 0,
	DESIRE_POINT_BTL_BOSS                    = 1,
	DESIRE_POINT_MIMAN                       = 2,
	DESIRE_POINT_STATUE                      = 3,
	DESIRE_POINT_MAGATSUKA                   = 4,
	DESIRE_POINT_RYU_OVER                    = 5,
	DESIRE_POINT_RYU_UNDR                    = 6,
	DESIRE_POINT_MAP                         = 7,
	DESIRE_POINT_QUEST                       = 8,
	DESIRE_POINT_DVT_NORM                    = 9,
	DESIRE_POINT_DVT_RARE                    = 10,
	TRUST_POINT_BTL_NORM                     = 11,
	TRUST_POINT_BTL_SPCL                     = 12,
	TRUST_POINT_BTL_BOSS                     = 13,
	TRUST_POINT_BTL_MGHI                     = 14,
	TRUST_POINT_BTL_STCK                     = 15,
	TRUST_POINT_DVT_NORM                     = 16,
	TRUST_POINT_DVT_RARE                     = 17,
	GARDENTALK_POINT_ADD                     = 18,
	GARDENTALK_POINT_PWR                     = 19,
	GARDENTALK_POINT_ITEM                    = 20,
	GARDENTALK_POINT_MAX                     = 21,
	GARDEN_DESIRE_POINT_MAX                  = 22,
	GARDEN_TRUST_POINT_MAX                   = 23,
	DEVIL_MAXSPAWN                           = 24,
	DEVIL_WEIGHT_NORM                        = 25,
	DEVIL_WEIGHT_GUEST                       = 26,
	SPOT_WEIGHT_NORM                         = 27,
	SPOT_WEIGHT_CHAIR                        = 28,
	SPOT_WEIGHT_SMALL                        = 29,
	TRUST_BTL_LEVELDIF_1                     = 30,
	TRUST_BTL_LEVELDIF_2                     = 31,
	TRUST_BTL_LEVELDIF_3                     = 32,
	TRUST_BTL_LEVELDIF_4                     = 33,
	TRUST_BTL_LEVELDIF_5                     = 34,
	TRUST_BTL_LEVELDIF_6                     = 35,
	TRUST_BTL_LEVELDIF_7                     = 36,
	TRUST_BTL_LEVELDIF_8                     = 37,
	TRUST_BTL_LEVELDIF_9                     = 38,
	TRUST_BTL_LEVELDIF_10PLUS                = 39,
	TALK_WEIGHT_NORM                         = 40,
	TALK_WEIGHT_COND                         = 41,
	TALK_WEIGHT_UNREAD                       = 42,
	PWR_WEIGHT_PARAMUP_ONE                   = 43,
	PWR_WEIGHT_PARAMUP_TWO                   = 44,
	PWR_WEIGHT_PARAMUP_THREE                 = 45,
	PWR_WEIGHT_PARAM                         = 46,
	PWR_WEIGHT_SKILL                         = 47,
	ITEM_WEIGHT_HEAL                         = 48,
	ITEM_WEIGHT_ATTACK                       = 49,
	ITEM_WEIGHT_RARE                         = 50,
	PWR_PARAMUP_TRUST                        = 51,
	SKILL_RANK_PWR                           = 52,
	SKILL_RANK_TRUST                         = 53,
	PLATALK_WEIGHT_NORM                      = 54,
	PLATALK_WEIGHT_UNREAD                    = 55,
	PLATALK_POWERUP_POINT                    = 56,
	E_GARDEN_BALANCE_MAX                     = 57,
};

// Enum Project.E_GARDEN_CHARA_MOTION_ID
// NumValues: 0x0007
enum class E_GARDEN_CHARA_MOTION_ID : uint8
{
	NONE                                     = 0,
	GARDEN_SIT_1                             = 93,
	GARDEN_SIT_2                             = 94,
	GARDEN_SIT_3                             = 95,
	GARDEN_SIT_4                             = 96,
	GARDEN_SIT_5                             = 97,
	E_GARDEN_CHARA_MOTION_MAX                = 98,
};

// Enum Project.E_GIFT_TYPE
// NumValues: 0x0009
enum class E_GIFT_TYPE : uint8
{
	E_GIFT_TYPE_DUMMY                        = 0,
	E_GIFT_TYPE_FIRE                         = 1,
	E_GIFT_TYPE_COLD                         = 2,
	E_GIFT_TYPE_ELECTRICITY                  = 3,
	E_GIFT_TYPE_WIND                         = 4,
	E_GIFT_TYPE_LIGHT                        = 5,
	E_GIFT_TYPE_DARK                         = 6,
	E_GIFT_TYPE_HEAL                         = 7,
	E_GIFT_TYPE_MAX                          = 8,
};

// Enum Project.E_GODPARAMETER_ID
// NumValues: 0x0094
enum class E_GODPARAMETER_ID : uint8
{
	E_GODPARAMETER_DUMMY                     = 0,
	E_GODPARAMETER_HADOU_00                  = 1,
	E_GODPARAMETER_HADOU_01                  = 2,
	E_GODPARAMETER_HADOU_02                  = 3,
	E_GODPARAMETER_HADOU_03                  = 4,
	E_GODPARAMETER_HADOU_04                  = 5,
	E_GODPARAMETER_HADOU_05                  = 6,
	E_GODPARAMETER_HADOU_06                  = 7,
	E_GODPARAMETER_HADOU_07                  = 8,
	E_GODPARAMETER_HADOU_08                  = 9,
	E_GODPARAMETER_HADOU_09                  = 10,
	E_GODPARAMETER_HADOU_10                  = 11,
	E_GODPARAMETER_HADOU_11                  = 12,
	E_GODPARAMETER_HADOU_12                  = 13,
	E_GODPARAMETER_HADOU_13                  = 14,
	E_GODPARAMETER_HADOU_14                  = 15,
	E_GODPARAMETER_HADOU_15                  = 16,
	E_GODPARAMETER_HADOU_16                  = 17,
	E_GODPARAMETER_HADOU_17                  = 18,
	E_GODPARAMETER_HADOU_18                  = 19,
	E_GODPARAMETER_HADOU_19                  = 20,
	E_GODPARAMETER_HADOU_20                  = 21,
	E_GODPARAMETER_HADOU_21                  = 22,
	E_GODPARAMETER_HADOU_22                  = 23,
	E_GODPARAMETER_HADOU_23                  = 24,
	E_GODPARAMETER_HADOU_24                  = 25,
	E_GODPARAMETER_HADOU_25                  = 26,
	E_GODPARAMETER_HUKUIN_00                 = 27,
	E_GODPARAMETER_HUKUIN_01                 = 28,
	E_GODPARAMETER_HUKUIN_02                 = 29,
	E_GODPARAMETER_HUKUIN_03                 = 30,
	E_GODPARAMETER_HUKUIN_04                 = 31,
	E_GODPARAMETER_HUKUIN_05                 = 32,
	E_GODPARAMETER_HUKUIN_06                 = 33,
	E_GODPARAMETER_HUKUIN_07                 = 34,
	E_GODPARAMETER_HUKUIN_08                 = 35,
	E_GODPARAMETER_HUKUIN_09                 = 36,
	E_GODPARAMETER_HUKUIN_10                 = 37,
	E_GODPARAMETER_HUKUIN_11                 = 38,
	E_GODPARAMETER_HUKUIN_12                 = 39,
	E_GODPARAMETER_HUKUIN_13                 = 40,
	E_GODPARAMETER_HUKUIN_14                 = 41,
	E_GODPARAMETER_KAKUSEI_00                = 42,
	E_GODPARAMETER_KAKUSEI_01                = 43,
	E_GODPARAMETER_KAKUSEI_02                = 44,
	E_GODPARAMETER_KAKUSEI_03                = 45,
	E_GODPARAMETER_KAKUSEI_04                = 46,
	E_GODPARAMETER_KAKUSEI_05                = 47,
	E_GODPARAMETER_KAKUSEI_06                = 48,
	E_GODPARAMETER_KAKUSEI_07                = 49,
	E_GODPARAMETER_KAKUSEI_08                = 50,
	E_GODPARAMETER_KAKUSEI_09                = 51,
	E_GODPARAMETER_KAKUSEI_10                = 52,
	E_GODPARAMETER_KAKUSEI_11                = 53,
	E_GODPARAMETER_KAKUSEI_12                = 54,
	E_GODPARAMETER_KAKUSEI_13                = 55,
	E_GODPARAMETER_KAKUSEI_14                = 56,
	E_GODPARAMETER_KAKUSEI_15                = 57,
	E_GODPARAMETER_KAKUSEI_16                = 58,
	E_GODPARAMETER_KAKUSEI_17                = 59,
	E_GODPARAMETER_KAKUSEI_18                = 60,
	E_GODPARAMETER_KAKUSEI_19                = 61,
	E_GODPARAMETER_KAKUSEI_20                = 62,
	E_GODPARAMETER_KAKUSEI_21                = 63,
	E_GODPARAMETER_KAKUSEI_22                = 64,
	E_GODPARAMETER_BANSYOU_00                = 65,
	E_GODPARAMETER_BANSYOU_01                = 66,
	E_GODPARAMETER_BANSYOU_02                = 67,
	E_GODPARAMETER_BANSYOU_03                = 68,
	E_GODPARAMETER_BANSYOU_04                = 69,
	E_GODPARAMETER_BANSYOU_05                = 70,
	E_GODPARAMETER_BANSYOU_06                = 71,
	E_GODPARAMETER_BANSYOU_07                = 72,
	E_GODPARAMETER_BANSYOU_08                = 73,
	E_GODPARAMETER_BANSYOU_09                = 74,
	E_GODPARAMETER_BANSYOU_10                = 75,
	E_GODPARAMETER_BANSYOU_11                = 76,
	E_GODPARAMETER_BANSYOU_12                = 77,
	E_GODPARAMETER_BANSYOU_13                = 78,
	E_GODPARAMETER_BANSYOU_14                = 79,
	E_GODPARAMETER_BANSYOU_15                = 80,
	E_GODPARAMETER_BANSYOU_16                = 81,
	E_GODPARAMETER_BANSYOU_17                = 82,
	E_GODPARAMETER_BANSYOU_18                = 83,
	E_GODPARAMETER_BANSYOU_19                = 84,
	E_GODPARAMETER_BANSYOU_20                = 85,
	E_GODPARAMETER_BANSYOU_21                = 86,
	E_GODPARAMETER_BANSYOU_22                = 87,
	E_GODPARAMETER_BANSYOU_23                = 88,
	E_GODPARAMETER_BANSYOU_24                = 89,
	E_GODPARAMETER_BANSYOU_25                = 90,
	E_GODPARAMETER_BANSYOU_26                = 91,
	E_GODPARAMETER_BANSYOU_27                = 92,
	E_GODPARAMETER_BANSYOU_28                = 93,
	E_GODPARAMETER_BANSYOU_29                = 94,
	E_GODPARAMETER_BANSYOU_30                = 95,
	E_GODPARAMETER_BANSYOU_31                = 96,
	E_GODPARAMETER_BANSYOU_32                = 97,
	E_GODPARAMETER_BANSYOU_33                = 98,
	E_GODPARAMETER_BANSYOU_34                = 99,
	E_GODPARAMETER_BANSYOU_35                = 100,
	E_GODPARAMETER_BANSYOU_36                = 101,
	E_GODPARAMETER_BANSYOU_37                = 102,
	E_GODPARAMETER_BANSYOU_38                = 103,
	E_GODPARAMETER_BANSYOU_39                = 104,
	E_GODPARAMETER_BANSYOU_40                = 105,
	E_GODPARAMETER_BANSYOU_41                = 106,
	E_GODPARAMETER_BANSYOU_42                = 107,
	E_GODPARAMETER_BANSYOU_43                = 108,
	E_GODPARAMETER_BANSYOU_44                = 109,
	E_GODPARAMETER_BANSYOU_45                = 110,
	E_GODPARAMETER_BANSYOU_46                = 111,
	E_GODPARAMETER_BANSYOU_47                = 112,
	E_GODPARAMETER_BANSYOU_48                = 113,
	E_GODPARAMETER_BANSYOU_49                = 114,
	E_GODPARAMETER_BANSYOU_50                = 115,
	E_GODPARAMETER_HADOU_26                  = 116,
	E_GODPARAMETER_HUKUIN_15                 = 117,
	E_GODPARAMETER_KAKUSEI_23                = 118,
	E_GODPARAMETER_KAKUSEI_24                = 119,
	E_GODPARAMETER_KAKUSEI_25                = 120,
	E_GODPARAMETER_HADOU_27                  = 121,
	E_GODPARAMETER_HADOU_28                  = 122,
	E_GODPARAMETER_HADOU_29                  = 123,
	E_GODPARAMETER_HADOU_30                  = 124,
	E_GODPARAMETER_HADOU_31                  = 125,
	E_GODPARAMETER_HADOU_32                  = 126,
	E_GODPARAMETER_HADOU_33                  = 127,
	E_GODPARAMETER_HADOU_34                  = 128,
	E_GODPARAMETER_HADOU_35                  = 129,
	E_GODPARAMETER_HADOU_36                  = 130,
	E_GODPARAMETER_HADOU_37                  = 131,
	E_GODPARAMETER_HADOU_38                  = 132,
	E_GODPARAMETER_HADOU_39                  = 133,
	E_GODPARAMETER_HADOU_40                  = 134,
	E_GODPARAMETER_HADOU_41                  = 135,
	E_GODPARAMETER_HADOU_42                  = 136,
	E_GODPARAMETER_HUKUIN_16                 = 137,
	E_GODPARAMETER_HUKUIN_17                 = 138,
	E_GODPARAMETER_HUKUIN_18                 = 139,
	E_GODPARAMETER_HUKUIN_19                 = 140,
	E_GODPARAMETER_HUKUIN_20                 = 141,
	E_GODPARAMETER_HUKUIN_21                 = 142,
	E_GODPARAMETER_HUKUIN_22                 = 143,
	E_GODPARAMETER_HUKUIN_23                 = 144,
	E_GODPARAMETER_KAKUSEI_26                = 145,
	E_GODPARAMETER_ID_END                    = 146,
	E_GODPARAMETER_MAX                       = 147,
};

// Enum Project.E_GODPARAMETER_TYPE
// NumValues: 0x0006
enum class E_GODPARAMETER_TYPE : uint8
{
	E_GODPARAMETER_TYPE_NONE                 = 0,
	E_GODPARAMETER_TYPE_HADOU                = 1,
	E_GODPARAMETER_TYPE_HUKUIN               = 2,
	E_GODPARAMETER_TYPE_KAKUSEI              = 3,
	E_GODPARAMETER_TYPE_BANSYOU              = 4,
	E_GODPARAMETER_TYPE_MAX                  = 5,
};

// Enum Project.E_GODPARAMETER_STATE
// NumValues: 0x0007
enum class E_GODPARAMETER_STATE : uint8
{
	E_GODPARAMETER_STATE_INVALID_ID          = 0,
	E_GODPARAMETER_STATE_NOT_DISPLAY         = 1,
	E_GODPARAMETER_STATE_NOT_PRIMISE_SKILL   = 2,
	E_GODPARAMETER_STATE_NOT_ENOUGH_POINT    = 3,
	E_GODPARAMETER_STATE_ENABLE_LEARNING     = 4,
	E_GODPARAMETER_STATE_ALREADY_LEARNING    = 5,
	E_GODPARAMETER_STATE_MAX                 = 6,
};

// Enum Project.E_HEALCHARAPANELFLAG
// NumValues: 0x0009
enum class E_HEALCHARAPANELFLAG : uint8
{
	CPLAYER                                  = 0,
	CPLAYERDEVIL                             = 1,
	CPLAYERDEVIIL_EVENT                      = 2,
	CFREE                                    = 3,
	CEMPTY                                   = 4,
	CBATTLEIN                                = 5,
	CSTOCK                                   = 6,
	CSUMMONED                                = 7,
	E_MAX                                    = 8,
};

// Enum Project.E_HEALCHARAPANELCTRL_GSTATUS
// NumValues: 0x0011
enum class E_HEALCHARAPANELCTRL_GSTATUS : uint8
{
	E_HEALCHARAPANELCTRL_INIT                = 0,
	E_HEALCHARAPANELCTRL_CREATE_TARGETSELECT = 1,
	E_HEALCHARAPANELCTRL_SELECTTARGET        = 2,
	E_HEALCHARAPANELCTRL_HEAL                = 3,
	E_HEALCHARAPANELCTRL_WAIT_ENDHEAL        = 4,
	E_HEALCHARAPANELCTRL_ENDHEAL             = 5,
	E_HEALCHARAPANELCTRL_SET_ERROR           = 6,
	E_HEALCHARAPANELCTRL_WAIT_ERROR          = 7,
	E_HEALCHARAPANELCTRL_SELECTALL_ON        = 8,
	E_HEALCHARAPANELCTRL_SELECT_ALL          = 9,
	E_HEALCHARAPANELCTRL_HEALALL             = 10,
	E_HEALCHARAPANELCTRL_WAIT_HEALALL        = 11,
	E_HEALCHARAPANELCTRL_STATUSDETAILINIT    = 12,
	E_HEALCHARAPANELCTRL_STATUSDETAIL        = 13,
	E_HEALCHARAPANELCTRL_HEALT_WAITMESSAGE   = 14,
	E_HEALCHARAPANELCTRL_SINGLEHEAL          = 15,
	E_HEALCHARAPANELCTRL_MAX                 = 16,
};

// Enum Project.E_HEALCHARAPANELBASE
// NumValues: 0x0004
enum class E_HEALCHARAPANELBASE : uint8
{
	E_HEALCHARAPANELBASE_NONE                = 0,
	CLISTMAX                                 = 16,
	CPARTYLISTMAX                            = 36,
	E_MAX                                    = 37,
};

// Enum Project.EGazeTargetType
// NumValues: 0x000A
enum class EGazeTargetType : uint8
{
	Dummy                                    = 0,
	EnemyDevil                               = 1,
	NPCDevil                                 = 2,
	NPCHuman                                 = 3,
	TreasureBox                              = 4,
	VendingMachine                           = 5,
	Miman                                    = 6,
	Magatsuka                                = 7,
	Itsuduka                                 = 8,
	EGazeTargetType_MAX                      = 9,
};

// Enum Project.E_GAMEPAD_TYPE
// NumValues: 0x0006
enum class E_GAMEPAD_TYPE : uint8
{
	E_GAMEPAD_OTHER                          = 0,
	E_GAMEPAD_SWITCH                         = 1,
	E_GAMEPAD_PS4                            = 2,
	E_GAMEPAD_PS5                            = 3,
	E_GAMEPAD_XBOX                           = 4,
	E_GAMEPAD_MAX                            = 5,
};

// Enum Project.E_KeyboardLanguage
// NumValues: 0x000D
enum class E_KeyboardLanguage : uint8
{
	E_Other                                  = 0,
	E_Japanese                               = 1,
	E_English                                = 2,
	E_French                                 = 3,
	E_German                                 = 4,
	E_Spanish                                = 5,
	E_Italian                                = 6,
	E_Portuguese                             = 7,
	E_Russian                                = 8,
	E_ChineseT                               = 9,
	E_ChineseS                               = 10,
	E_Korean                                 = 11,
	E_MAX                                    = 12,
};

// Enum Project.E_NAHOBINO_ITEM_MOTION
// NumValues: 0x0004
enum class E_NAHOBINO_ITEM_MOTION : uint8
{
	E_NAHOBINO_ITEM_MOTION_NONE              = 0,
	E_NAHOBINO_ITEM_MOTION_ATTACK            = 1,
	E_NAHOBINO_ITEM_MOTION_SUPPORT           = 2,
	E_NAHOBINO_ITEM_MOTION_MAX               = 3,
};

// Enum Project.E_ITEM_ENABLE_SCENE
// NumValues: 0x0009
enum class E_ITEM_ENABLE_SCENE : uint8
{
	E_SKILL_ENABLE_SCENE_NOT_USE             = 0,
	E_SKILL_ENABLE_SCENE_FIELD               = 1,
	E_SKILL_ENABLE_SCENE_BATTLE              = 2,
	E_SKILL_ENABLE_SCENE_FACILITY            = 3,
	E_SKILL_ENABLE_SCENE_NOT_BATTLE          = 4,
	E_SKILL_ENABLE_SCENE_NOT_FIELD           = 5,
	E_SKILL_ENABLE_SCENE_NOT_FACILITY        = 6,
	E_SKILL_ENABLE_SCENE_ALL_SCENE           = 7,
	E_SKILL_ENABLE_SCENE_MAX                 = 8,
};

// Enum Project.E_ITEM_KIND
// NumValues: 0x0007
enum class E_ITEM_KIND : uint8
{
	E_ITEM_KIND_USE                          = 0,
	E_ITEM_KIND_SKILL_GET                    = 1,
	E_ITEM_KIND_UTSUSEMI                     = 2,
	E_ITEM_KIND_RELIC                        = 3,
	E_ITEM_KIND_IMPORTANT                    = 4,
	E_ITEM_KIND_INVALID                      = 5,
	E_ITEM_KIND_MAX                          = 6,
};

// Enum Project.E_ITEM_ICONTYPE
// NumValues: 0x0015
enum class E_ITEM_ICONTYPE : uint8
{
	ICON_NONE                                = 0,
	ICON_I_CURE                              = 1,
	ICON_PHYSICS                             = 2,
	ICON_FIRE                                = 3,
	ICON_ICE                                 = 4,
	ICON_THUNDER                             = 5,
	ICON_WIND                                = 6,
	ICON_LIGHT                               = 7,
	ICON_DARK                                = 8,
	ICON_BANNOU                              = 9,
	ICON_BST                                 = 10,
	ICON_CURE                                = 11,
	ICON_AID                                 = 12,
	ICON_SPECIAL                             = 13,
	ICON_PARAMETER_UP                        = 14,
	ICON_GET_SKILL                           = 15,
	ICON_PROPERTY_ADD                        = 16,
	ICON_DELIVERY                            = 17,
	ICON_RELIC                               = 18,
	ICON_VALUABLES                           = 19,
	ICON_MAX                                 = 20,
};

// Enum Project.E_ITEM_USECONDITION
// NumValues: 0x000B
enum class E_ITEM_USECONDITION : uint8
{
	E_ITEM_USECONDITION_NONE                 = 0,
	E_ITEM_USECONDITION_GOTOMAP              = 1,
	E_ITEM_USECONDITION_ENCOUNTOFF           = 2,
	E_ITEM_USECONDITION_CHANGETEKISEI        = 3,
	E_ITEM_USECONDITION_REPLACEMENTTEKISEI   = 4,
	E_ITEM_USECONDITION_CHANGEGODPARAMETER   = 5,
	E_ITEM_USECONDITION_KUISHIBARI           = 6,
	E_ITEM_USECONDITION_RENZOKU_UP           = 7,
	E_ITEM_USECONDITION_CHANGEPARAMETER      = 8,
	E_ITEM_USECONDITION_NOTSELECTED_MULTIPLE = 9,
	E_ITEM_USECONDITION_MAX                  = 10,
};

// Enum Project.E_KAMUI_SORT_TYPE
// NumValues: 0x0006
enum class E_KAMUI_SORT_TYPE : uint8
{
	TYPE                                     = 0,
	COST                                     = 1,
	NOT_LEARNING                             = 2,
	ENABLE_LEARNING                          = 3,
	NEW                                      = 4,
	E_KAMUI_SORT_MAX                         = 5,
};

// Enum Project.E_KAMUI_UI_USE_KEY
// NumValues: 0x000B
enum class E_KAMUI_UI_USE_KEY : uint8
{
	NONE                                     = 0,
	ACTION                                   = 1,
	CANCEL                                   = 2,
	SORT                                     = 3,
	UP                                       = 4,
	DOWN                                     = 5,
	LEFT                                     = 6,
	RIGHT                                    = 7,
	TAB_L                                    = 8,
	TAB_R                                    = 9,
	E_KAMUI_UI_USE_MAX                       = 10,
};

// Enum Project.E_KAMUI_UI_INPUT_TYPE
// NumValues: 0x0004
enum class E_KAMUI_UI_INPUT_TYPE : uint8
{
	NONE                                     = 0,
	TRIGGER                                  = 1,
	REPEAT                                   = 2,
	E_KAMUI_UI_INPUT_MAX                     = 3,
};

// Enum Project.EKawaiiHairActionType
// NumValues: 0x0004
enum class EKawaiiHairActionType : uint8
{
	Walk                                     = 0,
	Run                                      = 1,
	Dash                                     = 2,
	EKawaiiHairActionType_MAX                = 3,
};

// Enum Project.E_StickButtonAction
// NumValues: 0x0004
enum class E_StickButtonAction : uint8
{
	E_StickButtonAction_None                 = 0,
	E_StickButtonAction_ToggleAutoRun        = 1,
	E_StickButtonAction_CameraReset          = 2,
	E_StickButtonAction_MAX                  = 3,
};

// Enum Project.E_LOCATION_WINDOW_STATE
// NumValues: 0x0006
enum class E_LOCATION_WINDOW_STATE : uint8
{
	Invalid                                  = 0,
	Closed                                   = 1,
	Opening                                  = 2,
	Opened                                   = 3,
	Closing                                  = 4,
	E_LOCATION_WINDOW_MAX                    = 5,
};

// Enum Project.E_LOCATION_WINDOW_TYPE
// NumValues: 0x0006
enum class E_LOCATION_WINDOW_TYPE : uint8
{
	None                                     = 0,
	Map                                      = 1,
	Facility                                 = 2,
	Automap                                  = 3,
	Largemap                                 = 4,
	E_LOCATION_WINDOW_MAX                    = 5,
};

// Enum Project.E_MAPCHARAPANELBASE
// NumValues: 0x0003
enum class E_MAPCHARAPANELBASE : uint8
{
	E_MAPCHARAPANELBASE_NONE                 = 0,
	CLISTMAX                                 = 4,
	E_MAX                                    = 5,
};

// Enum Project.E_MAGATSUKA_STATE
// NumValues: 0x0003
enum class E_MAGATSUKA_STATE : uint8
{
	E_MAGATSUKA_STATE_ACT                    = 0,
	E_MAGATSUKA_STATE_STOP                   = 1,
	E_MAGATSUKA_STATE_MAX                    = 2,
};

// Enum Project.E_AActionWindowType
// NumValues: 0x0006
enum class E_AActionWindowType : uint8
{
	E_AActionWindow_None                     = 0,
	E_AActionWindow_Search                   = 1,
	E_AActionWindow_MapIn                    = 2,
	E_AActionWindow_Talk                     = 3,
	E_AActionWindow_Open                     = 4,
	E_AActionWindow_MAX                      = 5,
};

// Enum Project.E_MAP_TOP_CAMERA_TRANSITION_STEP
// NumValues: 0x0005
enum class E_MAP_TOP_CAMERA_TRANSITION_STEP : uint8
{
	E_NEAR_MAP                               = 0,
	E_CHANGE                                 = 1,
	E_NEAR_TOP                               = 2,
	E_DONE                                   = 3,
	E_MAX                                    = 4,
};

// Enum Project.E_MAP_TOP_CAMERA_STEP
// NumValues: 0x0008
enum class E_MAP_TOP_CAMERA_STEP : uint8
{
	E_NONE                                   = 0,
	E_INITIALIZE                             = 1,
	E_TO_TOP_CAMERA                          = 2,
	E_PROCESS_INPUT                          = 3,
	E_TO_MAP_CAMERA                          = 4,
	E_FINALIZE                               = 5,
	E_DELETE                                 = 6,
	E_MAX                                    = 7,
};

// Enum Project.E_MESSAGE_TYPE
// NumValues: 0x0003
enum class E_MESSAGE_TYPE : uint8
{
	E_MESSAGE_TYPE_NORMAL                    = 0,
	E_MESSAGE_TYPE_SYSTEM                    = 1,
	E_MESSAGE_TYPE_MAX                       = 2,
};

// Enum Project.E_MIMAN_REWARD_ITEMSET
// NumValues: 0x0015
enum class E_MIMAN_REWARD_ITEMSET : uint8
{
	E_MIMAN_REWARD_ITEMSET_DUMMY             = 0,
	E_MIMAN_REWARD_ITEMSET_00                = 1,
	E_MIMAN_REWARD_ITEMSET_01                = 2,
	E_MIMAN_REWARD_ITEMSET_02                = 3,
	E_MIMAN_REWARD_ITEMSET_03                = 4,
	E_MIMAN_REWARD_ITEMSET_04                = 5,
	E_MIMAN_REWARD_ITEMSET_05                = 6,
	E_MIMAN_REWARD_ITEMSET_06                = 7,
	E_MIMAN_REWARD_ITEMSET_07                = 8,
	E_MIMAN_REWARD_ITEMSET_08                = 9,
	E_MIMAN_REWARD_ITEMSET_09                = 10,
	E_MIMAN_REWARD_ITEMSET_10                = 11,
	E_MIMAN_REWARD_ITEMSET_11                = 12,
	E_MIMAN_REWARD_ITEMSET_12                = 13,
	E_MIMAN_REWARD_ITEMSET_13                = 14,
	E_MIMAN_REWARD_ITEMSET_14                = 15,
	E_MIMAN_REWARD_ITEMSET_15                = 16,
	E_MIMAN_REWARD_ITEMSET_16                = 17,
	E_MIMAN_REWARD_ITEMSET_17                = 18,
	E_MIMAN_REWARD_ITEMSET_18                = 19,
	E_MIMAN_REWARD_ITEMSET_MAX               = 20,
};

// Enum Project.E_MINIMAP_AREA_TABLE_OVERRIDE_TARGET
// NumValues: 0x0004
enum class E_MINIMAP_AREA_TABLE_OVERRIDE_TARGET : uint8
{
	NONE                                     = 0,
	MinimapZoom                              = 1,
	Footprint                                = 2,
	E_MINIMAP_AREA_TABLE_OVERRIDE_MAX        = 3,
};

// Enum Project.E_MINIMAP_ICON_SORT_TYPE
// NumValues: 0x0003
enum class E_MINIMAP_ICON_SORT_TYPE : uint8
{
	NORMAL                                   = 0,
	RYUKETSU                                 = 1,
	E_MINIMAP_ICON_SORT_MAX                  = 2,
};

// Enum Project.E_MINIMAP_CHANGE_TYPE
// NumValues: 0x000B
enum class E_MINIMAP_CHANGE_TYPE : uint8
{
	MAP_MOVE                                 = 0,
	MAP_SELECT                               = 1,
	RYUKETSU                                 = 2,
	RESET                                    = 3,
	OTHER                                    = 4,
	MODE_CHANGE                              = 5,
	NEXT_AREA                                = 6,
	AREA_MOVE                                = 7,
	FOCUS_TARGET                             = 8,
	GARDEN                                   = 9,
	E_MINIMAP_CHANGE_MAX                     = 10,
};

// Enum Project.E_POP_UP_ICON_TYPE
// NumValues: 0x0005
enum class E_POP_UP_ICON_TYPE : uint8
{
	NONE                                     = 0,
	ENEMY_ACTIVE                             = 1,
	ENEMY_IDLE                               = 2,
	NAVI                                     = 3,
	E_POP_UP_ICON_MAX                        = 4,
};

// Enum Project.E_MINIMAP_LOAD_STATE
// NumValues: 0x0003
enum class E_MINIMAP_LOAD_STATE : uint8
{
	NOT_LOADED                               = 0,
	LOADED                                   = 1,
	E_MINIMAP_LOAD_MAX                       = 2,
};

// Enum Project.E_TOKYO_ICON_TYPE
// NumValues: 0x0004
enum class E_TOKYO_ICON_TYPE : uint8
{
	E_ICON_NONE                              = 0,
	E_ICON_TALK                              = 1,
	E_ICON_MISSION                           = 2,
	E_ICON_MAX                               = 3,
};

// Enum Project.E_MAP_3D_ICON
// NumValues: 0x000B
enum class E_MAP_3D_ICON : uint8
{
	E_MAP_3D_ICON_NONE                       = 0,
	E_MAP_3D_ICON_ENEMY_ACTIVE               = 1,
	E_MAP_3D_ICON_ENEMY_IDLE                 = 2,
	E_MAP_3D_ICON_MISSION_ENTRY              = 3,
	E_MAP_3D_ICON_MISSION_PROGRESS           = 4,
	E_MAP_3D_ICON_MISSION_REPORT             = 5,
	E_MAP_3D_ICON_MAIN_TARGET                = 6,
	E_MAP_3D_ICON_SUB_TARGET                 = 7,
	E_MAP_3D_ICON_TALK                       = 8,
	E_MAP_3D_ICON_AUTO                       = 9,
	E_MAP_3D_ICON_MAX                        = 10,
};

// Enum Project.E_MINIMAP_VISIBILITY
// NumValues: 0x0004
enum class E_MINIMAP_VISIBILITY : uint8
{
	INVISIBLE                                = 0,
	VISIBLE                                  = 1,
	OUTER                                    = 2,
	E_MINIMAP_MAX                            = 3,
};

// Enum Project.E_MINIMAP_POI_ICON
// NumValues: 0x0039
enum class E_MINIMAP_POI_ICON : uint8
{
	E_MINIMAP_POI_ICON_NONE                  = 0,
	E_MINIMAP_POI_ICON_ENEMY_ACTIVE          = 1,
	E_MINIMAP_POI_ICON_ENEMY_IDLE            = 2,
	E_MINIMAP_POI_ICON_MISSION_ENTRY         = 3,
	E_MINIMAP_POI_ICON_MISSION_PROGRESS      = 4,
	E_MINIMAP_POI_ICON_MISSION_REPORT        = 5,
	E_MINIMAP_POI_ICON_MAGATSUKA             = 6,
	E_MINIMAP_POI_ICON_RYUKETSU              = 7,
	E_MINIMAP_POI_ICON_MAIN_TARGET           = 8,
	E_MINIMAP_POI_ICON_SUB_TARGET            = 9,
	E_MINIMAP_POI_ICON_UNIQUE_ENEMY_ACTIVE   = 10,
	E_MINIMAP_POI_ICON_UNIQUE_ENEMY_IDLE     = 11,
	E_MINIMAP_POI_ICON_TALK                  = 12,
	E_MINIMAP_POI_ICON_TALK_OFF              = 13,
	E_MINIMAP_POI_ICON_TALK_IMPORTANT        = 14,
	E_MINIMAP_POI_ICON_GOD                   = 15,
	E_MINIMAP_POI_ICON_TREASURE              = 16,
	E_MINIMAP_POI_ICON_GENERAL               = 17,
	E_MINIMAP_POI_ICON_ENTRANCE              = 18,
	E_MINIMAP_POI_ICON_STAIR_UP              = 19,
	E_MINIMAP_POI_ICON_STAIR_DOWN            = 20,
	E_MINIMAP_POI_ICON_GATE                  = 21,
	E_MINIMAP_POI_ICON_DOOR                  = 22,
	E_MINIMAP_POI_ICON_SHOOT                 = 23,
	E_MINIMAP_POI_ICON_MIMAN                 = 24,
	E_MINIMAP_POI_ICON_RELIC                 = 25,
	E_MINIMAP_POI_ICON_NAVI                  = 26,
	E_MINIMAP_POI_ICON_ENEMY_STOP            = 27,
	E_MINIMAP_POI_ICON_UNIQUE_ENEMY_STOP     = 28,
	E_MINIMAP_POI_ICON_GATE_STOP             = 29,
	E_MINIMAP_POI_ICON_DOOR_STOP             = 30,
	E_MINIMAP_POI_ICON_TREASURE_STOP         = 31,
	E_MINIMAP_POI_ICON_RELIC_STOP            = 32,
	E_MINIMAP_POI_ICON_RYUKETSU_STOP         = 33,
	E_MINIMAP_POI_ICON_AUTO                  = 34,
	E_MINIMAP_POI_ICON_PLAYER                = 35,
	E_MINIMAP_POI_ICON_PLAYER_DIRECTION      = 36,
	E_MINIMAP_POI_ICON_MAIN_TARGET_LIST      = 37,
	E_MINIMAP_POI_ICON_SUB_TARGET_LIST       = 38,
	E_MINIMAP_POI_ICON_MAGATSUKA_LIST        = 39,
	E_MINIMAP_POI_ICON_CLIMB_POINT           = 40,
	E_MINIMAP_POI_ICON_DELIVERY              = 41,
	E_MINIMAP_POI_ICON_STATUE                = 42,
	E_MINIMAP_POI_ICON_NAVI_TALK             = 43,
	E_MINIMAP_POI_ICON_TREASURE_OPEN         = 44,
	E_MINIMAP_POI_ICON_MISSION_ENTRY_REPEAT  = 45,
	E_MINIMAP_POI_ICON_ROTATE_SWITCH         = 46,
	E_MINIMAP_POI_ICON_ROTATE_SWITCH_STOP    = 47,
	E_MINIMAP_POI_ICON_DOOR_CEILING          = 48,
	E_MINIMAP_POI_ICON_TREASURE_CEILING      = 49,
	E_MINIMAP_POI_ICON_ROTATE_COASTER        = 50,
	E_MINIMAP_POI_ICON_AOGAMI_DEBRIS         = 51,
	E_MINIMAP_POI_ICON_AOGAMI_DEBRIS_STOP    = 52,
	E_MINIMAP_POI_ICON_LANDMARK              = 53,
	E_MINIMAP_POI_ICON_LANDMARK_LIST         = 54,
	E_MINIMAP_POI_ICON_RYUKETSU_UNREGISTERED = 55,
	E_MINIMAP_POI_ICON_MAX                   = 56,
};

// Enum Project.E_MINIMAP_POI_TYPE
// NumValues: 0x0018
enum class E_MINIMAP_POI_TYPE : uint8
{
	E_MINIMAP_POI_TYPE_NONE                  = 0,
	E_MINIMAP_POI_TYPE_ENEMY                 = 1,
	E_MINIMAP_POI_TYPE_MISSION               = 2,
	E_MINIMAP_POI_TYPE_ACTOR                 = 3,
	E_MINIMAP_POI_TYPE_MAGATSUKA             = 4,
	E_MINIMAP_POI_TYPE_RYUKETSU              = 5,
	E_MINIMAP_POI_TYPE_GOD                   = 6,
	E_MINIMAP_POI_TYPE_TREASURE              = 7,
	E_MINIMAP_POI_TYPE_DOOR                  = 8,
	E_MINIMAP_POI_TYPE_DG_OBJ                = 9,
	E_MINIMAP_POI_TYPE_TIME_STOP             = 10,
	E_MINIMAP_POI_TYPE_TIME_MOVE             = 11,
	E_MINIMAP_POI_TYPE_MIMAN                 = 12,
	E_MINIMAP_POI_TYPE_RELIC                 = 13,
	E_MINIMAP_POI_TYPE_CHANGE_AREA           = 14,
	E_MINIMAP_POI_TYPE_CLIMB_POINT           = 15,
	E_MINIMAP_POI_TYPE_DEVIL_STATUE          = 16,
	E_MINIMAP_POI_TYPE_GARDEN_DEVIL          = 17,
	E_MINIMAP_POI_TYPE_ROTATE_SWITCH         = 18,
	E_MINIMAP_POI_TYPE_DOOR_SWITCH           = 19,
	E_MINIMAP_POI_TYPE_COASTER               = 20,
	E_MINIMAP_POI_TYPE_AOGAMI_DEBRIS         = 21,
	E_MINIMAP_POI_TYPE_LANDMARK              = 22,
	E_MINIMAP_POI_TYPE_MAX                   = 23,
};

// Enum Project.E_MINIMAP_MODE
// NumValues: 0x0004
enum class E_MINIMAP_MODE : uint8
{
	E_MINIMAP_MODE_NONE                      = 0,
	E_MINIMAP_MODE_MINI                      = 1,
	E_MINIMAP_MODE_ALL                       = 2,
	E_MINIMAP_MODE_MAX                       = 3,
};

// Enum Project.E_MINIMAP_FOG_GRID_MAP_TYPE
// NumValues: 0x0004
enum class E_MINIMAP_FOG_GRID_MAP_TYPE : uint8
{
	NONE                                     = 0,
	LARGE                                    = 1,
	NORMAL                                   = 2,
	E_MINIMAP_FOG_GRID_MAP_MAX               = 3,
};

// Enum Project.E_MINIMAP_ICON_HELP_TYPE
// NumValues: 0x0004
enum class E_MINIMAP_ICON_HELP_TYPE : uint8
{
	E_ICON                                   = 0,
	E_ALL_ON                                 = 1,
	E_ALL_OFF                                = 2,
	E_MAX                                    = 3,
};

// Enum Project.E_MAP_SELECT_STEP
// NumValues: 0x0004
enum class E_MAP_SELECT_STEP : uint8
{
	None                                     = 0,
	Parent                                   = 1,
	Child                                    = 2,
	E_MAP_SELECT_MAX                         = 3,
};

// Enum Project.E_MAP_SELECT_ITEM_TYPE
// NumValues: 0x0005
enum class E_MAP_SELECT_ITEM_TYPE : uint8
{
	None                                     = 0,
	Map                                      = 1,
	Parent                                   = 2,
	Child                                    = 3,
	E_MAP_SELECT_ITEM_MAX                    = 4,
};

// Enum Project.E_MINIMAP_ICON_FOG_GRID_CHECK_TYPE
// NumValues: 0x0004
enum class E_MINIMAP_ICON_FOG_GRID_CHECK_TYPE : uint8
{
	None                                     = 0,
	FogGrid                                  = 1,
	SaveFlag                                 = 2,
	E_MINIMAP_ICON_FOG_GRID_CHECK_MAX        = 3,
};

// Enum Project.E_MISSION_TIME_ATTACK_INFO_TYPE
// NumValues: 0x0005
enum class E_MISSION_TIME_ATTACK_INFO_TYPE : uint8
{
	E_NONE                                   = 0,
	E_REMAIN                                 = 1,
	E_REPORT                                 = 2,
	E_REPORT_FAIL                            = 3,
	E_MAX                                    = 4,
};

// Enum Project.E_MISSION_REPEAT_TYPE
// NumValues: 0x0004
enum class E_MISSION_REPEAT_TYPE : uint8
{
	E_NONE                                   = 0,
	E_DELIVERY                               = 1,
	E_TIME_ATTACK                            = 2,
	E_MAX                                    = 3,
};

// Enum Project.E_MISSION_STATE
// NumValues: 0x0009
enum class E_MISSION_STATE : uint8
{
	E_MISSION_STATE_NOT_ENTRY                = 0,
	E_MISSION_STATE_CAN_ENTRY                = 1,
	E_MISSION_STATE_CAN_ENTRY_COMPLETE       = 2,
	E_MISSION_STATE_NOW_ENTRY                = 3,
	E_MISSION_STATE_CAN_COMPLETE             = 4,
	E_MISSION_STATE_END_COMPLETE             = 5,
	E_MISSION_STATE_COMPLETE_REPEAT          = 6,
	E_MISSION_STATE_REPEAT_DELIVERY          = 7,
	E_MISSION_STATE_MAX                      = 8,
};

// Enum Project.E_MISSION_COND_TYPE
// NumValues: 0x000D
enum class E_MISSION_COND_TYPE : uint8
{
	E_MISSION_COND_NONE                      = 0,
	E_MISSION_COND_HUNT                      = 1,
	E_MISSION_COND_ITEM                      = 2,
	E_MISSION_COND_FLAG                      = 3,
	E_MISSION_COND_COUNT                     = 4,
	E_MISSION_COND_NAKAMA                    = 5,
	E_MISSION_COND_NAKAMA_LEVEL              = 6,
	E_MISSION_COND_NAKAMA_SKILL              = 7,
	E_MISSION_COND_PLAYER_SKILL              = 8,
	E_MISSION_COND_COUNT_ONLY                = 9,
	E_MISSION_COND_GROUP_HUNT                = 10,
	E_MISSION_COND_GOD                       = 11,
	E_MISSION_COND_MAX                       = 12,
};

// Enum Project.E_MISSION_TYPE
// NumValues: 0x0007
enum class E_MISSION_TYPE : uint8
{
	E_MISSION_TYPE_NONE                      = 0,
	E_MISSION_TYPE_HUNT                      = 1,
	E_MISSION_TYPE_DELIVERY                  = 2,
	E_MISSION_TYPE_NAKAMA                    = 3,
	E_MISSION_TYPE_TRAVEL                    = 4,
	E_MISSION_TYPE_RECORD                    = 5,
	E_MISSION_TYPE_MAX                       = 6,
};

// Enum Project.E_MISSION_MAJOR_TYPE
// NumValues: 0x0003
enum class E_MISSION_MAJOR_TYPE : uint8
{
	E_MISSION_MAJOR_MAIN                     = 0,
	E_MISSION_MAJOR_SUB                      = 1,
	E_MISSION_MAJOR_MAX                      = 2,
};

// Enum Project.E_MISSION_INFO_TEXT
// NumValues: 0x0009
enum class E_MISSION_INFO_TEXT : uint8
{
	E_MISSION_INFO_TEXT_NAME                 = 0,
	E_MISSION_INFO_TEXT_CLIENT               = 1,
	E_MISSION_INFO_TEXT_REWARD               = 2,
	E_MISSION_INFO_TEXT_EXPLAIN              = 3,
	E_MISSION_INFO_TEXT_HELP                 = 4,
	E_MISSION_INFO_TEXT_UPDATE_REPORT        = 5,
	E_MISSION_INFO_TEXT_UPDATE_COMPLETED     = 6,
	E_MISSION_INFO_TEXT_ENUM_SIZE            = 7,
	E_MISSION_INFO_TEXT_MAX                  = 8,
};

// Enum Project.E_MISSION_INFO_HEADER_TEXT
// NumValues: 0x0005
enum class E_MISSION_INFO_HEADER_TEXT : uint8
{
	Dummy                                    = 0,
	RewardItem                               = 1,
	RewardMoney                              = 2,
	ENUM_SIZE                                = 3,
	E_MISSION_INFO_HEADER_MAX                = 4,
};

// Enum Project.E_TIME_ATTACK_MISSION_STATE
// NumValues: 0x0006
enum class E_TIME_ATTACK_MISSION_STATE : uint8
{
	E_NONE                                   = 0,
	E_IN_TIME_ATTACK                         = 1,
	E_AFTER_TIME_ATTACK_BEFORE_INFO          = 2,
	E_AFTER_TIME_ATTACK_AFTER_INFO           = 3,
	E_REACHED_GOAL                           = 4,
	E_MAX                                    = 5,
};

// Enum Project.EFireActorEventsAtPosition
// NumValues: 0x0004
enum class EFireActorEventsAtPosition : uint8
{
	AtStartOfEvaluation                      = 0,
	AtEndOfEvaluation                        = 1,
	AfterSpawn                               = 2,
	EFireActorEventsAtPosition_MAX           = 3,
};

// Enum Project.E_NKM_INIT_TYPE
// NumValues: 0x0004
enum class E_NKM_INIT_TYPE : uint8
{
	E_NKM_INIT_TYPE_FIRST_INIT               = 0,
	E_NKM_INIT_TYPE_NKM_BOOK                 = 1,
	E_NKM_INIT_TYPE_CLEAR                    = 2,
	E_NKM_INIT_TYPE_MAX                      = 3,
};

// Enum Project.E_OPTION_ADDITIONAL_RESPONCE
// NumValues: 0x0005
enum class E_OPTION_ADDITIONAL_RESPONCE : uint8
{
	E_OPTION_ADDITIONAL_RESPONCE_NONE        = 0,
	E_OPTION_ADDITIONAL_RESPONCE_PLAY_VOICE  = 1,
	E_OPTION_ADDITIONAL_RESPONCE_DIFFICULTY_TUTORIAL = 2,
	E_OPTION_ADDITIONAL_RESPONCE_SKILL_SPEED_TUTORIAL = 3,
	E_OPTION_ADDITIONAL_RESPONCE_MAX         = 4,
};

// Enum Project.E_OPTION_SLOT_TYPE
// NumValues: 0x0006
enum class E_OPTION_SLOT_TYPE : uint8
{
	E_OPTION_SLOT_TYPE_PANEL                 = 0,
	E_OPTION_SLOT_TYPE_SELECT                = 1,
	E_OPTION_SLOT_TYPE_SLIDER                = 2,
	E_OPTION_SLOT_TYPE_KEYSELECT             = 3,
	E_OPTION_SLOT_TYPE_BTNICON               = 4,
	E_OPTION_SLOT_TYPE_MAX                   = 5,
};

// Enum Project.E_INPUT_TYPE
// NumValues: 0x0005
enum class E_INPUT_TYPE : uint8
{
	E_INPUT_TYPE_HOLD                        = 0,
	E_INPUT_TYPE_TRIGGER                     = 1,
	E_INPUT_TYPE_RELEASE                     = 2,
	E_INPUT_TYPE_REPEAT                      = 3,
	E_INPUT_TYPE_MAX                         = 4,
};

// Enum Project.E_AXIS_MAPPING_TYPE
// NumValues: 0x000F
enum class E_AXIS_MAPPING_TYPE : uint8
{
	E_AXIS_MAPPING_MOVE_FORWARD              = 0,
	E_AXIS_MAPPING_MOVE_RIGHT                = 1,
	E_AXIS_MAPPING_LOOK_UP                   = 2,
	E_AXIS_MAPPING_LOOK_RIGHT                = 3,
	E_AXIS_MAPPING_LOOK_UP_MOUSE             = 4,
	E_AXIS_MAPPING_LOOK_RIGHT_MOUSE          = 5,
	E_AXIS_MAPPING_SCROLL_UP                 = 6,
	E_AXIS_MAPPING_SCROLL_RIGHT              = 7,
	E_AXIS_MAPPING_GARDEN_MOVE_UP            = 8,
	E_AXIS_MAPPING_GARDEN_MOVE_RIGHT         = 9,
	E_AXIS_MAPPING_AUTOMAP_ZOOM              = 10,
	E_AXIS_MAPPING_TOPCAMERA_MOVE_UP         = 11,
	E_AXIS_MAPPING_TOPCAMERA_MOVE_RIGHT      = 12,
	E_AXIS_MAPPING_TOPCAMERA_ZOOM            = 13,
	E_AXIS_MAPPING_MAX                       = 14,
};

// Enum Project.E_ACTION_MAPPING_TYPE
// NumValues: 0x0038
enum class E_ACTION_MAPPING_TYPE : uint8
{
	E_ACTION_MAPPING_ACTION                  = 0,
	E_ACTION_MAPPING_CANCEL                  = 1,
	E_ACTION_MAPPING_UP                      = 2,
	E_ACTION_MAPPING_DOWN                    = 3,
	E_ACTION_MAPPING_LEFT                    = 4,
	E_ACTION_MAPPING_RIGHT                   = 5,
	E_ACTION_MAPPING_FACE_TOP                = 6,
	E_ACTION_MAPPING_FACE_LEFT               = 7,
	E_ACTION_MAPPING_SHOULDER_LEFT           = 8,
	E_ACTION_MAPPING_SHOULDER_RIGHT          = 9,
	E_ACTION_MAPPING_TRIGGER_LEFT            = 10,
	E_ACTION_MAPPING_TRIGGER_RIGHT           = 11,
	E_ACTION_MAPPING_SPECIAL_LEFT            = 12,
	E_ACTION_MAPPING_SPECIAL_RIGHT           = 13,
	E_ACTION_MAPPING_RSTICK_UP               = 14,
	E_ACTION_MAPPING_RSTICK_DOWN             = 15,
	E_ACTION_MAPPING_STICKBUTTON_RIGHT       = 16,
	E_ACTION_MAPPING_MOUSE_ACTION            = 17,
	E_ACTION_MAPPING_MOUSE_CANCEL            = 18,
	E_ACTION_MAPPING_MOVIE_SKIP              = 19,
	E_ACTION_MAPPING_KEYCONFIG_DEL           = 20,
	E_ACTION_MAPPING_MAP_ACTION              = 21,
	E_ACTION_MAPPING_MAP_ATTACK              = 22,
	E_ACTION_MAPPING_CAMPOPEN                = 23,
	E_ACTION_MAPPING_MAP_ACTION_JUMP         = 24,
	E_ACTION_MAPPING_MAP_CAMERARESET         = 25,
	E_ACTION_MAPPING_MAP_TRAPORT             = 26,
	E_ACTION_MAPPING_MAP_AUTO_HEAL           = 27,
	E_ACTION_MAPPING_MAP_DASH                = 28,
	E_ACTION_MAPPING_MAP_DASH_R              = 29,
	E_ACTION_MAPPING_AUTO_MAP                = 30,
	E_ACTION_MAPPING_MAP_VIEW_DOWN           = 31,
	E_ACTION_MAPPING_MAP_TOGGLE_AUTORUN      = 32,
	E_ACTION_MAPPING_MAP_ESTOMA              = 33,
	E_ACTION_MAPPING_MAP_SAVE                = 34,
	E_ACTION_MAPPING_CALL_DEBUG_MENU         = 35,
	E_ACTION_MAPPING_MENU_UP                 = 36,
	E_ACTION_MAPPING_MENU_DOWN               = 37,
	E_ACTION_MAPPING_MENU_LEFT               = 38,
	E_ACTION_MAPPING_MENU_RIGHT              = 39,
	E_ACTION_MAPPING_CURSOR_SKIP             = 40,
	E_ACTION_MAPPING_CURSOR_SKIP_LARGE       = 41,
	E_ACTION_MAPPING_DBG_SWITCH_GOST         = 42,
	E_ACTION_MAPPING_DEBUG_PLAYER_UP         = 43,
	E_ACTION_MAPPING_DEBUG_PLAYER_DOWN       = 44,
	E_ACTION_MAPPING_BTL_DBG_CENTER          = 45,
	E_ACTION_MAPPING_BTL_DBG_OPTION          = 46,
	E_ACTION_MAPPING_BTL_DBG_R1              = 47,
	E_ACTION_MAPPING_BTL_DBG_R2              = 48,
	E_ACTION_MAPPING_BTL_DBG_L1              = 49,
	E_ACTION_MAPPING_BTL_DBG_L2              = 50,
	E_ACTION_MAPPING_EVT_DBG_1               = 51,
	E_ACTION_MAPPING_EVT_DBG_2               = 52,
	E_ACTION_MAPPING_AUTOMAP_ZOOM_UP         = 53,
	E_ACTION_MAPPING_AUTOMAP_ZOOM_DOWN       = 54,
	E_ACTION_MAPPING_MAX                     = 55,
};

// Enum Project.ES3N2ParticleCollisionType
// NumValues: 0x0004
enum class ES3N2ParticleCollisionType : uint8
{
	HitAll                                   = 0,
	HitCharacter                             = 1,
	HitGeometry                              = 2,
	ES3N2ParticleCollisionType_MAX           = 3,
};

// Enum Project.E_SHISEIJO
// NumValues: 0x0003
enum class E_SHISEIJO : uint8
{
	E_TAO                                    = 0,
	E_YOKO                                   = 1,
	E_MAX                                    = 2,
};

// Enum Project.E_DEFAISHOU_PRIO
// NumValues: 0x0008
enum class E_DEFAISHOU_PRIO : uint8
{
	PHYSICAL                                 = 0,
	FIRE                                     = 1,
	ICE                                      = 2,
	THUNDER                                  = 3,
	WIND                                     = 4,
	LIGHT                                    = 5,
	DARK                                     = 6,
	E_DEFAISHOU_MAX                          = 7,
};

// Enum Project.E_HERO_KIND
// NumValues: 0x0004
enum class E_HERO_KIND : uint8
{
	E_HERO_KIND_BOY                          = 0,
	E_HERO_KIND_AOGAMI                       = 1,
	E_HERO_KIND_UNITE                        = 2,
	E_HERO_KIND_MAX                          = 3,
};

// Enum Project.E_HERO_STAT
// NumValues: 0x0003
enum class E_HERO_STAT : uint8
{
	E_HERO_STAT_BOY_EXIST                    = 0,
	E_HERO_STAT_AOGAMI_EXIST                 = 1,
	E_HERO_STAT_MAX                          = 2,
};

// Enum Project.E_PARAM_TYPE
// NumValues: 0x0007
enum class E_PARAM_TYPE : uint8
{
	E_PARAM_TYPE_STR                         = 0,
	E_PARAM_TYPE_VIT                         = 1,
	E_PARAM_TYPE_MGI                         = 2,
	E_PARAM_TYPE_AGI                         = 3,
	E_PARAM_TYPE_LUC                         = 4,
	E_PARAM_TYPE_LAST                        = 5,
	E_PARAM_TYPE_MAX                         = 6,
};

// Enum Project.E_PIECE_TYPE
// NumValues: 0x0007
enum class E_PIECE_TYPE : uint8
{
	E_PIECE_TYPE_ITEM                        = 0,
	E_PIECE_TYPE_MAKKA                       = 1,
	E_PIECE_TYPE_HP                          = 2,
	E_PIECE_TYPE_MP                          = 3,
	E_PIECE_TYPE_UNIT                        = 4,
	E_PIECE_TYPE_GOD                         = 5,
	E_PIECE_TYPE_MAX                         = 6,
};

// Enum Project.E_PIECE_MAJOR_TYPE
// NumValues: 0x0004
enum class E_PIECE_MAJOR_TYPE : uint8
{
	E_PIECE_MAJOR_HAVE                       = 0,
	E_PIECE_MAJOR_NOW                        = 1,
	E_PIECE_MAJOR_INVALID                    = 2,
	E_PIECE_MAJOR_MAX                        = 3,
};

// Enum Project.eDebugFlag
// NumValues: 0x000B
enum class EDebugFlag : uint8
{
	None                                     = 0,
	DebugDraw                                = 1,
	EventHitOff                              = 2,
	EventViewerMode                          = 3,
	EncountHitOff                            = 4,
	LevelStatusLog                           = 5,
	LogTextFlagOn                            = 6,
	TemporaryTest1                           = 7,
	TemporaryTest2                           = 8,
	TemporaryTest3                           = 9,
	EDebugFlag_MAX                           = 10,
};

// Enum Project.EDisableMenuReason
// NumValues: 0x0006
enum class EDisableMenuReason : uint8
{
	Invalid                                  = 0,
	Sword                                    = 1,
	Air                                      = 2,
	GimmickWind                              = 3,
	Damage                                   = 4,
	EDisableMenuReason_MAX                   = 5,
};

// Enum Project.EGCPriority
// NumValues: 0x0004
enum class EGCPriority : uint8
{
	Default                                  = 0,
	IfDontAfford                             = 1,
	ForceFullPurge                           = 2,
	EGCPriority_MAX                          = 3,
};

// Enum Project.EProjectStreamingStatus
// NumValues: 0x000B
enum class EProjectStreamingStatus : uint8
{
	PROJECT_LEVEL_Invalid                    = 0,
	PROJECT_LEVEL_Unloaded                   = 1,
	PROJECT_LEVEL_UnloadedButStillAround     = 2,
	PROJECT_LEVEL_Loading                    = 3,
	PROJECT_LEVEL_Loaded                     = 4,
	PROJECT_LEVEL_MakingVisible              = 5,
	PROJECT_LEVEL_Visible                    = 6,
	PROJECT_LEVEL_Preloading                 = 7,
	PROJECT_LEVEL_AlwaysLoaded               = 8,
	PROJECT_LEVEL_Persistent                 = 9,
	PROJECT_LEVEL_MAX                        = 10,
};

// Enum Project.EWindowsWindowMode
// NumValues: 0x0004
enum class EWindowsWindowMode : uint8
{
	Fullscreen                               = 0,
	WindowedFullscreen                       = 1,
	Windowed                                 = 2,
	EWindowsWindowMode_MAX                   = 3,
};

// Enum Project.EReverbType
// NumValues: 0x0005
enum class EReverbType : uint8
{
	None                                     = 0,
	Reverb_S                                 = 1,
	Reverb_M                                 = 2,
	Reverb_L                                 = 3,
	EReverbType_MAX                          = 4,
};

// Enum Project.EFadeoutType
// NumValues: 0x0003
enum class EFadeoutType : uint8
{
	Middle                                   = 0,
	Long                                     = 1,
	EFadeoutType_MAX                         = 2,
};

// Enum Project.EFadeType
// NumValues: 0x0006
enum class EFadeType : uint8
{
	NoFade                                   = 0,
	CrossFade                                = 1,
	PlayAfterFadeout                         = 2,
	LongCrossFade                            = 3,
	PlayWithFadeout                          = 4,
	EFadeType_MAX                            = 5,
};

// Enum Project.ESystemSE
// NumValues: 0x000E
enum class ESystemSE : uint8
{
	Cursor                                   = 0,
	Decide                                   = 1,
	Cancel                                   = 2,
	Error                                    = 3,
	ActionWindowOpen                         = 4,
	ActionWindowClose                        = 5,
	ActionWindowDecide                       = 6,
	MessageSkip                              = 7,
	BattleCursor                             = 8,
	BattleCursor2                            = 9,
	BattleDecide                             = 10,
	BattleDecide2                            = 11,
	BattleCancel                             = 12,
	ESystemSE_MAX                            = 13,
};

// Enum Project.EGameVolumeCategory
// NumValues: 0x0005
enum class EGameVolumeCategory : uint8
{
	BGM                                      = 0,
	ENV                                      = 1,
	SE                                       = 2,
	Voice                                    = 3,
	EGameVolumeCategory_MAX                  = 4,
};

// Enum Project.EOptionVolumeCategory
// NumValues: 0x0005
enum class EOptionVolumeCategory : uint8
{
	BGM                                      = 0,
	ENV                                      = 1,
	SE                                       = 2,
	Voice                                    = 3,
	EOptionVolumeCategory_MAX                = 4,
};

// Enum Project.E_RECORD_DISP_TYPE
// NumValues: 0x0003
enum class E_RECORD_DISP_TYPE : uint8
{
	E_RECORD_DISP_NORMAL                     = 0,
	E_RECORD_DISP_TIME                       = 1,
	E_RECORD_DISP_MAX                        = 2,
};

// Enum Project.E_RECORD_ID
// NumValues: 0x0042
enum class E_RECORD_ID : uint8
{
	E_RECORD_NONE                            = 0,
	E_RECORD_PLAY_TIME                       = 1,
	E_RECORD_TOTAL_INCOME                    = 2,
	E_RECORD_TOTAL_DISTANCE                  = 3,
	E_RECORD_BATTLE                          = 4,
	E_RECORD_GIANT_BATTLE                    = 5,
	E_RECORD_GAMEOVER                        = 6,
	E_RECORD_ESCAPE                          = 7,
	E_RECORD_HUNT_DEVIL                      = 8,
	E_RECORD_GIVE_MAX_DAMAGE                 = 9,
	E_RECORD_GIVE_TOTAL_DAMAGE               = 10,
	E_RECORD_CRITICAL                        = 11,
	E_RECORD_COUNTER                         = 12,
	E_RECORD_GIVE_BAD_STATE                  = 13,
	E_RECORD_BUDDY_ATTACK                    = 14,
	E_RECORD_BTL_UNIT_FORM                   = 15,
	E_RECORD_TALK                            = 16,
	E_RECORD_SCOUT_SUCCESS                   = 17,
	E_RECORD_TALK_GIVE_MONEY                 = 18,
	E_RECORD_TALK_GIVE_ITEM                  = 19,
	E_RECORD_TALK_GET_ITEM                   = 20,
	E_RECORD_GET_RELIC                       = 21,
	E_RECORD_OPEN_TAKARA                     = 22,
	E_RECORD_SHOP_PAY_MONEY                  = 23,
	E_RECORD_SHOP_SELL_MONEY                 = 24,
	E_RECORD_CLEAR_KOKUBOU                   = 25,
	E_RECORD_KOKUBOU_GET_MONEY               = 26,
	E_RECORD_KOKUBOU_GET_ITEM                = 27,
	E_RECORD_TOTAL_CAMP_TIME                 = 28,
	E_RECORD_TOTAL_UNITE_TIME                = 29,
	E_RECORD_UNITE                           = 30,
	E_RECORD_UNITE_ACCIDENT                  = 31,
	E_RECORD_TOTAL_BIBLE_MONEY               = 32,
	E_RECORD_GET_PROPERTY                    = 33,
	E_RECORD_TOTAL_SKILL_SOURCE              = 34,
	E_RECORD_PAY_SKILL_LIB                   = 35,
	E_RECORD_ENTRY_SKILL_LIB                 = 36,
	E_RECORD_LEARN_SKILL_LIB                 = 37,
	E_RECORD_TOTAL_CASINO_COIN               = 38,
	E_RECORD_ONLINE                          = 39,
	E_RECORD_CLEAR_SPOT                      = 40,
	E_RECORD_CHAIN_HIT_TOTAL                 = 41,
	E_RECORD_RESERVE_42                      = 42,
	E_RECORD_RESERVE_43                      = 43,
	E_RECORD_RESERVE_44                      = 44,
	E_RECORD_RESERVE_45                      = 45,
	E_RECORD_RESERVE_46                      = 46,
	E_RECORD_RESERVE_47                      = 47,
	E_RECORD_RESERVE_48                      = 48,
	E_RECORD_RESERVE_49                      = 49,
	E_RECORD_RESERVE_50                      = 50,
	E_RECORD_RESERVE_51                      = 51,
	E_RECORD_RESERVE_52                      = 52,
	E_RECORD_RESERVE_53                      = 53,
	E_RECORD_RESERVE_54                      = 54,
	E_RECORD_RESERVE_55                      = 55,
	E_RECORD_RESERVE_56                      = 56,
	E_RECORD_RESERVE_57                      = 57,
	E_RECORD_RESERVE_58                      = 58,
	E_RECORD_RESERVE_59                      = 59,
	E_RECORD_RESERVE_60                      = 60,
	E_RECORD_RESERVE_61                      = 61,
	E_RECORD_RESERVE_62                      = 62,
	E_RECORD_RESERVE_63                      = 63,
	E_RECORD_ID_MAX                          = 64,
	E_RECORD_MAX                             = 65,
};

// Enum Project.RESULT_JOINDATA
// NumValues: 0x0007
enum class ERESULT_JOINDATA : uint8
{
	RESULT_JOINDATA_JOIN                     = 0,
	RESULT_JOINDATA_STOCK                    = 1,
	RESULT_JOINDATA_DEAD                     = 2,
	RESULT_JOINDATA_LVUP_EXP                 = 3,
	RESULT_JOINDATA_QUEST                    = 4,
	RESULT_JOINDATA_FUSION                   = 5,
	RESULT_JOINDATA_MAX                      = 6,
};

// Enum Project.E_LVUPMANAGER_GSTATUS
// NumValues: 0x001B
enum class E_LVUPMANAGER_GSTATUS : uint8
{
	E_LVUPMANAGER_GSTATUS_EMPTY              = 0,
	E_LVUPMANAGER_GSTATUS_SHOW_UP_PARAM      = 1,
	E_LVUPMANAGER_GSTATUS_PARAM_ALLOCATE     = 2,
	E_LVUPMANAGER_GSTATUS_PARAM_ALLOCATE_MESSAGE = 3,
	E_LVUPMANAGER_GSTATUS_WAIT_BEFORE_REICHI = 4,
	E_LVUPMANAGER_GSTATUS_GET_REICHI         = 5,
	E_LVUPMANAGER_GSTATUS_SKILL_MESSAGE      = 6,
	E_LVUPMANAGER_GSTATUS_SKILL_SELECT       = 7,
	E_LVUPMANAGER_GSTATUS_SKILL_SET_ANIMATION = 8,
	E_LVUPMANAGER_GSTATUS_SKILL_DISCARD_MESSAGE = 9,
	E_LVUPMANAGER_GSTATUS_SKILL_DECIDE_MESSAGE = 10,
	E_LVUPMANAGER_GSTATUS_EX_SKILL           = 11,
	E_LVUPMANAGER_GSTATUS_BEFORE_GIFT        = 12,
	E_LVUPMANAGER_GSTATUS_GIFT               = 13,
	E_LVUPMANAGER_GSTATUS_GIFT_SYSTEM_MESSAGE = 14,
	E_LVUPMANAGER_GSTATUS_FLASH_NEXT_SKILLS  = 15,
	E_LVUPMANAGER_GSTATUS_SKILL_DISCARD_START_MESSAGE = 16,
	E_LVUPMANAGER_GSTATUS_ALLOCATE_START_MESSAGE = 17,
	E_LVUPMANAGER_GSTATUS_ALLOCATE_NOT_YET_MESSAGE = 18,
	E_LVUPMANAGER_GSTATUS_GARDEN_SHOW_STATUS = 19,
	E_LVUPMANAGER_GSTATUS_GARDEN_TEKISEI_UP_MESSAGE = 20,
	E_LVUPMANAGER_GSTATUS_GARDEN_PARAM_UP_MESSAGE = 21,
	E_LVUPMANAGER_GSTATUS_GARDEN_ALLOCATE_START_MESSAGE = 22,
	E_LVUPMANAGER_GSTATUS_GARDEN_PARAM_ALLOCATE = 23,
	E_LVUPMANAGER_GSTATUS_GARDEN_ALLOCATE_NOT_YET_MESSAGE = 24,
	E_LVUPMANAGER_GSTATUS_GARDEN_PARAM_ALLOCATE_MESSAGE = 25,
	E_LVUPMANAGER_GSTATUS_MAX                = 26,
};

// Enum Project.E_RYUKETSU_GARDEN_TYPE
// NumValues: 0x000B
enum class E_RYUKETSU_GARDEN_TYPE : uint8
{
	E_NONE                                   = 0,
	E_DAATH_1                                = 1,
	E_DAATH_2                                = 2,
	E_DAATH_2_FOREST                         = 3,
	E_DAATH_3                                = 4,
	E_DAATH_4                                = 5,
	E_DAATH_5                                = 6,
	E_SHRINE                                 = 7,
	E_MAOU                                   = 8,
	E_ROTATE                                 = 9,
	E_MAX                                    = 10,
};

// Enum Project.E_Load_LOCATION
// NumValues: 0x0003
enum class E_Load_LOCATION : uint8
{
	Title                                    = 0,
	Camp                                     = 1,
	E_Load_MAX                               = 2,
};

// Enum Project.E_SAVE_LOCATION
// NumValues: 0x0008
enum class E_SAVE_LOCATION : uint8
{
	Default                                  = 0,
	M083Shinagawa                            = 1,
	M030gijidou                              = 2,
	CampSave                                 = 3,
	FieldSave                                = 4,
	RyuketsuSave                             = 5,
	E2140dormitory                           = 6,
	E_SAVE_MAX                               = 7,
};

// Enum Project.E_JOIN_DLC_TYPE
// NumValues: 0x000A
enum class E_JOIN_DLC_TYPE : uint8
{
	ADDITIONAL_DIFFICULTY                    = 0,
	CHEAT_MONEY                              = 1,
	CHEAT_EXP                                = 2,
	CHEAT_GLORY                              = 3,
	MISSION_ARTEMIS                          = 4,
	MISSION_CLEOPATRA                        = 5,
	MISSION_MEPHISTO                         = 6,
	MISSION_FIEND                            = 7,
	JAPANESE_VOICE                           = 8,
	E_JOIN_DLC_MAX                           = 9,
};

// Enum Project.E_SaveExistsResult
// NumValues: 0x0005
enum class E_SaveExistsResult : uint8
{
	E_OK                                     = 0,
	E_DoesNotExist                           = 1,
	E_Corrupt                                = 2,
	E_UnspecifiedError                       = 3,
	E_MAX                                    = 4,
};

// Enum Project.E_SaveListType
// NumValues: 0x0003
enum class E_SaveListType : uint8
{
	E_SaveListTypeSave                       = 0,
	E_SaveListTypeLoad                       = 1,
	E_MAX                                    = 2,
};

// Enum Project.E_SaveType
// NumValues: 0x0005
enum class E_SaveType : uint8
{
	E_SaveTypeGame                           = 0,
	E_SaveTypeAuto                           = 1,
	E_SaveTypeSystem                         = 2,
	E_SaveTypeSystemLocal                    = 3,
	E_MAX                                    = 4,
};

// Enum Project.E_ShinseiKind
// NumValues: 0x0006
enum class E_ShinseiKind : uint8
{
	E_ShinseiKind_XS                         = 0,
	E_ShinseiKind_S                          = 1,
	E_ShinseiKind_M                          = 2,
	E_ShinseiKind_L                          = 3,
	E_ShinseiKind_XL                         = 4,
	E_ShinseiKind_MAX                        = 5,
};

// Enum Project.E_SHOP_ITEM_SELECT_TYPE
// NumValues: 0x0004
enum class E_SHOP_ITEM_SELECT_TYPE : uint8
{
	E_SHOP_ITEM_SELECT_NORMAL                = 0,
	E_SHOP_ITEM_SELECT_SELECT                = 1,
	E_SHOP_ITEM_SELECT_NOT                   = 2,
	E_SHOP_ITEM_SELECT_MAX                   = 3,
};

// Enum Project.E_SHOP_ITEM_SORT_TYPE
// NumValues: 0x000A
enum class E_SHOP_ITEM_SORT_TYPE : uint8
{
	E_SHOP_ITEM_SORT_KIND                    = 0,
	E_SHOP_ITEM_SORT_ITEM_NUM                = 1,
	E_SHOP_ITEM_SORT_NEW                     = 2,
	E_SHOP_ITEM_SORT_BUYING_PRICE            = 3,
	E_SHOP_ITEM_SORT_SELLING_PRICE           = 4,
	E_SHOP_ITEM_SORT_UTSUSEMI                = 5,
	E_SHOP_ITEM_SORT_UTSUSEMI_NUM            = 6,
	E_SHOP_ITEM_SORT_UTSUSEMI_NEW            = 7,
	E_SHOP_ITEM_SORT_UTSUSEMI_BUYING_PRICE   = 8,
	E_SHOP_ITEM_SORT_MAX                     = 9,
};

// Enum Project.E_NAHOBINO_SKILL_MOTION
// NumValues: 0x0007
enum class E_NAHOBINO_SKILL_MOTION : uint8
{
	E_NAHOBINO_SKILL_MOTION_NONE             = 0,
	E_NAHOBINO_SKILL_MOTION_RANGED           = 1,
	E_NAHOBINO_SKILL_MOTION_CLOSE_SWORD      = 2,
	E_NAHOBINO_SKILL_MOTION_CLOSE_FIST       = 3,
	E_NAHOBINO_SKILL_MOTION_SUPPORT          = 4,
	E_NAHOBINO_SKILL_MOTION_ATTACK           = 5,
	E_NAHOBINO_SKILL_MOTION_MAX              = 6,
};

// Enum Project.E_SKILLINFO_CONDITION
// NumValues: 0x0003
enum class E_SKILLINFO_CONDITION : uint8
{
	E_NONE                                   = 0,
	E_GODSKILL_AID                           = 1,
	E_MAX                                    = 2,
};

// Enum Project.E_OVERWRITE_FORMULA
// NumValues: 0x000C
enum class E_OVERWRITE_FORMULA : uint8
{
	E_OVERWRITE_FORMULA_NONE                 = 0,
	E_OVERWRITE_FORMULA_VAL                  = 1,
	E_OVERWRITE_FORMULA_DEATH                = 2,
	E_OVERWRITE_FORMULA_NOTCURE_ATTRBST      = 3,
	E_OVERWRITE_FORMULA_AID_VAL              = 4,
	E_OVERWRITE_FORMULA_AID_TURN             = 5,
	E_OVERWRITE_FORMULA_CURE_BST             = 6,
	E_OVERWRITE_FORMULA_HPUP_RATE            = 7,
	E_OVERWRITE_FORMULA_MAX_ATTACK_CNT       = 8,
	E_OVERWRITE_FORMULA_MP_CURE_RATE         = 9,
	E_OVERWRITE_FORMULA_MP_CURE_VALUE        = 10,
	E_OVERWRITE_FORMULA_MAX                  = 11,
};

// Enum Project.E_OVERWRITE_CONDITION
// NumValues: 0x0008
enum class E_OVERWRITE_CONDITION : uint8
{
	E_OVERWRITE_CONDITION_NONE               = 0,
	E_OVERWRITE_CONDITION_UPLIFTING          = 1,
	E_OVERWRITE_CONDITION_WEAK               = 2,
	E_OVERWRITE_CONDITION_CRITICAL           = 3,
	E_OVERWRITE_CONDITION_TARGET_BST         = 4,
	E_OVERWRITE_CONDITION_CALC_ATTACK_CNT    = 5,
	E_OVERWRITE_CONDITION_MP_CURE            = 6,
	E_OVERWRITE_CONDITION_MAX                = 7,
};

// Enum Project.E_SKILL_BARRIER_TYPE
// NumValues: 0x000A
enum class E_SKILL_BARRIER_TYPE : uint8
{
	E_SKILL_BARRIER_PHISICS                  = 0,
	E_SKILL_BARRIER_FIRE                     = 1,
	E_SKILL_BARRIER_ICE                      = 2,
	E_SKILL_BARRIER_THUNDER                  = 3,
	E_SKILL_BARRIER_WIND                     = 4,
	E_SKILL_BARRIER_LIGHT                    = 5,
	E_SKILL_BARRIER_DARK                     = 6,
	E_SKILL_BARRIER_SOUL_BAD                 = 7,
	E_SKILL_BARRIER_PHISICS_BAD              = 8,
	E_SKILL_BARRIER_MAX                      = 9,
};

// Enum Project.E_SKILL_BARRIER_REF
// NumValues: 0x0006
enum class E_SKILL_BARRIER_REF : uint8
{
	E_SKILL_BARRIER_REF_NONE                 = 0,
	E_SKILL_BARRIER_REF_RESIST               = 1,
	E_SKILL_BARRIER_REF_REFLEX               = 2,
	E_SKILL_BARRIER_REF_ABSORB               = 3,
	E_SKILL_BARRIER_REF_BLOCK                = 4,
	E_SKILL_BARRIER_REF_MAX                  = 5,
};

// Enum Project.E_SKILL_HIT_STAMP_TYPE
// NumValues: 0x000C
enum class E_SKILL_HIT_STAMP_TYPE : uint8
{
	E_SKILL_HIT_STAMP_TYPE_NONE              = 0,
	E_SKILL_HIT_STAMP_TYPE_BLOW              = 1,
	E_SKILL_HIT_STAMP_TYPE_SLASH             = 2,
	E_SKILL_HIT_STAMP_TYPE_FIRE              = 3,
	E_SKILL_HIT_STAMP_TYPE_ICE               = 4,
	E_SKILL_HIT_STAMP_TYPE_THUNDER           = 5,
	E_SKILL_HIT_STAMP_TYPE_WIND              = 6,
	E_SKILL_HIT_STAMP_TYPE_LIGHT             = 7,
	E_SKILL_HIT_STAMP_TYPE_DARK              = 8,
	E_SKILL_HIT_STAMP_TYPE_ALL               = 9,
	E_SKILL_HIT_STAMP_TYPE_TWO               = 10,
	E_SKILL_HIT_STAMP_TYPE_MAX               = 11,
};

// Enum Project.E_SKILL_UNIQUE_TYPE
// NumValues: 0x0007
enum class E_SKILL_UNIQUE_TYPE : uint8
{
	E_SKILL_UNIQUE_TYPE_ALL                  = 0,
	E_SKILL_UNIQUE_TYPE_PLAYER               = 1,
	E_SKILL_UNIQUE_TYPE_NAKAMA               = 2,
	E_SKILL_UNIQUE_TYPE_ENEMY                = 3,
	E_SKILL_UNIQUE_TYPE_PARTNER              = 4,
	E_SKILL_UNIQUE_TYPE_UNIQUE               = 5,
	E_SKILL_UNIQUE_TYPE_MAX                  = 6,
};

// Enum Project.E_SKILL_MASTER_TARGET
// NumValues: 0x0003
enum class E_SKILL_MASTER_TARGET : uint8
{
	E_SKILL_MASTER_TARGET_ACTOR              = 0,
	E_SKILL_MASTER_TARGET_TARGET             = 1,
	E_SKILL_MASTER_TARGET_MAX                = 2,
};

// Enum Project.E_SKILL_MASTER_EFT
// NumValues: 0x000E
enum class E_SKILL_MASTER_EFT : uint8
{
	E_SKILL_MASTER_EFT_CRI_ADD               = 0,
	E_SKILL_MASTER_EFT_ATK_ADD               = 1,
	E_SKILL_MASTER_EFT_DAMAGE                = 2,
	E_SKILL_MASTER_EFT_HIT_100               = 3,
	E_SKILL_MASTER_EFT_BST_ADD               = 4,
	E_SKILL_MASTER_EFT_BST_UP                = 5,
	E_SKILL_MASTER_EFT_MAKA_ADD              = 6,
	E_SKILL_MASTER_EFT_TARU_ADD              = 7,
	E_SKILL_MASTER_EFT_RAKU_ADD              = 8,
	E_SKILL_MASTER_EFT_SUKU_ADD              = 9,
	E_SKILL_MASTER_EFT_DRAIN_HP_ADD          = 10,
	E_SKILL_MASTER_EFT_DRAIN_MP_ADD          = 11,
	E_SKILL_MASTER_EFT_BARRIER_ADD           = 12,
	E_SKILL_MASTER_EFT_MAX                   = 13,
};

// Enum Project.E_SKILL_MASTER_COND
// NumValues: 0x000B
enum class E_SKILL_MASTER_COND : uint8
{
	E_SKILL_MASTER_COND_NONE                 = 0,
	E_SKILL_MASTER_COND_FAST_ACT             = 1,
	E_SKILL_MASTER_COND_WEAK                 = 2,
	E_SKILL_MASTER_COND_COUNTER              = 3,
	E_SKILL_MASTER_COND_CRITICAL             = 4,
	E_SKILL_MASTER_COND_ACT_HP_MAX           = 5,
	E_SKILL_MASTER_COND_TGT_BST_ANY          = 6,
	E_SKILL_MASTER_COND_MULTI_ENEMY          = 7,
	E_SKILL_MASTER_COND_BST_HIT              = 8,
	E_SKILL_MASTER_COND_INVALID              = 9,
	E_SKILL_MASTER_COND_MAX                  = 10,
};

// Enum Project.E_SKILL_INFO_MESS_TIMING
// NumValues: 0x000A
enum class E_SKILL_INFO_MESS_TIMING : uint8
{
	E_SKILL_INFO_MESS_TIMING_ACTION          = 0,
	E_SKILL_INFO_MESS_TIMING_HIT             = 1,
	E_SKILL_INFO_MESS_TIMING_AFTER           = 2,
	E_SKILL_INFO_MESS_TIMING_PRE_SUMMON      = 3,
	E_SKILL_INFO_MESS_TIMING_AFTER_SUMMON    = 4,
	E_SKILL_INFO_MESS_TIMING_AFTER_TURN_CHANGE = 5,
	E_SKILL_INFO_MESS_TIMING_AFTER_KUISHIBARI = 6,
	E_SKILL_INFO_MESS_TIMING_CRITICAL_RETURN = 7,
	E_SKILL_INFO_MESS_TIMING_CHARGE_DEAD     = 8,
	E_SKILL_INFO_MESS_TIMING_MAX             = 9,
};

// Enum Project.E_AUTO_SKILL_EXTRA_EFFECT
// NumValues: 0x00C0
enum class E_AUTO_SKILL_EXTRA_EFFECT : uint8
{
	E_NONE                                   = 0,
	E_NKM_EXP_UP                             = 1,
	E_HITRATE_UP                             = 2,
	E_POISON_RATE                            = 3,
	E_BST_RATE                               = 4,
	E_TARGET_CRITICAL_RATE                   = 5,
	E_WEAKENED_CRITICALED_PRESS_NORMAL       = 6,
	E_FAILED_ATTACK_PRESS_NORMAL             = 7,
	E_KAJYANDA_TURN                          = 8,
	E_BURST_BST_CURE_RATE                    = 9,
	E_MOONSKILL_ENABLE_RATE                  = 10,
	E_NEXT_TYPE                              = 11,
	E_ADD_BST_MP_VALUE                       = 12,
	E_WEAK_CRITICAL_HALF_MP_VALUE            = 13,
	E_USE_PRESS_HALF_MP_VALUE                = 14,
	E_1TURN_MPUP_2TURN_MPDOWN                = 15,
	E_WEAK_NO_PRESS_RATE                     = 16,
	E_BURST_NO_PRESS_RATE                    = 17,
	E_CRITICAL_NO_PRESS_RATE                 = 18,
	E_ADD_BST_NO_PRESS_RATE                  = 19,
	E_CRITICAL_DAMAGE_RATE                   = 20,
	E_BURST_DAMAGE_RATE                      = 21,
	E_ADD_ATTRBST_RATE                       = 22,
	E_NO_ADD_ATTRBST                         = 23,
	E_NORMAL_DAMAGE_RATE                     = 24,
	E_ATTR_DAMAGE_RATE                       = 25,
	E_COUNTERSKILL_ID                        = 26,
	E_BATTLE_WIN_HP_CURE_VALUE               = 27,
	E_BATTLE_WIN_MP_CURE_VALUE               = 28,
	E_COUNTER_ELECTRIFICATION_NUM            = 29,
	E_BOOSTA_RATE                            = 30,
	E_HP_UP_VALUE                            = 31,
	E_MP_UP_VALUE                            = 32,
	E_UNIQUE_GAUGE_MAX_MP_CURE               = 33,
	E_UNIQUE_REDUCTION_RELIC_COLLECTION_TIME = 34,
	E_UNIQUE_TALK_MEDIATE                    = 35,
	E_UNIQUE_TALK_DISCOUNT                   = 36,
	E_UNIQUE_CHANGE_MAJIN                    = 37,
	E_UNIQUE_CHANGE_HAKAISHIN_RYUUO          = 38,
	E_UNIQUE_CHANGE_GENMA                    = 39,
	E_UNIQUE_CHANGE_4KNIGHT                  = 40,
	E_UNIQUE_CHANGE_KAJYA                    = 41,
	E_UNIQUE_CHANGE_BATK                     = 42,
	E_UNIQUE_CHANGE_MATK                     = 43,
	E_UNIQUE_CHANGE_CRITICAL                 = 44,
	E_UNIQUE_CHANGE_KANTUU                   = 45,
	E_UNIQUE_RETURN_NOT_PRESS                = 46,
	E_UNIQUE_SUMMON_KAJYA_UP                 = 47,
	E_UNIQUE_SUMMON_NNDA_ERASE               = 48,
	E_UNIQUE_SUMMON_KAJYANNDA_ERASE          = 49,
	E_UNIQUE_SUMMON_KAJYANNDA_REVERSE        = 50,
	E_UNIQUE_SUMMON_RAKUNNDA                 = 51,
	E_UNIQUE_SUMMON_TARUNNDA                 = 52,
	E_UNIQUE_SUMMON_SUKUNNDA                 = 53,
	E_UNIQUE_GAUGE_NOT_MAX_WEAKDAMAGE_UP     = 54,
	E_UNIQUE_JARYU_RYUUJIN_RYUUO_HIT_UP      = 55,
	E_UNIQUE_JARYU_RYUUJIN_RYUUO_CRITICAL_UP = 56,
	E_UNIQUE_DAITENSHI_MEGAMI_KIJO_ZIBOSHIN_NNDA2 = 57,
	E_UNIQUE_MAO_RYUUO_CRITICAL              = 58,
	E_UNIQUE_DATENSHI_WEAK_DAMAGE_UP         = 59,
	E_UNIQUE_ZIBOSHIN_MEGAMI_KIJO_CRITICAL   = 60,
	E_UNIQUE_SHINJUU_SEIJUU_MAJUU_YOUJUU_CRITICAL_DAMAGE_UP = 61,
	E_UNIQUE_JARYU_RYUUJIN_RYUUO_WEAK_DAMAGE_UP = 62,
	E_UNIQUE_HAKAISHIN_TENSHI_DAITENSHI_WEAK_DAMAGE_UP = 63,
	E_UNIQUE_NYAN2_DAMAGE_UP                 = 64,
	E_UNIQUE_SHITISYUKU_SKILL_TEKISEI        = 65,
	E_UNIQUE_YONKI_BATK_CRITICAL             = 66,
	E_UNIQUE_SHITENNOU_KAJYA2                = 67,
	E_UNIQUE_GOREI_GAUGE_UP                  = 68,
	E_UNIQUE_WAIT_NNDA2                      = 69,
	E_UNIQUE_BESTFRIEND_HP_CURE              = 70,
	E_UNIQUE_BESTFRIEND_MP_CURE              = 71,
	E_UNIQUE_KUNITSUKAMI_COST_DOWN           = 72,
	E_UNIQUE_DOG_HIT                         = 73,
	E_UNIQUE_MOIRA_YARN                      = 74,
	E_UNIQUE_MOIRA_SCISSORS                  = 75,
	E_UNIQUE_MOIRA_SPINNING_WHEEL            = 76,
	E_UNIQUE_BATTLE_END_RECOME               = 77,
	E_UNIQUE_ATTR_CRITICAL                   = 78,
	E_UNIQUE_BST_TARGET_CRITICAL             = 79,
	E_UNIQUE_SKILL_TEKISEI_CRITICAL          = 80,
	E_UNIQUE_BST_TARGET_HIT_CRITICAL         = 81,
	E_UNIQUE_BST_TARGET_WEAK_DAMAGE_UP       = 82,
	E_UNIQUE_WEAK_DAMAGE_UP                  = 83,
	E_UNIQUE_BST_DOWN                        = 84,
	E_UNIQUE_BATK_CRITICAL_DAMAGE_UP         = 85,
	E_UNIQUE_ATTR_WEAK_DAMAGE_UP             = 86,
	E_UNIQUE_CURE_SKILL_COST_DOWN            = 87,
	E_UNIQUE_AID_SKILL_COST_DOWN             = 88,
	E_UNIQUE_SKILL_TEKISEI_UP                = 89,
	E_UNIQUE_CRIME_AND_PUNISHMENT_CHARGE_DEAD = 90,
	E_UNIQUE_CRIME_AND_PUNISHMENT_CRITICAL_DAMAGE = 91,
	E_UNIQUE_CHARGE_COST_DOWN                = 92,
	E_UNIQUE_CHARGE_NOT_RELEASE              = 93,
	E_UNIQUE_BST_UP                          = 94,
	E_UNIQUE_BST_CURE_DOWN                   = 95,
	E_UNIQUE_BST_CURE                        = 96,
	E_UNIQUE_TURNEND_MP_CURE                 = 97,
	E_UNIQUE_TARUKAJYA2_MAGIC_CRITICAL       = 98,
	E_UNIQUE_RARUKAJYA2_DAMAGE_DOWN          = 99,
	E_UNIQUE_SUKUKAJYA2_CRITICAL             = 100,
	E_UNIQUE_PROVOKE_DAMAGE_DOWN             = 101,
	E_UNIQUE_PROVOKE_ESC_UP                  = 102,
	E_UNIQUE_PROVOKE_KUISHIBARI              = 103,
	E_UNIQUE_SUMMON_SAME_AID                 = 104,
	E_UNIQUE_RETURN_BST_CURE                 = 105,
	E_UNIQUE_BST_DAMAGE_UP                   = 106,
	E_UNIQUE_BST_ACTION                      = 107,
	E_UNIQUE_HERO_STOCK_KUISHIBAI            = 108,
	E_UNIQUE_STOCK_KUISHIBAI                 = 109,
	E_UNIQUE_MYDEAD_HP_CURE                  = 110,
	E_UNIQUE_DEAD_NDA2                       = 111,
	E_UNIQUE_DEAD_GIFT_AID                   = 112,
	E_UNIQUE_DEAD_HP_CURE                    = 113,
	E_UNIQUE_DEAD_MP_CURE                    = 114,
	E_UNIQUE_DEAD_ALL_AID                    = 115,
	E_UNIQUE_RAND_UP                         = 116,
	E_UNIQUE_MULTI_DAMAGE_UP                 = 117,
	E_UNIQUE_MULTI_HIT_UP                    = 118,
	E_UNIQUE_MULTI_HIT_NUM_UP                = 119,
	E_UNIQUE_ACTION_MP_CURE                  = 120,
	E_UNIQUE_SKILL_TEKISEI_WEAK_CRITICAL     = 121,
	E_UNIQUE_SKILL_TEKISEI_DAMAGE_UP         = 122,
	E_UNIQUE_SKILL_TEKISEI_DEAD              = 123,
	E_UNIQUE_SKILL_TEKISEI_SLEEP             = 124,
	E_UNIQUE_BST_NO_PRESS                    = 125,
	E_UNIQUE_MAGATSUHISKILL_MP_CURE          = 126,
	E_UNIQUE_WEAK_NUM_REF_DAMAGE_UP          = 127,
	E_UNIQUE_WEAK_NUM_CRITICAL_UP            = 128,
	E_UNIQUE_WEAK_NUM_CRITICAL_DAMAGE_UP     = 129,
	E_UNIQUE_CLONE_NUM_DAMAGE_UP             = 130,
	E_UNIQUE_STOCK_NUM_THUNDER_HIT           = 131,
	E_UNIQUE_STOCK_NUM_THUNDER_CRITICAL      = 132,
	E_UNIQUE_STOCK_DEAD_NUM_DAMAGE_UP        = 133,
	E_UNIQUE_HIT_UP                          = 134,
	E_UNIQUE_TEKISEL_DAMAGE_UP               = 135,
	E_UNIQUE_PRESS_UP_ADD                    = 136,
	E_UNIQUE_NEXT_ACTOR_HIT_UP               = 137,
	E_UNIQUE_NEXT_ACTOR_WEAK_UP              = 138,
	E_UNIQUE_PREV_ACTOR_HIT_UP               = 139,
	E_UNIQUE_PREV_ACTOR_CRITICAL_UP          = 140,
	E_UNIQUE_NO_UNIQUE_EFFECT                = 141,
	E_UNIQUE_AID_CRITICAL_UP                 = 142,
	E_UNIQUE_AID_CRITICAL_DAMAGE_UP          = 143,
	E_UNIQUE_WEAK_CRITICAL_DEAD              = 144,
	E_UNIQUE_CRITICAL_STOCK                  = 145,
	E_UNIQUE_BST_TARGET_DAMAGE_UP            = 146,
	E_UNIQUE_SLEEP_NO_CURE                   = 147,
	E_UNIQUE_AID_BST_CURE                    = 148,
	E_UNIQUE_CURE_KAJYA1_3TURN               = 149,
	E_UNIQUE_HP_CURE_BST_CURE                = 150,
	E_UNIQUE_BTAK_HIT_UP                     = 151,
	E_UNIQUE_BTAK_CRITICAL_UP                = 152,
	E_UNIQUE_8ACTION_DAMAGE_UP               = 153,
	E_UNIQUE_HIT_NUM_DAMAGE_UP               = 154,
	E_UNIQUE_AID_MP_CURE                     = 155,
	E_UNIQUE_NDA_HP_BST_CURE                 = 156,
	E_UNIQUE_NDA_MP_CURE                     = 157,
	E_UNIQUE_NDA_PRESS_ADD                   = 158,
	E_UNIQUE_DAMAGED_ATTR_COUNTER            = 159,
	E_UNIQUE_DAMAGED_PRESS_ADD               = 160,
	E_UNIQUE_DEFENSE_COUNTER                 = 161,
	E_UNIQUE_KANTSUU_COUNTER                 = 162,
	E_UNIQUE_BST_COUNTER                     = 163,
	E_UNIQUE_RAKUKAJYA2_KANTUU_BLOCK         = 164,
	E_UNIQUE_BLOCK_WEAK_NOT_ESC              = 165,
	E_UNIQUE_SUKUKAJYA_CRITICAL_UP           = 166,
	E_UNIQUE_AGI_LOW_MAGIC_CRITICAL          = 167,
	E_UNIQUE_GOD_HEART                       = 168,
	E_UNIQUE_STRICTLY_ADHERING               = 169,
	E_UNIQUE_SUBORDINATE_EQUIPMENT           = 170,
	E_UNIQUE_SURPLUS                         = 171,
	E_UNIQUE_STAR_PARTS                      = 172,
	E_UNIQUE_NYOMA_DAMAGE_DOWN               = 173,
	E_UNIQUE_NYOMA_MAGIC_CRITICAL            = 174,
	E_UNIQUE_NYOMA_HIT_UP                    = 175,
	E_UNIQUE_NYOMA_ESC_UP                    = 176,
	E_UNIQUE_NYOMA_CRITICAL_UP               = 177,
	E_UNIQUE_TURNEND_MP_CURE_RATE            = 178,
	E_DAMAGED_RAND_KANTUU                    = 179,
	E_AVOID_COUNTER                          = 180,
	E_AVOID_UP                               = 181,
	E_ADD_PRESS_AVOLD                        = 182,
	E_UNIQUE_LOW_HP_CURE_UP                  = 183,
	E_UNIQUE_KUISHIBARI_ABS                  = 184,
	E_UNIQUE_WEAK_TO_ABS                     = 185,
	E_UNIQUE_NYOMA_BST_KANTUU                = 186,
	E_UNIQUE_WEAK_OR_CRITICAL_CNT_ADD_PRESS  = 187,
	E_UNIQUE_ALL_AID_HPMP_UP                 = 188,
	E_UNIQUE_CRITICAL_UP_KANTSUU             = 189,
	E_UNIQUE_SAVING_MAGATSUHI_SKILL_COST     = 190,
	E_MAX                                    = 191,
};

// Enum Project.E_SKILL_EXTRA_EFFECT
// NumValues: 0x005E
enum class E_SKILL_EXTRA_EFFECT : uint8
{
	E_SKILL_EXTRA_EFFECT_NONE                = 0,
	E_SKILL_EXTRA_EFFECT_BATKX2              = 1,
	E_SKILL_EXTRA_EFFECT_MATKX2              = 2,
	E_SKILL_EXTRA_EFFECT_CRITICAL_ABS        = 3,
	E_SKILL_EXTRA_EFFECT_ESC_UP              = 4,
	E_SKILL_EXTRA_EFFECT_CRI_BST_UP          = 5,
	E_SKILL_EXTRA_EFFECT_ESC_UP_B            = 6,
	E_SKILL_EXTRA_EFFECT_ESC_UP_M            = 7,
	E_SKILL_EXTRA_EFFECT_MP_0                = 8,
	E_SKILL_EXTRA_EFFECT_PROVOKE_3TURN       = 9,
	E_SKILL_EXTRA_EFFECT_BST_CRI             = 10,
	E_SKILL_EXTRA_EFFECT_NAHOBINO_BREAK      = 11,
	E_SKILL_EXTRA_EFFECT_NAHOBINO_CLOSE_3    = 12,
	E_SKILL_EXTRA_EFFECT_DAMAGE_CUT          = 13,
	E_SKILL_EXTRA_EFFECT_POW_DOWN_ONLY_TARGET_NUM = 14,
	E_SKILL_EXTRA_EFFECT_SKILLCALL_290       = 15,
	E_SKILL_EXTRA_EFFECT_BATKX1_5            = 16,
	E_SKILL_EXTRA_EFFECT_MATKX1_5            = 17,
	E_SKILL_EXTRA_EFFECT_PRESS_2             = 18,
	E_SKILL_EXTRA_EFFECT_PRESS_0             = 19,
	E_SKILL_EXTRA_EFFECT_KHONSRA_COUNTER     = 20,
	E_SKILL_EXTRA_EFFECT_DARKNESS_DAMAGE_DOWN = 21,
	E_SKILL_EXTRA_EFFECT_TETORAKARN          = 22,
	E_SKILL_EXTRA_EFFECT_MAKARAKARN          = 23,
	E_SKILL_EXTRA_EFFECT_ESCAPE              = 24,
	E_SKILL_EXTRA_EFFECT_REC_X2              = 25,
	E_SKILL_EXTRA_EFFECT_HPUP_RATE           = 26,
	E_SKILL_EXTRA_EFFECT_ELECTRIFICATION     = 27,
	E_SKILL_EXTRA_EFFECT_DEL_ALL_ELECTRIFICATION = 28,
	E_SKILL_EXTRA_EFFECT_RETURN_BEFORE_SUMMON = 29,
	E_SKILL_EXTRA_EFFECT_SHUFFLE_ARRANGEMENT = 30,
	E_SKILL_EXTRA_EFFECT_SAVE_USER_HP        = 31,
	E_SKILL_EXTRA_EFFECT_ADD_PRESSICON       = 32,
	E_SKILL_EXTRA_EFFECT_LUCIFER             = 33,
	E_SKILL_EXTRA_EFFECT_LUCIFER_POWER       = 34,
	E_SKILL_EXTRA_EFFECT_KANTUU              = 35,
	E_SKILL_EXTRA_EFFECT_BATK_MATK           = 36,
	E_SKILL_EXTRA_EFFECT_UPLIFTING           = 37,
	E_SKILL_EXTRA_EFFECT_USE_ALLPRESS        = 38,
	E_SKILL_EXTRA_EFFECT_DEAD_SUMMON         = 39,
	E_SKILL_EXTRA_EFFECT_ESTOMA              = 40,
	E_SKILL_EXTRA_EFFECT_ANALYZE             = 41,
	E_SKILL_EXTRA_EFFECT_SUB_PRESSICON       = 42,
	E_SKILL_EXTRA_EFFECT_ENEMY_RETURN        = 43,
	E_SKILL_EXTRA_EFFECT_OFFSET_HIT_RATE     = 44,
	E_SKILL_EXTRA_EFFECT_ALL_ATTACK_CRITICAL = 45,
	E_SKILL_EXTRA_EFFECT_DAMAGE_CUT_90       = 46,
	E_SKILL_EXTRA_EFFECT_BATK_MATK_4         = 47,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_KANTUU    = 48,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_HIT       = 49,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_BST_HIT   = 50,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_ADVERSITY = 51,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_COST1     = 52,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_AID_RATE  = 53,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_MAX_HIT   = 54,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_TALK_FAILED_BLOCK = 55,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_COST_ATTACK_UP = 56,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_EXP_UP    = 57,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_MAKKA_UP  = 58,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_TEKISEI_MAX = 59,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_CHAGE_NO_CANCEL = 60,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_HP_DRAIN  = 61,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_MP_DRAIN  = 62,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_ALL_AID_DELETE = 63,
	E_SKILL_EXTRA_EFFECT_NOT_CHANGE_ORDER    = 64,
	E_SKILL_EXTRA_EFFECT_NOT_PRESS_0_NORMAL_ACT = 65,
	E_SKILL_EXTRA_EFFECT_BST_PRIORITY_SORT   = 66,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_WEAK_DAMAGE_UP = 67,
	E_SKILL_EXTRA_EFFECT_MAGATSUHI_ITEM_DROP = 68,
	E_SKILL_EXTRA_EFFECT_PRESSICON_RECOVER_TURNSTART = 69,
	E_SKILL_EXTRA_EFFECT_NOPRESS_CHANGE_PASS = 70,
	E_SKILL_EXTRA_EFFECT_PRESS_HALF          = 71,
	E_SKILL_EXTRA_EFFECT_NEXTTURN_PRESS_ADD  = 72,
	E_SKILL_EXTRA_EFFECT_NEXTTURN_PRESS_SUB  = 73,
	E_SKILL_EXTRA_EFFECT_ENEMY_KILLED_PRESS_ADD = 74,
	E_SKILL_EXTRA_EFFECT_RIBERAMA            = 75,
	E_SKILL_EXTRA_EFFECT_CHARGE_ERASE        = 76,
	E_SKILL_EXTRA_EFFECT_BARRIER_ERASE       = 77,
	E_SKILL_EXTRA_EFFECT_ATKUP_TARGET_NUM    = 78,
	E_SKILL_EXTRA_EFFECT_ADD_GAUGE           = 79,
	E_SKILL_EXTRA_EFFECT_ATKUP_NDA_NUM       = 80,
	E_SKILL_EXTRA_EFFECT_RETURN_DAMAGE       = 81,
	E_SKILL_EXTRA_EFFECT_UPLIFTING_KANTUU    = 82,
	E_SKILL_EXTRA_EFFECT_STEAL_TAISEI        = 83,
	E_SKILL_EXTRA_EFFECT_STEAL_MAGATSUHI_SKILL = 84,
	E_SKILL_EXTRA_EFFECT_RESET_STEAL_PARAM   = 85,
	E_SKILL_EXTRA_EFFECT_UPLIFTING_ONLY      = 86,
	E_SKILL_EXTRA_EFFECT_COST_PREV_AVOID     = 87,
	E_SKILL_EXTRA_EFFECT_ATTACK_NUM_AGI      = 88,
	E_SKILL_EXTRA_EFFECT_FORCE_AVOID         = 89,
	E_SKILL_EXTRA_EFFECT_RENZOKU_SKILL       = 90,
	E_SKILL_EXTRA_EFFECT_RESET_TAISEI        = 91,
	E_SKILL_EXTRA_EFFECT_PASS                = 92,
	E_SKILL_EXTRA_EFFECT_MAX                 = 93,
};

// Enum Project.E_AUTO_SKILL_REC_TYPE
// NumValues: 0x0007
enum class E_AUTO_SKILL_REC_TYPE : uint8
{
	E_AUTO_SKILL_REC_NONE                    = 0,
	E_AUTO_SKILL_REC_HP                      = 1,
	E_AUTO_SKILL_REC_MP                      = 2,
	E_AUTO_SKILL_REC_FULL                    = 3,
	E_AUTO_SKILL_REC_HP_S                    = 4,
	E_AUTO_SKILL_REC_MP_S                    = 5,
	E_AUTO_SKILL_REC_MAX                     = 6,
};

// Enum Project.E_AUTO_SKILL_EFT_TYPE
// NumValues: 0x000A
enum class E_AUTO_SKILL_EFT_TYPE : uint8
{
	E_AUTO_SKILL_EFT_NONE                    = 0,
	E_AUTO_SKILL_EFT_RESIST                  = 1,
	E_AUTO_SKILL_EFT_BLOCK                   = 2,
	E_AUTO_SKILL_EFT_REFLEX                  = 3,
	E_AUTO_SKILL_EFT_ABSORB                  = 4,
	E_AUTO_SKILL_EFT_BOOST                   = 5,
	E_AUTO_SKILL_EFT_HIGHBOOST               = 6,
	E_AUTO_SKILL_EFT_CRI_BOOST               = 7,
	E_AUTO_SKILL_EFT_CRI_HIGHBOOST           = 8,
	E_AUTO_SKILL_EFT_MAX                     = 9,
};

// Enum Project.E_SKILL_REC_TYPE
// NumValues: 0x0004
enum class E_SKILL_REC_TYPE : uint8
{
	E_SKILL_REC_FULL                         = 0,
	E_SKILL_REC_FIX_RATE                     = 1,
	E_SKILL_REC_NORMAL                       = 2,
	E_SKILL_REC_MAX                          = 3,
};

// Enum Project.E_SKILL_KIND
// NumValues: 0x0004
enum class E_SKILL_KIND : uint8
{
	E_SKILL_KIND_INVALID                     = 0,
	E_SKILL_KIND_NORMAL                      = 1,
	E_SKILL_KIND_AUTO                        = 2,
	E_SKILL_KIND_MAX                         = 3,
};

// Enum Project.E_SKILL_ENABLE_SCENE
// NumValues: 0x0005
enum class E_SKILL_ENABLE_SCENE : uint8
{
	E_SKILL_ENABLE_SCENE_NOT_USE             = 0,
	E_SKILL_ENABLE_SCENE_FIELD               = 1,
	E_SKILL_ENABLE_SCENE_BATTLE              = 2,
	E_SKILL_ENABLE_SCENE_ALL_SCENE           = 3,
	E_SKILL_ENABLE_SCENE_MAX                 = 4,
};

// Enum Project.E_SKILL_TARGET
// NumValues: 0x000C
enum class E_SKILL_TARGET : uint8
{
	E_SKILL_TARGET_INV_SIDE_ONE              = 0,
	E_SKILL_TARGET_INV_SIDE_ALL              = 1,
	E_SKILL_TARGET_SELF_SIDE_ONE             = 2,
	E_SKILL_TARGET_SELF_SIDE_ALL             = 3,
	E_SKILL_TARGET_SELF                      = 4,
	E_SKILL_TARGET_ALL_SIDE_ALL              = 5,
	E_SKILL_TARGET_INV_SIDE_ALL_RANDOM       = 6,
	E_SKILL_TARGET_SELF_SIDE_CMP_ONE         = 7,
	E_SKILL_TARGET_SELF_SIDE_CMP_ALL         = 8,
	E_SKILL_TARGET_INV_SIDE_STAN_ONE         = 9,
	E_SKILL_TARGET_INV_SIDE_STAN_ALL         = 10,
	E_SKILL_TARGET_MAX                       = 11,
};

// Enum Project.E_SKILL_TEKISEI_EFT_TYPE
// NumValues: 0x0006
enum class E_SKILL_TEKISEI_EFT_TYPE : uint8
{
	E_SKILL_TEKISEI_EFT_NONE                 = 0,
	E_SKILL_TEKISEI_EFT_DAMAGE               = 1,
	E_SKILL_TEKISEI_EFT_REC                  = 2,
	E_SKILL_TEKISEI_EFT_MP                   = 3,
	E_SKILL_TEKISEI_EFT_RATE                 = 4,
	E_SKILL_TEKISEI_EFT_MAX                  = 5,
};

// Enum Project.E_SKILL_TEKISEI_TYPE
// NumValues: 0x0006
enum class E_SKILL_TEKISEI_TYPE : uint8
{
	E_SKILL_TEKISEI_TYPE_NONE                = 0,
	E_SKILL_TEKISEI_TYPE_A                   = 1,
	E_SKILL_TEKISEI_TYPE_B                   = 2,
	E_SKILL_TEKISEI_TYPE_C                   = 3,
	E_SKILL_TEKISEI_TYPE_D                   = 4,
	E_SKILL_TEKISEI_TYPE_MAX                 = 5,
};

// Enum Project.E_SKILL_ICON
// NumValues: 0x000E
enum class E_SKILL_ICON : uint8
{
	E_SKILL_ICON_PHISICS                     = 0,
	E_SKILL_ICON_FIRE                        = 1,
	E_SKILL_ICON_ICE                         = 2,
	E_SKILL_ICON_THUNDER                     = 3,
	E_SKILL_ICON_WIND                        = 4,
	E_SKILL_ICON_LIGHT                       = 5,
	E_SKILL_ICON_DARK                        = 6,
	E_SKILL_ICON_ALL                         = 7,
	E_SKILL_ICON_NODAMAGE_ATK                = 8,
	E_SKILL_ICON_AID                         = 9,
	E_SKILL_ICON_RECOVERY                    = 10,
	E_SKILL_ICON_SPECIAL                     = 11,
	E_SKILL_ICON_TWO                         = 12,
	E_SKILL_ICON_MAX                         = 13,
};

// Enum Project.E_SKILL_LIMITED
// NumValues: 0x0008
enum class E_SKILL_LIMITED : uint8
{
	E_SKILL_LIMITED_ALL                      = 0,
	E_SKILL_LIMITED_WEAPON                   = 1,
	E_SKILL_LIMITED_PHYSICAL                 = 2,
	E_SKILL_LIMITED_NEEDLE                   = 3,
	E_SKILL_LIMITED_BITE                     = 4,
	E_SKILL_LIMITED_CLAW                     = 5,
	E_SKILL_LIMITED_MAGIC                    = 6,
	E_SKILL_LIMITED_MAX                      = 7,
};

// Enum Project.E_SKILL_TYPE
// NumValues: 0x0011
enum class E_SKILL_TYPE : uint8
{
	E_SKILL_TYPE_PHYSICAL_ATK                = 0,
	E_SKILL_TYPE_MAGIC_ATK                   = 1,
	E_SKILL_TYPE_NODAMAGE_ATK                = 2,
	E_SKILL_TYPE_RECOVERY                    = 3,
	E_SKILL_TYPE_AID                         = 4,
	E_SKILL_TYPE_AUTO_ERUPT_ATTR             = 5,
	E_SKILL_TYPE_AUTO_ERUPT                  = 6,
	E_SKILL_TYPE_SUMMON                      = 7,
	E_SKILL_TYPE_SPECIAL_ATK                 = 8,
	E_SKILL_TYPE_CALL                        = 9,
	E_SKILL_TYPE_NOT_ACT                     = 10,
	E_SKILL_TYPE_STATUS_UP                   = 11,
	E_SKILL_TYPE_PHYSICAL_MAGIC_ATK          = 12,
	E_SKILL_TYPE_EXTRA_ATK                   = 13,
	E_SKILL_TYPE_PHYSICAL_RATE_ATK           = 14,
	E_SKILL_TYPE_RETURN                      = 15,
	E_SKILL_TYPE_MAX                         = 16,
};

// Enum Project.E_SKILL_WHISPER_VAL_TYPE
// NumValues: 0x0009
enum class E_SKILL_WHISPER_VAL_TYPE : uint8
{
	E_SKILL_WHISPER_VAL_TYPE_NONE            = 0,
	E_SKILL_WHISPER_VAL_TYPE_DAMAGE_VAL      = 1,
	E_SKILL_WHISPER_VAL_TYPE_RECOVERY_VAL    = 2,
	E_SKILL_WHISPER_VAL_TYPE_RATE            = 3,
	E_SKILL_WHISPER_VAL_TYPE_COST            = 4,
	E_SKILL_WHISPER_VAL_TYPE_MINUS_DAM       = 5,
	E_SKILL_WHISPER_VAL_TYPE_MINUS_RATE      = 6,
	E_SKILL_WHISPER_VAL_TYPE_MINUS_COST      = 7,
	E_SKILL_WHISPER_VAL_TYPE_MAX             = 8,
};

// Enum Project.E_SKILL_BST
// NumValues: 0x0011
enum class E_SKILL_BST : uint8
{
	E_SKILL_BST_EXCEPT_DEAD                  = 0,
	E_SKILL_BST_SLEEP_FEAR                   = 1,
	E_SKILL_BST_ALL                          = 2,
	E_SKILL_BST_EXCEPT_BOMB_DOWN_DEAD        = 3,
	E_SKILL_BST_UROBOROS                     = 4,
	E_SKILL_BST_EXCEPT_STRAY                 = 5,
	E_SKILL_BST_BATTLE                       = 6,
	E_SKILL_BST_ELDJUON                      = 7,
	E_SKILL_BST_KKIRI                        = 8,
	E_SKILL_BST_POISON_ILL                   = 9,
	E_SKILL_BST_JUNAN                        = 10,
	E_SKILL_BST_AKUEKI                       = 11,
	E_SKILL_BST_MUSOU                        = 12,
	E_SKILL_BST_KAMITSUKI                    = 13,
	E_SKILL_BST_WAZURAI                      = 14,
	E_SKILL_BST_DLC_ITEM                     = 15,
	E_SKILL_BST_MAX                          = 16,
};

// Enum Project.E_SKILL_LIB_CATEGORY
// NumValues: 0x0011
enum class E_SKILL_LIB_CATEGORY : uint8
{
	E_SKILL_LIB_CATEGORY_ALL                 = 0,
	E_SKILL_LIB_CATEGORY_PHISICS             = 1,
	E_SKILL_LIB_CATEGORY_FIRE                = 2,
	E_SKILL_LIB_CATEGORY_ICE                 = 3,
	E_SKILL_LIB_CATEGORY_THUNDER             = 4,
	E_SKILL_LIB_CATEGORY_WIND                = 5,
	E_SKILL_LIB_CATEGORY_LIGHT               = 6,
	E_SKILL_LIB_CATEGORY_DARK                = 7,
	E_SKILL_LIB_CATEGORY_EVERY               = 8,
	E_SKILL_LIB_CATEGORY_RECOVERY            = 9,
	E_SKILL_LIB_CATEGORY_AID                 = 10,
	E_SKILL_LIB_CATEGORY_NODAMAGE_ATK        = 11,
	E_SKILL_LIB_CATEGORY_AUTO                = 12,
	E_SKILL_LIB_CATEGORY_SPECIAL             = 13,
	E_SKILL_LIB_CATEGORY_DOUBLE              = 14,
	E_SKILL_LIB_CATEGORY_MAX                 = 15,
	E_SKILL_LIB_CATEGORY_NONE                = 16,
};

// Enum Project.E_SKILL_LIB_STATUS_STEP
// NumValues: 0x0009
enum class E_SKILL_LIB_STATUS_STEP : uint8
{
	E_SKILL_LIB_STATUS_STEP_NONE             = 0,
	E_SKILL_LIB_STATUS_STEP_IN               = 1,
	E_SKILL_LIB_STATUS_STEP_CHARA_SEL        = 2,
	E_SKILL_LIB_STATUS_STEP_SKILL_GET_CHECK  = 3,
	E_SKILL_LIB_STATUS_STEP_SKILL_CHANGE     = 4,
	E_SKILL_LIB_STATUS_STEP_SKILL_CHANGE_CHECK = 5,
	E_SKILL_LIB_STATUS_STEP_OUT              = 6,
	E_SKILL_LIB_STATUS_STEP_END              = 7,
	E_SKILL_LIB_STATUS_STEP_MAX              = 8,
};

// Enum Project.E_SKILL_LIB_MENU_STEP
// NumValues: 0x0011
enum class E_SKILL_LIB_MENU_STEP : uint8
{
	E_SKILL_LIB_MENU_STEP_NONE               = 0,
	E_SKILL_LIB_MENU_STEP_IN                 = 1,
	E_SKILL_LIB_MENU_STEP_CATEGORY_SEL       = 2,
	E_SKILL_LIB_MENU_STEP_SKILL_SEL          = 3,
	E_SKILL_LIB_MENU_STEP_PARTY_SEL          = 4,
	E_SKILL_LIB_MENU_STEP_STATUS_VIEW        = 5,
	E_SKILL_LIB_MENU_STEP_CHECK_SKILL_GET    = 6,
	E_SKILL_LIB_MENU_STEP_SKILL_GET          = 7,
	E_SKILL_LIB_MENU_STEP_CHANGE_SKILL_SEL   = 8,
	E_SKILL_LIB_MENU_STEP_CHECK_CHANGE_SKILL = 9,
	E_SKILL_LIB_MENU_STEP_SKILL_GET_END      = 10,
	E_SKILL_LIB_MENU_STEP_MASTER             = 11,
	E_SKILL_LIB_MENU_STEP_MESS_WAIT          = 12,
	E_SKILL_LIB_MENU_STEP_ANIM_WAIT          = 13,
	E_SKILL_LIB_MENU_STEP_OUT                = 14,
	E_SKILL_LIB_MENU_STEP_END                = 15,
	E_SKILL_LIB_MENU_STEP_MAX                = 16,
};

// Enum Project.E_SKILL_LIB_SCREEN_TYPE
// NumValues: 0x0005
enum class E_SKILL_LIB_SCREEN_TYPE : uint8
{
	E_SKILL_LIB_SCREEN_TYPE_NONE             = 0,
	E_SKILL_LIB_SCREEN_TYPE_MENU             = 1,
	E_SKILL_LIB_SCREEN_TYPE_STATUS           = 2,
	E_SKILL_LIB_SCREEN_TYPE_END              = 3,
	E_SKILL_LIB_SCREEN_TYPE_MAX              = 4,
};

// Enum Project.E_SORT_WINDOW_SORT_ORDER
// NumValues: 0x0004
enum class E_SORT_WINDOW_SORT_ORDER : uint8
{
	NOT_APPLY                                = 0,
	ASCENDING                                = 1,
	DESCENDING                               = 2,
	E_SORT_WINDOW_SORT_MAX                   = 3,
};

// Enum Project.E_SORT_WINDOW_SORT_TYPE
// NumValues: 0x0013
enum class E_SORT_WINDOW_SORT_TYPE : uint8
{
	CAMP_SKILL                               = 0,
	CAMP_ITEM_CONSUMPTION                    = 1,
	CAMP_ITEM_RELIC                          = 2,
	CAMP_ITEM_VALUABLES                      = 3,
	CAMP_PARTY_STOCK                         = 4,
	CAMP_ANALYZE_ENEMY                       = 5,
	SHOP_ITEM_PURCHASE_CONSUMPTION           = 6,
	SHOP_SALE_CONSUMPTION                    = 7,
	SHOP_SALE_RELIC                          = 8,
	NOT_USE_00                               = 9,
	COALESCENCE_RESULT_SELECT_COALESCENCE_RESULT = 10,
	COALESCENCE_COMBINATION_SELECT_COMBINATION = 11,
	COALESCENCE_COMPENDIUM_READ_DEMON        = 12,
	AUTOMAP                                  = 13,
	GODPARAMETER_ACQUISITION                 = 14,
	CAMP_UTSUSEMI                            = 15,
	SHOP_ITEM_PURCHASE_UTSUSEMI              = 16,
	COALESCENCE_RESULT_SELECT_COALESCENCE_RESULT_SP = 17,
	MAX                                      = 18,
};

// Enum Project.E_STATUSSKILLLIST_CANSELTYPE
// NumValues: 0x0003
enum class E_STATUSSKILLLIST_CANSELTYPE : uint8
{
	NORMAL                                   = 0,
	ERROR_TYPE                               = 1,
	E_STATUSSKILLLIST_MAX                    = 2,
};

// Enum Project.E_STATUSSKILLLIST_ANIMETYPE
// NumValues: 0x0004
enum class E_STATUSSKILLLIST_ANIMETYPE : uint8
{
	CURSOR                                   = 0,
	NORMAL                                   = 1,
	NOT                                      = 2,
	E_STATUSSKILLLIST_MAX                    = 3,
};

// Enum Project.E_UI_STATUS_R_ANIM_TYPE
// NumValues: 0x0005
enum class E_UI_STATUS_R_ANIM_TYPE : uint8
{
	E_UI_STATUS_R_ANIM_TYPE_NONE             = 0,
	E_UI_STATUS_R_ANIM_TYPE_SKILL_CURSOR     = 1,
	E_UI_STATUS_R_ANIM_TYPE_SKILL_IN         = 2,
	E_UI_STATUS_R_ANIM_TYPE_SKILL_GET_OUT    = 3,
	E_UI_STATUS_R_ANIM_TYPE_MAX              = 4,
};

// Enum Project.E_UI_STATUS_R_ANIM_TABLE
// NumValues: 0x0008
enum class E_UI_STATUS_R_ANIM_TABLE : uint8
{
	E_UI_STATUS_R_ANIM_TABLE_SKILL_IN        = 0,
	E_UI_STATUS_R_ANIM_TABLE_SKILL_IN_WAIT   = 1,
	E_UI_STATUS_R_ANIM_TABLE_SKILL_OUT       = 2,
	E_UI_STATUS_R_ANIM_TABLE_BLINK           = 3,
	E_UI_STATUS_R_ANIM_TABLE_SKILL_OUT_WAIT  = 4,
	E_UI_STATUS_R_ANIM_TABLE_SKILL_CURSOR_00 = 5,
	E_UI_STATUS_R_ANIM_TABLE_SKILL_CURSOR_01 = 6,
	E_UI_STATUS_R_ANIM_TABLE_MAX             = 7,
};

// Enum Project.E_UI_STATUS_ANIM_TYPE
// NumValues: 0x0008
enum class E_UI_STATUS_ANIM_TYPE : uint8
{
	E_UI_STATUS_ANIM_TYPE_NONE               = 0,
	E_UI_STATUS_ANIM_TYPE_NO_DRAW            = 1,
	E_UI_STATUS_ANIM_TYPE_DEVIL_MES_IN       = 2,
	E_UI_STATUS_ANIM_TYPE_SKILL_HELP_IN      = 3,
	E_UI_STATUS_ANIM_TYPE_NEXT_SKILL_HELP_IN = 4,
	E_UI_STATUS_ANIM_TYPE_LEFT_UI_IN         = 5,
	E_UI_STATUS_ANIM_TYPE_RIGHT_UI_IN        = 6,
	E_UI_STATUS_ANIM_TYPE_MAX                = 7,
};

// Enum Project.E_UI_STATUS_ANIM_TABLE
// NumValues: 0x0008
enum class E_UI_STATUS_ANIM_TABLE : uint8
{
	E_UI_STATUS_ANIM_TABLE_NO_DRAW           = 0,
	E_UI_STATUS_ANIM_TABLE_LEFT_IN           = 1,
	E_UI_STATUS_ANIM_TABLE_LEFT_OUT          = 2,
	E_UI_STATUS_ANIM_TABLE_RIGHT_IN          = 3,
	E_UI_STATUS_ANIM_TABLE_RIGHT_OUT         = 4,
	E_UI_STATUS_ANIM_TABLE_SKILL_HELP_IN     = 5,
	E_UI_STATUS_ANIM_TABLE_MODEL_SLIDE       = 6,
	E_UI_STATUS_ANIM_TABLE_MAX               = 7,
};

// Enum Project.E_STATUS_SKILL_LIST_TYPE
// NumValues: 0x0004
enum class E_STATUS_SKILL_LIST_TYPE : uint8
{
	E_STATUS_SKILL_LIST_TYPE_NORMAL          = 0,
	E_STATUS_SKILL_LIST_TYPE_AUTO            = 1,
	E_STATUS_SKILL_LIST_TYPE_NEXT            = 2,
	E_STATUS_SKILL_LIST_TYPE_MAX             = 3,
};

// Enum Project.E_STATUS_UI_VIEW_TYPE
// NumValues: 0x0004
enum class E_STATUS_UI_VIEW_TYPE : uint8
{
	E_STATUS_UI_VIEW_TYPE_NORMAL             = 0,
	E_STATUS_UI_VIEW_TYPE_TONE_DOWN          = 1,
	E_STATUS_UI_VIEW_TYPE_TONE_UP            = 2,
	E_STATUS_UI_VIEW_TYPE_MAX                = 3,
};

// Enum Project.E_STATUS_MES_TYPE
// NumValues: 0x0003
enum class E_STATUS_MES_TYPE : uint8
{
	E_STATUS_MES_TYPE_PARAM_SET_CHECK        = 0,
	E_STATUS_MES_TYPE_PARAM_CANCEL_CHECK     = 1,
	E_STATUS_MES_TYPE_PARAM_MAX              = 2,
};

// Enum Project.E_STATUS_PARAM_SET_SETP
// NumValues: 0x0004
enum class E_STATUS_PARAM_SET_SETP : uint8
{
	E_STATUS_PARAM_SET_SETP_SET              = 0,
	E_STATUS_PARAM_SET_SETP_CHECK_CANCEL     = 1,
	E_STATUS_PARAM_SET_SETP_CHECK_ACT        = 2,
	E_STATUS_PARAM_SET_SETP_MAX              = 3,
};

// Enum Project.E_STATUS_FLAG
// NumValues: 0x0007
enum class E_STATUS_FLAG : uint8
{
	E_STATUS_FLAG_NONE                       = 0,
	E_STATUS_FLAG_ANIM_WAIT                  = 1,
	E_STATUS_FLAG_DEVIL_MES                  = 2,
	E_STATUS_FLAG_SKILL_SEL                  = 3,
	E_STATUS_FLAG_SKILL_CHANGE               = 4,
	E_STATUS_FLAG_PARAM_SET                  = 5,
	E_STATUS_FLAG_MAX                        = 6,
};

// Enum Project.E_UI_CONDITION_NAME
// NumValues: 0x0044
enum class E_UI_CONDITION_NAME : uint8
{
	E_UI_CONDITION_NAME_NONE                 = 0,
	E_UI_CONDITION_NAME_SLEEP                = 1,
	E_UI_CONDITION_NAME_CONFUSE              = 2,
	E_UI_CONDITION_NAME_CHARM                = 3,
	E_UI_CONDITION_NAME_CLOSE                = 4,
	E_UI_CONDITION_NAME_POISON               = 5,
	E_UI_CONDITION_NAME_MUD                  = 6,
	E_UI_CONDITION_NAME_DARKNESS             = 7,
	E_UI_CONDITION_NAME_DEAD                 = 8,
	E_UI_CONDITION_NAME_VERTIGO              = 9,
	E_UI_CONDITION_NAME_STRAY                = 10,
	E_UI_CONDITION_NAME_STONE                = 11,
	E_UI_CONDITION_NAME_DAZZLE               = 12,
	E_UI_CONDITION_NAME_ATTACK_UP            = 13,
	E_UI_CONDITION_NAME_DEFENCE_UP           = 14,
	E_UI_CONDITION_NAME_HIT_ESC_UP           = 15,
	E_UI_CONDITION_NAME_ATTACK_DOWN          = 16,
	E_UI_CONDITION_NAME_DEFENCE_DOWN         = 17,
	E_UI_CONDITION_NAME_HIT_ESC_DOWN         = 18,
	E_UI_CONDITION_NAME_ATTACK_REF           = 19,
	E_UI_CONDITION_NAME_MAGIC_REF            = 20,
	E_UI_CONDITION_NAME_TETORAJYA            = 21,
	E_UI_CONDITION_NAME_ATTACK_CHARGE        = 22,
	E_UI_CONDITION_NAME_MAGIC_CHARGE         = 23,
	E_UI_CONDITION_NAME_CRITICAL_ABS_CHARGE  = 24,
	E_UI_CONDITION_NAME_RECOVERLY_CHARGE     = 25,
	E_UI_CONDITION_NAME_PENETRATE_CHARGE     = 26,
	E_UI_CONDITION_NAME_PROVOKE              = 27,
	E_UI_CONDITION_NAME_NO_ABNORMAL          = 28,
	E_UI_CONDITION_NAME_SHIELD               = 29,
	E_UI_CONDITION_NAME_MAGA_GOD_SHIELD      = 30,
	E_UI_CONDITION_NAME_MAGA_GOD_PENETRATE   = 31,
	E_UI_CONDITION_NAME_MAGA_CRITICAL_CHARGE = 32,
	E_UI_CONDITION_NAME_MAGA_PENETRATE_CHARGE = 33,
	E_UI_CONDITION_NAME_MAGA_BST_HIT_UP      = 34,
	E_UI_CONDITION_NAME_MAGA_ADVERSITY       = 35,
	E_UI_CONDITION_NAME_MAGA_COST1           = 36,
	E_UI_CONDITION_NAME_MAGA_AID_RATE        = 37,
	E_UI_CONDITION_NAME_MAGA_MAX_HIT         = 38,
	E_UI_CONDITION_NAME_MAGA_TALK_FAILED_BLOCK = 39,
	E_UI_CONDITION_NAME_MAGA_COST_ATTACK_UP  = 40,
	E_UI_CONDITION_NAME_MAGA_RESULT_BONUS    = 41,
	E_UI_CONDITION_NAME_MAGA_POTENTIAL_MAX   = 42,
	E_UI_CONDITION_NAME_MAGA_CHAGE_NO_CANCEL = 43,
	E_UI_CONDITION_NAME_BLOCK_PHISICS        = 44,
	E_UI_CONDITION_NAME_BLOCK_FIRE           = 45,
	E_UI_CONDITION_NAME_BLOCK_ICE            = 46,
	E_UI_CONDITION_NAME_BLOCK_THUNDER        = 47,
	E_UI_CONDITION_NAME_BLOCK_WIND           = 48,
	E_UI_CONDITION_NAME_BLOCK_LIGHT          = 49,
	E_UI_CONDITION_NAME_BLOCK_DARK           = 50,
	E_UI_CONDITION_NAME_MAGA_ENEMY_CHARGE    = 51,
	E_UI_CONDITION_NAME_ATTACK_UP2           = 52,
	E_UI_CONDITION_NAME_DEFENCE_UP2          = 53,
	E_UI_CONDITION_NAME_HIT_ESC_UP2          = 54,
	E_UI_CONDITION_NAME_ATTACK_DOWN2         = 55,
	E_UI_CONDITION_NAME_DEFENCE_DOWN2        = 56,
	E_UI_CONDITION_NAME_HIT_ESC_DOWN2        = 57,
	E_UI_CONDITION_NAME_MAGA_ENEMY_PENETRATE_CHARGE = 58,
	E_UI_CONDITION_NAME_RENZOKU_SKILL        = 59,
	E_UI_CONDITION_NAME_FORCE_AVOID          = 60,
	E_UI_CONDITION_NAME_MAGA_WEAK_DAMAGE_UP  = 61,
	E_UI_CONDITION_NAME_MAGA_ITEM_DROP       = 62,
	E_UI_CONDITION_NAME_MAGA_ENEMY_KILLED_PRESS_ADD = 63,
	E_UI_CONDITION_NAME_MAGA_PRESS_HALF      = 64,
	E_UI_CONDITION_NAME_MAGA_NOPRESS_CHANGE_PASS = 65,
	E_UI_CONDITION_NAME_MAGA_AURA_ONLY       = 66,
	E_UI_CONDITION_NAME_MAX                  = 67,
};

// Enum Project.ASubLevelVisibilityVolumeUsage
// NumValues: 0x0004
enum class EASubLevelVisibilityVolumeUsage : uint8
{
	SLVV_Show                                = 0,
	SLVV_Hide                                = 1,
	SLVV_None                                = 2,
	SLVV_MAX                                 = 3,
};

// Enum Project.E_OPTION_DLC_TYPE
// NumValues: 0x0007
enum class E_OPTION_DLC_TYPE : uint8
{
	E_OPTION_DLC_TYPE_DIFFICULTY_EASY        = 0,
	E_OPTION_DLC_TYPE_DIFFICULTY_VERY_HARD   = 1,
	E_OPTION_DLC_TYPE_JP_VOICE               = 2,
	E_OPTION_DLC_TYPE_CHEAT_MONEY            = 3,
	E_OPTION_DLC_TYPE_CHEAT_EXP              = 4,
	E_OPTION_DLC_TYPE_CHEAT_GLORY            = 5,
	E_OPTION_DLC_TYPE_MAX                    = 6,
};

// Enum Project.E_OPTION_CONTENT_FRAME_RATE_TYPE
// NumValues: 0x0007
enum class E_OPTION_CONTENT_FRAME_RATE_TYPE : uint8
{
	E_OPTION_CONTENT_FRAME_RATE_TYPE_UNLIMITED = 0,
	E_OPTION_CONTENT_FRAME_RATE_TYPE_30      = 30,
	E_OPTION_CONTENT_FRAME_RATE_TYPE_60      = 60,
	E_OPTION_CONTENT_FRAME_RATE_TYPE_90      = 90,
	E_OPTION_CONTENT_FRAME_RATE_TYPE_120     = 120,
	E_OPTION_CONTENT_FRAME_RATE_TYPE_144     = 144,
	E_OPTION_CONTENT_FRAME_RATE_TYPE_MAX     = 145,
};

// Enum Project.E_OPTION_CONTENT_SCREEN_MODE
// NumValues: 0x0004
enum class E_OPTION_CONTENT_SCREEN_MODE : uint8
{
	E_OPTION_CONTENT_SCREEN_MODE_FULL_SCREEN = 0,
	E_OPTION_CONTENT_SCREEN_MODE_BORDERLESS  = 1,
	E_OPTION_CONTENT_SCREEN_MODE_WINDOW      = 2,
	E_OPTION_CONTENT_SCREEN_MODE_MAX         = 3,
};

// Enum Project.E_OPTION_CONTENT_SPEED_TYPE
// NumValues: 0x0006
enum class E_OPTION_CONTENT_SPEED_TYPE : uint8
{
	E_OPTION_CONTENT_SPEED_TYPE_X1           = 0,
	E_OPTION_CONTENT_SPEED_TYPE_X2           = 1,
	E_OPTION_CONTENT_SPEED_TYPE_X3           = 2,
	E_OPTION_CONTENT_SPEED_TYPE_X4           = 3,
	E_OPTION_CONTENT_SPEED_TYPE_SKIP         = 4,
	E_OPTION_CONTENT_SPEED_TYPE_MAX          = 5,
};

// Enum Project.E_OPTION_CONTENT_BATTLE_ACTION_TYPE
// NumValues: 0x0004
enum class E_OPTION_CONTENT_BATTLE_ACTION_TYPE : uint8
{
	E_OPTION_CONTENT_BATTLE_ACTION_TYPE_ATTACK = 0,
	E_OPTION_CONTENT_BATTLE_ACTION_TYPE_SKILL = 1,
	E_OPTION_CONTENT_BATTLE_ACTION_TYPE_SELECT_AT_START = 2,
	E_OPTION_CONTENT_BATTLE_ACTION_TYPE_MAX  = 3,
};

// Enum Project.E_OPTION_CONTENT_ITEM_PRIORITIZE_TYPE
// NumValues: 0x0005
enum class E_OPTION_CONTENT_ITEM_PRIORITIZE_TYPE : uint8
{
	E_OPTION_CONTENT_ITEM_PRIORITIZE_TYPE_HEAL = 0,
	E_OPTION_CONTENT_ITEM_PRIORITIZE_TYPE_ATTACK = 1,
	E_OPTION_CONTENT_ITEM_PRIORITIZE_TYPE_ASSIST = 2,
	E_OPTION_CONTENT_ITEM_PRIORITIZE_TYPE_SPECIAL = 3,
	E_OPTION_CONTENT_ITEM_PRIORITIZE_TYPE_MAX = 4,
};

// Enum Project.E_OPTION_CONTENT_STICK_PUSH_TYPE
// NumValues: 0x0004
enum class E_OPTION_CONTENT_STICK_PUSH_TYPE : uint8
{
	E_OPTION_CONTENT_STICK_PUSH_TYPE_NONE    = 0,
	E_OPTION_CONTENT_STICK_PUSH_TYPE_AUTO_DASH = 1,
	E_OPTION_CONTENT_STICK_PUSH_TYPE_CAMERA_RESET = 2,
	E_OPTION_CONTENT_STICK_PUSH_TYPE_MAX     = 3,
};

// Enum Project.E_OPTION_CONTENT_FOV_TYPE
// NumValues: 0x0004
enum class E_OPTION_CONTENT_FOV_TYPE : uint8
{
	E_OPTION_CONTENT_FOV_TYPE_NARROW         = 0,
	E_OPTION_CONTENT_FOV_TYPE_STANDARD       = 1,
	E_OPTION_CONTENT_FOV_TYPE_WIDE           = 2,
	E_OPTION_CONTENT_FOV_TYPE_MAX            = 3,
};

// Enum Project.E_OPTION_CONTENT_BUTTON_ICON_TYPE
// NumValues: 0x0006
enum class E_OPTION_CONTENT_BUTTON_ICON_TYPE : uint8
{
	E_OPTION_CONTENT_BUTTON_ICON_TYPE_DEFAULT = 0,
	E_OPTION_CONTENT_BUTTON_ICON_TYPE_SWITCH = 1,
	E_OPTION_CONTENT_BUTTON_ICON_TYPE_PS4    = 2,
	E_OPTION_CONTENT_BUTTON_ICON_TYPE_PS5    = 3,
	E_OPTION_CONTENT_BUTTON_ICON_TYPE_XBOX   = 4,
	E_OPTION_CONTENT_BUTTON_ICON_TYPE_MAX    = 5,
};

// Enum Project.E_OPTION_CONTENT_CONTROL_TYPE
// NumValues: 0x0003
enum class E_OPTION_CONTENT_CONTROL_TYPE : uint8
{
	E_OPTION_CONTENT_CONTROL_TYPE_A          = 0,
	E_OPTION_CONTENT_CONTROL_TYPE_B          = 1,
	E_OPTION_CONTENT_CONTROL_TYPE_MAX        = 2,
};

// Enum Project.E_OPTION_CONTENT_LANGUAGE_TYPE
// NumValues: 0x0003
enum class E_OPTION_CONTENT_LANGUAGE_TYPE : uint8
{
	E_OPTION_CONTENT_LANGUAGE_TYPE_JP        = 0,
	E_OPTION_CONTENT_LANGUAGE_TYPE_EN        = 1,
	E_OPTION_CONTENT_LANGUAGE_TYPE_MAX       = 2,
};

// Enum Project.E_OPTION_COMMON_SWITCH_TYPE
// NumValues: 0x0003
enum class E_OPTION_COMMON_SWITCH_TYPE : uint8
{
	E_OPTION_COMMON_SELECT_TYPE_ON           = 0,
	E_OPTION_COMMON_SELECT_TYPE_OFF          = 1,
	E_OPTION_COMMON_SELECT_TYPE_MAX          = 2,
};

// Enum Project.E_OPTION_COMMON_SELECT_TYPE
// NumValues: 0x0004
enum class E_OPTION_COMMON_SELECT_TYPE : uint8
{
	E_OPTION_COMMON_SELECT_TYPE_DO           = 0,
	E_OPTION_COMMON_SELECT_TYPE_DONOT        = 1,
	E_OPTION_COMMON_SELECT_TYPE_AUTO         = 2,
	E_OPTION_COMMON_SELECT_TYPE_MAX          = 3,
};

// Enum Project.E_OPTION_BATTLE_PRODUCTION_TYPE
// NumValues: 0x0004
enum class E_OPTION_BATTLE_PRODUCTION_TYPE : uint8
{
	E_OPTION_BATTLE_PRODUCTION_TYPE_A_BUTTON = 0,
	E_OPTION_BATTLE_PRODUCTION_TYPE_ALWAYS   = 1,
	E_OPTION_BATTLE_PRODUCTION_TYPE_INVALID  = 2,
	E_OPTION_BATTLE_PRODUCTION_TYPE_MAX      = 3,
};

// Enum Project.E_OPTION_CAMERA_INPUT_TYPE
// NumValues: 0x0004
enum class E_OPTION_CAMERA_INPUT_TYPE : uint8
{
	E_OPTION_CAMERA_INPUT_TYPE_STANDARD      = 0,
	E_OPTION_CAMERA_INPUT_TYPE_REVERSE       = 1,
	E_OPTION_CAMERA_INPUT_TYPE_INVALID       = 2,
	E_OPTION_CAMERA_INPUT_TYPE_MAX           = 3,
};

// Enum Project.E_OPTION_MESSAGE_SPEED_TYPE
// NumValues: 0x0005
enum class E_OPTION_MESSAGE_SPEED_TYPE : uint8
{
	E_OPTION_SPEED_TYPE_STANDARD             = 0,
	E_OPTION_SPEED_TYPE_FAST                 = 1,
	E_OPTION_SPEED_TYPE_SWIFT                = 2,
	E_OPTION_SPEED_TYPE_IMMEDIATE            = 3,
	E_OPTION_SPEED_TYPE_MAX                  = 4,
};

// Enum Project.E_SYSTEM_MENU_TYPE
// NumValues: 0x0007
enum class E_SYSTEM_MENU_TYPE : uint8
{
	E_SYSTEM_MENU_TYPE_TOP                   = 0,
	E_SYSTEM_MENU_TYPE_SAVE                  = 1,
	E_SYSTEM_MENU_TYPE_LOAD                  = 2,
	E_SYSTEM_MENU_TYPE_DELETE                = 3,
	E_SYSTEM_MENU_TYPE_OPTION                = 4,
	E_SYSTEM_MENU_TYPE_BACK_TITLE            = 5,
	E_SYSTEM_MENU_TYPE_MAX                   = 6,
};

// Enum Project.E_TALK_CAMERA_MODEL_HIDE
// NumValues: 0x0006
enum class E_TALK_CAMERA_MODEL_HIDE : uint8
{
	E_NONE                                   = 0,
	E_HIDE_FRIEND                            = 1,
	E_HIDE_ENEMY                             = 2,
	E_HIDE_BOTH                              = 3,
	E_INVALID                                = 4,
	E_MAX                                    = 5,
};

// Enum Project.E_TALK_CAMERA_DATA_TYPE
// NumValues: 0x0005
enum class E_TALK_CAMERA_DATA_TYPE : uint8
{
	E_NONE                                   = 0,
	E_FRIEND                                 = 1,
	E_ENEMY                                  = 2,
	E_FRIEND_UP                              = 3,
	E_MAX                                    = 4,
};

// Enum Project.eTalkDebugFlag
// NumValues: 0x0015
enum class ETalkDebugFlag : uint8
{
	None                                     = 0,
	GodParamAll                              = 1,
	GodParamNone                             = 2,
	GodSafety100                             = 3,
	GodLevelOK                               = 4,
	GodNkmUnconditional100                   = 5,
	GodAllButUnconditional                   = 6,
	GodNotUnconditional                      = 7,
	FriendTalk_SameNkm                       = 8,
	FriendTalk_SameNkmDead                   = 9,
	FriendTalk_Item100                       = 10,
	FriendTalk_Money100                      = 11,
	FriendTalk_Heal100                       = 12,
	StockFull                                = 13,
	Want_Next100                             = 14,
	Want_Leave100                            = 15,
	EasyMode                                 = 16,
	MagatsuhiSafetyActive                    = 17,
	Quiz100                                  = 18,
	QuizListAll                              = 19,
	ETalkDebugFlag_MAX                       = 20,
};

// Enum Project.E_TALK_SAFETY_TYPE
// NumValues: 0x0006
enum class E_TALK_SAFETY_TYPE : uint8
{
	E_NONE                                   = 0,
	E_GOD                                    = 1,
	E_MAGATSUHI                              = 2,
	E_BIBLE_DEVIL                            = 3,
	E_UNIQUE_SKILL                           = 4,
	E_MAX                                    = 5,
};

// Enum Project.E_TALK_HERO_BST_TYPE
// NumValues: 0x0004
enum class E_TALK_HERO_BST_TYPE : uint8
{
	E_NONE                                   = 0,
	E_CONFUSE                                = 1,
	E_CHARM                                  = 2,
	E_MAX                                    = 3,
};

// Enum Project.ETalkGodParam
// NumValues: 0x000E
enum class ETalkGodParam : uint8
{
	NKM_LEVEL_UP                             = 0,
	FRIEND_TALK_HEAL                         = 1,
	SAFETY                                   = 2,
	BEGLIFE                                  = 3,
	BEGLIFE_MONEY                            = 4,
	BEGLIFE_SOUL                             = 5,
	BEGLIFE_INCENSE                          = 6,
	HALF_PRESS                               = 7,
	LEVEL_OK                                 = 8,
	NKM_UNCONDITIONAL                        = 9,
	WANT_MONEY_DEC_1                         = 10,
	WANT_MONEY_DEC_2                         = 11,
	BIBLE_DEVIL                              = 12,
	ETalkGodParam_MAX                        = 13,
};

// Enum Project.EMythTalkerType
// NumValues: 0x0004
enum class EMythTalkerType : uint8
{
	System                                   = 0,
	Friend                                   = 1,
	Enemy                                    = 2,
	EMythTalkerType_MAX                      = 3,
};

// Enum Project.EMythProcessType
// NumValues: 0x0006
enum class EMythProcessType : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Item                                     = 2,
	End                                      = 3,
	EnemyTurn                                = 4,
	EMythProcessType_MAX                     = 5,
};

// Enum Project.EDevilTalkVoice
// NumValues: 0x000B
enum class EDevilTalkVoice : uint8
{
	None                                     = 0,
	Positive                                 = 51,
	Negative                                 = 52,
	Intimidation                             = 53,
	Thought                                  = 54,
	Bearish                                  = 55,
	Call                                     = 56,
	Together                                 = 57,
	Disappointment                           = 58,
	Yorosiku                                 = 61,
	EDevilTalkVoice_MAX                      = 62,
};

// Enum Project.E_TALK_WANT_KIND
// NumValues: 0x0008
enum class E_TALK_WANT_KIND : uint8
{
	WANT_NONE                                = 0,
	WANT_ITEM                                = 1,
	WANT_MONEY                               = 2,
	WANT_HP                                  = 3,
	WANT_MP                                  = 4,
	WANT_MASEKI                              = 5,
	WANT_MONEY_DEAL                          = 6,
	WANT_MAX                                 = 7,
};

// Enum Project.E_TALK_JUDGE_PARAM
// NumValues: 0x0007
enum class E_TALK_JUDGE_PARAM : uint8
{
	JUDGE_NONE                               = 0,
	JUDGE_STR                                = 201,
	JUDGE_VIT                                = 202,
	JUDGE_MGI                                = 203,
	JUDGE_AGI                                = 204,
	JUDGE_LUC                                = 205,
	JUDGE_MAX                                = 206,
};

// Enum Project.E_TALK_WANT_REAC
// NumValues: 0x0007
enum class E_TALK_WANT_REAC : uint8
{
	WANT_REAC_INVALID                        = 0,
	WANT_REAC_SUC                            = 1,
	WANT_REAC_NEXT                           = 2,
	WANT_REAC_END_USE_PRESS                  = 3,
	WANT_REAC_LEAVE                          = 4,
	WANT_REAC_ENEMY_TURN                     = 5,
	WANT_REAC_MAX                            = 6,
};

// Enum Project.E_TALK_WANT_AC
// NumValues: 0x0007
enum class E_TALK_WANT_AC : uint8
{
	WANT_AC_INVALID                          = 0,
	WANT_AC_YES                              = 1,
	WANT_AC_OTHER                            = 2,
	WANT_AC_NOT_HAVE                         = 3,
	WANT_AC_SHORTCUT                         = 4,
	WANT_AC_CARD                             = 5,
	WANT_AC_MAX                              = 6,
};

// Enum Project.E_TALK_GIFT_ITEM_TYPE
// NumValues: 0x0005
enum class E_TALK_GIFT_ITEM_TYPE : uint8
{
	ITEM_NONE                                = 0,
	ITEM_CURE                                = 1,
	ITEM_ATTACK                              = 2,
	ITEM_RARE                                = 3,
	ITEM_MAX                                 = 4,
};

// Enum Project.E_TALK_QUE_ADD_RESULT
// NumValues: 0x0006
enum class E_TALK_QUE_ADD_RESULT : uint8
{
	QUE_ADD_RESULT_NONE                      = 0,
	QUE_ADD_RESULT_ITEM_CURE                 = 1,
	QUE_ADD_RESULT_ITEM_ATTACK               = 2,
	QUE_ADD_RESULT_ITEM_RARE                 = 3,
	QUE_ADD_RESULT_MONEY                     = 4,
	QUE_ADD_RESULT_MAX                       = 5,
};

// Enum Project.E_TALK_QUE_REAC
// NumValues: 0x000A
enum class E_TALK_QUE_REAC : uint8
{
	QUE_REAC_INVALID                         = 0,
	QUE_REAC_END_FAIL                        = 1,
	QUE_REAC_END_NO_PRESS                    = 2,
	QUE_REAC_ACCEPT                          = 3,
	QUE_REAC_NEXT                            = 4,
	QUE_REAC_LEAVE                           = 5,
	QUE_REAC_ETURN                           = 6,
	QUE_REAC_SCOUT_SUC                       = 7,
	QUE_REAC_A_PART                          = 8,
	QUE_REAC_MAX                             = 9,
};

// Enum Project.E_TALK_QUESTION_PART
// NumValues: 0x0006
enum class E_TALK_QUESTION_PART : uint8
{
	QUESTION_PART_NONE                       = 0,
	QUESTION_PART_A                          = 1,
	QUESTION_PART_B                          = 2,
	QUESTION_PART_A_LOW                      = 3,
	QUESTION_PART_A_HIGH                     = 4,
	QUESTION_PART_MAX                        = 5,
};

// Enum Project.E_TALK_FRIEND_TALK
// NumValues: 0x0004
enum class E_TALK_FRIEND_TALK : uint8
{
	NONE                                     = 0,
	FRIEND                                   = 1,
	DEAD                                     = 2,
	E_TALK_FRIEND_MAX                        = 3,
};

// Enum Project.E_TALK_MOON_TEMPER_STATUS
// NumValues: 0x0006
enum class E_TALK_MOON_TEMPER_STATUS : uint8
{
	INVALID                                  = 0,
	NORMAL                                   = 1,
	GOOD                                     = 2,
	ENEMY_TURN                               = 3,
	NO_TALK                                  = 4,
	E_TALK_MOON_TEMPER_MAX                   = 5,
};

// Enum Project.E_TALK_MOON_TEMPER_DATA
// NumValues: 0x0004
enum class E_TALK_MOON_TEMPER_DATA : uint8
{
	NONE                                     = 0,
	SILENT_MOON                              = 1,
	FULL_MOON                                = 2,
	E_TALK_MOON_TEMPER_MAX                   = 3,
};

// Enum Project.E_TALK_RESULT_TARGET_STATUS
// NumValues: 0x0004
enum class E_TALK_RESULT_TARGET_STATUS : uint8
{
	TARGET_STATUS_NONE                       = 0,
	TARGET_STATUS_SCOUT                      = 1,
	TARGET_STATUS_LEAVE                      = 2,
	TARGET_STATUS_MAX                        = 3,
};

// Enum Project.E_TALK_END_TYPE
// NumValues: 0x0007
enum class E_TALK_END_TYPE : uint8
{
	E_TALK_END_NONE                          = 0,
	E_TALK_END_USE_PRESS                     = 1,
	E_TALK_END_NO_PRESS                      = 2,
	E_TALK_END_ENEMY_TURN                    = 3,
	E_TALK_END_ENEMY_LEAVE                   = 4,
	E_TALK_END_FRIEND_ESCAPE                 = 5,
	E_TALK_END_MAX                           = 6,
};

// Enum Project.E_TALK_START_TYPE
// NumValues: 0x0005
enum class E_TALK_START_TYPE : uint8
{
	E_TALK_START_SCOUT                       = 0,
	E_TALK_START_BEGLIFE                     = 1,
	E_TALK_START_MERCY                       = 2,
	E_TALK_START_INTERRUPT                   = 3,
	E_TALK_START_MAX                         = 4,
};

// Enum Project.E_TALK_NG_TYPE
// NumValues: 0x0006
enum class E_TALK_NG_TYPE : uint8
{
	E_NONE                                   = 0,
	E_COMMON                                 = 1,
	E_BAD_STATUS                             = 2,
	E_MAGATSUKA                              = 3,
	E_MAGATSUHI_DEVIL                        = 4,
	E_MAX                                    = 5,
};

// Enum Project.E_TALK_TONE_TYPE
// NumValues: 0x0071
enum class E_TALK_TONE_TYPE : uint8
{
	E_NONE                                   = 0,
	E_BOY                                    = 1,
	E_YOUNG                                  = 2,
	E_HERO                                   = 3,
	E_DUMMY_4                                = 4,
	E_GENTLE                                 = 5,
	E_IJIN                                   = 6,
	E_OLDMAN                                 = 7,
	E_GIRL                                   = 8,
	E_GAL                                    = 9,
	E_LADY                                   = 10,
	E_WITCH                                  = 11,
	E_BEAST                                  = 12,
	E_HEEHO                                  = 13,
	E_KAIJIN                                 = 14,
	E_LOUPGAROU                              = 15,
	E_KAYANO                                 = 16,
	E_DUMMY_17                               = 17,
	E_DUMMY_18                               = 18,
	E_MERMAID                                = 19,
	E_DUMMY_20                               = 20,
	E_DUMMY_21                               = 21,
	E_TUTORIAL                               = 22,
	E_RESERVE_2                              = 23,
	E_RESERVE_3                              = 24,
	E_RESERVE_4                              = 25,
	E_RESERVE_5                              = 26,
	E_RESERVE_6                              = 27,
	E_RESERVE_7                              = 28,
	E_RESERVE_8                              = 29,
	E_RESERVE_9                              = 30,
	E_RESERVE_10                             = 31,
	E_TAO                                    = 32,
	E_HAYATARO                               = 33,
	E_ABDIEL                                 = 34,
	E_ABDIEL_II                              = 35,
	E_JOKA                                   = 36,
	E_LAHMU                                  = 37,
	E_FIONN                                  = 38,
	E_SHIVA                                  = 39,
	E_BEELZEBUB                              = 40,
	E_METATRON                               = 41,
	E_ODIN                                   = 42,
	E_ZEUS                                   = 43,
	E_KHONS                                  = 44,
	E_KHONSRA                                = 45,
	E_VASUKI                                 = 46,
	E_SURT                                   = 47,
	E_ISHTAR                                 = 48,
	E_ITHUNN                                 = 49,
	E_ARIOCH                                 = 50,
	E_ARTEMIS                                = 51,
	E_MEPHISTO                               = 52,
	E_CLEO                                   = 53,
	E_DANU                                   = 54,
	E_SUKUNA                                 = 55,
	E_INANNA                                 = 56,
	E_DEMETER                                = 57,
	E_AMON                                   = 58,
	E_ANAHITA                                = 59,
	E_MARIA                                  = 60,
	E_TRUMPETER                              = 61,
	E_MOTHER                                 = 62,
	E_BLACK                                  = 63,
	E_RED                                    = 64,
	E_WHITE                                  = 65,
	E_ALICE                                  = 66,
	E_HELLS                                  = 67,
	E_DAISOUJOU                              = 68,
	E_PALE                                   = 69,
	E_MATADOR                                = 70,
	E_BISHAMON                               = 71,
	E_JIKOKU                                 = 72,
	E_KOUMOKU                                = 73,
	E_ZOCHO                                  = 74,
	E_MIKAEL                                 = 75,
	E_GABRIEL                                = 76,
	E_RAPHAEL                                = 77,
	E_URIEL                                  = 78,
	E_CUCHULAINN                             = 79,
	E_MARA                                   = 80,
	E_SANDAL                                 = 81,
	E_AMANO                                  = 82,
	E_HERO_WA                                = 83,
	E_GAL_WA                                 = 84,
	E_ANGEL                                  = 85,
	E_SCATHACH                               = 86,
	E_MADAME                                 = 87,
	E_FIEND                                  = 88,
	E_SATAN                                  = 89,
	E_LUCIFER                                = 90,
	E_DAGDA                                  = 91,
	E_KRESNIK                                = 92,
	E_ANANSI                                 = 93,
	E_NAHOBIHO                               = 94,
	E_TURBO                                  = 95,
	E_DUMMY_96                               = 96,
	E_MASAKADO                               = 97,
	E_MANSEMAT                               = 98,
	E_ONYANKOPON                             = 99,
	E_AMABIE                                 = 100,
	E_LILITH                                 = 101,
	E_AGRAT                                  = 102,
	E_NAAMAH                                 = 103,
	E_EISHETH                                = 104,
	E_TAO_HUMAN                              = 105,
	E_YUDURU                                 = 106,
	E_ICHIRO                                 = 107,
	E_YOKO_HUMAN                             = 108,
	E_YOKO                                   = 109,
	E_HITOSHURA                              = 110,
	E_KONOHANASAKUYA                         = 111,
	E_MAX                                    = 112,
};

// Enum Project.E_TALK_BALANCE_TABLE_TARGET
// NumValues: 0x005F
enum class E_TALK_BALANCE_TABLE_TARGET : uint8
{
	MOON_TEMPER_GOOD_WANT_MODIFY             = 0,
	GIFT_MONEY_RATE                          = 1,
	WANT_MASEKI_NUM_BASE                     = 2,
	WANT_MASEKI_DIV_LEVEL                    = 3,
	WANT_HP_BASE                             = 4,
	WANT_MP_BASE                             = 5,
	WANT_HPMP_RANK1                          = 6,
	WANT_HPMP_RANK2                          = 7,
	WANT_HPMP_RANK3                          = 8,
	WANT_REDUCE_PROBABILITY_UNIQUE_SKILL     = 9,
	WANT_REDUCE_ITEM_RANK                    = 10,
	MONEY_DEAL_PROBABILITY                   = 11,
	MONEY_DEAL_MULTIPLY                      = 12,
	UPLIFTING_ADD_RATE                       = 13,
	DIFFICULTY_EASY_RATE                     = 14,
	DIFFICULTY_NORMAL_RATE                   = 15,
	DIFFICULTY_HARD_RATE                     = 16,
	DIFFICULTY_VERY_HARD_RATE                = 17,
	DIFFICULTY_EASY_RATE_REV                 = 18,
	DIFFICULTY_NORMAL_RATE_REV               = 19,
	DIFFICULTY_HARD_RATE_REV                 = 20,
	DIFFICULTY_VERY_HARD_RATE_REV            = 21,
	MERCY_BASE_RATE                          = 22,
	MERCY_ENEMY_LEVEL_HIGH_RATE              = 23,
	MERCY_ENEMY_LEVEL_LOW_RATE               = 24,
	MERCY_HP_25_RATE                         = 25,
	MERCY_HP_50_RATE                         = 26,
	MERCY_HP_75_RATE                         = 27,
	MERCY_RATE_MAX                           = 28,
	MERCY_MONEY_1_MIN                        = 29,
	MERCY_MONEY_1_MAX                        = 30,
	MERCY_MONEY_2_MIN                        = 31,
	MERCY_MONEY_2_MAX                        = 32,
	MERCY_MONEY_3_MIN                        = 33,
	MERCY_MONEY_3_MAX                        = 34,
	MERCY_MONEY_HP_25                        = 35,
	MERCY_MONEY_HP_50                        = 36,
	MERCY_MONEY_HP_75                        = 37,
	MERCY_MONEY_REPEAT_1                     = 38,
	MERCY_MONEY_REPEAT_2                     = 39,
	BEGLIFE_BATTLE_INTERVAL                  = 40,
	BEGLIFE_HP_RATE                          = 41,
	BEGLIFE_BASE_RATE                        = 42,
	BEGLIFE_MAX_RATE_STOCK_3                 = 43,
	BEGLIFE_MAX_RATE                         = 44,
	BEGLIFE_0_MOON_ADD                       = 45,
	BEGLIFE_1_MOON_ADD                       = 46,
	BEGLIFE_2_MOON_ADD                       = 47,
	BEGLIFE_MONEY_RATE_1                     = 48,
	BEGLIFE_MONEY_RATE_2                     = 49,
	BEGLIFE_MONEY_RATE_3                     = 50,
	BEGLIFE_BALM_RATE                        = 51,
	BEGLIFE_INSENCE_HP_RATE                  = 52,
	BEGLIFE_INSENCE_MP_RATE                  = 53,
	BEGLIFE_INSENCE_OTHER_RATE               = 54,
	BEGLIFE_INSENCE_NUM_RATE_DIV_LEVEL       = 55,
	BEGLIFE_INSENCE_NUM_RATE_MAX             = 56,
	BEGLIFE_INSENCE_NUM_MAX                  = 57,
	FRIEND_ITEM_PROBABILITY                  = 58,
	FRIEND_MONEY_PROBABILITY                 = 59,
	FRIEND_ITEM_AND_MONEY_PROBABILITY        = 60,
	FRIEND_MONEY_MIN                         = 61,
	FRIEND_MONEY_MAX                         = 62,
	FRIEND_HEAL_PROBABILITY_BASE             = 63,
	FRIEND_HEAL_HP_DIVIDE                    = 64,
	FRIEND_HEAL_MP_DIVIDE                    = 65,
	SAFETY_PROBABILITY_GOD                   = 66,
	SAFETY_PROBABILITY_MAGATSUHI             = 67,
	SAFETY_MAX_COUNT_GOD                     = 68,
	SAFETY_MAX_COUNT_MAGATSUHI               = 69,
	SAFETY_MAX_COUNT_BIBLE_DEVIL             = 70,
	SAFETY_PROBABILITY_UNIQUE_SKILL          = 71,
	NKM_UNCONDITIONAL_BASE                   = 72,
	NKM_UNCONDITIONAL_LEVEL                  = 73,
	NKM_UNCONDITIONAL_MIN                    = 74,
	NKM_UNCONDITIONAL_MAX                    = 75,
	HERO_BST_CONFUSE_PROBABILITY             = 76,
	HERO_BST_CHARM_PROBABILITY               = 77,
	EASY_MODE_TOPIC_FAIL_RATE                = 78,
	EASY_MODE_WANT_SUCCESS_ADD               = 79,
	EASY_MODE_WANT_FAIL_SUBTRACT             = 80,
	NORMAL_MODE_TOPIC_FAIL_RATE              = 81,
	NORMAL_MODE_WANT_SUCCESS_ADD             = 82,
	NORMAL_MODE_WANT_FAIL_SUBTRACT           = 83,
	APOLOGY_SUCCESS_PROBABILITY              = 84,
	GOD_PARAM_WANT_MONEY_RATE_1              = 85,
	GOD_PARAM_WANT_MONEY_RATE_2              = 86,
	BIBLE_DEVIL_WANT_MONEY_RATE              = 87,
	QUIZ_PROBABILITY_SUBTRACT                = 88,
	QUIZ_PROBABILITY_MULTIPLY                = 89,
	QUIZ_PROBABILITY_MAX                     = 90,
	QUIZ_PROBABILITY_MIN                     = 91,
	QUIZ_REROLL_RATE                         = 92,
	UNIQUE_SKILL_MODIFY_SKILL_RATE           = 93,
	E_TALK_BALANCE_TABLE_MAX                 = 94,
};

// Enum Project.EConvertScaleType
// NumValues: 0x0003
enum class EConvertScaleType : uint8
{
	AttachParent                             = 0,
	OwnerActor                               = 1,
	EConvertScaleType_MAX                    = 2,
};

// Enum Project.EConvertRotationType
// NumValues: 0x0004
enum class EConvertRotationType : uint8
{
	AttachParent                             = 0,
	OwnerActor                               = 1,
	FixedUpBillboard                         = 2,
	EConvertRotationType_MAX                 = 3,
};

// Enum Project.EConvertLocationType
// NumValues: 0x0003
enum class EConvertLocationType : uint8
{
	AttachParent                             = 0,
	OwnerActor                               = 1,
	EConvertLocationType_MAX                 = 2,
};

// Enum Project.E_TUTORIAL_WINDOW_SCROLL_INPUT_TYPE
// NumValues: 0x0005
enum class E_TUTORIAL_WINDOW_SCROLL_INPUT_TYPE : uint8
{
	UP                                       = 0,
	DOWN                                     = 1,
	TOP                                      = 2,
	BOTTOM                                   = 3,
	MAX                                      = 4,
};

// Enum Project.E_TUTORIAL_WINDOW_MESSAGE_TYPE
// NumValues: 0x00D5
enum class E_TUTORIAL_WINDOW_MESSAGE_TYPE : uint8
{
	DASH                                     = 0,
	LIGHTSPOT                                = 1,
	JUMP_01                                  = 2,
	JUMP_02                                  = 3,
	SLASH                                    = 4,
	NAHOBINO                                 = 5,
	MAGATSUKA                                = 6,
	SUBQUEST                                 = 7,
	MISSION                                  = 8,
	TAKARA                                   = 9,
	FUSION_GUIDE_01_01                       = 10,
	FUSION_GUIDE_01_02                       = 11,
	FUSION_GUIDE_01_03                       = 12,
	FUSION_GUIDE_01_04                       = 13,
	FUSION_GUIDE_01_05                       = 14,
	FUSION_GUIDE_02_01                       = 15,
	FUSION_GUIDE_02_02                       = 16,
	FUSION_GUIDE_02_03                       = 17,
	FUSION_GUIDE_02_04                       = 18,
	FUSION_GUIDE_02_05                       = 19,
	FUSION_GUIDE_03_01                       = 20,
	FUSION_GUIDE_03_02                       = 21,
	FUSION_GUIDE_03_03                       = 22,
	FUSION_GUIDE_03_04                       = 23,
	FUSION_GUIDE_03_05                       = 24,
	FUSION_GUIDE_04_01                       = 25,
	FUSION_GUIDE_04_02                       = 26,
	FUSION_GUIDE_04_03                       = 27,
	FUSION_GUIDE_04_04                       = 28,
	FUSION_GUIDE_04_05                       = 29,
	FUSION_GUIDE_05_01                       = 30,
	FUSION_GUIDE_05_02                       = 31,
	FUSION_GUIDE_05_03                       = 32,
	FUSION_GUIDE_05_04                       = 33,
	FUSION_GUIDE_05_05                       = 34,
	TRANSPORT_TITLE                          = 35,
	MINIMAP                                  = 36,
	AUTOMAP                                  = 37,
	CAMP                                     = 38,
	TRANSPORT                                = 39,
	DLC_UNLOCK_DFCL                          = 40,
	DLC_UNLOCK_ESS                           = 41,
	DLC_UNLOCK_MONEY                         = 42,
	DLC_UNLOCK_EXP                           = 43,
	DLC_UNLOCK_GLORY                         = 44,
	DLC_UNLOCK_ARTE                          = 45,
	DLC_UNLOCK_CLEO                          = 46,
	DLC_UNLOCK_MEPH                          = 47,
	DLC_UNLOCK_FIEND                         = 48,
	DLC_UNLOCK_VOICE                         = 49,
	JAKYO_01                                 = 50,
	CLEAR_SAVEDATA                           = 51,
	QUESTNAVI                                = 52,
	MIITSU                                   = 53,
	QUESTNAVI_REACTION                       = 54,
	MIITSU_INDUCTION                         = 55,
	MIITSU_SEARCH                            = 56,
	OPTION_VERYHARD                          = 57,
	JEWELRYTRADE                             = 58,
	DESTINATION                              = 59,
	BATTLESKILL                              = 60,
	MAPOPEN                                  = 61,
	JAKYO_02                                 = 62,
	REGRESSIONPILLAR                         = 63,
	JOINLABO                                 = 64,
	PRESSTURN                                = 65,
	ELEMENTWEAK                              = 66,
	MAGATSUHISKILL                           = 67,
	DIVINEINTENTION                          = 68,
	PRESSTURN2                               = 69,
	DLC_INVALID                              = 70,
	BADSTATUS                                = 71,
	AMULET_00                                = 72,
	AMULET_01                                = 73,
	AMULET_02                                = 74,
	AMULET_03                                = 75,
	AMULET_04                                = 76,
	AMULET_05                                = 77,
	AMULET_06                                = 78,
	AMULET_07                                = 79,
	AMULET_08                                = 80,
	AMULET_09                                = 81,
	AMULET_10                                = 82,
	AMULET_11                                = 83,
	AMULET_12                                = 84,
	AMULET_13                                = 85,
	AMULET_14                                = 86,
	AMULET_15                                = 87,
	AMULET_16                                = 88,
	AMULET_17                                = 89,
	AMULET_18                                = 90,
	AMULET_19                                = 91,
	AMULET_20                                = 92,
	AMULET_21                                = 93,
	AMULET_22                                = 94,
	AMULET_23                                = 95,
	AMULET_24                                = 96,
	AMULET_25                                = 97,
	AMULET_26                                = 98,
	AMULET_27                                = 99,
	AMULET_28                                = 100,
	AMULET_29                                = 101,
	AMULET_30                                = 102,
	AMULET_31                                = 103,
	AMULET_32                                = 104,
	MIMAN                                    = 105,
	MIMAN_REWARD                             = 106,
	RELIC                                    = 107,
	STRONGENEMY                              = 108,
	PARTY                                    = 109,
	WARNING                                  = 110,
	OLDDUMMY                                 = 111,
	OPTION_KEYSELECT_MAIN_TITLE              = 112,
	OPTION_KEYSELECT_SUB_TITLE               = 113,
	OPTION_KEYSELECT_MOUSE_TITLE             = 114,
	SAVELOAD_INCOMPATIBLE_LOAD_TITLE         = 115,
	PERIOD_QUEST_TITLE                       = 116,
	REMOTE_DEVIL_CONTROL_TITLE               = 117,
	TITLE_ERROR_TITLE                        = 118,
	TIME_ATTACK_01_TITLE                     = 119,
	TIME_ATTACK_02_TITLE                     = 120,
	TIME_ATTACK_03_TITLE                     = 121,
	TIME_ATTACK_04_TITLE                     = 122,
	TIME_ATTACK_05_TITLE                     = 123,
	VIRTUAL_TRAINER_TITLE                    = 124,
	JEWELRYTRADE_SJK_TITLE                   = 125,
	OPTION_SKILL_VOICE_ATTENTION_TITLE       = 126,
	GARDEN_TITLE                             = 127,
	GARDENTALK_TITLE                         = 128,
	GARDENTRIBUTE_TITLE                      = 129,
	GARDENAOGM_TITLE                         = 130,
	DLC_UNLOCK_KNHN_TITLE                    = 131,
	DLC_UNLOCK_DAGDA_TITLE                   = 132,
	DLC_UNLOCK_ENGVOICE_TITLE                = 133,
	W5PARAM_TITLE                            = 134,
	ATTRIBUTE_TITLE                          = 135,
	RESISTANCE_TITLE                         = 136,
	AILMENT_TITLE                            = 137,
	COND_BLOCK_TITLE                         = 138,
	COND_BUFF_TITLE                          = 139,
	COND_CHARGE_TITLE                        = 140,
	COND_MISC_TITLE                          = 141,
	ESSENCE_TITLE                            = 142,
	DFCLTY_TITLE                             = 143,
	DFCLTY_NOSAFE_TITLE                      = 144,
	MOONPHASE_TITLE                          = 145,
	POTENTIAL_TITLE                          = 146,
	UNIQUESKILL_TITLE                        = 147,
	BOSSRUSH                                 = 148,
	MAGATSURO                                = 149,
	GUEST                                    = 150,
	GUEST2                                   = 151,
	MAGATSUHIDEVIL                           = 152,
	MOONQUEST                                = 153,
	SKYVIEW                                  = 154,
	AMULET_41                                = 155,
	AMULET_42                                = 156,
	AMULET_43                                = 157,
	AMULET_44                                = 158,
	AMULET_45                                = 159,
	AMULET_46                                = 160,
	AMULET_47                                = 161,
	AMULET_48                                = 162,
	AMULET_49                                = 163,
	AMULET_50                                = 164,
	AMULET_51                                = 165,
	AMULET_52                                = 166,
	AMULET_53                                = 167,
	AMULET_54                                = 168,
	AMULET_55                                = 169,
	AMULET_56                                = 170,
	AMULET_57                                = 171,
	AMULET_58                                = 172,
	AMULET_59                                = 173,
	AMULET_60                                = 174,
	AMULET_61                                = 175,
	AMULET_62                                = 176,
	AMULET_63                                = 177,
	AMULET_64                                = 178,
	AMULET_65                                = 179,
	AMULET_66                                = 180,
	AMULET_67                                = 181,
	AMULET_33                                = 182,
	AMULET_34                                = 183,
	AMULET_35                                = 184,
	AMULET_36                                = 185,
	AMULET_37                                = 186,
	AMULET_38                                = 187,
	AMULET_39                                = 188,
	AMULET_40                                = 189,
	MYTH_STANCE_TITLE                        = 190,
	MACCA                                    = 191,
	GARDEN_NEWROUTE                          = 192,
	ESTOMA                                   = 193,
	TAO_UNLOCK                               = 194,
	YOKO_UNLOCK                              = 195,
	SAVE                                     = 196,
	LEYLINE                                  = 197,
	BATTLE_SERIAL                            = 198,
	AOGAMI_BODY                              = 199,
	AMULET_OVERVIEW_1                        = 200,
	AMULET_OVERVIEW_2                        = 201,
	QUESTNAVI_CHOICE                         = 202,
	PRIVATEROOM                              = 203,
	BADSTATUS_LAHMU                          = 204,
	BADSTATUS_KHONS                          = 205,
	ESSENCE_FUSION_01                        = 206,
	ESSENCE_FUSION_02                        = 207,
	DLC_UNLOCK_PREORDER                      = 208,
	STORYSELECT                              = 209,
	SAVELOAD_INCOMP_LOAD_TITLE               = 210,
	GUEST_DEMIFIEND_TITLE                    = 211,
	MAX                                      = 212,
};

// Enum Project.E_BTL_COMM_ANIM_TYPE
// NumValues: 0x0003
enum class E_BTL_COMM_ANIM_TYPE : uint8
{
	E_BTL_COMM_ANIM_TYPE_NONE                = 0,
	E_BTL_COMM_ANIM_TYPE_UNIT_FORM_BLINKING  = 1,
	E_BTL_COMM_ANIM_TYPE_MAX                 = 2,
};

// Enum Project.E_BTL_COMM_ANIM_TABLE
// NumValues: 0x0003
enum class E_BTL_COMM_ANIM_TABLE : uint8
{
	E_BTL_COMM_ANIM_TABLE_BLINKING_00        = 0,
	E_BTL_COMM_ANIM_TABLE_BLINKING_01        = 1,
	E_BTL_COMM_ANIM_TABLE_BLINKING_MAX       = 2,
};

// Enum Project.E_BTL_SUB_COMMAND_TYPE
// NumValues: 0x0008
enum class E_BTL_SUB_COMMAND_TYPE : uint8
{
	E_BTL_SUB_COMMAND_TYPE_CHANGE_CHARA      = 0,
	E_BTL_SUB_COMMAND_TYPE_AUTO              = 1,
	E_BTL_SUB_COMMAND_TYPE_CONDITION         = 2,
	E_BTL_SUB_COMMAND_TYPE_ANALYZE           = 3,
	E_BTL_SUB_COMMAND_TYPE_BTL_PLAN          = 4,
	E_BTL_SUB_COMMAND_TYPE_EXCHANGE          = 5,
	E_BTL_SUB_COMMAND_TYPE_ESCAPE            = 6,
	E_BTL_SUB_COMMAND_TYPE_MAX               = 7,
};

// Enum Project.E_BTL_MAIN_COMMAND_TYPE
// NumValues: 0x0007
enum class E_BTL_MAIN_COMMAND_TYPE : uint8
{
	E_BTL_MAIN_COMMAND_TYPE_SKILL            = 0,
	E_BTL_MAIN_COMMAND_TYPE_ITEM             = 1,
	E_BTL_MAIN_COMMAND_TYPE_TALK             = 2,
	E_BTL_MAIN_COMMAND_TYPE_SUMMON           = 3,
	E_BTL_MAIN_COMMAND_TYPE_ACT_END          = 4,
	E_BTL_MAIN_COMMAND_TYPE_UNIT_FORM        = 5,
	E_BTL_MAIN_COMMAND_TYPE_MAX              = 6,
};

// Enum Project.E_BTL_UI_COMMAND
// NumValues: 0x0011
enum class E_BTL_UI_COMMAND : uint8
{
	E_BTL_UI_COMM_NONE                       = 0,
	E_BTL_UI_COMM_SKILL                      = 1,
	E_BTL_UI_COMM_ITEM                       = 2,
	E_BTL_UI_COMM_SUMMON                     = 3,
	E_BTL_UI_COMM_TALK                       = 4,
	E_BTL_UI_COMM_ESCAPE                     = 5,
	E_BTL_UI_COMM_ACT_END                    = 6,
	E_BTL_UI_COMM_UNIT_FORM                  = 7,
	E_BTL_UI_COMM_PRV_CHAR                   = 8,
	E_BTL_UI_COMM_NEXT_CHAR                  = 9,
	E_BTL_UI_COMM_AUTO                       = 10,
	E_BTL_UI_COMM_CONDITION                  = 11,
	E_BTL_UI_COMM_ANALYZE                    = 12,
	E_BTL_UI_COMM_BTL_PLAN                   = 13,
	E_BTL_UI_COMM_EXCHANGE                   = 14,
	E_BTL_UI_COMM_TARGET_SELECT              = 15,
	E_BTL_UI_COMM_MAX                        = 16,
};

// Enum Project.E_BTL_UI_COMM_STEP
// NumValues: 0x0010
enum class E_BTL_UI_COMM_STEP : uint8
{
	E_BTL_UI_COMM_STEP_NONE                  = 0,
	E_BTL_UI_COMM_STEP_COMM_MENE             = 1,
	E_BTL_UI_COMM_STEP_SKILL_MENU            = 2,
	E_BTL_UI_COMM_STEP_ITEM_MENU             = 3,
	E_BTL_UI_COMM_STEP_TALK                  = 4,
	E_BTL_UI_COMM_STEP_ESCAPE_MENU           = 5,
	E_BTL_UI_COMM_STEP_ACT_END_MENU          = 6,
	E_BTL_UI_COMM_STEP_CONDITION             = 7,
	E_BTL_UI_COMM_STEP_ANALAYZE              = 8,
	E_BTL_UI_COMM_STEP_PLAN                  = 9,
	E_BTL_UI_COMM_STEP_TARGET_SELECT         = 10,
	E_BTL_UI_COMM_STEP_ASYNC_WAIT            = 11,
	E_BTL_UI_COMM_STEP_IDLING                = 12,
	E_BTL_UI_COMM_STEP_AUTO_BATTLE           = 13,
	E_BTL_UI_COMM_STEP_OPTION                = 14,
	E_BTL_UI_COMM_STEP_MAX                   = 15,
};

// Enum Project.E_UI_STATUS_ESSENCE_ICON
// NumValues: 0x0006
enum class E_UI_STATUS_ESSENCE_ICON : uint8
{
	E_UI_STATUS_ESSENCE_ICON_INVISIBLE       = 0,
	E_UI_STATUS_ESSENCE_ICON_NOT_YET         = 1,
	E_UI_STATUS_ESSENCE_ICON_OWNE            = 2,
	E_UI_STATUS_ESSENCE_ICON_USED            = 3,
	E_UI_STATUS_ESSENCE_ICON_NONE            = 4,
	E_UI_STATUS_ESSENCE_ICON_MAX             = 5,
};

// Enum Project.E_UI_STATUS_RESISTANCES_BAD_ICON
// NumValues: 0x0008
enum class E_UI_STATUS_RESISTANCES_BAD_ICON : uint8
{
	E_UI_STATUS_RESISTANCES_BAD_ICON_SLEEP   = 0,
	E_UI_STATUS_RESISTANCES_BAD_ICON_DAZZLE  = 1,
	E_UI_STATUS_RESISTANCES_BAD_ICON_POISON  = 2,
	E_UI_STATUS_RESISTANCES_BAD_ICON_CONFUSE = 3,
	E_UI_STATUS_RESISTANCES_BAD_ICON_CHARM   = 4,
	E_UI_STATUS_RESISTANCES_BAD_ICON_CLOSE   = 5,
	E_UI_STATUS_RESISTANCES_BAD_ICON_MAX_END = 6,
	E_UI_STATUS_RESISTANCES_BAD_ICON_MAX     = 7,
};

// Enum Project.E_UI_STATUS_FUSION_ORDER
// NumValues: 0x0007
enum class E_UI_STATUS_FUSION_ORDER : uint8
{
	E_UI_STATUS_FUSION_ORDER_FIRST           = 0,
	E_UI_STATUS_FUSION_ORDER_SECOND          = 1,
	E_UI_STATUS_FUSION_ORDER_THIRD           = 2,
	E_UI_STATUS_FUSION_ORDER_FOURTH          = 3,
	E_UI_STATUS_FUSION_ORDER_RESULT          = 4,
	E_UI_STATUS_FUSION_ORDER_INVISIBLE       = 5,
	E_UI_STATUS_FUSION_ORDER_MAX             = 6,
};

// Enum Project.E_UI_STATUS_SLOT
// NumValues: 0x0013
enum class E_UI_STATUS_SLOT : uint8
{
	E_UI_STATUS_SLOT_TITLE_BTL_CONDITION     = 0,
	E_UI_STATUS_SLOT_TITLE_DROP_ITEMS        = 1,
	E_UI_STATUS_SLOT_TITLE_NEW_SKILLS        = 2,
	E_UI_STATUS_SLOT_TITLE_INHERITING        = 3,
	E_UI_STATUS_SLOT_TITLE_KAMI_SKILLS       = 4,
	E_UI_STATUS_SLOT_TITLE_KAMI_SYSTEM       = 5,
	E_UI_STATUS_SLOT_TITLE_NEXT_SKILLS       = 6,
	E_UI_STATUS_SLOT_TITLE_PARENT_SKILLS     = 7,
	E_UI_STATUS_SLOT_TITLE_UNIQUE_SKILLS     = 8,
	E_UI_STATUS_SLOT_TITLE_SKILLS            = 9,
	E_UI_STATUS_SLOT_EXIT_BUTTON             = 10,
	E_UI_STATUS_SLOT_BLANK                   = 11,
	E_UI_STATUS_SLOT_CURSOR                  = 12,
	E_UI_STATUS_SLOT_NEW                     = 13,
	E_UI_STATUS_SLOT_NORMAL                  = 14,
	E_UI_STATUS_SLOT_NOT                     = 15,
	E_UI_STATUS_SLOT_SELECT                  = 16,
	E_UI_STATUS_SLOT_INVISIBLE               = 17,
	E_UI_STATUS_SLOT_MAX                     = 18,
};

// Enum Project.E_UI_STATUS_LIST_ITEM_TYPE
// NumValues: 0x0006
enum class E_UI_STATUS_LIST_ITEM_TYPE : uint8
{
	E_UI_STATUS_LIST_ITEM_TYPE_SKILL         = 0,
	E_UI_STATUS_LIST_ITEM_TYPE_ITEM          = 1,
	E_UI_STATUS_LIST_ITEM_TYPE_CONDITION     = 2,
	E_UI_STATUS_LIST_ITEM_TYPE_GOD           = 3,
	E_UI_STATUS_LIST_ITEM_TYPE_END_BUTTON    = 4,
	E_UI_STATUS_LIST_ITEM_TYPE_MAX           = 5,
};

// Enum Project.E_UI_STATUS_SIMPLE_SOURCE
// NumValues: 0x0007
enum class E_UI_STATUS_SIMPLE_SOURCE : uint8
{
	E_UI_STATUS_SIMPLE_SOURCE_HERO           = 0,
	E_UI_STATUS_SIMPLE_SOURCE_NKM            = 1,
	E_UI_STATUS_SIMPLE_SOURCE_BASE           = 2,
	E_UI_STATUS_SIMPLE_SOURCE_ENEMY          = 3,
	E_UI_STATUS_SIMPLE_SOURCE_BIBLE          = 4,
	E_UI_STATUS_SIMPLE_SOURCE_EMPTY          = 5,
	E_UI_STATUS_SIMPLE_SOURCE_MAX            = 6,
};

// Enum Project.E_UI_STATUS_UNITE_SOURCE
// NumValues: 0x0008
enum class E_UI_STATUS_UNITE_SOURCE : uint8
{
	E_UI_STATUS_UNITE_SOURCE_HERO            = 0,
	E_UI_STATUS_UNITE_SOURCE_NKM             = 1,
	E_UI_STATUS_UNITE_SOURCE_BASE            = 2,
	E_UI_STATUS_UNITE_SOURCE_ENEMY           = 3,
	E_UI_STATUS_UNITE_SOURCE_BIBLE           = 4,
	E_UI_STATUS_UNITE_SOURCE_RESULT          = 5,
	E_UI_STATUS_UNITE_SOURCE_UNKNOWN         = 6,
	E_UI_STATUS_UNITE_SOURCE_MAX             = 7,
};

// Enum Project.E_UI_STATUS_PAGE_TYPE
// NumValues: 0x0006
enum class E_UI_STATUS_PAGE_TYPE : uint8
{
	E_UI_STATUS_PAGE_TYPE_SKILL              = 0,
	E_UI_STATUS_PAGE_TYPE_CONDITION          = 1,
	E_UI_STATUS_PAGE_TYPE_BIOGRAPHY          = 2,
	E_UI_STATUS_PAGE_TYPE_SKILLSWAP          = 3,
	E_UI_STATUS_PAGE_TYPE_INVISIBLE          = 4,
	E_UI_STATUS_PAGE_TYPE_MAX                = 5,
};

// Enum Project.E_UI_STATUS_CTRL_TYPE
// NumValues: 0x001D
enum class E_UI_STATUS_CTRL_TYPE : uint8
{
	E_UI_STATUS_CTRL_TYPE_BTL_ENEMY          = 0,
	E_UI_STATUS_CTRL_TYPE_BTL_PARTY          = 1,
	E_UI_STATUS_CTRL_TYPE_BTL_STOCK          = 2,
	E_UI_STATUS_CTRL_TYPE_CAMP_PARTY         = 3,
	E_UI_STATUS_CTRL_TYPE_CAMP_STOCK         = 4,
	E_UI_STATUS_CTRL_TYPE_CAMP_SKILL         = 5,
	E_UI_STATUS_CTRL_TYPE_CAMP_ANALYZE       = 6,
	E_UI_STATUS_CTRL_TYPE_HEAL_PARTY         = 7,
	E_UI_STATUS_CTRL_TYPE_HEAL_STOCK         = 8,
	E_UI_STATUS_CTRL_TYPE_UNITE_FIRST        = 9,
	E_UI_STATUS_CTRL_TYPE_UNITE_SECOND       = 10,
	E_UI_STATUS_CTRL_TYPE_UNITE_SEARCH_FIRST = 11,
	E_UI_STATUS_CTRL_TYPE_UNITE_SEARCH_SECOND = 12,
	E_UI_STATUS_CTRL_TYPE_UNITE_SEARCH_BIBLE_FIRST = 13,
	E_UI_STATUS_CTRL_TYPE_UNITE_SEARCH_BIBLE_SECOND = 14,
	E_UI_STATUS_CTRL_TYPE_UNITE_SPECIAL_FIRST = 15,
	E_UI_STATUS_CTRL_TYPE_UNITE_SPECIAL_SECOND = 16,
	E_UI_STATUS_CTRL_TYPE_BIBLE_LOOK         = 17,
	E_UI_STATUS_CTRL_TYPE_BIBLE_LOOK_ALL     = 18,
	E_UI_STATUS_CTRL_TYPE_BIBLE_LOOK_ORIGINAL = 19,
	E_UI_STATUS_CTRL_TYPE_BIBLE_NEW          = 20,
	E_UI_STATUS_CTRL_TYPE_BIBLE_OLD          = 21,
	E_UI_STATUS_CTRL_TYPE_UNITE_USTUSEMI_FIRST = 22,
	E_UI_STATUS_CTRL_TYPE_UNITE_USTUSEMI_SECOND = 23,
	E_UI_STATUS_CTRL_TYPE_UNITE_PARTY        = 24,
	E_UI_STATUS_CTRL_TYPE_UNITE_INHERIT_RESULT = 25,
	E_UI_STATUS_CTRL_TYPE_UNITE_SKILL_INHERIT = 26,
	E_UI_STATUS_CTRL_TYPE_UNITE_RESISTANCES_INHERIT_RESULT = 27,
	E_UI_STATUS_CTRL_TYPE_MAX                = 28,
};

// Enum Project.E_UI_STATUS_BOOK
// NumValues: 0x000B
enum class E_UI_STATUS_BOOK : uint8
{
	E_UI_STATUS_BOOK_INVISIBLE               = 0,
	E_UI_STATUS_BOOK_NON                     = 1,
	E_UI_STATUS_BOOK_MEMBER                  = 2,
	E_UI_STATUS_BOOK_BOOK                    = 3,
	E_UI_STATUS_BOOK_OLD                     = 4,
	E_UI_STATUS_BOOK_NEW                     = 5,
	E_UI_STATUS_BOOK_UNENROLLED              = 6,
	E_UI_STATUS_BOOK_GUEST                   = 7,
	E_UI_STATUS_BOOK_CUSTOM                  = 8,
	E_UI_STATUS_BOOK_ORIGINAL                = 9,
	E_UI_STATUS_BOOK_MAX                     = 10,
};

// Enum Project.E_UI_STATUS_TITLE
// NumValues: 0x0004
enum class E_UI_STATUS_TITLE : uint8
{
	E_UI_STATUS_TITLE_INVISIBLE              = 0,
	E_UI_STATUS_TITLE_STATUS                 = 1,
	E_UI_STATUS_TITLE_RESULT                 = 2,
	E_UI_STATUS_TITLE_MAX                    = 3,
};

// Enum Project.E_UI_STATUS_OPEN
// NumValues: 0x0014
enum class E_UI_STATUS_OPEN : uint8
{
	E_UI_STATUS_OPEN_RACE                    = 0,
	E_UI_STATUS_OPEN_NAME                    = 1,
	E_UI_STATUS_OPEN_LEVEL                   = 2,
	E_UI_STATUS_OPEN_EXP                     = 3,
	E_UI_STATUS_OPEN_HP                      = 4,
	E_UI_STATUS_OPEN_MP                      = 5,
	E_UI_STATUS_OPEN_PARAM                   = 6,
	E_UI_STATUS_OPEN_DEFENCE_AISHOU          = 7,
	E_UI_STATUS_OPEN_FACE_ICON               = 8,
	E_UI_STATUS_OPEN_CHARA_MODEL             = 9,
	E_UI_STATUS_OPEN_SKILL_TEKISEI           = 10,
	E_UI_STATUS_OPEN_SKILL                   = 11,
	E_UI_STATUS_OPEN_PLACE                   = 12,
	E_UI_STATUS_OPEN_DROP_ITEM               = 13,
	E_UI_STATUS_OPEN_TEXT                    = 14,
	E_UI_STATUS_OPEN_DEFENCE_AISHOU_BAD      = 15,
	E_UI_STATUS_OPEN_MP_LIMITED              = 16,
	E_UI_STATUS_OPEN_ESSENCE_ICON            = 30,
	E_UI_STATUS_IS_UTSUSEMI                  = 31,
	E_UI_STATUS_MAX                          = 32,
};

// Enum Project.E_UI_ELEMENT_ICON
// NumValues: 0x0047
enum class E_UI_ELEMENT_ICON : uint8
{
	E_UI_ELEMENT_ICON_PHISICS                = 0,
	E_UI_ELEMENT_ICON_FIRE                   = 1,
	E_UI_ELEMENT_ICON_ICE                    = 2,
	E_UI_ELEMENT_ICON_THUNDER                = 3,
	E_UI_ELEMENT_ICON_WIND                   = 4,
	E_UI_ELEMENT_ICON_LIGHT                  = 5,
	E_UI_ELEMENT_ICON_DARK                   = 6,
	E_UI_ELEMENT_ICON_ALL                    = 7,
	E_UI_ELEMENT_ICON_NODAMAGE_ATK           = 8,
	E_UI_ELEMENT_ICON_AID                    = 9,
	E_UI_ELEMENT_ICON_RECOVERY               = 10,
	E_UI_ELEMENT_ICON_SPECIAL                = 11,
	E_UI_ELEMENT_ICON_AUTO                   = 12,
	E_UI_ELEMENT_ICON_COMPOSITE              = 13,
	E_UI_ELEMENT_ICON_POWER_UP               = 14,
	E_UI_ELEMENT_ICON_KEY_ITEM               = 15,
	E_UI_ELEMENT_ICON_GOD_SKILL              = 16,
	E_UI_ELEMENT_ICON_GUARD                  = 17,
	E_UI_ELEMENT_ICON_TALK                   = 18,
	E_UI_ELEMENT_ICON_SUMMON                 = 19,
	E_UI_ELEMENT_ICON_RETURN                 = 20,
	E_UI_ELEMENT_ICON_ESCAPE                 = 21,
	E_UI_ELEMENT_ICON_BURN                   = 24,
	E_UI_ELEMENT_ICON_FREEZE                 = 25,
	E_UI_ELEMENT_ICON_SHOCK                  = 26,
	E_UI_ELEMENT_ICON_DAZZLE                 = 27,
	E_UI_ELEMENT_ICON_SLEEP                  = 28,
	E_UI_ELEMENT_ICON_CONFUSE                = 29,
	E_UI_ELEMENT_ICON_CHARM                  = 30,
	E_UI_ELEMENT_ICON_CLOSE                  = 31,
	E_UI_ELEMENT_ICON_POISON                 = 32,
	E_UI_ELEMENT_ICON_MUD                    = 33,
	E_UI_ELEMENT_ICON_DARKNESS               = 34,
	E_UI_ELEMENT_ICON_DEAD                   = 35,
	E_UI_ELEMENT_ICON_LACERATION             = 24,
	E_UI_ELEMENT_ICON_VERTIGO                = 24,
	E_UI_ELEMENT_ICON_STRAY                  = 24,
	E_UI_ELEMENT_ICON_STONE                  = 24,
	E_UI_ELEMENT_ICON_TETORAJYA              = 24,
	E_UI_ELEMENT_ICON_PHISICS_BLO            = 41,
	E_UI_ELEMENT_ICON_FIRE_BLO               = 42,
	E_UI_ELEMENT_ICON_ICE_BLO                = 43,
	E_UI_ELEMENT_ICON_THUNDER_BLO            = 44,
	E_UI_ELEMENT_ICON_WIND_BLO               = 45,
	E_UI_ELEMENT_ICON_LIGHT_BLO              = 46,
	E_UI_ELEMENT_ICON_DARK_BLO               = 47,
	E_UI_ELEMENT_ICON_ATTACK_UP1             = 48,
	E_UI_ELEMENT_ICON_ATTACK_UP2             = 49,
	E_UI_ELEMENT_ICON_DEFENCE_UP1            = 50,
	E_UI_ELEMENT_ICON_DEFENCE_UP2            = 51,
	E_UI_ELEMENT_ICON_HIT_ESC_UP1            = 52,
	E_UI_ELEMENT_ICON_HIT_ESC_UP2            = 53,
	E_UI_ELEMENT_ICON_ATTACK_DOWN1           = 54,
	E_UI_ELEMENT_ICON_ATTACK_DOWN2           = 55,
	E_UI_ELEMENT_ICON_DEFENCE_DOWN1          = 56,
	E_UI_ELEMENT_ICON_DEFENCE_DOWN2          = 57,
	E_UI_ELEMENT_ICON_HIT_ESC_DOWN1          = 58,
	E_UI_ELEMENT_ICON_HIT_ESC_DOWN2          = 59,
	E_UI_ELEMENT_ICON_ATTACK_REF             = 60,
	E_UI_ELEMENT_ICON_MAGIC_REF              = 61,
	E_UI_ELEMENT_ICON_SHIELD                 = 62,
	E_UI_ELEMENT_ICON_ATTACK_CHARGE          = 63,
	E_UI_ELEMENT_ICON_MAGIC_CHARGE           = 64,
	E_UI_ELEMENT_ICON_CRITICAL_ABS_CHARGE    = 65,
	E_UI_ELEMENT_ICON_RECOVERLY_CHARGE       = 66,
	E_UI_ELEMENT_ICON_PENETRATE_CHARGE       = 67,
	E_UI_ELEMENT_ICON_PROVOKE                = 68,
	E_UI_ELEMENT_ICON_MAGATOKI               = 69,
	E_UI_ELEMENT_ICON_RENZOKU_SKILL          = 70,
	E_UI_ELEMENT_ICON_FORCE_AVOID            = 71,
	E_UI_ELEMENT_ICON_MAX                    = 72,
};

// Enum Project.E_UI_POS_TYPE
// NumValues: 0x0006
enum class E_UI_POS_TYPE : uint8
{
	E_UI_POS_TYPE_LEFT                       = 0,
	E_UI_POS_TYPE_CENTER                     = 1,
	E_UI_POS_TYPE_RIGHT                      = 2,
	E_UI_POS_TYPE_UP                         = 3,
	E_UI_POS_TYPE_DOWN                       = 4,
	E_UI_POS_TYPE_MAX                        = 5,
};

// Enum Project.E_ICON_SPR_ID
// NumValues: 0x0021
enum class E_ICON_SPR_ID : uint8
{
	E_ICON_SPR_ID_PHYSICS                    = 0,
	E_ICON_SPR_ID_FIRE                       = 1,
	E_ICON_SPR_ID_ICE                        = 2,
	E_ICON_SPR_ID_THUNDER                    = 3,
	E_ICON_SPR_ID_WIND                       = 4,
	E_ICON_SPR_ID_LIGHT                      = 5,
	E_ICON_SPR_ID_DARK                       = 6,
	E_ICON_SPR_ID_EVERY                      = 7,
	E_ICON_SPR_ID_BST                        = 8,
	E_ICON_SPR_ID_CURE                       = 9,
	E_ICON_SPR_ID_AID                        = 10,
	E_ICON_SPR_ID_SP                         = 11,
	E_ICON_SPR_ID_AUTO                       = 12,
	E_ICON_SPR_ID_SHIELD                     = 13,
	E_ICON_SPR_ID_QUESTION                   = 14,
	E_ICON_SPR_ID_TAB                        = 15,
	E_ICON_SPR_ID_PARAM_UP                   = 16,
	E_ICON_SPR_ID_SKILL_GET                  = 17,
	E_ICON_SPR_ID_PUROPATRY_UP               = 18,
	E_ICON_SPR_ID_DELIVERTY                  = 19,
	E_ICON_SPR_ID_RELIC                      = 20,
	E_ICON_SPR_ID_VALUABLES                  = 21,
	E_ICON_SPR_ID_ALL                        = 22,
	E_ICON_SPR_ID_COMPOSITE                  = 23,
	E_ICON_SPR_ID_TALK                       = 24,
	E_ICON_SPR_ID_DUMMY25                    = 25,
	E_ICON_SPR_ID_DUMMY26                    = 26,
	E_ICON_SPR_ID_DUMMY27                    = 27,
	E_ICON_SPR_ID_DUMMY28                    = 28,
	E_ICON_SPR_ID_DUMMY29                    = 29,
	E_ICON_SPR_ID_DUMMY30                    = 30,
	E_ICON_SPR_ID_DUMMY31                    = 31,
	E_ICON_SPR_ID_MAX                        = 32,
};

// Enum Project.E_ITEM_ICON_ID
// NumValues: 0x0015
enum class E_ITEM_ICON_ID : uint8
{
	E_ITEM_ICON_ID_DUMMY                     = 0,
	E_ITEM_ICON_ID_CURE                      = 1,
	E_ITEM_ICON_ID_SKILL_PHYSICS             = 2,
	E_ITEM_ICON_ID_SKILL_FIRE                = 3,
	E_ITEM_ICON_ID_SKILL_ICE                 = 4,
	E_ITEM_ICON_ID_SKILL_THUNDER             = 5,
	E_ITEM_ICON_ID_SKILL_WIND                = 6,
	E_ITEM_ICON_ID_SKILL_LIGHT               = 7,
	E_ITEM_ICON_ID_SKILL_DARK                = 8,
	E_ITEM_ICON_ID_SKILL_EVERY               = 9,
	E_ITEM_ICON_ID_SKILL_BST                 = 10,
	E_ITEM_ICON_ID_SKILL_CURE                = 11,
	E_ITEM_ICON_ID_SKILL_AID                 = 12,
	E_ITEM_ICON_ID_SKILL_SP                  = 13,
	E_ITEM_ICON_PARAM_UP                     = 14,
	E_ITEM_ICON_SKILL_GET                    = 15,
	E_ITEM_ICON_PUROPATRY_UP                 = 16,
	E_ITEM_ICON_DELIVERTY                    = 17,
	E_ITEM_ICON_RELIC                        = 18,
	E_ITEM_ICON_VALUABLES                    = 19,
	E_ITEM_ICON_MAX                          = 20,
};

// Enum Project.E_ICON_TYPE
// NumValues: 0x0003
enum class E_ICON_TYPE : uint8
{
	E_ICON_TYPE_SKILL                        = 0,
	E_ICON_TYPE_SKILL_VALUE                  = 1,
	E_ICON_TYPE_MAX                          = 2,
};

// Enum Project.E_UI_FADE_STATE
// NumValues: 0x0005
enum class E_UI_FADE_STATE : uint8
{
	E_UI_FADE_STATE_NONE                     = 0,
	E_UI_FADE_STATE_OUT                      = 1,
	E_UI_FADE_STATE_IN                       = 2,
	E_UI_FADE_STATE_FADE                     = 3,
	E_UI_FADE_STATE_MAX                      = 4,
};

// Enum Project.E_SYS_INFO_ANIM
// NumValues: 0x0005
enum class E_SYS_INFO_ANIM : uint8
{
	E_SYS_INFO_ANIM_NONE                     = 0,
	E_SYS_INFO_ANIM_IN                       = 1,
	E_SYS_INFO_ANIM_WAIT                     = 2,
	E_SYS_INFO_ANIM_OUT                      = 3,
	E_SYS_INFO_ANIM_MAX                      = 4,
};

// Enum Project.E_SYS_INFO_ANIM_TBL
// NumValues: 0x0003
enum class E_SYS_INFO_ANIM_TBL : uint8
{
	E_SYS_INFO_ANIM_TBL_IN                   = 0,
	E_SYS_INFO_ANIM_TBL_OUT                  = 1,
	E_SYS_INFO_ANIM_TBL_MAX                  = 2,
};

// Enum Project.E_WIDGET_TICK_TASK_TYPE
// NumValues: 0x0003
enum class E_WIDGET_TICK_TASK_TYPE : uint8
{
	E_WIDGET_TICK_TASK_TYPE_ANIM             = 0,
	E_WIDGET_TICK_TASK_TYPE_HOLD_KEY         = 1,
	E_WIDGET_TICK_TASK_TYPE_MAX              = 2,
};

// Enum Project.E_WIDGET_PRIO
// NumValues: 0x0020
enum class E_WIDGET_PRIO : uint8
{
	E_WIDGET_PRIO_DEFAULT                    = 0,
	E_WIDGET_PRIO_BACK_FADE                  = 1,
	E_WIDGET_PRIO_RYUKETSU                   = 2,
	E_WIDGET_PRIO_MAP                        = 3,
	E_WIDGET_PRIO_MAP_MAGATSUHI              = 4,
	E_WIDGET_PRIO_MAP_AACTION_WINDOW         = 5,
	E_WIDGET_PRIO_MAP_INFO                   = 6,
	E_WIDGET_PRIO_RYUKETSU_FT_LIST           = 7,
	E_WIDGET_PRIO_CAMP                       = 8,
	E_WIDGET_PRIO_CAMP_HELPMESSAGE           = 9,
	E_WIDGET_PRIO_BATTLE                     = 10,
	E_WIDGET_PRIO_BATTLE_CHARAPANEL          = 11,
	E_WIDGET_PRIO_BATTLE_MESSAGE_WINDOW      = 12,
	E_WIDGET_PRIO_MESSAGE_WIN                = 13,
	E_WIDGET_PRIO_DIALOG_WINDOW              = 14,
	E_WIDGET_PRIO_BACK_LOG                   = 15,
	E_WIDGET_PRIO_SORT_WINDOW                = 16,
	E_WIDGET_PRIO_RYUKETSU_FRONT1            = 17,
	E_WIDGET_PRIO_RYUKETSU_FRONT2            = 18,
	E_WIDGET_PRIO_BUTTON_HELP                = 19,
	E_WIDGET_PRIO_CAMP_DIALOG_WINDOW         = 20,
	E_WIDGET_PRIO_HEAL_RECOVERY_ALL          = 21,
	E_WIDGET_PRIO_MAP_FRONT                  = 22,
	E_WIDGET_PRIO_RYUKETSU_DIALOG_WINDOW     = 23,
	E_WIDGET_PRIO_BATTLE_DIALOG_WINDOW       = 24,
	E_WIDGTE_PRIO_SCREEN_FADE                = 25,
	E_WIDGET_PRIO_BATTLE_TURNCHANGE          = 26,
	E_WIDGET_PRIO_LOADING                    = 27,
	E_WIDGET_PRIO_DEBUG_MENU                 = 28,
	E_WIDGET_PRIO_DEBUG_MENU_FUNC            = 29,
	E_WIDGET_PRIO_MAX                        = 30,
	E_MAX                                    = 31,
};

// Enum Project.E_UNITECHARAPANEL_BTNHELPTYPE
// NumValues: 0x000E
enum class E_UNITECHARAPANEL_BTNHELPTYPE : uint8
{
	E_UNITEPANEL_BTNHELP_DUMMY               = 0,
	E_UNITEPANEL_BTNHELP_PARTY_SRC           = 1,
	E_UNITEPANEL_BTNHELP_PARTY_DST           = 2,
	E_UNITEPANEL_BTNHELP_FUSION_1            = 3,
	E_UNITEPANEL_BTNHELP_FUSION_2            = 4,
	E_UNITEPANEL_BTNHELP_SEARCH              = 5,
	E_UNITEPANEL_BTNHELP_SPECIAL_1           = 6,
	E_UNITEPANEL_BTNHELP_SPECIAL_2           = 7,
	E_UNITEPANEL_BTNHELP_UTSUSEMI_1          = 8,
	E_UNITEPANEL_BTNHELP_UTSUSEMI_2          = 9,
	E_UNITEPANEL_BTNHELP_UTSUSEMI_SKILL      = 10,
	E_UNITEPANEL_BTNHELP_DEVILBOOK_1         = 11,
	E_UNITEPANEL_BTNHELP_DEVILBOOK_2         = 12,
	E_UNITEPANEL_BTNHELP_MAX                 = 13,
};

// Enum Project.E_UNITECHARAPANEL_ERRORTYPE
// NumValues: 0x000A
enum class E_UNITECHARAPANEL_ERRORTYPE : uint8
{
	E_UNITEPANEL_ERROR_NONE                  = 0,
	E_UNITEPANEL_ERROR_HAVE                  = 1,
	E_UNITEPANEL_ERROR_CANNOT                = 2,
	E_UNITEPANEL_ERROR_LEVEL                 = 3,
	E_UNITEPANEL_ERROR_SOZAI                 = 4,
	E_UNITEPANEL_ERROR_MONEY                 = 5,
	E_UNITEPANEL_ERROR_STOCK                 = 6,
	E_UNITEPANEL_ERROR_ENTRY                 = 7,
	E_UNITEPANEL_ERROR_SCENARIO              = 8,
	E_UNITEPANEL_ERROR_MAX                   = 9,
};

// Enum Project.E_UNITEPANEL_SORT
// NumValues: 0x001C
enum class E_UNITEPANEL_SORT : uint8
{
	E_UNITEPANEL_SORT_SORTID                 = 0,
	E_UNITEPANEL_SORT_ENTRYINDEX             = 1,
	E_UNITEPANEL_SORT_LEVEL                  = 2,
	E_UNITEPANEL_SORT_HP                     = 3,
	E_UNITEPANEL_SORT_MP                     = 4,
	E_UNITEPANEL_SORT_DEVILGROUP             = 5,
	E_UNITEPANEL_SORT_COST                   = 6,
	E_UNITEPANEL_SORT_BOOKENTRY              = 7,
	E_UNITEPANEL_SORT_ABLEFUSION             = 8,
	E_UNITEPANEL_SORT_NEWDISP                = 9,
	E_UNITEPANEL_SORT_UTSUSEMINEWDISP        = 10,
	E_UNITEPANEL_SORT_NAME                   = 11,
	E_UNITEPANEL_SORT_DEF_PHISICS            = 12,
	E_UNITEPANEL_SORT_DEF_FIRE               = 13,
	E_UNITEPANEL_SORT_DEF_ICE                = 14,
	E_UNITEPANEL_SORT_DEF_THUNDER            = 15,
	E_UNITEPANEL_SORT_DEF_WIND               = 16,
	E_UNITEPANEL_SORT_DEF_LIGHT              = 17,
	E_UNITEPANEL_SORT_DEF_DARK               = 18,
	E_UNITEPANEL_SORT_AVAILABLEBUY           = 19,
	E_UNITEPANEL_SORT_DEVILGROUP01           = 20,
	E_UNITEPANEL_SORT_DEVILGROUP02           = 21,
	E_UNITEPANEL_SORT_LEVEL01                = 22,
	E_UNITEPANEL_SORT_LEVEL02                = 23,
	E_UNITEPANEL_SORT_NAME01                 = 24,
	E_UNITEPANEL_SORT_NAME02                 = 25,
	E_UNITEPANEL_SORT_POSSESSION             = 26,
	E_UNITEPANEL_SORT_MAX                    = 27,
};

// Enum Project.E_UNITECHARAPANEL_SEARCH
// NumValues: 0x0004
enum class E_UNITECHARAPANEL_SEARCH : uint8
{
	E_SEARCH_PARTY                           = 0,
	E_SEARCH_DEVILBOOK                       = 1,
	E_SEARCH_PARTYSELECT                     = 2,
	E_SEARCH_MAX                             = 3,
};

// Enum Project.E_UNITECHARAPANEL_DEVILDATATYPE
// NumValues: 0x0006
enum class E_UNITECHARAPANEL_DEVILDATATYPE : uint8
{
	E_DEVILDATATYPE_NONE                     = 0,
	E_DEVILDATATYPE_BASE                     = 1,
	E_DEVILDATATYPE_NAKAMA                   = 2,
	E_DEVILDATATYPE_BOOK                     = 3,
	E_DEVILDATATYPE_UTSUSEMI                 = 4,
	E_DEVILDATATYPE_MAX                      = 5,
};

// Enum Project.E_UNITECHARAPANEL_REWRITETYPE
// NumValues: 0x0003
enum class E_UNITECHARAPANEL_REWRITETYPE : uint8
{
	NEW                                      = 0,
	OLD                                      = 1,
	E_UNITECHARAPANEL_MAX                    = 2,
};

// Enum Project.E_UNITECHARAPANEL_DEVILBOOKTYPE
// NumValues: 0x0003
enum class E_UNITECHARAPANEL_DEVILBOOKTYPE : uint8
{
	REGISTED                                 = 0,
	ALL                                      = 1,
	E_UNITECHARAPANEL_MAX                    = 2,
};

// Enum Project.E_UNITECHARAPANEL_MENUTYPE
// NumValues: 0x0008
enum class E_UNITECHARAPANEL_MENUTYPE : uint8
{
	E_UNITECHARAPANEL_MENU_PARTY             = 0,
	E_UNITECHARAPANEL_MENU_DEVILBOOK         = 1,
	E_UNITECHARAPANEL_MENU_UTSUSEMI          = 2,
	E_UNITECHARAPANEL_MENU_FUSION_COMBINE    = 3,
	E_UNITECHARAPANEL_MENU_FUSION_SEARCH     = 4,
	E_UNITECHARAPANEL_MENU_SPECIAL           = 5,
	E_UNITECHARAPANEL_MENU_SPECIAL_COMBINE   = 6,
	E_UNITECHARAPANEL_MENU_MAX               = 7,
};

// Enum Project.E_UNITECHARAPANELFLAG
// NumValues: 0x0009
enum class E_UNITECHARAPANELFLAG : uint8
{
	CPLAYER                                  = 0,
	CPLAYERDEVIL                             = 1,
	CPLAYERDEVIIL_EVENT                      = 2,
	CFREE                                    = 3,
	CEMPTY                                   = 4,
	CBATTLEIN                                = 5,
	CSTOCK                                   = 6,
	CSUMMONED                                = 7,
	E_MAX                                    = 8,
};

// Enum Project.E_UNITECHARAPANELCTRL_GSTATUS
// NumValues: 0x0033
enum class E_UNITECHARAPANELCTRL_GSTATUS : uint8
{
	E_UNITECHARAPANELCTRL_INIT               = 0,
	E_UNITECHARAPANELCTRL_MOVESRC            = 1,
	E_UNITECHARAPANELCTRL_MOVEDST            = 2,
	E_UNITECHARAPANELCTRL_MOVEPROC           = 3,
	E_CAMPCHARAPANELCTRL_MOVEANIMEWAIT       = 4,
	E_UNITECHARAPANELCTRL_MOVEEND            = 5,
	E_UNITECHARAPANELCTRL_SETDIALOG_ERROR    = 6,
	E_UNITECHARAPANELCTRL_WAIT_DIALOG        = 7,
	E_UNITECHARAPANELCTRL_SELECTDIALOG_ON    = 8,
	E_UNITECHARAPANELCTRL_SELECT_DELETECHARA = 9,
	E_UNITECHARAPANELCTRL_DELETECHARA        = 10,
	E_CAMPCHARAPANELCTRL_DELETECHARAANIME    = 11,
	E_UNITECHARAPANELCTRL_WAIT_CLOSEDIALOG   = 12,
	E_UNITECHARAPANELCTRL_UTSUSEMIMOVECURSOR = 13,
	E_UNITECHARAPANELCTRL_UTSUSEMISKILLLIST  = 14,
	E_UNITECHARAPANELCTRL_UTSUSEMIMOVEEND    = 15,
	E_UNITECHARAPANELCTRL_UTSUSEMISETMENU    = 16,
	E_UNITECHARAPANELCTRL_UTSUSEMIWAITMENU   = 17,
	E_UNITECHARAPANELCTRL_DEVILBOOKMOVECURSOR = 18,
	E_UNITECHARAPANELCTRL_DEVILBOOKMOVEEND   = 19,
	E_UNITECHARAPANELCTRL_DEVILBOOKSETYESNO  = 20,
	E_UNITECHARAPANELCTRL_DEVILBOOKWAITYESNO = 21,
	E_UNITECHARAPANELCTRL_FUSIONCREATEPANEL_FIRST = 22,
	E_UNITECHARAPANELCTRL_FUSIONMOVECURSOR_FIRST = 23,
	E_UNITECHARAPANELCTRL_FUSIONCREATEPANEL_SECOND = 24,
	E_UNITECHARAPANELCTRL_FUSIONMOVECURSOR_SECOND = 25,
	E_UNITECHARAPANELCTRL_FUSIONEND          = 26,
	E_UNITECHARAPANELCTRL_SET_ERRORMESSAGE   = 27,
	E_UNITECHARAPANELCTRL_WAIT_ERRORMESSAGE  = 28,
	E_UNITECHARAPANELCTRL_WAIT_STATUSDETAIL_INIT = 29,
	E_UNITECHARAPANELCTRL_STATUSDETAIL       = 30,
	E_UNITECHARAPANELCTRL_SORTFIRST_INIT     = 31,
	E_UNITECHARAPANELCTRL_SORTFIRST_SELECT   = 32,
	E_UNITECHARAPANELCTRL_SORTFIRST_APPLY    = 33,
	E_UNITECHARAPANELCTRL_SORTFIRST_CHANGE   = 34,
	E_UNITECHARAPANELCTRL_SORTSECOND_INIT    = 35,
	E_UNITECHARAPANELCTRL_SORTSECOND_SELECT  = 36,
	E_UNITECHARAPANELCTRL_SORTSECOND_APPLY   = 37,
	E_UNITECHARAPANELCTRL_SORTSECOND_CHANGE  = 38,
	E_UNITECHARAPANELCTRL_FUSIONINITPANEL_SEARCHPARTY = 39,
	E_UNITECHARAPANELCTRL_FUSIONCREATEPANEL_SEARCH = 40,
	E_UNITECHARAPANELCTRL_FUSIONMOVECURSOR_SEARCH = 41,
	E_UNITECHARAPANELCTRL_SORTSEARCH_INIT    = 42,
	E_UNITECHARAPANELCTRL_SORTSEARCH_SELECT  = 43,
	E_UNITECHARAPANELCTRL_SORTSEARCH_APPLY   = 44,
	E_UNITECHARAPANELCTRL_SORTSEARCH_CHANGE  = 45,
	E_UNITECHARAPANELCTRL_SORTSKILL_INIT     = 46,
	E_UNITECHARAPANELCTRL_SORTSKILL_SELECT   = 47,
	E_UNITECHARAPANELCTRL_SORTSKILL_APPLY    = 48,
	E_UNITECHARAPANELCTRL_SORTSKILL_CHANGE   = 49,
	E_MAX                                    = 50,
};

// Enum Project.E_UNITECHARAPANELBASE
// NumValues: 0x0004
enum class E_UNITECHARAPANELBASE : uint8
{
	E_UNITECHARAPANELBASE_NONE               = 0,
	CLISTMAX                                 = 16,
	CPARTYLISTMAX                            = 34,
	E_MAX                                    = 35,
};

// Enum Project.E_SKILLINHERIT_RESULT
// NumValues: 0x000A
enum class E_SKILLINHERIT_RESULT : uint8
{
	E_SKILLINHERIT_RESULT_NONE               = 0,
	E_SKILLINHERIT_RESULT_SUCCESS            = 1,
	E_SKILLINHERIT_RESULT_ERROR              = 2,
	E_SKILLINHERIT_RESULT_ERROR_UNIQUE       = 3,
	E_SKILLINHERIT_RESULT_ERROR_UNIQUE_PLAYER = 4,
	E_SKILLINHERIT_RESULT_ERROR_UNIQUE_NAKAMA = 5,
	E_SKILLINHERIT_RESULT_ERROR_NOSKILL      = 6,
	E_SKILLINHERIT_RESULT_END                = 7,
	E_SKILLINHERIT_RESULT_RETURN             = 8,
	E_SKILLINHERIT_RESULT_MAX                = 9,
};

// Enum Project.E_UNITE_NKM_TYPE
// NumValues: 0x0006
enum class E_UNITE_NKM_TYPE : uint8
{
	E_UNITE_NKM_TYPE_NONE                    = 0,
	E_UNITE_NKM_TYPE_PARTY                   = 1,
	E_UNITE_NKM_TYPE_ORIGINAL                = 2,
	E_UNITE_NKM_TYPE_CUSTOM                  = 3,
	E_UNITE_NKM_TYPE_UTSUSEMI                = 4,
	E_UNITE_NKM_TYPE_MAX                     = 5,
};

// Enum Project.E_UNITE_SEARCH
// NumValues: 0x0003
enum class E_UNITE_SEARCH : uint8
{
	E_UNITE_SEARCH_NONE                      = 0,
	E_UNITE_SEARCH_BIBLE                     = 1,
	E_UNITE_SEARCH_MAX                       = 2,
};

// ScriptStruct Project.AogamiDebrisData
// 0x0014 (0x0014 - 0x0000)
struct FAogamiDebrisData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Index;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemID;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RebornTime;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RebornRate;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAogamiDebrisData) == 0x000004, "Wrong alignment on FAogamiDebrisData");
static_assert(sizeof(FAogamiDebrisData) == 0x000014, "Wrong size on FAogamiDebrisData");
static_assert(offsetof(FAogamiDebrisData, M_MapID) == 0x000000, "Member 'FAogamiDebrisData::M_MapID' has a wrong offset!");
static_assert(offsetof(FAogamiDebrisData, M_Index) == 0x000004, "Member 'FAogamiDebrisData::M_Index' has a wrong offset!");
static_assert(offsetof(FAogamiDebrisData, M_ItemID) == 0x000008, "Member 'FAogamiDebrisData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FAogamiDebrisData, M_RebornTime) == 0x00000C, "Member 'FAogamiDebrisData::M_RebornTime' has a wrong offset!");
static_assert(offsetof(FAogamiDebrisData, M_RebornRate) == 0x000010, "Member 'FAogamiDebrisData::M_RebornRate' has a wrong offset!");

// ScriptStruct Project.SkillInfo
// 0x0024 (0x0024 - 0x0000)
struct FSkillInfo final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UseMes;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UseMasterMes;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UseMesTime;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HitMes;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HitMesTime;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NotMes;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UserName;                                        // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TargetName;                                      // 0x001D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x6];                                       // 0x001E(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillInfo) == 0x000004, "Wrong alignment on FSkillInfo");
static_assert(sizeof(FSkillInfo) == 0x000024, "Wrong size on FSkillInfo");
static_assert(offsetof(FSkillInfo, M_Id) == 0x000000, "Member 'FSkillInfo::M_Id' has a wrong offset!");
static_assert(offsetof(FSkillInfo, M_UseMes) == 0x000004, "Member 'FSkillInfo::M_UseMes' has a wrong offset!");
static_assert(offsetof(FSkillInfo, M_UseMasterMes) == 0x000008, "Member 'FSkillInfo::M_UseMasterMes' has a wrong offset!");
static_assert(offsetof(FSkillInfo, M_UseMesTime) == 0x00000C, "Member 'FSkillInfo::M_UseMesTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, M_HitMes) == 0x000010, "Member 'FSkillInfo::M_HitMes' has a wrong offset!");
static_assert(offsetof(FSkillInfo, M_HitMesTime) == 0x000014, "Member 'FSkillInfo::M_HitMesTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, M_NotMes) == 0x000018, "Member 'FSkillInfo::M_NotMes' has a wrong offset!");
static_assert(offsetof(FSkillInfo, M_UserName) == 0x00001C, "Member 'FSkillInfo::M_UserName' has a wrong offset!");
static_assert(offsetof(FSkillInfo, M_TargetName) == 0x00001D, "Member 'FSkillInfo::M_TargetName' has a wrong offset!");

// ScriptStruct Project.BenefitDevilData
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FBenefitDevilData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x8];                                        // 0x0004(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Level;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x60];                                      // 0x0010(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBenefitDevilData) == 0x000008, "Wrong alignment on FBenefitDevilData");
static_assert(sizeof(FBenefitDevilData) == 0x000070, "Wrong size on FBenefitDevilData");
static_assert(offsetof(FBenefitDevilData, M_Id) == 0x000000, "Member 'FBenefitDevilData::M_Id' has a wrong offset!");
static_assert(offsetof(FBenefitDevilData, M_Level) == 0x00000C, "Member 'FBenefitDevilData::M_Level' has a wrong offset!");

// ScriptStruct Project.BenefitItemData
// 0x0008 (0x0008 - 0x0000)
struct FBenefitItemData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Num;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenefitItemData) == 0x000004, "Wrong alignment on FBenefitItemData");
static_assert(sizeof(FBenefitItemData) == 0x000008, "Wrong size on FBenefitItemData");
static_assert(offsetof(FBenefitItemData, M_Id) == 0x000000, "Member 'FBenefitItemData::M_Id' has a wrong offset!");
static_assert(offsetof(FBenefitItemData, M_Num) == 0x000004, "Member 'FBenefitItemData::M_Num' has a wrong offset!");

// ScriptStruct Project.BenefitData
// 0x0038 (0x0038 - 0x0000)
struct FBenefitData final
{
public:
	bool                                          M_IsExist;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ClearAlignment;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBenefitDevilData>              M_DevilData;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBenefitItemData>               M_ItemData;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBenefitDevilData>              M_DisableDevilData;                                // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenefitData) == 0x000008, "Wrong alignment on FBenefitData");
static_assert(sizeof(FBenefitData) == 0x000038, "Wrong size on FBenefitData");
static_assert(offsetof(FBenefitData, M_IsExist) == 0x000000, "Member 'FBenefitData::M_IsExist' has a wrong offset!");
static_assert(offsetof(FBenefitData, M_ClearAlignment) == 0x000001, "Member 'FBenefitData::M_ClearAlignment' has a wrong offset!");
static_assert(offsetof(FBenefitData, M_DevilData) == 0x000008, "Member 'FBenefitData::M_DevilData' has a wrong offset!");
static_assert(offsetof(FBenefitData, M_ItemData) == 0x000018, "Member 'FBenefitData::M_ItemData' has a wrong offset!");
static_assert(offsetof(FBenefitData, M_DisableDevilData) == 0x000028, "Member 'FBenefitData::M_DisableDevilData' has a wrong offset!");

// ScriptStruct Project.SkillLibListData
// 0x0020 (0x0020 - 0x0000)
struct FSkillLibListData final
{
public:
	E_SKILL_LIB_CATEGORY                          M_Category;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_SkillIDArray;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_ListNum;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillLibListData) == 0x000008, "Wrong alignment on FSkillLibListData");
static_assert(sizeof(FSkillLibListData) == 0x000020, "Wrong size on FSkillLibListData");
static_assert(offsetof(FSkillLibListData, M_Category) == 0x000000, "Member 'FSkillLibListData::M_Category' has a wrong offset!");
static_assert(offsetof(FSkillLibListData, M_SkillIDArray) == 0x000008, "Member 'FSkillLibListData::M_SkillIDArray' has a wrong offset!");
static_assert(offsetof(FSkillLibListData, M_ListNum) == 0x000018, "Member 'FSkillLibListData::M_ListNum' has a wrong offset!");

// ScriptStruct Project.AnalyzeData
// 0x0050 (0x0050 - 0x0000)
struct FAnalyzeData final
{
public:
	bool                                          M_IsOpenAnalyze;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsNewIconAnalyze;                                // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  M_IsOpenDefenceAishou;                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_IsOpenSkillTekisei;                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_IsOpenSkill;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_IsOpenMagatsuhiSkill;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_IsOpenUniqueSkill;                               // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnalyzeData) == 0x000008, "Wrong alignment on FAnalyzeData");
static_assert(sizeof(FAnalyzeData) == 0x000050, "Wrong size on FAnalyzeData");
static_assert(offsetof(FAnalyzeData, M_IsOpenAnalyze) == 0x000000, "Member 'FAnalyzeData::M_IsOpenAnalyze' has a wrong offset!");
static_assert(offsetof(FAnalyzeData, M_IsNewIconAnalyze) == 0x000001, "Member 'FAnalyzeData::M_IsNewIconAnalyze' has a wrong offset!");
static_assert(offsetof(FAnalyzeData, M_IsOpenDefenceAishou) == 0x000008, "Member 'FAnalyzeData::M_IsOpenDefenceAishou' has a wrong offset!");
static_assert(offsetof(FAnalyzeData, M_IsOpenSkillTekisei) == 0x000018, "Member 'FAnalyzeData::M_IsOpenSkillTekisei' has a wrong offset!");
static_assert(offsetof(FAnalyzeData, M_IsOpenSkill) == 0x000028, "Member 'FAnalyzeData::M_IsOpenSkill' has a wrong offset!");
static_assert(offsetof(FAnalyzeData, M_IsOpenMagatsuhiSkill) == 0x000038, "Member 'FAnalyzeData::M_IsOpenMagatsuhiSkill' has a wrong offset!");
static_assert(offsetof(FAnalyzeData, M_IsOpenUniqueSkill) == 0x000048, "Member 'FAnalyzeData::M_IsOpenUniqueSkill' has a wrong offset!");

// ScriptStruct Project.TalkMythProcess
// 0x000C (0x000C - 0x0000)
struct FTalkMythProcess final
{
public:
	EMythProcessType                              M_Process;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMythTalkerType                               M_Talker;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDevilTalkVoice                               M_Voice;                                           // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CHARA_MOTION_ID                             M_Motion;                                          // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ProcessValue;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Camera;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkMythProcess) == 0x000004, "Wrong alignment on FTalkMythProcess");
static_assert(sizeof(FTalkMythProcess) == 0x00000C, "Wrong size on FTalkMythProcess");
static_assert(offsetof(FTalkMythProcess, M_Process) == 0x000000, "Member 'FTalkMythProcess::M_Process' has a wrong offset!");
static_assert(offsetof(FTalkMythProcess, M_Talker) == 0x000001, "Member 'FTalkMythProcess::M_Talker' has a wrong offset!");
static_assert(offsetof(FTalkMythProcess, M_Voice) == 0x000002, "Member 'FTalkMythProcess::M_Voice' has a wrong offset!");
static_assert(offsetof(FTalkMythProcess, M_Motion) == 0x000003, "Member 'FTalkMythProcess::M_Motion' has a wrong offset!");
static_assert(offsetof(FTalkMythProcess, M_ProcessValue) == 0x000004, "Member 'FTalkMythProcess::M_ProcessValue' has a wrong offset!");
static_assert(offsetof(FTalkMythProcess, M_Camera) == 0x000008, "Member 'FTalkMythProcess::M_Camera' has a wrong offset!");

// ScriptStruct Project.TalkMythProcessTable
// 0x0010 (0x0010 - 0x0000)
struct FTalkMythProcessTable final
{
public:
	TArray<struct FTalkMythProcess>               M_ProcessArray;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkMythProcessTable) == 0x000008, "Wrong alignment on FTalkMythProcessTable");
static_assert(sizeof(FTalkMythProcessTable) == 0x000010, "Wrong size on FTalkMythProcessTable");
static_assert(offsetof(FTalkMythProcessTable, M_ProcessArray) == 0x000000, "Member 'FTalkMythProcessTable::M_ProcessArray' has a wrong offset!");

// ScriptStruct Project.BtlResultItemData
// 0x000C (0x000C - 0x0000)
struct FBtlResultItemData final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemCnt;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsNew;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlResultItemData) == 0x000004, "Wrong alignment on FBtlResultItemData");
static_assert(sizeof(FBtlResultItemData) == 0x00000C, "Wrong size on FBtlResultItemData");
static_assert(offsetof(FBtlResultItemData, M_ItemID) == 0x000000, "Member 'FBtlResultItemData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FBtlResultItemData, M_ItemCnt) == 0x000004, "Member 'FBtlResultItemData::M_ItemCnt' has a wrong offset!");
static_assert(offsetof(FBtlResultItemData, M_IsNew) == 0x000008, "Member 'FBtlResultItemData::M_IsNew' has a wrong offset!");

// ScriptStruct Project.AUListData
// 0x0008 (0x0008 - 0x0000)
struct FAUListData final
{
public:
	int32                                         M_DevilID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CmpSkillId;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAUListData) == 0x000004, "Wrong alignment on FAUListData");
static_assert(sizeof(FAUListData) == 0x000008, "Wrong size on FAUListData");
static_assert(offsetof(FAUListData, M_DevilID) == 0x000000, "Member 'FAUListData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FAUListData, M_CmpSkillId) == 0x000004, "Member 'FAUListData::M_CmpSkillId' has a wrong offset!");

// ScriptStruct Project.ActivityDataParam
// 0x0008 (0x0010 - 0x0008)
struct FActivityDataParam final : public FTableRowBase
{
public:
	int32                                         MapEventID;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActivityTaskID                               StartTask;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActivityDataParam) == 0x000008, "Wrong alignment on FActivityDataParam");
static_assert(sizeof(FActivityDataParam) == 0x000010, "Wrong size on FActivityDataParam");
static_assert(offsetof(FActivityDataParam, MapEventID) == 0x000008, "Member 'FActivityDataParam::MapEventID' has a wrong offset!");
static_assert(offsetof(FActivityDataParam, StartTask) == 0x00000C, "Member 'FActivityDataParam::StartTask' has a wrong offset!");

// ScriptStruct Project.BtlParamData
// 0x0024 (0x0024 - 0x0000)
struct FBtlParamData final
{
public:
	int32                                         M_HP;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPMax;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPMax;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Str;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Vit;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Mgi;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Agi;                                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Luc;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlParamData) == 0x000004, "Wrong alignment on FBtlParamData");
static_assert(sizeof(FBtlParamData) == 0x000024, "Wrong size on FBtlParamData");
static_assert(offsetof(FBtlParamData, M_HP) == 0x000000, "Member 'FBtlParamData::M_HP' has a wrong offset!");
static_assert(offsetof(FBtlParamData, M_HPMax) == 0x000004, "Member 'FBtlParamData::M_HPMax' has a wrong offset!");
static_assert(offsetof(FBtlParamData, M_MP) == 0x000008, "Member 'FBtlParamData::M_MP' has a wrong offset!");
static_assert(offsetof(FBtlParamData, M_MPMax) == 0x00000C, "Member 'FBtlParamData::M_MPMax' has a wrong offset!");
static_assert(offsetof(FBtlParamData, M_Str) == 0x000010, "Member 'FBtlParamData::M_Str' has a wrong offset!");
static_assert(offsetof(FBtlParamData, M_Vit) == 0x000014, "Member 'FBtlParamData::M_Vit' has a wrong offset!");
static_assert(offsetof(FBtlParamData, M_Mgi) == 0x000018, "Member 'FBtlParamData::M_Mgi' has a wrong offset!");
static_assert(offsetof(FBtlParamData, M_Agi) == 0x00001C, "Member 'FBtlParamData::M_Agi' has a wrong offset!");
static_assert(offsetof(FBtlParamData, M_Luc) == 0x000020, "Member 'FBtlParamData::M_Luc' has a wrong offset!");

// ScriptStruct Project.AnimNode_BoneMotionByChannel
// 0x0070 (0x0080 - 0x0010)
struct alignas(0x10) FAnimNode_BoneMotionByChannel final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BaseAnim;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              BoneMotion;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ApplyBone;                                         // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsEnableTranslate;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableRotate;                                    // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableScale;                                     // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x3D];                                      // 0x0043(0x003D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_BoneMotionByChannel) == 0x000010, "Wrong alignment on FAnimNode_BoneMotionByChannel");
static_assert(sizeof(FAnimNode_BoneMotionByChannel) == 0x000080, "Wrong size on FAnimNode_BoneMotionByChannel");
static_assert(offsetof(FAnimNode_BoneMotionByChannel, BaseAnim) == 0x000010, "Member 'FAnimNode_BoneMotionByChannel::BaseAnim' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneMotionByChannel, BoneMotion) == 0x000020, "Member 'FAnimNode_BoneMotionByChannel::BoneMotion' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneMotionByChannel, ApplyBone) == 0x000030, "Member 'FAnimNode_BoneMotionByChannel::ApplyBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneMotionByChannel, IsEnableTranslate) == 0x000040, "Member 'FAnimNode_BoneMotionByChannel::IsEnableTranslate' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneMotionByChannel, IsEnableRotate) == 0x000041, "Member 'FAnimNode_BoneMotionByChannel::IsEnableRotate' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneMotionByChannel, IsEnableScale) == 0x000042, "Member 'FAnimNode_BoneMotionByChannel::IsEnableScale' has a wrong offset!");

// ScriptStruct Project.BtlEncData
// 0x0058 (0x0058 - 0x0000)
struct FBtlEncData final
{
public:
	bool                                          M_IsForceSurpriseAtk;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsForcePreemptiveAtk;                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsNotEscape;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsNoDeadEffect;                                  // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsNoDestroyModel;                                // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsSubMission;                                    // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_EnemyHPRate;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndEnemyHPRate;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsRoomBoss;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_EnemyNotAutoUplifting;                           // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsSkipResult;                                    // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_EncID;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EvtEncID;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BGMNo;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_ENCOUNT_TYPE                            M_EncType;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_CheckEndLeaderDead;                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsBossRush;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_SubLebelName;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_EnemyIDArray;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlEncData) == 0x000008, "Wrong alignment on FBtlEncData");
static_assert(sizeof(FBtlEncData) == 0x000058, "Wrong size on FBtlEncData");
static_assert(offsetof(FBtlEncData, M_IsForceSurpriseAtk) == 0x000000, "Member 'FBtlEncData::M_IsForceSurpriseAtk' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_IsForcePreemptiveAtk) == 0x000001, "Member 'FBtlEncData::M_IsForcePreemptiveAtk' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_IsNotEscape) == 0x000002, "Member 'FBtlEncData::M_IsNotEscape' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_IsNoDeadEffect) == 0x000003, "Member 'FBtlEncData::M_IsNoDeadEffect' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_IsNoDestroyModel) == 0x000004, "Member 'FBtlEncData::M_IsNoDestroyModel' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_IsSubMission) == 0x000005, "Member 'FBtlEncData::M_IsSubMission' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_EnemyHPRate) == 0x000008, "Member 'FBtlEncData::M_EnemyHPRate' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_EndEnemyHPRate) == 0x00000C, "Member 'FBtlEncData::M_EndEnemyHPRate' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_IsRoomBoss) == 0x000010, "Member 'FBtlEncData::M_IsRoomBoss' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_EnemyNotAutoUplifting) == 0x000011, "Member 'FBtlEncData::M_EnemyNotAutoUplifting' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_IsSkipResult) == 0x000012, "Member 'FBtlEncData::M_IsSkipResult' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_EncID) == 0x000014, "Member 'FBtlEncData::M_EncID' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_EvtEncID) == 0x000018, "Member 'FBtlEncData::M_EvtEncID' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_BGMNo) == 0x00001C, "Member 'FBtlEncData::M_BGMNo' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_EncType) == 0x000020, "Member 'FBtlEncData::M_EncType' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_CheckEndLeaderDead) == 0x000024, "Member 'FBtlEncData::M_CheckEndLeaderDead' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_IsBossRush) == 0x000028, "Member 'FBtlEncData::M_IsBossRush' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_SubLebelName) == 0x000030, "Member 'FBtlEncData::M_SubLebelName' has a wrong offset!");
static_assert(offsetof(FBtlEncData, M_EnemyIDArray) == 0x000048, "Member 'FBtlEncData::M_EnemyIDArray' has a wrong offset!");

// ScriptStruct Project.MissionTimeAttackInfo
// 0x0010 (0x0010 - 0x0000)
struct FMissionTimeAttackInfo final
{
public:
	int32                                         MissionId;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MISSION_TIME_ATTACK_INFO_TYPE               InfoType;                                          // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value1;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value2;                                            // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionTimeAttackInfo) == 0x000004, "Wrong alignment on FMissionTimeAttackInfo");
static_assert(sizeof(FMissionTimeAttackInfo) == 0x000010, "Wrong size on FMissionTimeAttackInfo");
static_assert(offsetof(FMissionTimeAttackInfo, MissionId) == 0x000000, "Member 'FMissionTimeAttackInfo::MissionId' has a wrong offset!");
static_assert(offsetof(FMissionTimeAttackInfo, InfoType) == 0x000004, "Member 'FMissionTimeAttackInfo::InfoType' has a wrong offset!");
static_assert(offsetof(FMissionTimeAttackInfo, Value1) == 0x000008, "Member 'FMissionTimeAttackInfo::Value1' has a wrong offset!");
static_assert(offsetof(FMissionTimeAttackInfo, Value2) == 0x00000C, "Member 'FMissionTimeAttackInfo::Value2' has a wrong offset!");

// ScriptStruct Project.FacialAnimationPreset_EVT04_PresetData
// 0x0040 (0x0040 - 0x0000)
struct FFacialAnimationPreset_EVT04_PresetData final
{
public:
	bool                                          bLightPositionB_Enable;                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LightPositionB;                                    // 0x0004(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightColorB_Enable;                               // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LightColorB;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightContrastB_Enable;                            // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightContrastB;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightRadiusB_Enable;                              // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightRadiusB;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightRangeB_Enable;                               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightRangeB;                                       // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacialAnimationPreset_EVT04_PresetData) == 0x000004, "Wrong alignment on FFacialAnimationPreset_EVT04_PresetData");
static_assert(sizeof(FFacialAnimationPreset_EVT04_PresetData) == 0x000040, "Wrong size on FFacialAnimationPreset_EVT04_PresetData");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, bLightPositionB_Enable) == 0x000000, "Member 'FFacialAnimationPreset_EVT04_PresetData::bLightPositionB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, LightPositionB) == 0x000004, "Member 'FFacialAnimationPreset_EVT04_PresetData::LightPositionB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, bLightColorB_Enable) == 0x000014, "Member 'FFacialAnimationPreset_EVT04_PresetData::bLightColorB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, LightColorB) == 0x000018, "Member 'FFacialAnimationPreset_EVT04_PresetData::LightColorB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, bLightContrastB_Enable) == 0x000028, "Member 'FFacialAnimationPreset_EVT04_PresetData::bLightContrastB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, LightContrastB) == 0x00002C, "Member 'FFacialAnimationPreset_EVT04_PresetData::LightContrastB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, bLightRadiusB_Enable) == 0x000030, "Member 'FFacialAnimationPreset_EVT04_PresetData::bLightRadiusB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, LightRadiusB) == 0x000034, "Member 'FFacialAnimationPreset_EVT04_PresetData::LightRadiusB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, bLightRangeB_Enable) == 0x000038, "Member 'FFacialAnimationPreset_EVT04_PresetData::bLightRangeB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT04_PresetData, LightRangeB) == 0x00003C, "Member 'FFacialAnimationPreset_EVT04_PresetData::LightRangeB' has a wrong offset!");

// ScriptStruct Project.SaveDataConvertResult
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSaveDataConvertResult final
{
public:
	bool                                          M_Success;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x17];                                       // 0x0001(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveDataConvertResult) == 0x000008, "Wrong alignment on FSaveDataConvertResult");
static_assert(sizeof(FSaveDataConvertResult) == 0x000018, "Wrong size on FSaveDataConvertResult");
static_assert(offsetof(FSaveDataConvertResult, M_Success) == 0x000000, "Member 'FSaveDataConvertResult::M_Success' has a wrong offset!");

// ScriptStruct Project.PathCurves
// 0x0108 (0x0108 - 0x0000)
struct FPathCurves final
{
public:
	struct FInterpCurveVector                     Position;                                          // 0x0000(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveQuat                       Rotation;                                          // 0x0018(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      Param1;                                            // 0x0030(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      Param2;                                            // 0x0048(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      Param3;                                            // 0x0060(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      Param4;                                            // 0x0078(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      Param5;                                            // 0x0090(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      Param6;                                            // 0x00A8(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      Param7;                                            // 0x00C0(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      Param8;                                            // 0x00D8(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      ReparamTable;                                      // 0x00F0(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathCurves) == 0x000008, "Wrong alignment on FPathCurves");
static_assert(sizeof(FPathCurves) == 0x000108, "Wrong size on FPathCurves");
static_assert(offsetof(FPathCurves, Position) == 0x000000, "Member 'FPathCurves::Position' has a wrong offset!");
static_assert(offsetof(FPathCurves, Rotation) == 0x000018, "Member 'FPathCurves::Rotation' has a wrong offset!");
static_assert(offsetof(FPathCurves, Param1) == 0x000030, "Member 'FPathCurves::Param1' has a wrong offset!");
static_assert(offsetof(FPathCurves, Param2) == 0x000048, "Member 'FPathCurves::Param2' has a wrong offset!");
static_assert(offsetof(FPathCurves, Param3) == 0x000060, "Member 'FPathCurves::Param3' has a wrong offset!");
static_assert(offsetof(FPathCurves, Param4) == 0x000078, "Member 'FPathCurves::Param4' has a wrong offset!");
static_assert(offsetof(FPathCurves, Param5) == 0x000090, "Member 'FPathCurves::Param5' has a wrong offset!");
static_assert(offsetof(FPathCurves, Param6) == 0x0000A8, "Member 'FPathCurves::Param6' has a wrong offset!");
static_assert(offsetof(FPathCurves, Param7) == 0x0000C0, "Member 'FPathCurves::Param7' has a wrong offset!");
static_assert(offsetof(FPathCurves, Param8) == 0x0000D8, "Member 'FPathCurves::Param8' has a wrong offset!");
static_assert(offsetof(FPathCurves, ReparamTable) == 0x0000F0, "Member 'FPathCurves::ReparamTable' has a wrong offset!");

// ScriptStruct Project.PathInstanceData
// 0x0218 (0x02D0 - 0x00B8)
struct FPathInstanceData final : public FSceneComponentInstanceData
{
public:
	struct FPathCurves                            SplineCurves;                                      // 0x00B8(0x0108)(NativeAccessSpecifierPublic)
	struct FPathCurves                            SplineCurvesPreUCS;                                // 0x01C0(0x0108)(NativeAccessSpecifierPublic)
	bool                                          bSplineHasBeenEdited;                              // 0x02C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathInstanceData) == 0x000008, "Wrong alignment on FPathInstanceData");
static_assert(sizeof(FPathInstanceData) == 0x0002D0, "Wrong size on FPathInstanceData");
static_assert(offsetof(FPathInstanceData, SplineCurves) == 0x0000B8, "Member 'FPathInstanceData::SplineCurves' has a wrong offset!");
static_assert(offsetof(FPathInstanceData, SplineCurvesPreUCS) == 0x0001C0, "Member 'FPathInstanceData::SplineCurvesPreUCS' has a wrong offset!");
static_assert(offsetof(FPathInstanceData, bSplineHasBeenEdited) == 0x0002C8, "Member 'FPathInstanceData::bSplineHasBeenEdited' has a wrong offset!");

// ScriptStruct Project.AnimNode_CustomPoseBlendNode
// 0x0088 (0x00C0 - 0x0038)
struct FAnimNode_CustomPoseBlendNode final : public FAnimNode_AssetPlayerBase
{
public:
	class UPoseAsset*                             PoseAsset;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomPoseWeightTable*                 PoseWeightTable;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPoseLink                              SourcePose;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOption;                                       // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomCurve;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x54];                                      // 0x006C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_CustomPoseBlendNode) == 0x000008, "Wrong alignment on FAnimNode_CustomPoseBlendNode");
static_assert(sizeof(FAnimNode_CustomPoseBlendNode) == 0x0000C0, "Wrong size on FAnimNode_CustomPoseBlendNode");
static_assert(offsetof(FAnimNode_CustomPoseBlendNode, PoseAsset) == 0x000038, "Member 'FAnimNode_CustomPoseBlendNode::PoseAsset' has a wrong offset!");
static_assert(offsetof(FAnimNode_CustomPoseBlendNode, PoseWeightTable) == 0x000040, "Member 'FAnimNode_CustomPoseBlendNode::PoseWeightTable' has a wrong offset!");
static_assert(offsetof(FAnimNode_CustomPoseBlendNode, SourcePose) == 0x000048, "Member 'FAnimNode_CustomPoseBlendNode::SourcePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_CustomPoseBlendNode, BlendOption) == 0x000058, "Member 'FAnimNode_CustomPoseBlendNode::BlendOption' has a wrong offset!");
static_assert(offsetof(FAnimNode_CustomPoseBlendNode, CustomCurve) == 0x000060, "Member 'FAnimNode_CustomPoseBlendNode::CustomCurve' has a wrong offset!");
static_assert(offsetof(FAnimNode_CustomPoseBlendNode, Alpha) == 0x000068, "Member 'FAnimNode_CustomPoseBlendNode::Alpha' has a wrong offset!");

// ScriptStruct Project.ActionMappingNameRow
// 0x0010 (0x0018 - 0x0008)
struct FActionMappingNameRow final : public FTableRowBase
{
public:
	class FName                                   MappingName;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_ACTION_MAPPING_TYPE                         EnumValue;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionMappingNameRow) == 0x000008, "Wrong alignment on FActionMappingNameRow");
static_assert(sizeof(FActionMappingNameRow) == 0x000018, "Wrong size on FActionMappingNameRow");
static_assert(offsetof(FActionMappingNameRow, MappingName) == 0x000008, "Member 'FActionMappingNameRow::MappingName' has a wrong offset!");
static_assert(offsetof(FActionMappingNameRow, EnumValue) == 0x000010, "Member 'FActionMappingNameRow::EnumValue' has a wrong offset!");

// ScriptStruct Project.BattleTaskArray
// 0x0010 (0x0010 - 0x0000)
struct FBattleTaskArray final
{
public:
	TArray<class ABattleActorBase*>               Array;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleTaskArray) == 0x000008, "Wrong alignment on FBattleTaskArray");
static_assert(sizeof(FBattleTaskArray) == 0x000010, "Wrong size on FBattleTaskArray");
static_assert(offsetof(FBattleTaskArray, Array) == 0x000000, "Member 'FBattleTaskArray::Array' has a wrong offset!");

// ScriptStruct Project.BtlTaskData
// 0x0030 (0x0030 - 0x0000)
struct FBtlTaskData final
{
public:
	uint8                                         Value8;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value32;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueF;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ValueV;                                            // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Flag;                                              // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlTaskData) == 0x000008, "Wrong alignment on FBtlTaskData");
static_assert(sizeof(FBtlTaskData) == 0x000030, "Wrong size on FBtlTaskData");
static_assert(offsetof(FBtlTaskData, Value8) == 0x000000, "Member 'FBtlTaskData::Value8' has a wrong offset!");
static_assert(offsetof(FBtlTaskData, Value32) == 0x000004, "Member 'FBtlTaskData::Value32' has a wrong offset!");
static_assert(offsetof(FBtlTaskData, ValueF) == 0x000008, "Member 'FBtlTaskData::ValueF' has a wrong offset!");
static_assert(offsetof(FBtlTaskData, ValueV) == 0x00000C, "Member 'FBtlTaskData::ValueV' has a wrong offset!");
static_assert(offsetof(FBtlTaskData, Flag) == 0x000018, "Member 'FBtlTaskData::Flag' has a wrong offset!");
static_assert(offsetof(FBtlTaskData, String) == 0x000020, "Member 'FBtlTaskData::String' has a wrong offset!");

// ScriptStruct Project.BtlTaskDesc
// 0x00A0 (0x00A0 - 0x0000)
struct FBtlTaskDesc final
{
public:
	E_BTL_TASK_COM                                M_Type;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Flag;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_LimitTime;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ActorPartyIndex;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TargetPartyIndex;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBtlTaskData                           M_TaskData;                                        // 0x0010(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBtlTaskData                           M_TaskData2;                                       // 0x0040(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTransform                             M_Transform;                                       // 0x0070(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlTaskDesc) == 0x000010, "Wrong alignment on FBtlTaskDesc");
static_assert(sizeof(FBtlTaskDesc) == 0x0000A0, "Wrong size on FBtlTaskDesc");
static_assert(offsetof(FBtlTaskDesc, M_Type) == 0x000000, "Member 'FBtlTaskDesc::M_Type' has a wrong offset!");
static_assert(offsetof(FBtlTaskDesc, M_Flag) == 0x000001, "Member 'FBtlTaskDesc::M_Flag' has a wrong offset!");
static_assert(offsetof(FBtlTaskDesc, M_LimitTime) == 0x000004, "Member 'FBtlTaskDesc::M_LimitTime' has a wrong offset!");
static_assert(offsetof(FBtlTaskDesc, M_ActorPartyIndex) == 0x000008, "Member 'FBtlTaskDesc::M_ActorPartyIndex' has a wrong offset!");
static_assert(offsetof(FBtlTaskDesc, M_TargetPartyIndex) == 0x00000C, "Member 'FBtlTaskDesc::M_TargetPartyIndex' has a wrong offset!");
static_assert(offsetof(FBtlTaskDesc, M_TaskData) == 0x000010, "Member 'FBtlTaskDesc::M_TaskData' has a wrong offset!");
static_assert(offsetof(FBtlTaskDesc, M_TaskData2) == 0x000040, "Member 'FBtlTaskDesc::M_TaskData2' has a wrong offset!");
static_assert(offsetof(FBtlTaskDesc, M_Transform) == 0x000070, "Member 'FBtlTaskDesc::M_Transform' has a wrong offset!");

// ScriptStruct Project.DebugBattleTaskInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FDebugBattleTaskInfo final
{
public:
	int32                                         PecID;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Step;                                              // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpdateTimes;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTerminal;                                        // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Memo;                                              // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 WaitTaskList;                                      // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlTaskDesc                           Desc;                                              // 0x0040(0x00A0)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugBattleTaskInfo) == 0x000010, "Wrong alignment on FDebugBattleTaskInfo");
static_assert(sizeof(FDebugBattleTaskInfo) == 0x0000E0, "Wrong size on FDebugBattleTaskInfo");
static_assert(offsetof(FDebugBattleTaskInfo, PecID) == 0x000000, "Member 'FDebugBattleTaskInfo::PecID' has a wrong offset!");
static_assert(offsetof(FDebugBattleTaskInfo, Step) == 0x000004, "Member 'FDebugBattleTaskInfo::Step' has a wrong offset!");
static_assert(offsetof(FDebugBattleTaskInfo, UpdateTimes) == 0x000008, "Member 'FDebugBattleTaskInfo::UpdateTimes' has a wrong offset!");
static_assert(offsetof(FDebugBattleTaskInfo, ElapsedTime) == 0x00000C, "Member 'FDebugBattleTaskInfo::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FDebugBattleTaskInfo, IsTerminal) == 0x000010, "Member 'FDebugBattleTaskInfo::IsTerminal' has a wrong offset!");
static_assert(offsetof(FDebugBattleTaskInfo, Memo) == 0x000018, "Member 'FDebugBattleTaskInfo::Memo' has a wrong offset!");
static_assert(offsetof(FDebugBattleTaskInfo, WaitTaskList) == 0x000028, "Member 'FDebugBattleTaskInfo::WaitTaskList' has a wrong offset!");
static_assert(offsetof(FDebugBattleTaskInfo, Desc) == 0x000040, "Member 'FDebugBattleTaskInfo::Desc' has a wrong offset!");

// ScriptStruct Project.StatusCharaCopyData_MeshData
// 0x0080 (0x0080 - 0x0000)
struct FStatusCharaCopyData_MeshData final
{
public:
	struct FTransform                             M_Transform;                                       // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           M_Mesh;                                            // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_AnimInstance;                                    // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusCharaCopyData_MeshData) == 0x000010, "Wrong alignment on FStatusCharaCopyData_MeshData");
static_assert(sizeof(FStatusCharaCopyData_MeshData) == 0x000080, "Wrong size on FStatusCharaCopyData_MeshData");
static_assert(offsetof(FStatusCharaCopyData_MeshData, M_Transform) == 0x000000, "Member 'FStatusCharaCopyData_MeshData::M_Transform' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_MeshData, M_Mesh) == 0x000030, "Member 'FStatusCharaCopyData_MeshData::M_Mesh' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_MeshData, M_AnimInstance) == 0x000058, "Member 'FStatusCharaCopyData_MeshData::M_AnimInstance' has a wrong offset!");

// ScriptStruct Project.StatusCharaCopyData_ParticleData
// 0x0060 (0x0060 - 0x0000)
struct FStatusCharaCopyData_ParticleData final
{
public:
	struct FTransform                             M_Transform;                                       // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         M_Template;                                        // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_AttachSocketName;                                // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusCharaCopyData_ParticleData) == 0x000010, "Wrong alignment on FStatusCharaCopyData_ParticleData");
static_assert(sizeof(FStatusCharaCopyData_ParticleData) == 0x000060, "Wrong size on FStatusCharaCopyData_ParticleData");
static_assert(offsetof(FStatusCharaCopyData_ParticleData, M_Transform) == 0x000000, "Member 'FStatusCharaCopyData_ParticleData::M_Transform' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_ParticleData, M_Template) == 0x000030, "Member 'FStatusCharaCopyData_ParticleData::M_Template' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_ParticleData, M_AttachSocketName) == 0x000058, "Member 'FStatusCharaCopyData_ParticleData::M_AttachSocketName' has a wrong offset!");

// ScriptStruct Project.StatusCharaCopyData_PointLightData
// 0x0070 (0x0070 - 0x0000)
struct FStatusCharaCopyData_PointLightData final
{
public:
	bool                                          M_IsView;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_Transform;                                       // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_AttachSocketName;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Intensity;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_LightColor;                                      // 0x004C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AttenuationRadius;                               // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_SourceRadius;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_SoftSourceRadius;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_SourceLength;                                    // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusCharaCopyData_PointLightData) == 0x000010, "Wrong alignment on FStatusCharaCopyData_PointLightData");
static_assert(sizeof(FStatusCharaCopyData_PointLightData) == 0x000070, "Wrong size on FStatusCharaCopyData_PointLightData");
static_assert(offsetof(FStatusCharaCopyData_PointLightData, M_IsView) == 0x000000, "Member 'FStatusCharaCopyData_PointLightData::M_IsView' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_PointLightData, M_Transform) == 0x000010, "Member 'FStatusCharaCopyData_PointLightData::M_Transform' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_PointLightData, M_AttachSocketName) == 0x000040, "Member 'FStatusCharaCopyData_PointLightData::M_AttachSocketName' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_PointLightData, M_Intensity) == 0x000048, "Member 'FStatusCharaCopyData_PointLightData::M_Intensity' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_PointLightData, M_LightColor) == 0x00004C, "Member 'FStatusCharaCopyData_PointLightData::M_LightColor' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_PointLightData, M_AttenuationRadius) == 0x00005C, "Member 'FStatusCharaCopyData_PointLightData::M_AttenuationRadius' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_PointLightData, M_SourceRadius) == 0x000060, "Member 'FStatusCharaCopyData_PointLightData::M_SourceRadius' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_PointLightData, M_SoftSourceRadius) == 0x000064, "Member 'FStatusCharaCopyData_PointLightData::M_SoftSourceRadius' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_PointLightData, M_SourceLength) == 0x000068, "Member 'FStatusCharaCopyData_PointLightData::M_SourceLength' has a wrong offset!");

// ScriptStruct Project.StatusCharaCopyData_DecalData
// 0x0070 (0x0070 - 0x0000)
struct FStatusCharaCopyData_DecalData final
{
public:
	struct FTransform                             M_Transform;                                       // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_DecalSize;                                       // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      M_Material;                                        // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_AttachSocketName;                                // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusCharaCopyData_DecalData) == 0x000010, "Wrong alignment on FStatusCharaCopyData_DecalData");
static_assert(sizeof(FStatusCharaCopyData_DecalData) == 0x000070, "Wrong size on FStatusCharaCopyData_DecalData");
static_assert(offsetof(FStatusCharaCopyData_DecalData, M_Transform) == 0x000000, "Member 'FStatusCharaCopyData_DecalData::M_Transform' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_DecalData, M_DecalSize) == 0x000030, "Member 'FStatusCharaCopyData_DecalData::M_DecalSize' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_DecalData, M_Material) == 0x000040, "Member 'FStatusCharaCopyData_DecalData::M_Material' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData_DecalData, M_AttachSocketName) == 0x000068, "Member 'FStatusCharaCopyData_DecalData::M_AttachSocketName' has a wrong offset!");

// ScriptStruct Project.StatusCharaCopyData
// 0x0128 (0x0130 - 0x0008)
struct FStatusCharaCopyData final : public FTableRowBase
{
public:
	int32                                         M_DevilID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatusCharaCopyData_MeshData          M_MeshData;                                        // 0x0010(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FStatusCharaCopyData_ParticleData> M_ParticleData;                                    // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FStatusCharaCopyData_PointLightData    M_PointLight;                                      // 0x00A0(0x0070)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FStatusCharaCopyData_DecalData> M_DecalData;                                       // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_NkmScale;                                        // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0xC];                                      // 0x0124(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusCharaCopyData) == 0x000010, "Wrong alignment on FStatusCharaCopyData");
static_assert(sizeof(FStatusCharaCopyData) == 0x000130, "Wrong size on FStatusCharaCopyData");
static_assert(offsetof(FStatusCharaCopyData, M_DevilID) == 0x000008, "Member 'FStatusCharaCopyData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData, M_MeshData) == 0x000010, "Member 'FStatusCharaCopyData::M_MeshData' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData, M_ParticleData) == 0x000090, "Member 'FStatusCharaCopyData::M_ParticleData' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData, M_PointLight) == 0x0000A0, "Member 'FStatusCharaCopyData::M_PointLight' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData, M_DecalData) == 0x000110, "Member 'FStatusCharaCopyData::M_DecalData' has a wrong offset!");
static_assert(offsetof(FStatusCharaCopyData, M_NkmScale) == 0x000120, "Member 'FStatusCharaCopyData::M_NkmScale' has a wrong offset!");

// ScriptStruct Project.BtlAISkillData
// 0x0008 (0x0008 - 0x0000)
struct FBtlAISkillData final
{
public:
	int32                                         M_SkillId;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillPerc;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlAISkillData) == 0x000004, "Wrong alignment on FBtlAISkillData");
static_assert(sizeof(FBtlAISkillData) == 0x000008, "Wrong size on FBtlAISkillData");
static_assert(offsetof(FBtlAISkillData, M_SkillId) == 0x000000, "Member 'FBtlAISkillData::M_SkillId' has a wrong offset!");
static_assert(offsetof(FBtlAISkillData, M_SkillPerc) == 0x000004, "Member 'FBtlAISkillData::M_SkillPerc' has a wrong offset!");

// ScriptStruct Project.SkillCriticalValueOne
// 0x0078 (0x0078 - 0x0000)
struct FSkillCriticalValueOne final
{
public:
	TArray<int32>                                 M_SkillId;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_Value;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_Cost;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_IsSkillCost;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_Valid;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_IsYugamiTarget;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_NotNkmCost;                                      // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_TargetIndex;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillCriticalValueOne) == 0x000008, "Wrong alignment on FSkillCriticalValueOne");
static_assert(sizeof(FSkillCriticalValueOne) == 0x000078, "Wrong size on FSkillCriticalValueOne");
static_assert(offsetof(FSkillCriticalValueOne, M_SkillId) == 0x000000, "Member 'FSkillCriticalValueOne::M_SkillId' has a wrong offset!");
static_assert(offsetof(FSkillCriticalValueOne, M_Value) == 0x000010, "Member 'FSkillCriticalValueOne::M_Value' has a wrong offset!");
static_assert(offsetof(FSkillCriticalValueOne, M_Cost) == 0x000020, "Member 'FSkillCriticalValueOne::M_Cost' has a wrong offset!");
static_assert(offsetof(FSkillCriticalValueOne, M_IsSkillCost) == 0x000030, "Member 'FSkillCriticalValueOne::M_IsSkillCost' has a wrong offset!");
static_assert(offsetof(FSkillCriticalValueOne, M_Valid) == 0x000040, "Member 'FSkillCriticalValueOne::M_Valid' has a wrong offset!");
static_assert(offsetof(FSkillCriticalValueOne, M_IsYugamiTarget) == 0x000050, "Member 'FSkillCriticalValueOne::M_IsYugamiTarget' has a wrong offset!");
static_assert(offsetof(FSkillCriticalValueOne, M_NotNkmCost) == 0x000060, "Member 'FSkillCriticalValueOne::M_NotNkmCost' has a wrong offset!");
static_assert(offsetof(FSkillCriticalValueOne, M_TargetIndex) == 0x000070, "Member 'FSkillCriticalValueOne::M_TargetIndex' has a wrong offset!");

// ScriptStruct Project.TalkUniqueSkillDevilTransformTableRow
// 0x0020 (0x0028 - 0x0008)
struct FTalkUniqueSkillDevilTransformTableRow final : public FTableRowBase
{
public:
	int32                                         DevilID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocX;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocY;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocZ;                                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotX;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotY;                                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotZ;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkUniqueSkillDevilTransformTableRow) == 0x000008, "Wrong alignment on FTalkUniqueSkillDevilTransformTableRow");
static_assert(sizeof(FTalkUniqueSkillDevilTransformTableRow) == 0x000028, "Wrong size on FTalkUniqueSkillDevilTransformTableRow");
static_assert(offsetof(FTalkUniqueSkillDevilTransformTableRow, DevilID) == 0x000008, "Member 'FTalkUniqueSkillDevilTransformTableRow::DevilID' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillDevilTransformTableRow, LocX) == 0x00000C, "Member 'FTalkUniqueSkillDevilTransformTableRow::LocX' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillDevilTransformTableRow, LocY) == 0x000010, "Member 'FTalkUniqueSkillDevilTransformTableRow::LocY' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillDevilTransformTableRow, LocZ) == 0x000014, "Member 'FTalkUniqueSkillDevilTransformTableRow::LocZ' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillDevilTransformTableRow, RotX) == 0x000018, "Member 'FTalkUniqueSkillDevilTransformTableRow::RotX' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillDevilTransformTableRow, RotY) == 0x00001C, "Member 'FTalkUniqueSkillDevilTransformTableRow::RotY' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillDevilTransformTableRow, RotZ) == 0x000020, "Member 'FTalkUniqueSkillDevilTransformTableRow::RotZ' has a wrong offset!");

// ScriptStruct Project.BtlAttack
// 0x0080 (0x0080 - 0x0000)
struct FBtlAttack final
{
public:
	E_SKILL_TARGET                                M_AttackArea;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AttackAttr;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_ATTRIBUTE_TYPE                              M_AttackAttribute;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_SKILL_TYPE                                  M_AttackKind;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AttackHit;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AttackCoe;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_WeaponPower;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CriticalRate;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CriticalAdd;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AttrRate_Low;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AttrRate_Chaos;                                  // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AttrRate_Neutral;                                // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AttackBst;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AttackBstHit;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_RecBst;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_VertigoBstHit;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NormalAttackType;                                // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Skill;                                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Item;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_TARGET_TYPE                             M_TargetAll;                                       // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_DrainHp;                                         // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_DrainMp;                                         // 0x003E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Min;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Max;                                             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BstCntPower;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BstPowerRate;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsWeakHit;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsNotCounter;                                    // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<E_SKILL_EXTRA_EFFECT>                  M_ExtraEffect;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<E_ATTRIBUTE_TYPE>                      M_AtkAttr;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         M_Kantuu;                                          // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlAttack) == 0x000008, "Wrong alignment on FBtlAttack");
static_assert(sizeof(FBtlAttack) == 0x000080, "Wrong size on FBtlAttack");
static_assert(offsetof(FBtlAttack, M_AttackArea) == 0x000000, "Member 'FBtlAttack::M_AttackArea' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttackAttr) == 0x000004, "Member 'FBtlAttack::M_AttackAttr' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttackAttribute) == 0x000008, "Member 'FBtlAttack::M_AttackAttribute' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttackKind) == 0x000009, "Member 'FBtlAttack::M_AttackKind' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttackHit) == 0x00000C, "Member 'FBtlAttack::M_AttackHit' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttackCoe) == 0x000010, "Member 'FBtlAttack::M_AttackCoe' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_WeaponPower) == 0x000014, "Member 'FBtlAttack::M_WeaponPower' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_CriticalRate) == 0x000018, "Member 'FBtlAttack::M_CriticalRate' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_CriticalAdd) == 0x00001C, "Member 'FBtlAttack::M_CriticalAdd' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttrRate_Low) == 0x000020, "Member 'FBtlAttack::M_AttrRate_Low' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttrRate_Chaos) == 0x000021, "Member 'FBtlAttack::M_AttrRate_Chaos' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttrRate_Neutral) == 0x000022, "Member 'FBtlAttack::M_AttrRate_Neutral' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttackBst) == 0x000024, "Member 'FBtlAttack::M_AttackBst' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AttackBstHit) == 0x000028, "Member 'FBtlAttack::M_AttackBstHit' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_RecBst) == 0x00002C, "Member 'FBtlAttack::M_RecBst' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_VertigoBstHit) == 0x000030, "Member 'FBtlAttack::M_VertigoBstHit' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_NormalAttackType) == 0x000031, "Member 'FBtlAttack::M_NormalAttackType' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_Skill) == 0x000034, "Member 'FBtlAttack::M_Skill' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_Item) == 0x000038, "Member 'FBtlAttack::M_Item' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_TargetAll) == 0x00003C, "Member 'FBtlAttack::M_TargetAll' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_DrainHp) == 0x00003D, "Member 'FBtlAttack::M_DrainHp' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_DrainMp) == 0x00003E, "Member 'FBtlAttack::M_DrainMp' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_Min) == 0x000040, "Member 'FBtlAttack::M_Min' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_Max) == 0x000044, "Member 'FBtlAttack::M_Max' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_BstCntPower) == 0x000048, "Member 'FBtlAttack::M_BstCntPower' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_BstPowerRate) == 0x00004C, "Member 'FBtlAttack::M_BstPowerRate' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_IsWeakHit) == 0x000050, "Member 'FBtlAttack::M_IsWeakHit' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_IsNotCounter) == 0x000051, "Member 'FBtlAttack::M_IsNotCounter' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_ExtraEffect) == 0x000058, "Member 'FBtlAttack::M_ExtraEffect' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_AtkAttr) == 0x000068, "Member 'FBtlAttack::M_AtkAttr' has a wrong offset!");
static_assert(offsetof(FBtlAttack, M_Kantuu) == 0x000078, "Member 'FBtlAttack::M_Kantuu' has a wrong offset!");

// ScriptStruct Project.BattleBossFlagData
// 0x0018 (0x0018 - 0x0000)
struct FBattleBossFlagData final
{
public:
	int32                                         M_DevilID;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_Flag;                                            // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleBossFlagData) == 0x000008, "Wrong alignment on FBattleBossFlagData");
static_assert(sizeof(FBattleBossFlagData) == 0x000018, "Wrong size on FBattleBossFlagData");
static_assert(offsetof(FBattleBossFlagData, M_DevilID) == 0x000000, "Member 'FBattleBossFlagData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FBattleBossFlagData, M_Flag) == 0x000008, "Member 'FBattleBossFlagData::M_Flag' has a wrong offset!");

// ScriptStruct Project.TakaraItemList
// 0x000C (0x000C - 0x0000)
struct FTakaraItemList final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Num;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Makka;                                           // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTakaraItemList) == 0x000004, "Wrong alignment on FTakaraItemList");
static_assert(sizeof(FTakaraItemList) == 0x00000C, "Wrong size on FTakaraItemList");
static_assert(offsetof(FTakaraItemList, M_ItemID) == 0x000000, "Member 'FTakaraItemList::M_ItemID' has a wrong offset!");
static_assert(offsetof(FTakaraItemList, M_Num) == 0x000004, "Member 'FTakaraItemList::M_Num' has a wrong offset!");
static_assert(offsetof(FTakaraItemList, M_Makka) == 0x000008, "Member 'FTakaraItemList::M_Makka' has a wrong offset!");

// ScriptStruct Project.TakaraData
// 0x0024 (0x0024 - 0x0000)
struct FTakaraData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TakaraID;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StartFlag;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndFlag;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AfterFlag;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTakaraItemList                        M_ItemList;                                        // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         M_SimpleEventFlag;                                 // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTakaraData) == 0x000004, "Wrong alignment on FTakaraData");
static_assert(sizeof(FTakaraData) == 0x000024, "Wrong size on FTakaraData");
static_assert(offsetof(FTakaraData, M_MapID) == 0x000000, "Member 'FTakaraData::M_MapID' has a wrong offset!");
static_assert(offsetof(FTakaraData, M_TakaraID) == 0x000004, "Member 'FTakaraData::M_TakaraID' has a wrong offset!");
static_assert(offsetof(FTakaraData, M_StartFlag) == 0x000008, "Member 'FTakaraData::M_StartFlag' has a wrong offset!");
static_assert(offsetof(FTakaraData, M_EndFlag) == 0x00000C, "Member 'FTakaraData::M_EndFlag' has a wrong offset!");
static_assert(offsetof(FTakaraData, M_AfterFlag) == 0x000010, "Member 'FTakaraData::M_AfterFlag' has a wrong offset!");
static_assert(offsetof(FTakaraData, M_ItemList) == 0x000014, "Member 'FTakaraData::M_ItemList' has a wrong offset!");
static_assert(offsetof(FTakaraData, M_SimpleEventFlag) == 0x000020, "Member 'FTakaraData::M_SimpleEventFlag' has a wrong offset!");

// ScriptStruct Project.UpliftingGaugeType
// 0x0008 (0x0008 - 0x0000)
struct FUpliftingGaugeType final
{
public:
	int32                                         M_Value;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RandValue;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpliftingGaugeType) == 0x000004, "Wrong alignment on FUpliftingGaugeType");
static_assert(sizeof(FUpliftingGaugeType) == 0x000008, "Wrong size on FUpliftingGaugeType");
static_assert(offsetof(FUpliftingGaugeType, M_Value) == 0x000000, "Member 'FUpliftingGaugeType::M_Value' has a wrong offset!");
static_assert(offsetof(FUpliftingGaugeType, M_RandValue) == 0x000004, "Member 'FUpliftingGaugeType::M_RandValue' has a wrong offset!");

// ScriptStruct Project.BattleEventCond
// 0x0008 (0x0008 - 0x0000)
struct FBattleEventCond final
{
public:
	E_BTL_EVT_COND                                M_CondType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Value;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleEventCond) == 0x000004, "Wrong alignment on FBattleEventCond");
static_assert(sizeof(FBattleEventCond) == 0x000008, "Wrong size on FBattleEventCond");
static_assert(offsetof(FBattleEventCond, M_CondType) == 0x000000, "Member 'FBattleEventCond::M_CondType' has a wrong offset!");
static_assert(offsetof(FBattleEventCond, M_Value) == 0x000004, "Member 'FBattleEventCond::M_Value' has a wrong offset!");

// ScriptStruct Project.BattleEventData
// 0x0040 (0x0040 - 0x0000)
struct FBattleEventData final
{
public:
	class FText                                   M_CallSubLevelName;                                // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         M_EventBattleID;                                   // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TableID;                                         // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_EVT_TYPE                                M_EvtType;                                         // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_EVT_RESULT                              M_EndType;                                         // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_EVT_POINT                               M_HookPoint;                                       // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_CallSubLevelID;                                  // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NextEventBattleID;                               // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBattleEventCond>               M_Condition;                                       // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleEventData) == 0x000008, "Wrong alignment on FBattleEventData");
static_assert(sizeof(FBattleEventData) == 0x000040, "Wrong size on FBattleEventData");
static_assert(offsetof(FBattleEventData, M_CallSubLevelName) == 0x000000, "Member 'FBattleEventData::M_CallSubLevelName' has a wrong offset!");
static_assert(offsetof(FBattleEventData, M_EventBattleID) == 0x000018, "Member 'FBattleEventData::M_EventBattleID' has a wrong offset!");
static_assert(offsetof(FBattleEventData, M_TableID) == 0x00001C, "Member 'FBattleEventData::M_TableID' has a wrong offset!");
static_assert(offsetof(FBattleEventData, M_EvtType) == 0x000020, "Member 'FBattleEventData::M_EvtType' has a wrong offset!");
static_assert(offsetof(FBattleEventData, M_EndType) == 0x000021, "Member 'FBattleEventData::M_EndType' has a wrong offset!");
static_assert(offsetof(FBattleEventData, M_HookPoint) == 0x000022, "Member 'FBattleEventData::M_HookPoint' has a wrong offset!");
static_assert(offsetof(FBattleEventData, M_CallSubLevelID) == 0x000024, "Member 'FBattleEventData::M_CallSubLevelID' has a wrong offset!");
static_assert(offsetof(FBattleEventData, M_NextEventBattleID) == 0x000028, "Member 'FBattleEventData::M_NextEventBattleID' has a wrong offset!");
static_assert(offsetof(FBattleEventData, M_Condition) == 0x000030, "Member 'FBattleEventData::M_Condition' has a wrong offset!");

// ScriptStruct Project.StatusDefenceAishou
// 0x000C (0x000C - 0x0000)
struct FStatusDefenceAishou final
{
public:
	E_ATTRIBUTE_TYPE                              M_AttrType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Param;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BuildParam;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusDefenceAishou) == 0x000004, "Wrong alignment on FStatusDefenceAishou");
static_assert(sizeof(FStatusDefenceAishou) == 0x00000C, "Wrong size on FStatusDefenceAishou");
static_assert(offsetof(FStatusDefenceAishou, M_AttrType) == 0x000000, "Member 'FStatusDefenceAishou::M_AttrType' has a wrong offset!");
static_assert(offsetof(FStatusDefenceAishou, M_Param) == 0x000004, "Member 'FStatusDefenceAishou::M_Param' has a wrong offset!");
static_assert(offsetof(FStatusDefenceAishou, M_BuildParam) == 0x000008, "Member 'FStatusDefenceAishou::M_BuildParam' has a wrong offset!");

// ScriptStruct Project.KuishibariRequirementsSkillData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FKuishibariRequirementsSkillData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKuishibariRequirementsSkillData) == 0x000004, "Wrong alignment on FKuishibariRequirementsSkillData");
static_assert(sizeof(FKuishibariRequirementsSkillData) == 0x00000C, "Wrong size on FKuishibariRequirementsSkillData");

// ScriptStruct Project.TalkQuizCameraTableRow
// 0x0020 (0x0028 - 0x0008)
struct FTalkQuizCameraTableRow final : public FTableRowBase
{
public:
	int32                                         DevilID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocX;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocY;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocZ;                                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotX;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotY;                                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotZ;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkQuizCameraTableRow) == 0x000008, "Wrong alignment on FTalkQuizCameraTableRow");
static_assert(sizeof(FTalkQuizCameraTableRow) == 0x000028, "Wrong size on FTalkQuizCameraTableRow");
static_assert(offsetof(FTalkQuizCameraTableRow, DevilID) == 0x000008, "Member 'FTalkQuizCameraTableRow::DevilID' has a wrong offset!");
static_assert(offsetof(FTalkQuizCameraTableRow, LocX) == 0x00000C, "Member 'FTalkQuizCameraTableRow::LocX' has a wrong offset!");
static_assert(offsetof(FTalkQuizCameraTableRow, LocY) == 0x000010, "Member 'FTalkQuizCameraTableRow::LocY' has a wrong offset!");
static_assert(offsetof(FTalkQuizCameraTableRow, LocZ) == 0x000014, "Member 'FTalkQuizCameraTableRow::LocZ' has a wrong offset!");
static_assert(offsetof(FTalkQuizCameraTableRow, RotX) == 0x000018, "Member 'FTalkQuizCameraTableRow::RotX' has a wrong offset!");
static_assert(offsetof(FTalkQuizCameraTableRow, RotY) == 0x00001C, "Member 'FTalkQuizCameraTableRow::RotY' has a wrong offset!");
static_assert(offsetof(FTalkQuizCameraTableRow, RotZ) == 0x000020, "Member 'FTalkQuizCameraTableRow::RotZ' has a wrong offset!");

// ScriptStruct Project.MitamaAnalyzeData
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FMitamaAnalyzeData final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMitamaAnalyzeData) == 0x000008, "Wrong alignment on FMitamaAnalyzeData");
static_assert(sizeof(FMitamaAnalyzeData) == 0x000058, "Wrong size on FMitamaAnalyzeData");

// ScriptStruct Project.PrevSkillArray
// 0x0010 (0x0010 - 0x0000)
struct FPrevSkillArray final
{
public:
	TArray<int32>                                 M_SkillIDArray;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrevSkillArray) == 0x000008, "Wrong alignment on FPrevSkillArray");
static_assert(sizeof(FPrevSkillArray) == 0x000010, "Wrong size on FPrevSkillArray");
static_assert(offsetof(FPrevSkillArray, M_SkillIDArray) == 0x000000, "Member 'FPrevSkillArray::M_SkillIDArray' has a wrong offset!");

// ScriptStruct Project.TalkMoonTemperTable
// 0x0003 (0x0003 - 0x0000)
struct FTalkMoonTemperTable final
{
public:
	E_TALK_MOON_TEMPER_DATA                       M_MoonTemper;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDevilTalkVoice                               M_NGVoice;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CHARA_MOTION_ID                             M_NGMotion;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkMoonTemperTable) == 0x000001, "Wrong alignment on FTalkMoonTemperTable");
static_assert(sizeof(FTalkMoonTemperTable) == 0x000003, "Wrong size on FTalkMoonTemperTable");
static_assert(offsetof(FTalkMoonTemperTable, M_MoonTemper) == 0x000000, "Member 'FTalkMoonTemperTable::M_MoonTemper' has a wrong offset!");
static_assert(offsetof(FTalkMoonTemperTable, M_NGVoice) == 0x000001, "Member 'FTalkMoonTemperTable::M_NGVoice' has a wrong offset!");
static_assert(offsetof(FTalkMoonTemperTable, M_NGMotion) == 0x000002, "Member 'FTalkMoonTemperTable::M_NGMotion' has a wrong offset!");

// ScriptStruct Project.BtlKuishibariData
// 0x0018 (0x0018 - 0x0000)
struct FBtlKuishibariData final
{
public:
	E_BTL_CHAR_TYPE                               M_CharType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Id;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_CheckUseArray;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlKuishibariData) == 0x000008, "Wrong alignment on FBtlKuishibariData");
static_assert(sizeof(FBtlKuishibariData) == 0x000018, "Wrong size on FBtlKuishibariData");
static_assert(offsetof(FBtlKuishibariData, M_CharType) == 0x000000, "Member 'FBtlKuishibariData::M_CharType' has a wrong offset!");
static_assert(offsetof(FBtlKuishibariData, M_Id) == 0x000004, "Member 'FBtlKuishibariData::M_Id' has a wrong offset!");
static_assert(offsetof(FBtlKuishibariData, M_CheckUseArray) == 0x000008, "Member 'FBtlKuishibariData::M_CheckUseArray' has a wrong offset!");

// ScriptStruct Project.BattleUnitPlaceOne
// 0x0028 (0x0028 - 0x0000)
struct FBattleUnitPlaceOne
{
public:
	int32                                         M_DevilID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_PostArray;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_VerticalGrid;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HorizontalGrid;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TallMax;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BeforeAreaIndex;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleUnitPlaceOne) == 0x000008, "Wrong alignment on FBattleUnitPlaceOne");
static_assert(sizeof(FBattleUnitPlaceOne) == 0x000028, "Wrong size on FBattleUnitPlaceOne");
static_assert(offsetof(FBattleUnitPlaceOne, M_DevilID) == 0x000000, "Member 'FBattleUnitPlaceOne::M_DevilID' has a wrong offset!");
static_assert(offsetof(FBattleUnitPlaceOne, M_PostArray) == 0x000008, "Member 'FBattleUnitPlaceOne::M_PostArray' has a wrong offset!");
static_assert(offsetof(FBattleUnitPlaceOne, M_VerticalGrid) == 0x000018, "Member 'FBattleUnitPlaceOne::M_VerticalGrid' has a wrong offset!");
static_assert(offsetof(FBattleUnitPlaceOne, M_HorizontalGrid) == 0x00001C, "Member 'FBattleUnitPlaceOne::M_HorizontalGrid' has a wrong offset!");
static_assert(offsetof(FBattleUnitPlaceOne, M_TallMax) == 0x000020, "Member 'FBattleUnitPlaceOne::M_TallMax' has a wrong offset!");
static_assert(offsetof(FBattleUnitPlaceOne, M_BeforeAreaIndex) == 0x000024, "Member 'FBattleUnitPlaceOne::M_BeforeAreaIndex' has a wrong offset!");

// ScriptStruct Project.TalkStartInfo
// 0x000C (0x000C - 0x0000)
struct FTalkStartInfo final
{
public:
	int32                                         M_DevilID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DevilIndex;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_START_TYPE                             M_StartType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkStartInfo) == 0x000004, "Wrong alignment on FTalkStartInfo");
static_assert(sizeof(FTalkStartInfo) == 0x00000C, "Wrong size on FTalkStartInfo");
static_assert(offsetof(FTalkStartInfo, M_DevilID) == 0x000000, "Member 'FTalkStartInfo::M_DevilID' has a wrong offset!");
static_assert(offsetof(FTalkStartInfo, M_DevilIndex) == 0x000004, "Member 'FTalkStartInfo::M_DevilIndex' has a wrong offset!");
static_assert(offsetof(FTalkStartInfo, M_StartType) == 0x000008, "Member 'FTalkStartInfo::M_StartType' has a wrong offset!");

// ScriptStruct Project.BattleUnitPlaceOneExtend
// 0x0010 (0x0038 - 0x0028)
struct FBattleUnitPlaceOneExtend final : public FBattleUnitPlaceOne
{
public:
	int32                                         M_Vertical;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Horizontal;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Tall;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleUnitPlaceOneExtend) == 0x000008, "Wrong alignment on FBattleUnitPlaceOneExtend");
static_assert(sizeof(FBattleUnitPlaceOneExtend) == 0x000038, "Wrong size on FBattleUnitPlaceOneExtend");
static_assert(offsetof(FBattleUnitPlaceOneExtend, M_Vertical) == 0x000028, "Member 'FBattleUnitPlaceOneExtend::M_Vertical' has a wrong offset!");
static_assert(offsetof(FBattleUnitPlaceOneExtend, M_Horizontal) == 0x00002C, "Member 'FBattleUnitPlaceOneExtend::M_Horizontal' has a wrong offset!");
static_assert(offsetof(FBattleUnitPlaceOneExtend, M_Tall) == 0x000030, "Member 'FBattleUnitPlaceOneExtend::M_Tall' has a wrong offset!");

// ScriptStruct Project.BtlResultMakkaData
// 0x0008 (0x0008 - 0x0000)
struct FBtlResultMakkaData final
{
public:
	int32                                         M_PreMakka;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GetMakka;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlResultMakkaData) == 0x000004, "Wrong alignment on FBtlResultMakkaData");
static_assert(sizeof(FBtlResultMakkaData) == 0x000008, "Wrong size on FBtlResultMakkaData");
static_assert(offsetof(FBtlResultMakkaData, M_PreMakka) == 0x000000, "Member 'FBtlResultMakkaData::M_PreMakka' has a wrong offset!");
static_assert(offsetof(FBtlResultMakkaData, M_GetMakka) == 0x000004, "Member 'FBtlResultMakkaData::M_GetMakka' has a wrong offset!");

// ScriptStruct Project.BtlCommand
// 0x0010 (0x0010 - 0x0000)
struct FBtlCommand final
{
public:
	E_BTL_COMM_TYPE                               M_Command;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_WEAPON_TYPE                             M_Index;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_AREA_TYPE                               M_TargetArea;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_TargetForm;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillId;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Turn;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlCommand) == 0x000004, "Wrong alignment on FBtlCommand");
static_assert(sizeof(FBtlCommand) == 0x000010, "Wrong size on FBtlCommand");
static_assert(offsetof(FBtlCommand, M_Command) == 0x000000, "Member 'FBtlCommand::M_Command' has a wrong offset!");
static_assert(offsetof(FBtlCommand, M_Index) == 0x000001, "Member 'FBtlCommand::M_Index' has a wrong offset!");
static_assert(offsetof(FBtlCommand, M_TargetArea) == 0x000002, "Member 'FBtlCommand::M_TargetArea' has a wrong offset!");
static_assert(offsetof(FBtlCommand, M_TargetForm) == 0x000004, "Member 'FBtlCommand::M_TargetForm' has a wrong offset!");
static_assert(offsetof(FBtlCommand, M_SkillId) == 0x000008, "Member 'FBtlCommand::M_SkillId' has a wrong offset!");
static_assert(offsetof(FBtlCommand, M_Turn) == 0x00000C, "Member 'FBtlCommand::M_Turn' has a wrong offset!");

// ScriptStruct Project.BtlCharData
// 0x0148 (0x0148 - 0x0000)
struct FBtlCharData final
{
public:
	class FText                                   M_Name;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	E_BTL_CHAR_TYPE                               M_CharType;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Flag;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Id;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StockIndex;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBtlParamData                          M_BaseParam;                                       // 0x0028(0x0024)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBtlParamData                          M_SkillParam;                                      // 0x004C(0x0024)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         M_Status;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ReqStatus;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ReqDelStatus;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Level;                                           // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OrderAgi;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Attr;                                            // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_DeathAddPerc;                                    // 0x0085(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UnionCnt;                                        // 0x0086(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AtkRate;                                         // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBtlCommand                            M_NowCmd;                                          // 0x008C(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBtlCommand>                    M_PrevCmd;                                         // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_Skill;                                           // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_UniqueSkill;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_SkilMoonAgeTurn;                                 // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_BaseDefenceAishou;                               // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_SkillDefenceAishou;                              // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_ApplyBarrierDefenceAishou;                       // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_BaseTekisei;                                     // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_SkillTekisei;                                    // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_UniqueSkillTekisei;                              // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_Uplifting;                                       // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Electrification;                                 // 0x0139(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Down;                                            // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_MOON_TEMPER_DATA                       M_MoonTemperData;                                  // 0x013B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_MOON_TEMPER_STATUS                     M_MoonTemperStatus;                                // 0x013C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_PrevHP;                                          // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SwapSkillID;                                     // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlCharData) == 0x000008, "Wrong alignment on FBtlCharData");
static_assert(sizeof(FBtlCharData) == 0x000148, "Wrong size on FBtlCharData");
static_assert(offsetof(FBtlCharData, M_Name) == 0x000000, "Member 'FBtlCharData::M_Name' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_CharType) == 0x000018, "Member 'FBtlCharData::M_CharType' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_Flag) == 0x00001C, "Member 'FBtlCharData::M_Flag' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_Id) == 0x000020, "Member 'FBtlCharData::M_Id' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_StockIndex) == 0x000024, "Member 'FBtlCharData::M_StockIndex' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_BaseParam) == 0x000028, "Member 'FBtlCharData::M_BaseParam' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_SkillParam) == 0x00004C, "Member 'FBtlCharData::M_SkillParam' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_Status) == 0x000070, "Member 'FBtlCharData::M_Status' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_ReqStatus) == 0x000074, "Member 'FBtlCharData::M_ReqStatus' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_ReqDelStatus) == 0x000078, "Member 'FBtlCharData::M_ReqDelStatus' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_Level) == 0x00007C, "Member 'FBtlCharData::M_Level' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_OrderAgi) == 0x000080, "Member 'FBtlCharData::M_OrderAgi' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_Attr) == 0x000084, "Member 'FBtlCharData::M_Attr' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_DeathAddPerc) == 0x000085, "Member 'FBtlCharData::M_DeathAddPerc' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_UnionCnt) == 0x000086, "Member 'FBtlCharData::M_UnionCnt' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_AtkRate) == 0x000088, "Member 'FBtlCharData::M_AtkRate' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_NowCmd) == 0x00008C, "Member 'FBtlCharData::M_NowCmd' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_PrevCmd) == 0x0000A0, "Member 'FBtlCharData::M_PrevCmd' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_Skill) == 0x0000B0, "Member 'FBtlCharData::M_Skill' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_UniqueSkill) == 0x0000C0, "Member 'FBtlCharData::M_UniqueSkill' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_SkilMoonAgeTurn) == 0x0000C8, "Member 'FBtlCharData::M_SkilMoonAgeTurn' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_BaseDefenceAishou) == 0x0000D8, "Member 'FBtlCharData::M_BaseDefenceAishou' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_SkillDefenceAishou) == 0x0000E8, "Member 'FBtlCharData::M_SkillDefenceAishou' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_ApplyBarrierDefenceAishou) == 0x0000F8, "Member 'FBtlCharData::M_ApplyBarrierDefenceAishou' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_BaseTekisei) == 0x000108, "Member 'FBtlCharData::M_BaseTekisei' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_SkillTekisei) == 0x000118, "Member 'FBtlCharData::M_SkillTekisei' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_UniqueSkillTekisei) == 0x000128, "Member 'FBtlCharData::M_UniqueSkillTekisei' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_Uplifting) == 0x000138, "Member 'FBtlCharData::M_Uplifting' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_Electrification) == 0x000139, "Member 'FBtlCharData::M_Electrification' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_Down) == 0x00013A, "Member 'FBtlCharData::M_Down' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_MoonTemperData) == 0x00013B, "Member 'FBtlCharData::M_MoonTemperData' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_MoonTemperStatus) == 0x00013C, "Member 'FBtlCharData::M_MoonTemperStatus' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_PrevHP) == 0x000140, "Member 'FBtlCharData::M_PrevHP' has a wrong offset!");
static_assert(offsetof(FBtlCharData, M_SwapSkillID) == 0x000144, "Member 'FBtlCharData::M_SwapSkillID' has a wrong offset!");

// ScriptStruct Project.BtlAnalyzeData
// 0x0050 (0x0050 - 0x0000)
struct FBtlAnalyzeData final
{
public:
	bool                                          M_IsOpenAnalyze;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  M_IsOpenDefenceAishou;                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_IsOpenSkillTekisei;                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_IsOpenSkill;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_IsOpenMagatsuhiSkill;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_IsOpenUniqueSkill;                               // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlAnalyzeData) == 0x000008, "Wrong alignment on FBtlAnalyzeData");
static_assert(sizeof(FBtlAnalyzeData) == 0x000050, "Wrong size on FBtlAnalyzeData");
static_assert(offsetof(FBtlAnalyzeData, M_IsOpenAnalyze) == 0x000000, "Member 'FBtlAnalyzeData::M_IsOpenAnalyze' has a wrong offset!");
static_assert(offsetof(FBtlAnalyzeData, M_IsOpenDefenceAishou) == 0x000008, "Member 'FBtlAnalyzeData::M_IsOpenDefenceAishou' has a wrong offset!");
static_assert(offsetof(FBtlAnalyzeData, M_IsOpenSkillTekisei) == 0x000018, "Member 'FBtlAnalyzeData::M_IsOpenSkillTekisei' has a wrong offset!");
static_assert(offsetof(FBtlAnalyzeData, M_IsOpenSkill) == 0x000028, "Member 'FBtlAnalyzeData::M_IsOpenSkill' has a wrong offset!");
static_assert(offsetof(FBtlAnalyzeData, M_IsOpenMagatsuhiSkill) == 0x000038, "Member 'FBtlAnalyzeData::M_IsOpenMagatsuhiSkill' has a wrong offset!");
static_assert(offsetof(FBtlAnalyzeData, M_IsOpenUniqueSkill) == 0x000048, "Member 'FBtlAnalyzeData::M_IsOpenUniqueSkill' has a wrong offset!");

// ScriptStruct Project.BtlPrevTurnInfo
// 0x0058 (0x0058 - 0x0000)
struct FBtlPrevTurnInfo final
{
public:
	int32                                         M_MinusDamageNum;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  M_RefAttrArray;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_AbsAttrArray;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_BlockAttrArray;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_AttrDamagedArray;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_WeakDamagedArray;                                // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlPrevTurnInfo) == 0x000008, "Wrong alignment on FBtlPrevTurnInfo");
static_assert(sizeof(FBtlPrevTurnInfo) == 0x000058, "Wrong size on FBtlPrevTurnInfo");
static_assert(offsetof(FBtlPrevTurnInfo, M_MinusDamageNum) == 0x000000, "Member 'FBtlPrevTurnInfo::M_MinusDamageNum' has a wrong offset!");
static_assert(offsetof(FBtlPrevTurnInfo, M_RefAttrArray) == 0x000008, "Member 'FBtlPrevTurnInfo::M_RefAttrArray' has a wrong offset!");
static_assert(offsetof(FBtlPrevTurnInfo, M_AbsAttrArray) == 0x000018, "Member 'FBtlPrevTurnInfo::M_AbsAttrArray' has a wrong offset!");
static_assert(offsetof(FBtlPrevTurnInfo, M_BlockAttrArray) == 0x000028, "Member 'FBtlPrevTurnInfo::M_BlockAttrArray' has a wrong offset!");
static_assert(offsetof(FBtlPrevTurnInfo, M_AttrDamagedArray) == 0x000038, "Member 'FBtlPrevTurnInfo::M_AttrDamagedArray' has a wrong offset!");
static_assert(offsetof(FBtlPrevTurnInfo, M_WeakDamagedArray) == 0x000048, "Member 'FBtlPrevTurnInfo::M_WeakDamagedArray' has a wrong offset!");

// ScriptStruct Project.BtlParty
// 0x0320 (0x0320 - 0x0000)
struct FBtlParty final
{
public:
	int32                                         M_Flag;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Flag2;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BehaviorFlag;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PartyIndex;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CounterSkill;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CounterAutoSkill;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PrevCounterAutoSkill;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AnalyzeCounterAutoSkill;                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PassiveReflex;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PassiveAbsorb;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PassiveBlock;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_KUISHIBARI_LEVEL                            M_KuiLevel;                                        // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_HPRate;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DmgRate;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GivenItemIdx;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GivenMaka;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ReichiPoint;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BAD_STATUS                                  M_ActEndBy;                                        // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlCharData                           M_CharData;                                        // 0x0048(0x0148)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         M_PlayerIndex;                                     // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NkmIndex;                                        // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ActCounter;                                      // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LocalActNum;                                     // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             M_HomeTransform;                                   // 0x01A0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_HomeTargetLocation;                              // 0x01D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_BAtkExtend;                                      // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_TalkAngry;                                       // 0x01E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_PoisonDamageRate;                                // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_OffsetHitValue;                                  // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CureHPValue;                                     // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CureMPValue;                                     // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPUpValue;                                       // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPUpValueUI;                                     // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BossFlag;                                        // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBtlAnalyzeData                        M_BtlAnalyzeData;                                  // 0x0200(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         M_CharmSkillID;                                    // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BossRushEventEncountlID;                         // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StealDevilID;                                    // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StealMagatsuhiSkill;                             // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_DAMAGE_HIT_TYPE                         M_DamagedHitType;                                  // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_DamagedValue;                                    // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBtlPrevTurnInfo>               M_PrevInfo;                                        // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_Count;                                           // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_TalkCount;                                       // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_GivenItem;                                       // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<E_BTL_CNT, int32>                        M_ConditionMap;                                    // 0x02A8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<E_BTL_SIDE>                            M_AidSide;                                         // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_StealSkill;                                      // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlParty) == 0x000010, "Wrong alignment on FBtlParty");
static_assert(sizeof(FBtlParty) == 0x000320, "Wrong size on FBtlParty");
static_assert(offsetof(FBtlParty, M_Flag) == 0x000000, "Member 'FBtlParty::M_Flag' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_Flag2) == 0x000004, "Member 'FBtlParty::M_Flag2' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_BehaviorFlag) == 0x000008, "Member 'FBtlParty::M_BehaviorFlag' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_PartyIndex) == 0x00000C, "Member 'FBtlParty::M_PartyIndex' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_CounterSkill) == 0x000010, "Member 'FBtlParty::M_CounterSkill' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_CounterAutoSkill) == 0x000014, "Member 'FBtlParty::M_CounterAutoSkill' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_PrevCounterAutoSkill) == 0x000018, "Member 'FBtlParty::M_PrevCounterAutoSkill' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_AnalyzeCounterAutoSkill) == 0x00001C, "Member 'FBtlParty::M_AnalyzeCounterAutoSkill' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_PassiveReflex) == 0x000020, "Member 'FBtlParty::M_PassiveReflex' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_PassiveAbsorb) == 0x000024, "Member 'FBtlParty::M_PassiveAbsorb' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_PassiveBlock) == 0x000028, "Member 'FBtlParty::M_PassiveBlock' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_KuiLevel) == 0x00002C, "Member 'FBtlParty::M_KuiLevel' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_HPRate) == 0x000030, "Member 'FBtlParty::M_HPRate' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_DmgRate) == 0x000034, "Member 'FBtlParty::M_DmgRate' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_GivenItemIdx) == 0x000038, "Member 'FBtlParty::M_GivenItemIdx' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_GivenMaka) == 0x00003C, "Member 'FBtlParty::M_GivenMaka' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_ReichiPoint) == 0x000040, "Member 'FBtlParty::M_ReichiPoint' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_ActEndBy) == 0x000044, "Member 'FBtlParty::M_ActEndBy' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_CharData) == 0x000048, "Member 'FBtlParty::M_CharData' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_PlayerIndex) == 0x000190, "Member 'FBtlParty::M_PlayerIndex' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_NkmIndex) == 0x000194, "Member 'FBtlParty::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_ActCounter) == 0x000198, "Member 'FBtlParty::M_ActCounter' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_LocalActNum) == 0x00019C, "Member 'FBtlParty::M_LocalActNum' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_HomeTransform) == 0x0001A0, "Member 'FBtlParty::M_HomeTransform' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_HomeTargetLocation) == 0x0001D0, "Member 'FBtlParty::M_HomeTargetLocation' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_BAtkExtend) == 0x0001DC, "Member 'FBtlParty::M_BAtkExtend' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_TalkAngry) == 0x0001E0, "Member 'FBtlParty::M_TalkAngry' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_PoisonDamageRate) == 0x0001E4, "Member 'FBtlParty::M_PoisonDamageRate' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_OffsetHitValue) == 0x0001E8, "Member 'FBtlParty::M_OffsetHitValue' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_CureHPValue) == 0x0001EC, "Member 'FBtlParty::M_CureHPValue' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_CureMPValue) == 0x0001F0, "Member 'FBtlParty::M_CureMPValue' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_HPUpValue) == 0x0001F4, "Member 'FBtlParty::M_HPUpValue' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_HPUpValueUI) == 0x0001F8, "Member 'FBtlParty::M_HPUpValueUI' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_BossFlag) == 0x0001FC, "Member 'FBtlParty::M_BossFlag' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_BtlAnalyzeData) == 0x000200, "Member 'FBtlParty::M_BtlAnalyzeData' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_CharmSkillID) == 0x000250, "Member 'FBtlParty::M_CharmSkillID' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_BossRushEventEncountlID) == 0x000254, "Member 'FBtlParty::M_BossRushEventEncountlID' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_StealDevilID) == 0x000258, "Member 'FBtlParty::M_StealDevilID' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_StealMagatsuhiSkill) == 0x00025C, "Member 'FBtlParty::M_StealMagatsuhiSkill' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_DamagedHitType) == 0x000260, "Member 'FBtlParty::M_DamagedHitType' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_DamagedValue) == 0x000264, "Member 'FBtlParty::M_DamagedValue' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_PrevInfo) == 0x000268, "Member 'FBtlParty::M_PrevInfo' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_Count) == 0x000278, "Member 'FBtlParty::M_Count' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_TalkCount) == 0x000288, "Member 'FBtlParty::M_TalkCount' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_GivenItem) == 0x000298, "Member 'FBtlParty::M_GivenItem' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_ConditionMap) == 0x0002A8, "Member 'FBtlParty::M_ConditionMap' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_AidSide) == 0x0002F8, "Member 'FBtlParty::M_AidSide' has a wrong offset!");
static_assert(offsetof(FBtlParty, M_StealSkill) == 0x000308, "Member 'FBtlParty::M_StealSkill' has a wrong offset!");

// ScriptStruct Project.BtlResultCharaData
// 0x0670 (0x0670 - 0x0000)
struct FBtlResultCharaData final
{
public:
	int32                                         M_GetExp;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PreExp;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AfterExp;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlParty                              M_PrePartyData;                                    // 0x0010(0x0320)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBtlParty                              M_AfterPartyData;                                  // 0x0330(0x0320)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_GetSkillArr;                                     // 0x0650(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_GetParamCnt;                                     // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ActionSkillScan;                                 // 0x0664(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsStatusView;                                    // 0x0665(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_666[0xA];                                      // 0x0666(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlResultCharaData) == 0x000010, "Wrong alignment on FBtlResultCharaData");
static_assert(sizeof(FBtlResultCharaData) == 0x000670, "Wrong size on FBtlResultCharaData");
static_assert(offsetof(FBtlResultCharaData, M_GetExp) == 0x000000, "Member 'FBtlResultCharaData::M_GetExp' has a wrong offset!");
static_assert(offsetof(FBtlResultCharaData, M_PreExp) == 0x000004, "Member 'FBtlResultCharaData::M_PreExp' has a wrong offset!");
static_assert(offsetof(FBtlResultCharaData, M_AfterExp) == 0x000008, "Member 'FBtlResultCharaData::M_AfterExp' has a wrong offset!");
static_assert(offsetof(FBtlResultCharaData, M_PrePartyData) == 0x000010, "Member 'FBtlResultCharaData::M_PrePartyData' has a wrong offset!");
static_assert(offsetof(FBtlResultCharaData, M_AfterPartyData) == 0x000330, "Member 'FBtlResultCharaData::M_AfterPartyData' has a wrong offset!");
static_assert(offsetof(FBtlResultCharaData, M_GetSkillArr) == 0x000650, "Member 'FBtlResultCharaData::M_GetSkillArr' has a wrong offset!");
static_assert(offsetof(FBtlResultCharaData, M_GetParamCnt) == 0x000660, "Member 'FBtlResultCharaData::M_GetParamCnt' has a wrong offset!");
static_assert(offsetof(FBtlResultCharaData, M_ActionSkillScan) == 0x000664, "Member 'FBtlResultCharaData::M_ActionSkillScan' has a wrong offset!");
static_assert(offsetof(FBtlResultCharaData, M_IsStatusView) == 0x000665, "Member 'FBtlResultCharaData::M_IsStatusView' has a wrong offset!");

// ScriptStruct Project.BtlResultMessageData
// 0x0018 (0x0018 - 0x0000)
struct FBtlResultMessageData final
{
public:
	TArray<int32>                                 M_GetProperty;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_AddStorage;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AddStockSpace;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlResultMessageData) == 0x000008, "Wrong alignment on FBtlResultMessageData");
static_assert(sizeof(FBtlResultMessageData) == 0x000018, "Wrong size on FBtlResultMessageData");
static_assert(offsetof(FBtlResultMessageData, M_GetProperty) == 0x000000, "Member 'FBtlResultMessageData::M_GetProperty' has a wrong offset!");
static_assert(offsetof(FBtlResultMessageData, M_AddStorage) == 0x000010, "Member 'FBtlResultMessageData::M_AddStorage' has a wrong offset!");
static_assert(offsetof(FBtlResultMessageData, M_AddStockSpace) == 0x000014, "Member 'FBtlResultMessageData::M_AddStockSpace' has a wrong offset!");

// ScriptStruct Project.BtlApllyResultData
// 0x0070 (0x0070 - 0x0000)
struct FBtlApllyResultData final
{
public:
	struct FBtlResultMakkaData                    M_MakkaData;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBtlResultItemData>             M_GetItemData;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBtlResultCharaData>            M_PartyData;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBtlResultCharaData>            M_StockData;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBtlResultCharaData>            M_PartnerData;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBtlResultMessageData                  M_MessData;                                        // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_IsBattleData;                                    // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_RecMagGauge;                                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_END                                     M_BtlEndType;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ChainEncountNum;                                 // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlApllyResultData) == 0x000008, "Wrong alignment on FBtlApllyResultData");
static_assert(sizeof(FBtlApllyResultData) == 0x000070, "Wrong size on FBtlApllyResultData");
static_assert(offsetof(FBtlApllyResultData, M_MakkaData) == 0x000000, "Member 'FBtlApllyResultData::M_MakkaData' has a wrong offset!");
static_assert(offsetof(FBtlApllyResultData, M_GetItemData) == 0x000008, "Member 'FBtlApllyResultData::M_GetItemData' has a wrong offset!");
static_assert(offsetof(FBtlApllyResultData, M_PartyData) == 0x000018, "Member 'FBtlApllyResultData::M_PartyData' has a wrong offset!");
static_assert(offsetof(FBtlApllyResultData, M_StockData) == 0x000028, "Member 'FBtlApllyResultData::M_StockData' has a wrong offset!");
static_assert(offsetof(FBtlApllyResultData, M_PartnerData) == 0x000038, "Member 'FBtlApllyResultData::M_PartnerData' has a wrong offset!");
static_assert(offsetof(FBtlApllyResultData, M_MessData) == 0x000048, "Member 'FBtlApllyResultData::M_MessData' has a wrong offset!");
static_assert(offsetof(FBtlApllyResultData, M_IsBattleData) == 0x000060, "Member 'FBtlApllyResultData::M_IsBattleData' has a wrong offset!");
static_assert(offsetof(FBtlApllyResultData, M_RecMagGauge) == 0x000064, "Member 'FBtlApllyResultData::M_RecMagGauge' has a wrong offset!");
static_assert(offsetof(FBtlApllyResultData, M_BtlEndType) == 0x000068, "Member 'FBtlApllyResultData::M_BtlEndType' has a wrong offset!");
static_assert(offsetof(FBtlApllyResultData, M_ChainEncountNum) == 0x00006C, "Member 'FBtlApllyResultData::M_ChainEncountNum' has a wrong offset!");

// ScriptStruct Project.TalkCameraParam
// 0x002C (0x002C - 0x0000)
struct FTalkCameraParam final
{
public:
	float                                         TargetEnemyHeight;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookPlayerRate;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookEnemyRate;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeRate;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeDistance;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookDistance;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeHorizontal;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookHorizontal;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeHeight;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookHeight;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_CAMERA_DATA_TYPE                       DataType;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_CAMERA_MODEL_HIDE                      ModelHide;                                         // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkCameraParam) == 0x000004, "Wrong alignment on FTalkCameraParam");
static_assert(sizeof(FTalkCameraParam) == 0x00002C, "Wrong size on FTalkCameraParam");
static_assert(offsetof(FTalkCameraParam, TargetEnemyHeight) == 0x000000, "Member 'FTalkCameraParam::TargetEnemyHeight' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, LookPlayerRate) == 0x000004, "Member 'FTalkCameraParam::LookPlayerRate' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, LookEnemyRate) == 0x000008, "Member 'FTalkCameraParam::LookEnemyRate' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, EyeRate) == 0x00000C, "Member 'FTalkCameraParam::EyeRate' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, EyeDistance) == 0x000010, "Member 'FTalkCameraParam::EyeDistance' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, LookDistance) == 0x000014, "Member 'FTalkCameraParam::LookDistance' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, EyeHorizontal) == 0x000018, "Member 'FTalkCameraParam::EyeHorizontal' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, LookHorizontal) == 0x00001C, "Member 'FTalkCameraParam::LookHorizontal' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, EyeHeight) == 0x000020, "Member 'FTalkCameraParam::EyeHeight' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, LookHeight) == 0x000024, "Member 'FTalkCameraParam::LookHeight' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, DataType) == 0x000028, "Member 'FTalkCameraParam::DataType' has a wrong offset!");
static_assert(offsetof(FTalkCameraParam, ModelHide) == 0x000029, "Member 'FTalkCameraParam::ModelHide' has a wrong offset!");

// ScriptStruct Project.TalkRequestItemTable
// 0x000C (0x000C - 0x0000)
struct FTalkRequestItemTable final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemRank;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MaxNum;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkRequestItemTable) == 0x000004, "Wrong alignment on FTalkRequestItemTable");
static_assert(sizeof(FTalkRequestItemTable) == 0x00000C, "Wrong size on FTalkRequestItemTable");
static_assert(offsetof(FTalkRequestItemTable, M_ItemID) == 0x000000, "Member 'FTalkRequestItemTable::M_ItemID' has a wrong offset!");
static_assert(offsetof(FTalkRequestItemTable, M_ItemRank) == 0x000004, "Member 'FTalkRequestItemTable::M_ItemRank' has a wrong offset!");
static_assert(offsetof(FTalkRequestItemTable, M_MaxNum) == 0x000008, "Member 'FTalkRequestItemTable::M_MaxNum' has a wrong offset!");

// ScriptStruct Project.TalkRequestItemRankTable
// 0x0018 (0x0018 - 0x0000)
struct FTalkRequestItemRankTable final
{
public:
	int32                                         M_MaxLevel;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_RankWeights;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkRequestItemRankTable) == 0x000008, "Wrong alignment on FTalkRequestItemRankTable");
static_assert(sizeof(FTalkRequestItemRankTable) == 0x000018, "Wrong size on FTalkRequestItemRankTable");
static_assert(offsetof(FTalkRequestItemRankTable, M_MaxLevel) == 0x000000, "Member 'FTalkRequestItemRankTable::M_MaxLevel' has a wrong offset!");
static_assert(offsetof(FTalkRequestItemRankTable, M_RankWeights) == 0x000008, "Member 'FTalkRequestItemRankTable::M_RankWeights' has a wrong offset!");

// ScriptStruct Project.TalkWantReactionTable
// 0x0010 (0x0010 - 0x0000)
struct FTalkWantReactionTable final
{
public:
	TArray<int32>                                 M_Weights;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkWantReactionTable) == 0x000008, "Wrong alignment on FTalkWantReactionTable");
static_assert(sizeof(FTalkWantReactionTable) == 0x000010, "Wrong size on FTalkWantReactionTable");
static_assert(offsetof(FTalkWantReactionTable, M_Weights) == 0x000000, "Member 'FTalkWantReactionTable::M_Weights' has a wrong offset!");

// ScriptStruct Project.TalkGiftItemTable
// 0x0010 (0x0010 - 0x0000)
struct FTalkGiftItemTable final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemRank;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MaxNum;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_GIFT_ITEM_TYPE                         M_ItemType;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkGiftItemTable) == 0x000004, "Wrong alignment on FTalkGiftItemTable");
static_assert(sizeof(FTalkGiftItemTable) == 0x000010, "Wrong size on FTalkGiftItemTable");
static_assert(offsetof(FTalkGiftItemTable, M_ItemID) == 0x000000, "Member 'FTalkGiftItemTable::M_ItemID' has a wrong offset!");
static_assert(offsetof(FTalkGiftItemTable, M_ItemRank) == 0x000004, "Member 'FTalkGiftItemTable::M_ItemRank' has a wrong offset!");
static_assert(offsetof(FTalkGiftItemTable, M_MaxNum) == 0x000008, "Member 'FTalkGiftItemTable::M_MaxNum' has a wrong offset!");
static_assert(offsetof(FTalkGiftItemTable, M_ItemType) == 0x00000C, "Member 'FTalkGiftItemTable::M_ItemType' has a wrong offset!");

// ScriptStruct Project.TalkMythTable
// 0x000C (0x000C - 0x0000)
struct FTalkMythTable final
{
public:
	int32                                         M_MythId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_FriendId;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EnemyID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkMythTable) == 0x000004, "Wrong alignment on FTalkMythTable");
static_assert(sizeof(FTalkMythTable) == 0x00000C, "Wrong size on FTalkMythTable");
static_assert(offsetof(FTalkMythTable, M_MythId) == 0x000000, "Member 'FTalkMythTable::M_MythId' has a wrong offset!");
static_assert(offsetof(FTalkMythTable, M_FriendId) == 0x000004, "Member 'FTalkMythTable::M_FriendId' has a wrong offset!");
static_assert(offsetof(FTalkMythTable, M_EnemyID) == 0x000008, "Member 'FTalkMythTable::M_EnemyID' has a wrong offset!");

// ScriptStruct Project.TalkMoonTemperRateTable
// 0x0010 (0x0010 - 0x0000)
struct FTalkMoonTemperRateTable final
{
public:
	TArray<int32>                                 M_Rates;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkMoonTemperRateTable) == 0x000008, "Wrong alignment on FTalkMoonTemperRateTable");
static_assert(sizeof(FTalkMoonTemperRateTable) == 0x000010, "Wrong size on FTalkMoonTemperRateTable");
static_assert(offsetof(FTalkMoonTemperRateTable, M_Rates) == 0x000000, "Member 'FTalkMoonTemperRateTable::M_Rates' has a wrong offset!");

// ScriptStruct Project.TalkBaseTable
// 0x0110 (0x0110 - 0x0000)
struct FTalkBaseTable final
{
public:
	TArray<int32>                                 M_BalanceArray;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_WantMoneyArray;                                  // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_FundAngryRateArray;                              // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTalkRequestItemTable>          M_RequestItemTableArray;                           // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTalkRequestItemRankTable>      M_RequestItemRankTableArray;                       // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_WantKindBeforeMoney;                             // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_WantKindAfterMoney;                              // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_WantKindBeforeMoney_Easy;                        // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_WantKindAfterMoney_Easy;                         // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTalkWantReactionTable>         M_WantReaction_Yes_Array;                          // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTalkWantReactionTable>         M_WantReaction_Other_Array;                        // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTalkWantReactionTable>         M_WantReaction_Shortcut_Array;                     // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTalkWantReactionTable>         M_WantReaction_NotHave_Array;                      // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTalkGiftItemTable>             M_GiftItemTableArray;                              // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTalkMythTable>                 M_MythTableArray;                                  // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTalkMoonTemperTable>           M_MoonTemperArray;                                 // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTalkMoonTemperRateTable>       M_MoonTemperRateArray;                             // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkBaseTable) == 0x000008, "Wrong alignment on FTalkBaseTable");
static_assert(sizeof(FTalkBaseTable) == 0x000110, "Wrong size on FTalkBaseTable");
static_assert(offsetof(FTalkBaseTable, M_BalanceArray) == 0x000000, "Member 'FTalkBaseTable::M_BalanceArray' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_WantMoneyArray) == 0x000010, "Member 'FTalkBaseTable::M_WantMoneyArray' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_FundAngryRateArray) == 0x000020, "Member 'FTalkBaseTable::M_FundAngryRateArray' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_RequestItemTableArray) == 0x000030, "Member 'FTalkBaseTable::M_RequestItemTableArray' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_RequestItemRankTableArray) == 0x000040, "Member 'FTalkBaseTable::M_RequestItemRankTableArray' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_WantKindBeforeMoney) == 0x000050, "Member 'FTalkBaseTable::M_WantKindBeforeMoney' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_WantKindAfterMoney) == 0x000060, "Member 'FTalkBaseTable::M_WantKindAfterMoney' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_WantKindBeforeMoney_Easy) == 0x000070, "Member 'FTalkBaseTable::M_WantKindBeforeMoney_Easy' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_WantKindAfterMoney_Easy) == 0x000080, "Member 'FTalkBaseTable::M_WantKindAfterMoney_Easy' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_WantReaction_Yes_Array) == 0x000090, "Member 'FTalkBaseTable::M_WantReaction_Yes_Array' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_WantReaction_Other_Array) == 0x0000A0, "Member 'FTalkBaseTable::M_WantReaction_Other_Array' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_WantReaction_Shortcut_Array) == 0x0000B0, "Member 'FTalkBaseTable::M_WantReaction_Shortcut_Array' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_WantReaction_NotHave_Array) == 0x0000C0, "Member 'FTalkBaseTable::M_WantReaction_NotHave_Array' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_GiftItemTableArray) == 0x0000D0, "Member 'FTalkBaseTable::M_GiftItemTableArray' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_MythTableArray) == 0x0000E0, "Member 'FTalkBaseTable::M_MythTableArray' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_MoonTemperArray) == 0x0000F0, "Member 'FTalkBaseTable::M_MoonTemperArray' has a wrong offset!");
static_assert(offsetof(FTalkBaseTable, M_MoonTemperRateArray) == 0x000100, "Member 'FTalkBaseTable::M_MoonTemperRateArray' has a wrong offset!");

// ScriptStruct Project.TalkReactionTable
// 0x0028 (0x0028 - 0x0000)
struct FTalkReactionTable final
{
public:
	int32                                         M_Rate;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDevilTalkVoice                               M_Voice;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CHARA_MOTION_ID                             M_Motion;                                          // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_MsgSys;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MsgDvl;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MsgSys2;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MsgDvl2;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsSysFirst;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsSysFirst2;                                     // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsFailSafeInvalid;                               // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_QUE_REAC                               M_Result;                                          // 0x001B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_QUE_ADD_RESULT                         M_AddResult;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_NextFlg;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NextFlg2;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkReactionTable) == 0x000004, "Wrong alignment on FTalkReactionTable");
static_assert(sizeof(FTalkReactionTable) == 0x000028, "Wrong size on FTalkReactionTable");
static_assert(offsetof(FTalkReactionTable, M_Rate) == 0x000000, "Member 'FTalkReactionTable::M_Rate' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_Voice) == 0x000004, "Member 'FTalkReactionTable::M_Voice' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_Motion) == 0x000005, "Member 'FTalkReactionTable::M_Motion' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_MsgSys) == 0x000008, "Member 'FTalkReactionTable::M_MsgSys' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_MsgDvl) == 0x00000C, "Member 'FTalkReactionTable::M_MsgDvl' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_MsgSys2) == 0x000010, "Member 'FTalkReactionTable::M_MsgSys2' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_MsgDvl2) == 0x000014, "Member 'FTalkReactionTable::M_MsgDvl2' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_IsSysFirst) == 0x000018, "Member 'FTalkReactionTable::M_IsSysFirst' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_IsSysFirst2) == 0x000019, "Member 'FTalkReactionTable::M_IsSysFirst2' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_IsFailSafeInvalid) == 0x00001A, "Member 'FTalkReactionTable::M_IsFailSafeInvalid' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_Result) == 0x00001B, "Member 'FTalkReactionTable::M_Result' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_AddResult) == 0x00001C, "Member 'FTalkReactionTable::M_AddResult' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_NextFlg) == 0x000020, "Member 'FTalkReactionTable::M_NextFlg' has a wrong offset!");
static_assert(offsetof(FTalkReactionTable, M_NextFlg2) == 0x000024, "Member 'FTalkReactionTable::M_NextFlg2' has a wrong offset!");

// ScriptStruct Project.TalkIntrTable
// 0x001C (0x001C - 0x0000)
struct FTalkIntrTable final
{
public:
	int32                                         M_MsgDvl;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MsgSys;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MsgChoice1;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MsgChoice2;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MsgChoice3;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Place;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_QUESTION_PART                          M_Part;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsSysFirst;                                      // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDevilTalkVoice                               M_Voice;                                           // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CHARA_MOTION_ID                             M_Motion;                                          // 0x001B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkIntrTable) == 0x000004, "Wrong alignment on FTalkIntrTable");
static_assert(sizeof(FTalkIntrTable) == 0x00001C, "Wrong size on FTalkIntrTable");
static_assert(offsetof(FTalkIntrTable, M_MsgDvl) == 0x000000, "Member 'FTalkIntrTable::M_MsgDvl' has a wrong offset!");
static_assert(offsetof(FTalkIntrTable, M_MsgSys) == 0x000004, "Member 'FTalkIntrTable::M_MsgSys' has a wrong offset!");
static_assert(offsetof(FTalkIntrTable, M_MsgChoice1) == 0x000008, "Member 'FTalkIntrTable::M_MsgChoice1' has a wrong offset!");
static_assert(offsetof(FTalkIntrTable, M_MsgChoice2) == 0x00000C, "Member 'FTalkIntrTable::M_MsgChoice2' has a wrong offset!");
static_assert(offsetof(FTalkIntrTable, M_MsgChoice3) == 0x000010, "Member 'FTalkIntrTable::M_MsgChoice3' has a wrong offset!");
static_assert(offsetof(FTalkIntrTable, M_Place) == 0x000014, "Member 'FTalkIntrTable::M_Place' has a wrong offset!");
static_assert(offsetof(FTalkIntrTable, M_Part) == 0x000018, "Member 'FTalkIntrTable::M_Part' has a wrong offset!");
static_assert(offsetof(FTalkIntrTable, M_IsSysFirst) == 0x000019, "Member 'FTalkIntrTable::M_IsSysFirst' has a wrong offset!");
static_assert(offsetof(FTalkIntrTable, M_Voice) == 0x00001A, "Member 'FTalkIntrTable::M_Voice' has a wrong offset!");
static_assert(offsetof(FTalkIntrTable, M_Motion) == 0x00001B, "Member 'FTalkIntrTable::M_Motion' has a wrong offset!");

// ScriptStruct Project.TalkChoiceTable
// 0x0010 (0x0010 - 0x0000)
struct FTalkChoiceTable final
{
public:
	TArray<struct FTalkReactionTable>             M_Reaction;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkChoiceTable) == 0x000008, "Wrong alignment on FTalkChoiceTable");
static_assert(sizeof(FTalkChoiceTable) == 0x000010, "Wrong size on FTalkChoiceTable");
static_assert(offsetof(FTalkChoiceTable, M_Reaction) == 0x000000, "Member 'FTalkChoiceTable::M_Reaction' has a wrong offset!");

// ScriptStruct Project.TalkScoutTable
// 0x0038 (0x0038 - 0x0000)
struct FTalkScoutTable final
{
public:
	struct FTalkIntrTable                         M_Intr;                                            // 0x0000(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTalkChoiceTable>               M_Choice;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_UseFlag;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_OpenFlag;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkScoutTable) == 0x000008, "Wrong alignment on FTalkScoutTable");
static_assert(sizeof(FTalkScoutTable) == 0x000038, "Wrong size on FTalkScoutTable");
static_assert(offsetof(FTalkScoutTable, M_Intr) == 0x000000, "Member 'FTalkScoutTable::M_Intr' has a wrong offset!");
static_assert(offsetof(FTalkScoutTable, M_Choice) == 0x000020, "Member 'FTalkScoutTable::M_Choice' has a wrong offset!");
static_assert(offsetof(FTalkScoutTable, M_UseFlag) == 0x000030, "Member 'FTalkScoutTable::M_UseFlag' has a wrong offset!");
static_assert(offsetof(FTalkScoutTable, M_OpenFlag) == 0x000034, "Member 'FTalkScoutTable::M_OpenFlag' has a wrong offset!");

// ScriptStruct Project.BattleSkillAction_Raw
// 0x0028 (0x0030 - 0x0008)
struct FBattleSkillAction_Raw final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   M_FilePath;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleSkillAction_Raw) == 0x000008, "Wrong alignment on FBattleSkillAction_Raw");
static_assert(sizeof(FBattleSkillAction_Raw) == 0x000030, "Wrong size on FBattleSkillAction_Raw");
static_assert(offsetof(FBattleSkillAction_Raw, M_FilePath) == 0x000008, "Member 'FBattleSkillAction_Raw::M_FilePath' has a wrong offset!");

// ScriptStruct Project.SkillActionTargetInfo
// 0x0098 (0x0098 - 0x0000)
struct FSkillActionTargetInfo final
{
public:
	TArray<E_BTL_REFLECT_RES_TYPE>                M_Value;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<E_BTL_DAMAGE_HIT_TYPE>                 M_DamageHit;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_Damage;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_DamageReal;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_Rec;                                             // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_DamageMP;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_RecMP;                                           // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_TargetIndex;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_FromIndex;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CriticalLevel;                                   // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Bst;                                             // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RecBst;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_SKILL_ACTION_AID                        M_Aid;                                             // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_DEAD_EFFECT                             M_DeadEffect;                                      // 0x0085(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsDead;                                          // 0x0086(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsCounter;                                       // 0x0087(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsNahobinoBreak;                                 // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsResist;                                        // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsGuard;                                         // 0x008A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsCombo;                                         // 0x008B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsWeak;                                          // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsTetraja;                                       // 0x008D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsIgnoreTargetEffect;                            // 0x008E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_KUISHIBARI_LEVEL                            M_Kuishibari;                                      // 0x008F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_KuishibariSpendPartyIndex;                       // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillActionTargetInfo) == 0x000008, "Wrong alignment on FSkillActionTargetInfo");
static_assert(sizeof(FSkillActionTargetInfo) == 0x000098, "Wrong size on FSkillActionTargetInfo");
static_assert(offsetof(FSkillActionTargetInfo, M_Value) == 0x000000, "Member 'FSkillActionTargetInfo::M_Value' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_DamageHit) == 0x000010, "Member 'FSkillActionTargetInfo::M_DamageHit' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_Damage) == 0x000020, "Member 'FSkillActionTargetInfo::M_Damage' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_DamageReal) == 0x000030, "Member 'FSkillActionTargetInfo::M_DamageReal' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_Rec) == 0x000040, "Member 'FSkillActionTargetInfo::M_Rec' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_DamageMP) == 0x000050, "Member 'FSkillActionTargetInfo::M_DamageMP' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_RecMP) == 0x000060, "Member 'FSkillActionTargetInfo::M_RecMP' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_TargetIndex) == 0x000070, "Member 'FSkillActionTargetInfo::M_TargetIndex' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_FromIndex) == 0x000074, "Member 'FSkillActionTargetInfo::M_FromIndex' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_CriticalLevel) == 0x000078, "Member 'FSkillActionTargetInfo::M_CriticalLevel' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_Bst) == 0x00007C, "Member 'FSkillActionTargetInfo::M_Bst' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_RecBst) == 0x000080, "Member 'FSkillActionTargetInfo::M_RecBst' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_Aid) == 0x000084, "Member 'FSkillActionTargetInfo::M_Aid' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_DeadEffect) == 0x000085, "Member 'FSkillActionTargetInfo::M_DeadEffect' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_IsDead) == 0x000086, "Member 'FSkillActionTargetInfo::M_IsDead' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_IsCounter) == 0x000087, "Member 'FSkillActionTargetInfo::M_IsCounter' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_IsNahobinoBreak) == 0x000088, "Member 'FSkillActionTargetInfo::M_IsNahobinoBreak' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_IsResist) == 0x000089, "Member 'FSkillActionTargetInfo::M_IsResist' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_IsGuard) == 0x00008A, "Member 'FSkillActionTargetInfo::M_IsGuard' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_IsCombo) == 0x00008B, "Member 'FSkillActionTargetInfo::M_IsCombo' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_IsWeak) == 0x00008C, "Member 'FSkillActionTargetInfo::M_IsWeak' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_IsTetraja) == 0x00008D, "Member 'FSkillActionTargetInfo::M_IsTetraja' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_IsIgnoreTargetEffect) == 0x00008E, "Member 'FSkillActionTargetInfo::M_IsIgnoreTargetEffect' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_Kuishibari) == 0x00008F, "Member 'FSkillActionTargetInfo::M_Kuishibari' has a wrong offset!");
static_assert(offsetof(FSkillActionTargetInfo, M_KuishibariSpendPartyIndex) == 0x000090, "Member 'FSkillActionTargetInfo::M_KuishibariSpendPartyIndex' has a wrong offset!");

// ScriptStruct Project.SkillActionDrainInfo
// 0x0008 (0x0008 - 0x0000)
struct FSkillActionDrainInfo final
{
public:
	int32                                         M_DrainHp;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DrainMp;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillActionDrainInfo) == 0x000004, "Wrong alignment on FSkillActionDrainInfo");
static_assert(sizeof(FSkillActionDrainInfo) == 0x000008, "Wrong size on FSkillActionDrainInfo");
static_assert(offsetof(FSkillActionDrainInfo, M_DrainHp) == 0x000000, "Member 'FSkillActionDrainInfo::M_DrainHp' has a wrong offset!");
static_assert(offsetof(FSkillActionDrainInfo, M_DrainMp) == 0x000004, "Member 'FSkillActionDrainInfo::M_DrainMp' has a wrong offset!");

// ScriptStruct Project.SkillActionExtend
// 0x00A8 (0x00A8 - 0x0000)
struct FSkillActionExtend final
{
public:
	E_BTL_EXTEND_ACTION                           M_ExtendType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ActorIndex;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillId;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillActionTargetInfo                 M_TargetInfo;                                      // 0x0010(0x0098)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillActionExtend) == 0x000008, "Wrong alignment on FSkillActionExtend");
static_assert(sizeof(FSkillActionExtend) == 0x0000A8, "Wrong size on FSkillActionExtend");
static_assert(offsetof(FSkillActionExtend, M_ExtendType) == 0x000000, "Member 'FSkillActionExtend::M_ExtendType' has a wrong offset!");
static_assert(offsetof(FSkillActionExtend, M_ActorIndex) == 0x000004, "Member 'FSkillActionExtend::M_ActorIndex' has a wrong offset!");
static_assert(offsetof(FSkillActionExtend, M_SkillId) == 0x000008, "Member 'FSkillActionExtend::M_SkillId' has a wrong offset!");
static_assert(offsetof(FSkillActionExtend, M_TargetInfo) == 0x000010, "Member 'FSkillActionExtend::M_TargetInfo' has a wrong offset!");

// ScriptStruct Project.SkillActionDesc
// 0x0090 (0x0090 - 0x0000)
struct FSkillActionDesc final
{
public:
	int32                                         M_ActorIndex;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkillActionTargetInfo>         M_TargetInfo;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_SkillId;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemID;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_SKILL_TYPE                                  M_Type;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_EXTRA_ACTION                            M_ExtraAction;                                     // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillActionDrainInfo                  M_DrainInfo;                                       // 0x0024(0x0008)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_SkillMasterExecList;                             // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkillActionExtend>             M_ExtendAction;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkillActionTargetInfo>         M_ReflexInfo;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_CounterOccured;                                  // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AddMagGauge;                                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AddReichi;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ActorBst;                                        // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_MagatsuhiOtherActors;                            // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAchievementFlag>                      M_UnlockAchievements;                              // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillActionDesc) == 0x000008, "Wrong alignment on FSkillActionDesc");
static_assert(sizeof(FSkillActionDesc) == 0x000090, "Wrong size on FSkillActionDesc");
static_assert(offsetof(FSkillActionDesc, M_ActorIndex) == 0x000000, "Member 'FSkillActionDesc::M_ActorIndex' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_TargetInfo) == 0x000008, "Member 'FSkillActionDesc::M_TargetInfo' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_SkillId) == 0x000018, "Member 'FSkillActionDesc::M_SkillId' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_ItemID) == 0x00001C, "Member 'FSkillActionDesc::M_ItemID' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_Type) == 0x000020, "Member 'FSkillActionDesc::M_Type' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_ExtraAction) == 0x000021, "Member 'FSkillActionDesc::M_ExtraAction' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_DrainInfo) == 0x000024, "Member 'FSkillActionDesc::M_DrainInfo' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_SkillMasterExecList) == 0x000030, "Member 'FSkillActionDesc::M_SkillMasterExecList' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_ExtendAction) == 0x000040, "Member 'FSkillActionDesc::M_ExtendAction' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_ReflexInfo) == 0x000050, "Member 'FSkillActionDesc::M_ReflexInfo' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_CounterOccured) == 0x000060, "Member 'FSkillActionDesc::M_CounterOccured' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_AddMagGauge) == 0x000064, "Member 'FSkillActionDesc::M_AddMagGauge' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_AddReichi) == 0x000068, "Member 'FSkillActionDesc::M_AddReichi' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_ActorBst) == 0x00006C, "Member 'FSkillActionDesc::M_ActorBst' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_MagatsuhiOtherActors) == 0x000070, "Member 'FSkillActionDesc::M_MagatsuhiOtherActors' has a wrong offset!");
static_assert(offsetof(FSkillActionDesc, M_UnlockAchievements) == 0x000080, "Member 'FSkillActionDesc::M_UnlockAchievements' has a wrong offset!");

// ScriptStruct Project.SkillEffectPairSetting
// 0x0030 (0x0030 - 0x0000)
struct FSkillEffectPairSetting final
{
public:
	E_BTL_EFFECT_TYPE                             EffectType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_EFFECT_FORM                             EffectForm;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ActorSocketLocation;                               // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetSocketLocation;                              // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletSpeed;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletTangent;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtensionDistance;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepBallEffect;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillEffectPairSetting) == 0x000004, "Wrong alignment on FSkillEffectPairSetting");
static_assert(sizeof(FSkillEffectPairSetting) == 0x000030, "Wrong size on FSkillEffectPairSetting");
static_assert(offsetof(FSkillEffectPairSetting, EffectType) == 0x000000, "Member 'FSkillEffectPairSetting::EffectType' has a wrong offset!");
static_assert(offsetof(FSkillEffectPairSetting, EffectForm) == 0x000001, "Member 'FSkillEffectPairSetting::EffectForm' has a wrong offset!");
static_assert(offsetof(FSkillEffectPairSetting, ActorSocketLocation) == 0x000004, "Member 'FSkillEffectPairSetting::ActorSocketLocation' has a wrong offset!");
static_assert(offsetof(FSkillEffectPairSetting, TargetSocketLocation) == 0x000010, "Member 'FSkillEffectPairSetting::TargetSocketLocation' has a wrong offset!");
static_assert(offsetof(FSkillEffectPairSetting, BulletSpeed) == 0x00001C, "Member 'FSkillEffectPairSetting::BulletSpeed' has a wrong offset!");
static_assert(offsetof(FSkillEffectPairSetting, BulletTangent) == 0x000020, "Member 'FSkillEffectPairSetting::BulletTangent' has a wrong offset!");
static_assert(offsetof(FSkillEffectPairSetting, Gravity) == 0x000024, "Member 'FSkillEffectPairSetting::Gravity' has a wrong offset!");
static_assert(offsetof(FSkillEffectPairSetting, ExtensionDistance) == 0x000028, "Member 'FSkillEffectPairSetting::ExtensionDistance' has a wrong offset!");
static_assert(offsetof(FSkillEffectPairSetting, KeepBallEffect) == 0x00002C, "Member 'FSkillEffectPairSetting::KeepBallEffect' has a wrong offset!");

// ScriptStruct Project.SkillActionEffect
// 0x0038 (0x0038 - 0x0000)
struct FSkillActionEffect final
{
public:
	class UParticleSystem*                        M_Particle;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          M_SE;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_SE_SyncPlaybackSpeed;                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          M_ModSkeletalMesh;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      M_ModAnim;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_ModSocketName;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillActionEffect) == 0x000008, "Wrong alignment on FSkillActionEffect");
static_assert(sizeof(FSkillActionEffect) == 0x000038, "Wrong size on FSkillActionEffect");
static_assert(offsetof(FSkillActionEffect, M_Particle) == 0x000000, "Member 'FSkillActionEffect::M_Particle' has a wrong offset!");
static_assert(offsetof(FSkillActionEffect, M_SE) == 0x000008, "Member 'FSkillActionEffect::M_SE' has a wrong offset!");
static_assert(offsetof(FSkillActionEffect, M_SE_SyncPlaybackSpeed) == 0x000010, "Member 'FSkillActionEffect::M_SE_SyncPlaybackSpeed' has a wrong offset!");
static_assert(offsetof(FSkillActionEffect, M_ModSkeletalMesh) == 0x000018, "Member 'FSkillActionEffect::M_ModSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSkillActionEffect, M_ModAnim) == 0x000020, "Member 'FSkillActionEffect::M_ModAnim' has a wrong offset!");
static_assert(offsetof(FSkillActionEffect, M_ModSocketName) == 0x000028, "Member 'FSkillActionEffect::M_ModSocketName' has a wrong offset!");

// ScriptStruct Project.BattleIntegerArray
// 0x0010 (0x0010 - 0x0000)
struct FBattleIntegerArray final
{
public:
	TArray<int32>                                 Array;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleIntegerArray) == 0x000008, "Wrong alignment on FBattleIntegerArray");
static_assert(sizeof(FBattleIntegerArray) == 0x000010, "Wrong size on FBattleIntegerArray");
static_assert(offsetof(FBattleIntegerArray, Array) == 0x000000, "Member 'FBattleIntegerArray::Array' has a wrong offset!");

// ScriptStruct Project.RenzokuEncountCalcDataTableRow
// 0x0008 (0x0010 - 0x0008)
struct FRenzokuEncountCalcDataTableRow final : public FTableRowBase
{
public:
	int32                                         M_RiveramaRate;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AttenuationRatio;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRenzokuEncountCalcDataTableRow) == 0x000008, "Wrong alignment on FRenzokuEncountCalcDataTableRow");
static_assert(sizeof(FRenzokuEncountCalcDataTableRow) == 0x000010, "Wrong size on FRenzokuEncountCalcDataTableRow");
static_assert(offsetof(FRenzokuEncountCalcDataTableRow, M_RiveramaRate) == 0x000008, "Member 'FRenzokuEncountCalcDataTableRow::M_RiveramaRate' has a wrong offset!");
static_assert(offsetof(FRenzokuEncountCalcDataTableRow, M_AttenuationRatio) == 0x00000C, "Member 'FRenzokuEncountCalcDataTableRow::M_AttenuationRatio' has a wrong offset!");

// ScriptStruct Project.StealSkillRateTable
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FStealSkillRateTable final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStealSkillRateTable) == 0x000004, "Wrong alignment on FStealSkillRateTable");
static_assert(sizeof(FStealSkillRateTable) == 0x000010, "Wrong size on FStealSkillRateTable");

// ScriptStruct Project.UIStatusSlotItemData
// 0x0018 (0x0018 - 0x0000)
struct FUIStatusSlotItemData final
{
public:
	E_UI_STATUS_SLOT                              M_AnimType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_UI_STATUS_SLOT                              M_FontColorType;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_IconNum;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TextNum;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CostNum;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_UI_STATUS_LIST_ITEM_TYPE                    M_TextType;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_OpenFlag;                                        // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AddNum;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIStatusSlotItemData) == 0x000004, "Wrong alignment on FUIStatusSlotItemData");
static_assert(sizeof(FUIStatusSlotItemData) == 0x000018, "Wrong size on FUIStatusSlotItemData");
static_assert(offsetof(FUIStatusSlotItemData, M_AnimType) == 0x000000, "Member 'FUIStatusSlotItemData::M_AnimType' has a wrong offset!");
static_assert(offsetof(FUIStatusSlotItemData, M_FontColorType) == 0x000001, "Member 'FUIStatusSlotItemData::M_FontColorType' has a wrong offset!");
static_assert(offsetof(FUIStatusSlotItemData, M_IconNum) == 0x000004, "Member 'FUIStatusSlotItemData::M_IconNum' has a wrong offset!");
static_assert(offsetof(FUIStatusSlotItemData, M_TextNum) == 0x000008, "Member 'FUIStatusSlotItemData::M_TextNum' has a wrong offset!");
static_assert(offsetof(FUIStatusSlotItemData, M_CostNum) == 0x00000C, "Member 'FUIStatusSlotItemData::M_CostNum' has a wrong offset!");
static_assert(offsetof(FUIStatusSlotItemData, M_TextType) == 0x000010, "Member 'FUIStatusSlotItemData::M_TextType' has a wrong offset!");
static_assert(offsetof(FUIStatusSlotItemData, M_OpenFlag) == 0x000011, "Member 'FUIStatusSlotItemData::M_OpenFlag' has a wrong offset!");
static_assert(offsetof(FUIStatusSlotItemData, M_AddNum) == 0x000014, "Member 'FUIStatusSlotItemData::M_AddNum' has a wrong offset!");

// ScriptStruct Project.StealSkillRateRow
// 0x0010 (0x0018 - 0x0008)
struct FStealSkillRateRow final : public FTableRowBase
{
public:
	int32                                         M_DevilID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MagatushiSkillID;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillID1;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillID2;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStealSkillRateRow) == 0x000008, "Wrong alignment on FStealSkillRateRow");
static_assert(sizeof(FStealSkillRateRow) == 0x000018, "Wrong size on FStealSkillRateRow");
static_assert(offsetof(FStealSkillRateRow, M_DevilID) == 0x000008, "Member 'FStealSkillRateRow::M_DevilID' has a wrong offset!");
static_assert(offsetof(FStealSkillRateRow, M_MagatushiSkillID) == 0x00000C, "Member 'FStealSkillRateRow::M_MagatushiSkillID' has a wrong offset!");
static_assert(offsetof(FStealSkillRateRow, M_SkillID1) == 0x000010, "Member 'FStealSkillRateRow::M_SkillID1' has a wrong offset!");
static_assert(offsetof(FStealSkillRateRow, M_SkillID2) == 0x000014, "Member 'FStealSkillRateRow::M_SkillID2' has a wrong offset!");

// ScriptStruct Project.UniqueSkillAddInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FUniqueSkillAddInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueSkillAddInfo) == 0x000004, "Wrong alignment on FUniqueSkillAddInfo");
static_assert(sizeof(FUniqueSkillAddInfo) == 0x00000C, "Wrong size on FUniqueSkillAddInfo");

// ScriptStruct Project.BtlCommandUIData
// 0x0005 (0x0005 - 0x0000)
struct FBtlCommandUIData final
{
public:
	E_BTL_UI_COMMAND                              M_CommId;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsUse;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsActionOnly;                                    // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_ACTION_MAPPING_TYPE                         M_ActMappingType;                                  // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_INPUT_TYPE                                  M_InputType;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlCommandUIData) == 0x000001, "Wrong alignment on FBtlCommandUIData");
static_assert(sizeof(FBtlCommandUIData) == 0x000005, "Wrong size on FBtlCommandUIData");
static_assert(offsetof(FBtlCommandUIData, M_CommId) == 0x000000, "Member 'FBtlCommandUIData::M_CommId' has a wrong offset!");
static_assert(offsetof(FBtlCommandUIData, M_IsUse) == 0x000001, "Member 'FBtlCommandUIData::M_IsUse' has a wrong offset!");
static_assert(offsetof(FBtlCommandUIData, M_IsActionOnly) == 0x000002, "Member 'FBtlCommandUIData::M_IsActionOnly' has a wrong offset!");
static_assert(offsetof(FBtlCommandUIData, M_ActMappingType) == 0x000003, "Member 'FBtlCommandUIData::M_ActMappingType' has a wrong offset!");
static_assert(offsetof(FBtlCommandUIData, M_InputType) == 0x000004, "Member 'FBtlCommandUIData::M_InputType' has a wrong offset!");

// ScriptStruct Project.BtlSubCommandUIData
// 0x0006 (0x0006 - 0x0000)
struct FBtlSubCommandUIData final
{
public:
	E_BTL_SUB_COMMAND_TYPE                        M_CommandType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBtlCommandUIData                      M_CommandData;                                     // 0x0001(0x0005)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlSubCommandUIData) == 0x000001, "Wrong alignment on FBtlSubCommandUIData");
static_assert(sizeof(FBtlSubCommandUIData) == 0x000006, "Wrong size on FBtlSubCommandUIData");
static_assert(offsetof(FBtlSubCommandUIData, M_CommandType) == 0x000000, "Member 'FBtlSubCommandUIData::M_CommandType' has a wrong offset!");
static_assert(offsetof(FBtlSubCommandUIData, M_CommandData) == 0x000001, "Member 'FBtlSubCommandUIData::M_CommandData' has a wrong offset!");

// ScriptStruct Project.UniqueSkillOnceInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FUniqueSkillOnceInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueSkillOnceInfo) == 0x000008, "Wrong alignment on FUniqueSkillOnceInfo");
static_assert(sizeof(FUniqueSkillOnceInfo) == 0x000010, "Wrong size on FUniqueSkillOnceInfo");

// ScriptStruct Project.UniqueSkillPrevTargetInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FUniqueSkillPrevTargetInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueSkillPrevTargetInfo) == 0x000004, "Wrong alignment on FUniqueSkillPrevTargetInfo");
static_assert(sizeof(FUniqueSkillPrevTargetInfo) == 0x000008, "Wrong size on FUniqueSkillPrevTargetInfo");

// ScriptStruct Project.UIAnimationCallData
// 0x0008 (0x0008 - 0x0000)
struct FUIAnimationCallData final
{
public:
	int32                                         M_AnimIndex;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsRev;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsPlayStop;                                      // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIAnimationCallData) == 0x000004, "Wrong alignment on FUIAnimationCallData");
static_assert(sizeof(FUIAnimationCallData) == 0x000008, "Wrong size on FUIAnimationCallData");
static_assert(offsetof(FUIAnimationCallData, M_AnimIndex) == 0x000000, "Member 'FUIAnimationCallData::M_AnimIndex' has a wrong offset!");
static_assert(offsetof(FUIAnimationCallData, M_IsRev) == 0x000004, "Member 'FUIAnimationCallData::M_IsRev' has a wrong offset!");
static_assert(offsetof(FUIAnimationCallData, M_IsPlayStop) == 0x000005, "Member 'FUIAnimationCallData::M_IsPlayStop' has a wrong offset!");

// ScriptStruct Project.UniqueSkillNextActorBuff
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FUniqueSkillNextActorBuff final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueSkillNextActorBuff) == 0x000004, "Wrong alignment on FUniqueSkillNextActorBuff");
static_assert(sizeof(FUniqueSkillNextActorBuff) == 0x00000C, "Wrong size on FUniqueSkillNextActorBuff");

// ScriptStruct Project.UniqueSkillPressIcon
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FUniqueSkillPressIcon final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueSkillPressIcon) == 0x000004, "Wrong alignment on FUniqueSkillPressIcon");
static_assert(sizeof(FUniqueSkillPressIcon) == 0x00000C, "Wrong size on FUniqueSkillPressIcon");

// ScriptStruct Project.UICalcRect
// 0x0018 (0x0018 - 0x0000)
struct FUICalcRect final
{
public:
	float                                         M_Left;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Top;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Right;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Bottom;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Width;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Height;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUICalcRect) == 0x000004, "Wrong alignment on FUICalcRect");
static_assert(sizeof(FUICalcRect) == 0x000018, "Wrong size on FUICalcRect");
static_assert(offsetof(FUICalcRect, M_Left) == 0x000000, "Member 'FUICalcRect::M_Left' has a wrong offset!");
static_assert(offsetof(FUICalcRect, M_Top) == 0x000004, "Member 'FUICalcRect::M_Top' has a wrong offset!");
static_assert(offsetof(FUICalcRect, M_Right) == 0x000008, "Member 'FUICalcRect::M_Right' has a wrong offset!");
static_assert(offsetof(FUICalcRect, M_Bottom) == 0x00000C, "Member 'FUICalcRect::M_Bottom' has a wrong offset!");
static_assert(offsetof(FUICalcRect, M_Width) == 0x000010, "Member 'FUICalcRect::M_Width' has a wrong offset!");
static_assert(offsetof(FUICalcRect, M_Height) == 0x000014, "Member 'FUICalcRect::M_Height' has a wrong offset!");

// ScriptStruct Project.UICalcRectCheck
// 0x0038 (0x0038 - 0x0000)
struct FUICalcRectCheck final
{
public:
	int32                                         M_Index;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUICalcRect                            M_MoveRect;                                        // 0x0004(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUICalcRect                            M_FixRect;                                         // 0x001C(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_IsBase;                                          // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUICalcRectCheck) == 0x000004, "Wrong alignment on FUICalcRectCheck");
static_assert(sizeof(FUICalcRectCheck) == 0x000038, "Wrong size on FUICalcRectCheck");
static_assert(offsetof(FUICalcRectCheck, M_Index) == 0x000000, "Member 'FUICalcRectCheck::M_Index' has a wrong offset!");
static_assert(offsetof(FUICalcRectCheck, M_MoveRect) == 0x000004, "Member 'FUICalcRectCheck::M_MoveRect' has a wrong offset!");
static_assert(offsetof(FUICalcRectCheck, M_FixRect) == 0x00001C, "Member 'FUICalcRectCheck::M_FixRect' has a wrong offset!");
static_assert(offsetof(FUICalcRectCheck, M_IsBase) == 0x000034, "Member 'FUICalcRectCheck::M_IsBase' has a wrong offset!");

// ScriptStruct Project.MagatsuhiDevilSkillRow
// 0x0008 (0x0010 - 0x0008)
struct FMagatsuhiDevilSkillRow final : public FTableRowBase
{
public:
	int32                                         M_SkillId;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMagatsuhiDevilSkillRow) == 0x000008, "Wrong alignment on FMagatsuhiDevilSkillRow");
static_assert(sizeof(FMagatsuhiDevilSkillRow) == 0x000010, "Wrong size on FMagatsuhiDevilSkillRow");
static_assert(offsetof(FMagatsuhiDevilSkillRow, M_SkillId) == 0x000008, "Member 'FMagatsuhiDevilSkillRow::M_SkillId' has a wrong offset!");

// ScriptStruct Project.MagatsuhiDevilParamRateRow
// 0x0018 (0x0020 - 0x0008)
struct FMagatsuhiDevilParamRateRow final : public FTableRowBase
{
public:
	int32                                         M_HPRate;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AbilityRate;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EXPRate;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MakkaRate;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemRate;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMagatsuhiDevilParamRateRow) == 0x000008, "Wrong alignment on FMagatsuhiDevilParamRateRow");
static_assert(sizeof(FMagatsuhiDevilParamRateRow) == 0x000020, "Wrong size on FMagatsuhiDevilParamRateRow");
static_assert(offsetof(FMagatsuhiDevilParamRateRow, M_HPRate) == 0x000008, "Member 'FMagatsuhiDevilParamRateRow::M_HPRate' has a wrong offset!");
static_assert(offsetof(FMagatsuhiDevilParamRateRow, M_AbilityRate) == 0x00000C, "Member 'FMagatsuhiDevilParamRateRow::M_AbilityRate' has a wrong offset!");
static_assert(offsetof(FMagatsuhiDevilParamRateRow, M_EXPRate) == 0x000010, "Member 'FMagatsuhiDevilParamRateRow::M_EXPRate' has a wrong offset!");
static_assert(offsetof(FMagatsuhiDevilParamRateRow, M_MakkaRate) == 0x000014, "Member 'FMagatsuhiDevilParamRateRow::M_MakkaRate' has a wrong offset!");
static_assert(offsetof(FMagatsuhiDevilParamRateRow, M_ItemRate) == 0x000018, "Member 'FMagatsuhiDevilParamRateRow::M_ItemRate' has a wrong offset!");

// ScriptStruct Project.UniqueSymbolData
// 0x002C (0x002C - 0x0000)
struct FUniqueSymbolData final
{
public:
	int32                                         M_UniqueSymbolID;                                  // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EncountID;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EventEncountID;                                  // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SymbolId;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RebornRate;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_LockAfterBattle;                                 // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UniqueIcon;                                      // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsPrioGaze;                                      // 0x0016(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_PrioGazeDistance;                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StartFlag;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndFlag;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ChainEncountRate;                                // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ChainEncount_NotEntry;                           // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_NoChainEncount;                                  // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueSymbolData) == 0x000004, "Wrong alignment on FUniqueSymbolData");
static_assert(sizeof(FUniqueSymbolData) == 0x00002C, "Wrong size on FUniqueSymbolData");
static_assert(offsetof(FUniqueSymbolData, M_UniqueSymbolID) == 0x000000, "Member 'FUniqueSymbolData::M_UniqueSymbolID' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_EncountID) == 0x000004, "Member 'FUniqueSymbolData::M_EncountID' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_EventEncountID) == 0x000008, "Member 'FUniqueSymbolData::M_EventEncountID' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_SymbolId) == 0x00000C, "Member 'FUniqueSymbolData::M_SymbolId' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_RebornRate) == 0x000010, "Member 'FUniqueSymbolData::M_RebornRate' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_LockAfterBattle) == 0x000014, "Member 'FUniqueSymbolData::M_LockAfterBattle' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_UniqueIcon) == 0x000015, "Member 'FUniqueSymbolData::M_UniqueIcon' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_IsPrioGaze) == 0x000016, "Member 'FUniqueSymbolData::M_IsPrioGaze' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_PrioGazeDistance) == 0x000018, "Member 'FUniqueSymbolData::M_PrioGazeDistance' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_StartFlag) == 0x00001C, "Member 'FUniqueSymbolData::M_StartFlag' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_EndFlag) == 0x000020, "Member 'FUniqueSymbolData::M_EndFlag' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_ChainEncountRate) == 0x000024, "Member 'FUniqueSymbolData::M_ChainEncountRate' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_ChainEncount_NotEntry) == 0x000028, "Member 'FUniqueSymbolData::M_ChainEncount_NotEntry' has a wrong offset!");
static_assert(offsetof(FUniqueSymbolData, M_NoChainEncount) == 0x000029, "Member 'FUniqueSymbolData::M_NoChainEncount' has a wrong offset!");

// ScriptStruct Project.MagatsuhiDevilParamRate
// 0x0014 (0x0014 - 0x0000)
struct FMagatsuhiDevilParamRate final
{
public:
	int32                                         M_HPRate;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AbilityRate;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EXPRate;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MakkaRate;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemRate;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMagatsuhiDevilParamRate) == 0x000004, "Wrong alignment on FMagatsuhiDevilParamRate");
static_assert(sizeof(FMagatsuhiDevilParamRate) == 0x000014, "Wrong size on FMagatsuhiDevilParamRate");
static_assert(offsetof(FMagatsuhiDevilParamRate, M_HPRate) == 0x000000, "Member 'FMagatsuhiDevilParamRate::M_HPRate' has a wrong offset!");
static_assert(offsetof(FMagatsuhiDevilParamRate, M_AbilityRate) == 0x000004, "Member 'FMagatsuhiDevilParamRate::M_AbilityRate' has a wrong offset!");
static_assert(offsetof(FMagatsuhiDevilParamRate, M_EXPRate) == 0x000008, "Member 'FMagatsuhiDevilParamRate::M_EXPRate' has a wrong offset!");
static_assert(offsetof(FMagatsuhiDevilParamRate, M_MakkaRate) == 0x00000C, "Member 'FMagatsuhiDevilParamRate::M_MakkaRate' has a wrong offset!");
static_assert(offsetof(FMagatsuhiDevilParamRate, M_ItemRate) == 0x000010, "Member 'FMagatsuhiDevilParamRate::M_ItemRate' has a wrong offset!");

// ScriptStruct Project.BtlMoonAge
// 0x0008 (0x0008 - 0x0000)
struct FBtlMoonAge final
{
public:
	int32                                         M_TurnCount;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_AddOK;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlMoonAge) == 0x000004, "Wrong alignment on FBtlMoonAge");
static_assert(sizeof(FBtlMoonAge) == 0x000008, "Wrong size on FBtlMoonAge");
static_assert(offsetof(FBtlMoonAge, M_TurnCount) == 0x000000, "Member 'FBtlMoonAge::M_TurnCount' has a wrong offset!");
static_assert(offsetof(FBtlMoonAge, M_AddOK) == 0x000004, "Member 'FBtlMoonAge::M_AddOK' has a wrong offset!");

// ScriptStruct Project.SlateSlotData
// 0x002C (0x002C - 0x0000)
struct FSlateSlotData final
{
public:
	struct FMargin                                Offset;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnchors                               InAnchors;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              InAlignment;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InAutoSize;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlateSlotData) == 0x000004, "Wrong alignment on FSlateSlotData");
static_assert(sizeof(FSlateSlotData) == 0x00002C, "Wrong size on FSlateSlotData");
static_assert(offsetof(FSlateSlotData, Offset) == 0x000000, "Member 'FSlateSlotData::Offset' has a wrong offset!");
static_assert(offsetof(FSlateSlotData, InAnchors) == 0x000010, "Member 'FSlateSlotData::InAnchors' has a wrong offset!");
static_assert(offsetof(FSlateSlotData, InAlignment) == 0x000020, "Member 'FSlateSlotData::InAlignment' has a wrong offset!");
static_assert(offsetof(FSlateSlotData, InAutoSize) == 0x000028, "Member 'FSlateSlotData::InAutoSize' has a wrong offset!");

// ScriptStruct Project.PressIcon
// 0x000C (0x000C - 0x0000)
struct FPressIcon final
{
public:
	int32                                         M_PressPoint;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PressPointHalf;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ExtendInPressPoint;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPressIcon) == 0x000004, "Wrong alignment on FPressIcon");
static_assert(sizeof(FPressIcon) == 0x00000C, "Wrong size on FPressIcon");
static_assert(offsetof(FPressIcon, M_PressPoint) == 0x000000, "Member 'FPressIcon::M_PressPoint' has a wrong offset!");
static_assert(offsetof(FPressIcon, M_PressPointHalf) == 0x000004, "Member 'FPressIcon::M_PressPointHalf' has a wrong offset!");
static_assert(offsetof(FPressIcon, M_ExtendInPressPoint) == 0x000008, "Member 'FPressIcon::M_ExtendInPressPoint' has a wrong offset!");

// ScriptStruct Project.BtlCycle
// 0x0014 (0x0014 - 0x0000)
struct FBtlCycle final
{
public:
	int32                                         M_Flag;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Wait;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_WaitDefault;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Count;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_CYCLE_TYPE                              M_CycleType;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlCycle) == 0x000004, "Wrong alignment on FBtlCycle");
static_assert(sizeof(FBtlCycle) == 0x000014, "Wrong size on FBtlCycle");
static_assert(offsetof(FBtlCycle, M_Flag) == 0x000000, "Member 'FBtlCycle::M_Flag' has a wrong offset!");
static_assert(offsetof(FBtlCycle, M_Wait) == 0x000004, "Member 'FBtlCycle::M_Wait' has a wrong offset!");
static_assert(offsetof(FBtlCycle, M_WaitDefault) == 0x000008, "Member 'FBtlCycle::M_WaitDefault' has a wrong offset!");
static_assert(offsetof(FBtlCycle, M_Count) == 0x00000C, "Member 'FBtlCycle::M_Count' has a wrong offset!");
static_assert(offsetof(FBtlCycle, M_CycleType) == 0x000010, "Member 'FBtlCycle::M_CycleType' has a wrong offset!");

// ScriptStruct Project.BtlMainCommandUIData
// 0x0006 (0x0006 - 0x0000)
struct FBtlMainCommandUIData final
{
public:
	E_BTL_MAIN_COMMAND_TYPE                       M_CommandType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBtlCommandUIData                      M_CommandData;                                     // 0x0001(0x0005)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlMainCommandUIData) == 0x000001, "Wrong alignment on FBtlMainCommandUIData");
static_assert(sizeof(FBtlMainCommandUIData) == 0x000006, "Wrong size on FBtlMainCommandUIData");
static_assert(offsetof(FBtlMainCommandUIData, M_CommandType) == 0x000000, "Member 'FBtlMainCommandUIData::M_CommandType' has a wrong offset!");
static_assert(offsetof(FBtlMainCommandUIData, M_CommandData) == 0x000001, "Member 'FBtlMainCommandUIData::M_CommandData' has a wrong offset!");

// ScriptStruct Project.BtlGardenPointData
// 0x000C (0x000C - 0x0000)
struct FBtlGardenPointData final
{
public:
	int32                                         M_EvtID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsMagatsuka;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsMagatsuhiDevil;                                // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_HighestEnemyLevel;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlGardenPointData) == 0x000004, "Wrong alignment on FBtlGardenPointData");
static_assert(sizeof(FBtlGardenPointData) == 0x00000C, "Wrong size on FBtlGardenPointData");
static_assert(offsetof(FBtlGardenPointData, M_EvtID) == 0x000000, "Member 'FBtlGardenPointData::M_EvtID' has a wrong offset!");
static_assert(offsetof(FBtlGardenPointData, M_IsMagatsuka) == 0x000004, "Member 'FBtlGardenPointData::M_IsMagatsuka' has a wrong offset!");
static_assert(offsetof(FBtlGardenPointData, M_IsMagatsuhiDevil) == 0x000005, "Member 'FBtlGardenPointData::M_IsMagatsuhiDevil' has a wrong offset!");
static_assert(offsetof(FBtlGardenPointData, M_HighestEnemyLevel) == 0x000008, "Member 'FBtlGardenPointData::M_HighestEnemyLevel' has a wrong offset!");

// ScriptStruct Project.UILevelBootItemData
// 0x0028 (0x0028 - 0x0000)
struct FUILevelBootItemData final
{
public:
	class FString                                 DispName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCategory;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUILevelBootItemData) == 0x000008, "Wrong alignment on FUILevelBootItemData");
static_assert(sizeof(FUILevelBootItemData) == 0x000028, "Wrong size on FUILevelBootItemData");
static_assert(offsetof(FUILevelBootItemData, DispName) == 0x000000, "Member 'FUILevelBootItemData::DispName' has a wrong offset!");
static_assert(offsetof(FUILevelBootItemData, LevelName) == 0x000010, "Member 'FUILevelBootItemData::LevelName' has a wrong offset!");
static_assert(offsetof(FUILevelBootItemData, IsCategory) == 0x000020, "Member 'FUILevelBootItemData::IsCategory' has a wrong offset!");

// ScriptStruct Project.ChainEncountEnemyInfo
// 0x0018 (0x0018 - 0x0000)
struct FChainEncountEnemyInfo final
{
public:
	int32                                         M_EncountID;                                       // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_InnerSymbol;                                     // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Magatsuhi;                                       // 0x0005(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_EnemyIDList;                                     // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChainEncountEnemyInfo) == 0x000008, "Wrong alignment on FChainEncountEnemyInfo");
static_assert(sizeof(FChainEncountEnemyInfo) == 0x000018, "Wrong size on FChainEncountEnemyInfo");
static_assert(offsetof(FChainEncountEnemyInfo, M_EncountID) == 0x000000, "Member 'FChainEncountEnemyInfo::M_EncountID' has a wrong offset!");
static_assert(offsetof(FChainEncountEnemyInfo, M_InnerSymbol) == 0x000004, "Member 'FChainEncountEnemyInfo::M_InnerSymbol' has a wrong offset!");
static_assert(offsetof(FChainEncountEnemyInfo, M_Magatsuhi) == 0x000005, "Member 'FChainEncountEnemyInfo::M_Magatsuhi' has a wrong offset!");
static_assert(offsetof(FChainEncountEnemyInfo, M_EnemyIDList) == 0x000008, "Member 'FChainEncountEnemyInfo::M_EnemyIDList' has a wrong offset!");

// ScriptStruct Project.ChainEncountInfo
// 0x0020 (0x0020 - 0x0000)
struct FChainEncountInfo final
{
public:
	bool                                          M_Enable;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_BaseRate;                                        // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SymbolNum;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChainEncountEnemyInfo>         M_EnemyList;                                       // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChainEncountInfo) == 0x000008, "Wrong alignment on FChainEncountInfo");
static_assert(sizeof(FChainEncountInfo) == 0x000020, "Wrong size on FChainEncountInfo");
static_assert(offsetof(FChainEncountInfo, M_Enable) == 0x000000, "Member 'FChainEncountInfo::M_Enable' has a wrong offset!");
static_assert(offsetof(FChainEncountInfo, M_BaseRate) == 0x000004, "Member 'FChainEncountInfo::M_BaseRate' has a wrong offset!");
static_assert(offsetof(FChainEncountInfo, M_SymbolNum) == 0x000008, "Member 'FChainEncountInfo::M_SymbolNum' has a wrong offset!");
static_assert(offsetof(FChainEncountInfo, M_EnemyList) == 0x000010, "Member 'FChainEncountInfo::M_EnemyList' has a wrong offset!");

// ScriptStruct Project.BtlDescData
// 0x0090 (0x0090 - 0x0000)
struct FBtlDescData final
{
public:
	int32                                         M_EvtID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_SYMBOL_ENCOUNT                          M_SymbolEncountType;                               // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_pTargetMember;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_BGMNo;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EncID;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             M_OriginTransform;                                 // 0x0020(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_NotBattleActor;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_MagatsukaSpawn;                                  // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_MagatsukaBoss;                                   // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChainEncountInfo                      M_ChainEncountInfo;                                // 0x0068(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_HitMapAttack;                                    // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Magatsuhi;                                       // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_BossRushChallengeMode;                           // 0x008A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlDescData) == 0x000010, "Wrong alignment on FBtlDescData");
static_assert(sizeof(FBtlDescData) == 0x000090, "Wrong size on FBtlDescData");
static_assert(offsetof(FBtlDescData, M_EvtID) == 0x000000, "Member 'FBtlDescData::M_EvtID' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_SymbolEncountType) == 0x000004, "Member 'FBtlDescData::M_SymbolEncountType' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_pTargetMember) == 0x000008, "Member 'FBtlDescData::M_pTargetMember' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_BGMNo) == 0x000018, "Member 'FBtlDescData::M_BGMNo' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_EncID) == 0x00001C, "Member 'FBtlDescData::M_EncID' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_OriginTransform) == 0x000020, "Member 'FBtlDescData::M_OriginTransform' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_NotBattleActor) == 0x000050, "Member 'FBtlDescData::M_NotBattleActor' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_MagatsukaSpawn) == 0x000060, "Member 'FBtlDescData::M_MagatsukaSpawn' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_MagatsukaBoss) == 0x000061, "Member 'FBtlDescData::M_MagatsukaBoss' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_ChainEncountInfo) == 0x000068, "Member 'FBtlDescData::M_ChainEncountInfo' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_HitMapAttack) == 0x000088, "Member 'FBtlDescData::M_HitMapAttack' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_Magatsuhi) == 0x000089, "Member 'FBtlDescData::M_Magatsuhi' has a wrong offset!");
static_assert(offsetof(FBtlDescData, M_BossRushChallengeMode) == 0x00008A, "Member 'FBtlDescData::M_BossRushChallengeMode' has a wrong offset!");

// ScriptStruct Project.UniteSkillData
// 0x0008 (0x0008 - 0x0000)
struct FUniteSkillData final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAbleInherit;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDefaultSkill;                                    // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniteSkillData) == 0x000004, "Wrong alignment on FUniteSkillData");
static_assert(sizeof(FUniteSkillData) == 0x000008, "Wrong size on FUniteSkillData");
static_assert(offsetof(FUniteSkillData, SkillId) == 0x000000, "Member 'FUniteSkillData::SkillId' has a wrong offset!");
static_assert(offsetof(FUniteSkillData, IsAbleInherit) == 0x000004, "Member 'FUniteSkillData::IsAbleInherit' has a wrong offset!");
static_assert(offsetof(FUniteSkillData, IsDefaultSkill) == 0x000005, "Member 'FUniteSkillData::IsDefaultSkill' has a wrong offset!");

// ScriptStruct Project.BtlSummonData
// 0x000C (0x000C - 0x0000)
struct FBtlSummonData final
{
public:
	int32                                         M_DevilID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PartyIndex;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TaskIndex;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlSummonData) == 0x000004, "Wrong alignment on FBtlSummonData");
static_assert(sizeof(FBtlSummonData) == 0x00000C, "Wrong size on FBtlSummonData");
static_assert(offsetof(FBtlSummonData, M_DevilID) == 0x000000, "Member 'FBtlSummonData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FBtlSummonData, M_PartyIndex) == 0x000004, "Member 'FBtlSummonData::M_PartyIndex' has a wrong offset!");
static_assert(offsetof(FBtlSummonData, M_TaskIndex) == 0x000008, "Member 'FBtlSummonData::M_TaskIndex' has a wrong offset!");

// ScriptStruct Project.UniteCharaPanelParamData
// 0x002C (0x002C - 0x0000)
struct FUniteCharaPanelParamData final
{
public:
	int32                                         M_Devil;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPMax;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HpColorType;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPMax;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MpColorType;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Lv;                                              // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LvColorType;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Cost;                                            // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CostColorType;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteCharaPanelParamData) == 0x000004, "Wrong alignment on FUniteCharaPanelParamData");
static_assert(sizeof(FUniteCharaPanelParamData) == 0x00002C, "Wrong size on FUniteCharaPanelParamData");
static_assert(offsetof(FUniteCharaPanelParamData, M_Devil) == 0x000000, "Member 'FUniteCharaPanelParamData::M_Devil' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_HP) == 0x000004, "Member 'FUniteCharaPanelParamData::M_HP' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_HPMax) == 0x000008, "Member 'FUniteCharaPanelParamData::M_HPMax' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_HpColorType) == 0x00000C, "Member 'FUniteCharaPanelParamData::M_HpColorType' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_MP) == 0x000010, "Member 'FUniteCharaPanelParamData::M_MP' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_MPMax) == 0x000014, "Member 'FUniteCharaPanelParamData::M_MPMax' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_MpColorType) == 0x000018, "Member 'FUniteCharaPanelParamData::M_MpColorType' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_Lv) == 0x00001C, "Member 'FUniteCharaPanelParamData::M_Lv' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_LvColorType) == 0x000020, "Member 'FUniteCharaPanelParamData::M_LvColorType' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_Cost) == 0x000024, "Member 'FUniteCharaPanelParamData::M_Cost' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelParamData, M_CostColorType) == 0x000028, "Member 'FUniteCharaPanelParamData::M_CostColorType' has a wrong offset!");

// ScriptStruct Project.BtlResultData
// 0x0050 (0x0050 - 0x0000)
struct FBtlResultData final
{
public:
	TArray<int32>                                 M_ItemID;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_ItemCnt;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_Makka;                                           // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MaxLevel;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RecMagGauge;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_OneExp;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_OneExpLevel;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlResultData) == 0x000008, "Wrong alignment on FBtlResultData");
static_assert(sizeof(FBtlResultData) == 0x000050, "Wrong size on FBtlResultData");
static_assert(offsetof(FBtlResultData, M_ItemID) == 0x000000, "Member 'FBtlResultData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FBtlResultData, M_ItemCnt) == 0x000010, "Member 'FBtlResultData::M_ItemCnt' has a wrong offset!");
static_assert(offsetof(FBtlResultData, M_Makka) == 0x000020, "Member 'FBtlResultData::M_Makka' has a wrong offset!");
static_assert(offsetof(FBtlResultData, M_Exp) == 0x000024, "Member 'FBtlResultData::M_Exp' has a wrong offset!");
static_assert(offsetof(FBtlResultData, M_MaxLevel) == 0x000028, "Member 'FBtlResultData::M_MaxLevel' has a wrong offset!");
static_assert(offsetof(FBtlResultData, M_RecMagGauge) == 0x00002C, "Member 'FBtlResultData::M_RecMagGauge' has a wrong offset!");
static_assert(offsetof(FBtlResultData, M_OneExp) == 0x000030, "Member 'FBtlResultData::M_OneExp' has a wrong offset!");
static_assert(offsetof(FBtlResultData, M_OneExpLevel) == 0x000040, "Member 'FBtlResultData::M_OneExpLevel' has a wrong offset!");

// ScriptStruct Project.BtlKillData
// 0x0008 (0x0008 - 0x0000)
struct FBtlKillData final
{
public:
	int32                                         M_EnemyID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_KillCnt;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlKillData) == 0x000004, "Wrong alignment on FBtlKillData");
static_assert(sizeof(FBtlKillData) == 0x000008, "Wrong size on FBtlKillData");
static_assert(offsetof(FBtlKillData, M_EnemyID) == 0x000000, "Member 'FBtlKillData::M_EnemyID' has a wrong offset!");
static_assert(offsetof(FBtlKillData, M_KillCnt) == 0x000004, "Member 'FBtlKillData::M_KillCnt' has a wrong offset!");

// ScriptStruct Project.IconData
// 0x000C (0x000C - 0x0000)
struct FIconData final
{
public:
	E_ICON_TYPE                                   M_IconType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_IconID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Count;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIconData) == 0x000004, "Wrong alignment on FIconData");
static_assert(sizeof(FIconData) == 0x00000C, "Wrong size on FIconData");
static_assert(offsetof(FIconData, M_IconType) == 0x000000, "Member 'FIconData::M_IconType' has a wrong offset!");
static_assert(offsetof(FIconData, M_IconID) == 0x000004, "Member 'FIconData::M_IconID' has a wrong offset!");
static_assert(offsetof(FIconData, M_Count) == 0x000008, "Member 'FIconData::M_Count' has a wrong offset!");

// ScriptStruct Project.BtlRefData
// 0x0008 (0x0008 - 0x0000)
struct FBtlRefData final
{
public:
	int32                                         M_HP;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPMax;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlRefData) == 0x000004, "Wrong alignment on FBtlRefData");
static_assert(sizeof(FBtlRefData) == 0x000008, "Wrong size on FBtlRefData");
static_assert(offsetof(FBtlRefData, M_HP) == 0x000000, "Member 'FBtlRefData::M_HP' has a wrong offset!");
static_assert(offsetof(FBtlRefData, M_HPMax) == 0x000004, "Member 'FBtlRefData::M_HPMax' has a wrong offset!");

// ScriptStruct Project.BtlPartnerAction
// 0x0014 (0x0014 - 0x0000)
struct FBtlPartnerAction final
{
public:
	int32                                         M_SrcIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TargetIndex;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillId;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemID;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Action;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlPartnerAction) == 0x000004, "Wrong alignment on FBtlPartnerAction");
static_assert(sizeof(FBtlPartnerAction) == 0x000014, "Wrong size on FBtlPartnerAction");
static_assert(offsetof(FBtlPartnerAction, M_SrcIndex) == 0x000000, "Member 'FBtlPartnerAction::M_SrcIndex' has a wrong offset!");
static_assert(offsetof(FBtlPartnerAction, M_TargetIndex) == 0x000004, "Member 'FBtlPartnerAction::M_TargetIndex' has a wrong offset!");
static_assert(offsetof(FBtlPartnerAction, M_SkillId) == 0x000008, "Member 'FBtlPartnerAction::M_SkillId' has a wrong offset!");
static_assert(offsetof(FBtlPartnerAction, M_ItemID) == 0x00000C, "Member 'FBtlPartnerAction::M_ItemID' has a wrong offset!");
static_assert(offsetof(FBtlPartnerAction, M_Action) == 0x000010, "Member 'FBtlPartnerAction::M_Action' has a wrong offset!");

// ScriptStruct Project.FusionCombineDispID
// 0x0010 (0x0010 - 0x0000)
struct FFusionCombineDispID final
{
public:
	int32                                         CombineListID;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UIPosID;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRate;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opacity;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFusionCombineDispID) == 0x000004, "Wrong alignment on FFusionCombineDispID");
static_assert(sizeof(FFusionCombineDispID) == 0x000010, "Wrong size on FFusionCombineDispID");
static_assert(offsetof(FFusionCombineDispID, CombineListID) == 0x000000, "Member 'FFusionCombineDispID::CombineListID' has a wrong offset!");
static_assert(offsetof(FFusionCombineDispID, UIPosID) == 0x000004, "Member 'FFusionCombineDispID::UIPosID' has a wrong offset!");
static_assert(offsetof(FFusionCombineDispID, MoveRate) == 0x000008, "Member 'FFusionCombineDispID::MoveRate' has a wrong offset!");
static_assert(offsetof(FFusionCombineDispID, Opacity) == 0x00000C, "Member 'FFusionCombineDispID::Opacity' has a wrong offset!");

// ScriptStruct Project.BtlActionStack
// 0x0014 (0x0014 - 0x0000)
struct FBtlActionStack final
{
public:
	E_BTL_ACT_TYPE                                M_ActionType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_From;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_To;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Data;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_AutoDestroy;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBtlActionStack) == 0x000004, "Wrong alignment on FBtlActionStack");
static_assert(sizeof(FBtlActionStack) == 0x000014, "Wrong size on FBtlActionStack");
static_assert(offsetof(FBtlActionStack, M_ActionType) == 0x000000, "Member 'FBtlActionStack::M_ActionType' has a wrong offset!");
static_assert(offsetof(FBtlActionStack, M_From) == 0x000004, "Member 'FBtlActionStack::M_From' has a wrong offset!");
static_assert(offsetof(FBtlActionStack, M_To) == 0x000008, "Member 'FBtlActionStack::M_To' has a wrong offset!");
static_assert(offsetof(FBtlActionStack, M_Data) == 0x00000C, "Member 'FBtlActionStack::M_Data' has a wrong offset!");
static_assert(offsetof(FBtlActionStack, M_AutoDestroy) == 0x000010, "Member 'FBtlActionStack::M_AutoDestroy' has a wrong offset!");

// ScriptStruct Project.UpliftingGauge
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FUpliftingGauge final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUpliftingGauge) == 0x000008, "Wrong alignment on FUpliftingGauge");
static_assert(sizeof(FUpliftingGauge) == 0x000010, "Wrong size on FUpliftingGauge");

// ScriptStruct Project.StatusCursorData
// 0x0020 (0x0020 - 0x0000)
struct FStatusCursorData final
{
public:
	int32                                         M_Index;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BackIndex;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_STATUS_SKILL_LIST_TYPE                      M_NowMoveCursorType;                               // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ListAllNum;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_ListNum;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusCursorData) == 0x000008, "Wrong alignment on FStatusCursorData");
static_assert(sizeof(FStatusCursorData) == 0x000020, "Wrong size on FStatusCursorData");
static_assert(offsetof(FStatusCursorData, M_Index) == 0x000000, "Member 'FStatusCursorData::M_Index' has a wrong offset!");
static_assert(offsetof(FStatusCursorData, M_BackIndex) == 0x000004, "Member 'FStatusCursorData::M_BackIndex' has a wrong offset!");
static_assert(offsetof(FStatusCursorData, M_NowMoveCursorType) == 0x000008, "Member 'FStatusCursorData::M_NowMoveCursorType' has a wrong offset!");
static_assert(offsetof(FStatusCursorData, M_ListAllNum) == 0x00000C, "Member 'FStatusCursorData::M_ListAllNum' has a wrong offset!");
static_assert(offsetof(FStatusCursorData, M_ListNum) == 0x000010, "Member 'FStatusCursorData::M_ListNum' has a wrong offset!");

// ScriptStruct Project.BenefitDevilMsgData
// 0x0008 (0x0008 - 0x0000)
struct FBenefitDevilMsgData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Level;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenefitDevilMsgData) == 0x000004, "Wrong alignment on FBenefitDevilMsgData");
static_assert(sizeof(FBenefitDevilMsgData) == 0x000008, "Wrong size on FBenefitDevilMsgData");
static_assert(offsetof(FBenefitDevilMsgData, M_Id) == 0x000000, "Member 'FBenefitDevilMsgData::M_Id' has a wrong offset!");
static_assert(offsetof(FBenefitDevilMsgData, M_Level) == 0x000004, "Member 'FBenefitDevilMsgData::M_Level' has a wrong offset!");

// ScriptStruct Project.BenefitDevilMsgDataList
// 0x0010 (0x0010 - 0x0000)
struct FBenefitDevilMsgDataList final
{
public:
	TArray<struct FBenefitDevilMsgData>           M_Data;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenefitDevilMsgDataList) == 0x000008, "Wrong alignment on FBenefitDevilMsgDataList");
static_assert(sizeof(FBenefitDevilMsgDataList) == 0x000010, "Wrong size on FBenefitDevilMsgDataList");
static_assert(offsetof(FBenefitDevilMsgDataList, M_Data) == 0x000000, "Member 'FBenefitDevilMsgDataList::M_Data' has a wrong offset!");

// ScriptStruct Project.AbilData
// 0x001C (0x001C - 0x0000)
struct FAbilData final
{
public:
	int32                                         M_HPMax;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPMax;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Str;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Vit;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Mgi;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Agi;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Luc;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilData) == 0x000004, "Wrong alignment on FAbilData");
static_assert(sizeof(FAbilData) == 0x00001C, "Wrong size on FAbilData");
static_assert(offsetof(FAbilData, M_HPMax) == 0x000000, "Member 'FAbilData::M_HPMax' has a wrong offset!");
static_assert(offsetof(FAbilData, M_MPMax) == 0x000004, "Member 'FAbilData::M_MPMax' has a wrong offset!");
static_assert(offsetof(FAbilData, M_Str) == 0x000008, "Member 'FAbilData::M_Str' has a wrong offset!");
static_assert(offsetof(FAbilData, M_Vit) == 0x00000C, "Member 'FAbilData::M_Vit' has a wrong offset!");
static_assert(offsetof(FAbilData, M_Mgi) == 0x000010, "Member 'FAbilData::M_Mgi' has a wrong offset!");
static_assert(offsetof(FAbilData, M_Agi) == 0x000014, "Member 'FAbilData::M_Agi' has a wrong offset!");
static_assert(offsetof(FAbilData, M_Luc) == 0x000018, "Member 'FAbilData::M_Luc' has a wrong offset!");

// ScriptStruct Project.StatusParamData
// 0x0054 (0x0054 - 0x0000)
struct FStatusParamData final
{
public:
	struct FAbilData                              M_Param;                                           // 0x0000(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAbilData                              M_BulidParam;                                      // 0x001C(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAbilData                              M_DiffParam;                                       // 0x0038(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusParamData) == 0x000004, "Wrong alignment on FStatusParamData");
static_assert(sizeof(FStatusParamData) == 0x000054, "Wrong size on FStatusParamData");
static_assert(offsetof(FStatusParamData, M_Param) == 0x000000, "Member 'FStatusParamData::M_Param' has a wrong offset!");
static_assert(offsetof(FStatusParamData, M_BulidParam) == 0x00001C, "Member 'FStatusParamData::M_BulidParam' has a wrong offset!");
static_assert(offsetof(FStatusParamData, M_DiffParam) == 0x000038, "Member 'FStatusParamData::M_DiffParam' has a wrong offset!");

// ScriptStruct Project.StatusSkillData
// 0x0014 (0x0014 - 0x0000)
struct FStatusSkillData final
{
public:
	E_LEARN_SKILL_TYPE                            M_LearnType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SkillId;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillCount;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BulidSkillCount;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsAuto;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusSkillData) == 0x000004, "Wrong alignment on FStatusSkillData");
static_assert(sizeof(FStatusSkillData) == 0x000014, "Wrong size on FStatusSkillData");
static_assert(offsetof(FStatusSkillData, M_LearnType) == 0x000000, "Member 'FStatusSkillData::M_LearnType' has a wrong offset!");
static_assert(offsetof(FStatusSkillData, M_SkillId) == 0x000004, "Member 'FStatusSkillData::M_SkillId' has a wrong offset!");
static_assert(offsetof(FStatusSkillData, M_SkillCount) == 0x000008, "Member 'FStatusSkillData::M_SkillCount' has a wrong offset!");
static_assert(offsetof(FStatusSkillData, M_BulidSkillCount) == 0x00000C, "Member 'FStatusSkillData::M_BulidSkillCount' has a wrong offset!");
static_assert(offsetof(FStatusSkillData, M_IsAuto) == 0x000010, "Member 'FStatusSkillData::M_IsAuto' has a wrong offset!");

// ScriptStruct Project.StatusSkillTekisei
// 0x0010 (0x0010 - 0x0000)
struct FStatusSkillTekisei final
{
public:
	E_SKILL_TEKISEI_CATEGORY                      M_Category;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_TekiseiCnt;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BuildTekiseiCnt;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_SKILL_ICON                                  M_IconID;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusSkillTekisei) == 0x000004, "Wrong alignment on FStatusSkillTekisei");
static_assert(sizeof(FStatusSkillTekisei) == 0x000010, "Wrong size on FStatusSkillTekisei");
static_assert(offsetof(FStatusSkillTekisei, M_Category) == 0x000000, "Member 'FStatusSkillTekisei::M_Category' has a wrong offset!");
static_assert(offsetof(FStatusSkillTekisei, M_TekiseiCnt) == 0x000004, "Member 'FStatusSkillTekisei::M_TekiseiCnt' has a wrong offset!");
static_assert(offsetof(FStatusSkillTekisei, M_BuildTekiseiCnt) == 0x000008, "Member 'FStatusSkillTekisei::M_BuildTekiseiCnt' has a wrong offset!");
static_assert(offsetof(FStatusSkillTekisei, M_IconID) == 0x00000C, "Member 'FStatusSkillTekisei::M_IconID' has a wrong offset!");

// ScriptStruct Project.StatusAddSkillData
// 0x0008 (0x0008 - 0x0000)
struct FStatusAddSkillData final
{
public:
	int32                                         M_Level;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillId;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusAddSkillData) == 0x000004, "Wrong alignment on FStatusAddSkillData");
static_assert(sizeof(FStatusAddSkillData) == 0x000008, "Wrong size on FStatusAddSkillData");
static_assert(offsetof(FStatusAddSkillData, M_Level) == 0x000000, "Member 'FStatusAddSkillData::M_Level' has a wrong offset!");
static_assert(offsetof(FStatusAddSkillData, M_SkillId) == 0x000004, "Member 'FStatusAddSkillData::M_SkillId' has a wrong offset!");

// ScriptStruct Project.CampStatusData
// 0x00F0 (0x00F0 - 0x0000)
struct FCampStatusData final
{
public:
	class FString                                 M_Name;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DevilID;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NkmIndex;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_PLAYER_TYPE                                 M_PlayerType;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Level;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BadStatus;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<E_SKILL_LIMITED>                       M_SkillLimit;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FStatusParamData                       M_Param;                                           // 0x0040(0x0054)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStatusSkillData>               M_Skill;                                           // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStatusSkillData>               M_AutoSkill;                                       // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStatusSkillTekisei>            M_SkillTekisei;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStatusDefenceAishou>           M_DefenceAishou;                                   // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_ParamPoint;                                      // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStatusAddSkillData>            M_AddSkill;                                        // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampStatusData) == 0x000008, "Wrong alignment on FCampStatusData");
static_assert(sizeof(FCampStatusData) == 0x0000F0, "Wrong size on FCampStatusData");
static_assert(offsetof(FCampStatusData, M_Name) == 0x000000, "Member 'FCampStatusData::M_Name' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_DevilID) == 0x000010, "Member 'FCampStatusData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_NkmIndex) == 0x000014, "Member 'FCampStatusData::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_PlayerType) == 0x000018, "Member 'FCampStatusData::M_PlayerType' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_Level) == 0x00001C, "Member 'FCampStatusData::M_Level' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_HP) == 0x000020, "Member 'FCampStatusData::M_HP' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_MP) == 0x000024, "Member 'FCampStatusData::M_MP' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_Exp) == 0x000028, "Member 'FCampStatusData::M_Exp' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_BadStatus) == 0x00002C, "Member 'FCampStatusData::M_BadStatus' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_SkillLimit) == 0x000030, "Member 'FCampStatusData::M_SkillLimit' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_Param) == 0x000040, "Member 'FCampStatusData::M_Param' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_Skill) == 0x000098, "Member 'FCampStatusData::M_Skill' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_AutoSkill) == 0x0000A8, "Member 'FCampStatusData::M_AutoSkill' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_SkillTekisei) == 0x0000B8, "Member 'FCampStatusData::M_SkillTekisei' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_DefenceAishou) == 0x0000C8, "Member 'FCampStatusData::M_DefenceAishou' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_ParamPoint) == 0x0000D8, "Member 'FCampStatusData::M_ParamPoint' has a wrong offset!");
static_assert(offsetof(FCampStatusData, M_AddSkill) == 0x0000E0, "Member 'FCampStatusData::M_AddSkill' has a wrong offset!");

// ScriptStruct Project.BenefitItemMsgDataList
// 0x0010 (0x0010 - 0x0000)
struct FBenefitItemMsgDataList final
{
public:
	TArray<struct FBenefitItemData>               M_Data;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBenefitItemMsgDataList) == 0x000008, "Wrong alignment on FBenefitItemMsgDataList");
static_assert(sizeof(FBenefitItemMsgDataList) == 0x000010, "Wrong size on FBenefitItemMsgDataList");
static_assert(offsetof(FBenefitItemMsgDataList, M_Data) == 0x000000, "Member 'FBenefitItemMsgDataList::M_Data' has a wrong offset!");

// ScriptStruct Project.BenefitItemTableData
// 0x0006 (0x0006 - 0x0000)
struct alignas(0x02) FBenefitItemTableData final
{
public:
	uint8                                         Pad_0[0x6];                                        // 0x0000(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBenefitItemTableData) == 0x000002, "Wrong alignment on FBenefitItemTableData");
static_assert(sizeof(FBenefitItemTableData) == 0x000006, "Wrong size on FBenefitItemTableData");

// ScriptStruct Project.SpecialFusionResultDevil
// 0x001C (0x001C - 0x0000)
struct FSpecialFusionResultDevil final
{
public:
	int32                                         DevilID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_UNITECHARAPANEL_DEVILDATATYPE               Type;                                              // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Lv;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hp;                                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mp;                                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialFusionResultDevil) == 0x000004, "Wrong alignment on FSpecialFusionResultDevil");
static_assert(sizeof(FSpecialFusionResultDevil) == 0x00001C, "Wrong size on FSpecialFusionResultDevil");
static_assert(offsetof(FSpecialFusionResultDevil, DevilID) == 0x000000, "Member 'FSpecialFusionResultDevil::DevilID' has a wrong offset!");
static_assert(offsetof(FSpecialFusionResultDevil, Type) == 0x000004, "Member 'FSpecialFusionResultDevil::Type' has a wrong offset!");
static_assert(offsetof(FSpecialFusionResultDevil, Cost) == 0x000008, "Member 'FSpecialFusionResultDevil::Cost' has a wrong offset!");
static_assert(offsetof(FSpecialFusionResultDevil, Exp) == 0x00000C, "Member 'FSpecialFusionResultDevil::Exp' has a wrong offset!");
static_assert(offsetof(FSpecialFusionResultDevil, Lv) == 0x000010, "Member 'FSpecialFusionResultDevil::Lv' has a wrong offset!");
static_assert(offsetof(FSpecialFusionResultDevil, Hp) == 0x000014, "Member 'FSpecialFusionResultDevil::Hp' has a wrong offset!");
static_assert(offsetof(FSpecialFusionResultDevil, Mp) == 0x000018, "Member 'FSpecialFusionResultDevil::Mp' has a wrong offset!");

// ScriptStruct Project.BinTableState
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBinTableState final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBinTableState) == 0x000008, "Wrong alignment on FBinTableState");
static_assert(sizeof(FBinTableState) == 0x000010, "Wrong size on FBinTableState");

// ScriptStruct Project.PanelGaugeAnimeBaseData
// 0x0010 (0x0010 - 0x0000)
struct FPanelGaugeAnimeBaseData final
{
public:
	float                                         M_Time;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Alpha;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsStartAnime;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AddCount;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPanelGaugeAnimeBaseData) == 0x000004, "Wrong alignment on FPanelGaugeAnimeBaseData");
static_assert(sizeof(FPanelGaugeAnimeBaseData) == 0x000010, "Wrong size on FPanelGaugeAnimeBaseData");
static_assert(offsetof(FPanelGaugeAnimeBaseData, M_Time) == 0x000000, "Member 'FPanelGaugeAnimeBaseData::M_Time' has a wrong offset!");
static_assert(offsetof(FPanelGaugeAnimeBaseData, M_Alpha) == 0x000004, "Member 'FPanelGaugeAnimeBaseData::M_Alpha' has a wrong offset!");
static_assert(offsetof(FPanelGaugeAnimeBaseData, M_IsStartAnime) == 0x000008, "Member 'FPanelGaugeAnimeBaseData::M_IsStartAnime' has a wrong offset!");
static_assert(offsetof(FPanelGaugeAnimeBaseData, M_AddCount) == 0x00000C, "Member 'FPanelGaugeAnimeBaseData::M_AddCount' has a wrong offset!");

// ScriptStruct Project.ListAnimationBaseData
// 0x0010 (0x0010 - 0x0000)
struct FListAnimationBaseData final
{
public:
	bool                                          M_bListAnimationFlag;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_sAnimationStepCount;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_sDisplayMax;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fListAnimationTime;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FListAnimationBaseData) == 0x000004, "Wrong alignment on FListAnimationBaseData");
static_assert(sizeof(FListAnimationBaseData) == 0x000010, "Wrong size on FListAnimationBaseData");
static_assert(offsetof(FListAnimationBaseData, M_bListAnimationFlag) == 0x000000, "Member 'FListAnimationBaseData::M_bListAnimationFlag' has a wrong offset!");
static_assert(offsetof(FListAnimationBaseData, M_sAnimationStepCount) == 0x000004, "Member 'FListAnimationBaseData::M_sAnimationStepCount' has a wrong offset!");
static_assert(offsetof(FListAnimationBaseData, M_sDisplayMax) == 0x000008, "Member 'FListAnimationBaseData::M_sDisplayMax' has a wrong offset!");
static_assert(offsetof(FListAnimationBaseData, M_fListAnimationTime) == 0x00000C, "Member 'FListAnimationBaseData::M_fListAnimationTime' has a wrong offset!");

// ScriptStruct Project.SortMouseBaseData
// 0x0014 (0x0014 - 0x0000)
struct FSortMouseBaseData final
{
public:
	bool                                          M_bSortParameter;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bLockSortMouseClick;                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SortListIndex;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortDispIndex;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortOffsetIndex;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortElementIndex;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSortMouseBaseData) == 0x000004, "Wrong alignment on FSortMouseBaseData");
static_assert(sizeof(FSortMouseBaseData) == 0x000014, "Wrong size on FSortMouseBaseData");
static_assert(offsetof(FSortMouseBaseData, M_bSortParameter) == 0x000000, "Member 'FSortMouseBaseData::M_bSortParameter' has a wrong offset!");
static_assert(offsetof(FSortMouseBaseData, M_bLockSortMouseClick) == 0x000001, "Member 'FSortMouseBaseData::M_bLockSortMouseClick' has a wrong offset!");
static_assert(offsetof(FSortMouseBaseData, M_SortListIndex) == 0x000004, "Member 'FSortMouseBaseData::M_SortListIndex' has a wrong offset!");
static_assert(offsetof(FSortMouseBaseData, M_SortDispIndex) == 0x000008, "Member 'FSortMouseBaseData::M_SortDispIndex' has a wrong offset!");
static_assert(offsetof(FSortMouseBaseData, M_SortOffsetIndex) == 0x00000C, "Member 'FSortMouseBaseData::M_SortOffsetIndex' has a wrong offset!");
static_assert(offsetof(FSortMouseBaseData, M_SortElementIndex) == 0x000010, "Member 'FSortMouseBaseData::M_SortElementIndex' has a wrong offset!");

// ScriptStruct Project.CursorStockBaseData
// 0x0014 (0x0014 - 0x0000)
struct FCursorStockBaseData final
{
public:
	int32                                         M_Number;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Offset;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Position;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DisplayMax;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_MovingFlag;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCursorStockBaseData) == 0x000004, "Wrong alignment on FCursorStockBaseData");
static_assert(sizeof(FCursorStockBaseData) == 0x000014, "Wrong size on FCursorStockBaseData");
static_assert(offsetof(FCursorStockBaseData, M_Number) == 0x000000, "Member 'FCursorStockBaseData::M_Number' has a wrong offset!");
static_assert(offsetof(FCursorStockBaseData, M_Offset) == 0x000004, "Member 'FCursorStockBaseData::M_Offset' has a wrong offset!");
static_assert(offsetof(FCursorStockBaseData, M_Position) == 0x000008, "Member 'FCursorStockBaseData::M_Position' has a wrong offset!");
static_assert(offsetof(FCursorStockBaseData, M_DisplayMax) == 0x00000C, "Member 'FCursorStockBaseData::M_DisplayMax' has a wrong offset!");
static_assert(offsetof(FCursorStockBaseData, M_MovingFlag) == 0x000010, "Member 'FCursorStockBaseData::M_MovingFlag' has a wrong offset!");

// ScriptStruct Project.GardenTutorialSpot
// 0x0050 (0x0050 - 0x0000)
struct FGardenTutorialSpot final
{
public:
	class AGardenActorSpawner*                    TutorialSpawnSpot;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TutorialCameraTransform;                           // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TutorialCameraFOV;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenTutorialSpot) == 0x000010, "Wrong alignment on FGardenTutorialSpot");
static_assert(sizeof(FGardenTutorialSpot) == 0x000050, "Wrong size on FGardenTutorialSpot");
static_assert(offsetof(FGardenTutorialSpot, TutorialSpawnSpot) == 0x000000, "Member 'FGardenTutorialSpot::TutorialSpawnSpot' has a wrong offset!");
static_assert(offsetof(FGardenTutorialSpot, TutorialCameraTransform) == 0x000010, "Member 'FGardenTutorialSpot::TutorialCameraTransform' has a wrong offset!");
static_assert(offsetof(FGardenTutorialSpot, TutorialCameraFOV) == 0x000040, "Member 'FGardenTutorialSpot::TutorialCameraFOV' has a wrong offset!");
static_assert(offsetof(FGardenTutorialSpot, DisplayTime) == 0x000044, "Member 'FGardenTutorialSpot::DisplayTime' has a wrong offset!");

// ScriptStruct Project.CursorCharaBaseData
// 0x0014 (0x0014 - 0x0000)
struct FCursorCharaBaseData final
{
public:
	int32                                         M_Number;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Offset;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Position;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DisplayMax;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_MovingFlag;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCursorCharaBaseData) == 0x000004, "Wrong alignment on FCursorCharaBaseData");
static_assert(sizeof(FCursorCharaBaseData) == 0x000014, "Wrong size on FCursorCharaBaseData");
static_assert(offsetof(FCursorCharaBaseData, M_Number) == 0x000000, "Member 'FCursorCharaBaseData::M_Number' has a wrong offset!");
static_assert(offsetof(FCursorCharaBaseData, M_Offset) == 0x000004, "Member 'FCursorCharaBaseData::M_Offset' has a wrong offset!");
static_assert(offsetof(FCursorCharaBaseData, M_Position) == 0x000008, "Member 'FCursorCharaBaseData::M_Position' has a wrong offset!");
static_assert(offsetof(FCursorCharaBaseData, M_DisplayMax) == 0x00000C, "Member 'FCursorCharaBaseData::M_DisplayMax' has a wrong offset!");
static_assert(offsetof(FCursorCharaBaseData, M_MovingFlag) == 0x000010, "Member 'FCursorCharaBaseData::M_MovingFlag' has a wrong offset!");

// ScriptStruct Project.CursorBaseData
// 0x0014 (0x0014 - 0x0000)
struct FCursorBaseData final
{
public:
	int32                                         M_Number;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Offset;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Position;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DisplayMax;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_MovingFlag;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCursorBaseData) == 0x000004, "Wrong alignment on FCursorBaseData");
static_assert(sizeof(FCursorBaseData) == 0x000014, "Wrong size on FCursorBaseData");
static_assert(offsetof(FCursorBaseData, M_Number) == 0x000000, "Member 'FCursorBaseData::M_Number' has a wrong offset!");
static_assert(offsetof(FCursorBaseData, M_Offset) == 0x000004, "Member 'FCursorBaseData::M_Offset' has a wrong offset!");
static_assert(offsetof(FCursorBaseData, M_Position) == 0x000008, "Member 'FCursorBaseData::M_Position' has a wrong offset!");
static_assert(offsetof(FCursorBaseData, M_DisplayMax) == 0x00000C, "Member 'FCursorBaseData::M_DisplayMax' has a wrong offset!");
static_assert(offsetof(FCursorBaseData, M_MovingFlag) == 0x000010, "Member 'FCursorBaseData::M_MovingFlag' has a wrong offset!");

// ScriptStruct Project.MissionSaveOneData
// 0x0030 (0x0030 - 0x0000)
struct FMissionSaveOneData final
{
public:
	bool                                          IsEntry;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsComplete;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCompleteInfo;                                    // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEnd;                                          // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLogUpdated;                                      // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TIME_ATTACK_MISSION_STATE                   TimeAttackState;                                   // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MoonAgePassed;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoonAgeReported;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurrentValues;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 LastReportedInfos;                                 // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionSaveOneData) == 0x000008, "Wrong alignment on FMissionSaveOneData");
static_assert(sizeof(FMissionSaveOneData) == 0x000030, "Wrong size on FMissionSaveOneData");
static_assert(offsetof(FMissionSaveOneData, IsEntry) == 0x000000, "Member 'FMissionSaveOneData::IsEntry' has a wrong offset!");
static_assert(offsetof(FMissionSaveOneData, IsComplete) == 0x000001, "Member 'FMissionSaveOneData::IsComplete' has a wrong offset!");
static_assert(offsetof(FMissionSaveOneData, IsCompleteInfo) == 0x000002, "Member 'FMissionSaveOneData::IsCompleteInfo' has a wrong offset!");
static_assert(offsetof(FMissionSaveOneData, IsNewEnd) == 0x000003, "Member 'FMissionSaveOneData::IsNewEnd' has a wrong offset!");
static_assert(offsetof(FMissionSaveOneData, IsLogUpdated) == 0x000004, "Member 'FMissionSaveOneData::IsLogUpdated' has a wrong offset!");
static_assert(offsetof(FMissionSaveOneData, TimeAttackState) == 0x000005, "Member 'FMissionSaveOneData::TimeAttackState' has a wrong offset!");
static_assert(offsetof(FMissionSaveOneData, MoonAgePassed) == 0x000008, "Member 'FMissionSaveOneData::MoonAgePassed' has a wrong offset!");
static_assert(offsetof(FMissionSaveOneData, MoonAgeReported) == 0x00000C, "Member 'FMissionSaveOneData::MoonAgeReported' has a wrong offset!");
static_assert(offsetof(FMissionSaveOneData, CurrentValues) == 0x000010, "Member 'FMissionSaveOneData::CurrentValues' has a wrong offset!");
static_assert(offsetof(FMissionSaveOneData, LastReportedInfos) == 0x000020, "Member 'FMissionSaveOneData::LastReportedInfos' has a wrong offset!");

// ScriptStruct Project.MissionSaveData
// 0x0010 (0x0010 - 0x0000)
struct FMissionSaveData final
{
public:
	TArray<struct FMissionSaveOneData>            MissionList;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionSaveData) == 0x000008, "Wrong alignment on FMissionSaveData");
static_assert(sizeof(FMissionSaveData) == 0x000010, "Wrong size on FMissionSaveData");
static_assert(offsetof(FMissionSaveData, MissionList) == 0x000000, "Member 'FMissionSaveData::MissionList' has a wrong offset!");

// ScriptStruct Project.MapAutoHealResult
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FMapAutoHealResult final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_NkmIndex;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PrevHP;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NextHP;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PrevMP;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NextMP;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapAutoHealResult) == 0x000008, "Wrong alignment on FMapAutoHealResult");
static_assert(sizeof(FMapAutoHealResult) == 0x000020, "Wrong size on FMapAutoHealResult");
static_assert(offsetof(FMapAutoHealResult, M_NkmIndex) == 0x000008, "Member 'FMapAutoHealResult::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FMapAutoHealResult, M_PrevHP) == 0x00000C, "Member 'FMapAutoHealResult::M_PrevHP' has a wrong offset!");
static_assert(offsetof(FMapAutoHealResult, M_NextHP) == 0x000010, "Member 'FMapAutoHealResult::M_NextHP' has a wrong offset!");
static_assert(offsetof(FMapAutoHealResult, M_PrevMP) == 0x000014, "Member 'FMapAutoHealResult::M_PrevMP' has a wrong offset!");
static_assert(offsetof(FMapAutoHealResult, M_NextMP) == 0x000018, "Member 'FMapAutoHealResult::M_NextMP' has a wrong offset!");

// ScriptStruct Project.EnableCheckGamertagFontData
// 0x0008 (0x0008 - 0x0000)
struct FEnableCheckGamertagFontData final
{
public:
	class UObject*                                FontObject;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnableCheckGamertagFontData) == 0x000008, "Wrong alignment on FEnableCheckGamertagFontData");
static_assert(sizeof(FEnableCheckGamertagFontData) == 0x000008, "Wrong size on FEnableCheckGamertagFontData");
static_assert(offsetof(FEnableCheckGamertagFontData, FontObject) == 0x000000, "Member 'FEnableCheckGamertagFontData::FontObject' has a wrong offset!");

// ScriptStruct Project.ResultGiftData
// 0x0064 (0x0064 - 0x0000)
struct alignas(0x04) FResultGiftData final
{
public:
	uint8                                         Pad_0[0x64];                                       // 0x0000(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResultGiftData) == 0x000004, "Wrong alignment on FResultGiftData");
static_assert(sizeof(FResultGiftData) == 0x000064, "Wrong size on FResultGiftData");

// ScriptStruct Project.BtnHelpInfo
// 0x0020 (0x0020 - 0x0000)
struct FBtnHelpInfo final
{
public:
	E_BTN_HELP_MAPPING_KEY_TYPE                   MappingType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HelpMsg;                                           // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtnHelpInfo) == 0x000008, "Wrong alignment on FBtnHelpInfo");
static_assert(sizeof(FBtnHelpInfo) == 0x000020, "Wrong size on FBtnHelpInfo");
static_assert(offsetof(FBtnHelpInfo, MappingType) == 0x000000, "Member 'FBtnHelpInfo::MappingType' has a wrong offset!");
static_assert(offsetof(FBtnHelpInfo, HelpMsg) == 0x000008, "Member 'FBtnHelpInfo::HelpMsg' has a wrong offset!");

// ScriptStruct Project.BtnHelpTblInfo
// 0x0002 (0x0002 - 0x0000)
struct FBtnHelpTblInfo final
{
public:
	E_BTN_HELP_MAPPING_KEY_TYPE                   MappingType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTN_HELP_MSG_TYPE                           MsgType;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtnHelpTblInfo) == 0x000001, "Wrong alignment on FBtnHelpTblInfo");
static_assert(sizeof(FBtnHelpTblInfo) == 0x000002, "Wrong size on FBtnHelpTblInfo");
static_assert(offsetof(FBtnHelpTblInfo, MappingType) == 0x000000, "Member 'FBtnHelpTblInfo::MappingType' has a wrong offset!");
static_assert(offsetof(FBtnHelpTblInfo, MsgType) == 0x000001, "Member 'FBtnHelpTblInfo::MsgType' has a wrong offset!");

// ScriptStruct Project.BtnHelpTblInfoList
// 0x0010 (0x0010 - 0x0000)
struct FBtnHelpTblInfoList final
{
public:
	TArray<struct FBtnHelpTblInfo>                HelpInfo;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtnHelpTblInfoList) == 0x000008, "Wrong alignment on FBtnHelpTblInfoList");
static_assert(sizeof(FBtnHelpTblInfoList) == 0x000010, "Wrong size on FBtnHelpTblInfoList");
static_assert(offsetof(FBtnHelpTblInfoList, HelpInfo) == 0x000000, "Member 'FBtnHelpTblInfoList::HelpInfo' has a wrong offset!");

// ScriptStruct Project.GardenTutorialCameraSetting
// 0x0040 (0x0040 - 0x0000)
struct FGardenTutorialCameraSetting final
{
public:
	struct FTransform                             TutorialCameraTransform;                           // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TutorialCameraFOV;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenTutorialCameraSetting) == 0x000010, "Wrong alignment on FGardenTutorialCameraSetting");
static_assert(sizeof(FGardenTutorialCameraSetting) == 0x000040, "Wrong size on FGardenTutorialCameraSetting");
static_assert(offsetof(FGardenTutorialCameraSetting, TutorialCameraTransform) == 0x000000, "Member 'FGardenTutorialCameraSetting::TutorialCameraTransform' has a wrong offset!");
static_assert(offsetof(FGardenTutorialCameraSetting, TutorialCameraFOV) == 0x000030, "Member 'FGardenTutorialCameraSetting::TutorialCameraFOV' has a wrong offset!");
static_assert(offsetof(FGardenTutorialCameraSetting, DisplayTime) == 0x000034, "Member 'FGardenTutorialCameraSetting::DisplayTime' has a wrong offset!");

// ScriptStruct Project.CameraAnimationDofKey
// 0x0008 (0x0008 - 0x0000)
struct FCameraAnimationDofKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DofDistance;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraAnimationDofKey) == 0x000004, "Wrong alignment on FCameraAnimationDofKey");
static_assert(sizeof(FCameraAnimationDofKey) == 0x000008, "Wrong size on FCameraAnimationDofKey");
static_assert(offsetof(FCameraAnimationDofKey, Time) == 0x000000, "Member 'FCameraAnimationDofKey::Time' has a wrong offset!");
static_assert(offsetof(FCameraAnimationDofKey, DofDistance) == 0x000004, "Member 'FCameraAnimationDofKey::DofDistance' has a wrong offset!");

// ScriptStruct Project.AxisKeyConfigSaveData
// 0x0010 (0x0010 - 0x0000)
struct FAxisKeyConfigSaveData final
{
public:
	int32                                         M_KeyIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AxisMappingType;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Scale;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Change;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAxisKeyConfigSaveData) == 0x000004, "Wrong alignment on FAxisKeyConfigSaveData");
static_assert(sizeof(FAxisKeyConfigSaveData) == 0x000010, "Wrong size on FAxisKeyConfigSaveData");
static_assert(offsetof(FAxisKeyConfigSaveData, M_KeyIndex) == 0x000000, "Member 'FAxisKeyConfigSaveData::M_KeyIndex' has a wrong offset!");
static_assert(offsetof(FAxisKeyConfigSaveData, M_AxisMappingType) == 0x000004, "Member 'FAxisKeyConfigSaveData::M_AxisMappingType' has a wrong offset!");
static_assert(offsetof(FAxisKeyConfigSaveData, M_Scale) == 0x000008, "Member 'FAxisKeyConfigSaveData::M_Scale' has a wrong offset!");
static_assert(offsetof(FAxisKeyConfigSaveData, M_Change) == 0x00000C, "Member 'FAxisKeyConfigSaveData::M_Change' has a wrong offset!");

// ScriptStruct Project.CameraAnimationFovKey
// 0x0008 (0x0008 - 0x0000)
struct FCameraAnimationFovKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraAnimationFovKey) == 0x000004, "Wrong alignment on FCameraAnimationFovKey");
static_assert(sizeof(FCameraAnimationFovKey) == 0x000008, "Wrong size on FCameraAnimationFovKey");
static_assert(offsetof(FCameraAnimationFovKey, Time) == 0x000000, "Member 'FCameraAnimationFovKey::Time' has a wrong offset!");
static_assert(offsetof(FCameraAnimationFovKey, FOV) == 0x000004, "Member 'FCameraAnimationFovKey::FOV' has a wrong offset!");

// ScriptStruct Project.CameraAnimationRotKey
// 0x0010 (0x0010 - 0x0000)
struct FCameraAnimationRotKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0004(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraAnimationRotKey) == 0x000004, "Wrong alignment on FCameraAnimationRotKey");
static_assert(sizeof(FCameraAnimationRotKey) == 0x000010, "Wrong size on FCameraAnimationRotKey");
static_assert(offsetof(FCameraAnimationRotKey, Time) == 0x000000, "Member 'FCameraAnimationRotKey::Time' has a wrong offset!");
static_assert(offsetof(FCameraAnimationRotKey, Rotation) == 0x000004, "Member 'FCameraAnimationRotKey::Rotation' has a wrong offset!");

// ScriptStruct Project.MinimapLandmark
// 0x0010 (0x0010 - 0x0000)
struct FMinimapLandmark final
{
public:
	int32                                         M_LandmarkMapId;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LandmarkAreaId;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_LandmarkLocationX;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_LandmarkLocationY;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapLandmark) == 0x000004, "Wrong alignment on FMinimapLandmark");
static_assert(sizeof(FMinimapLandmark) == 0x000010, "Wrong size on FMinimapLandmark");
static_assert(offsetof(FMinimapLandmark, M_LandmarkMapId) == 0x000000, "Member 'FMinimapLandmark::M_LandmarkMapId' has a wrong offset!");
static_assert(offsetof(FMinimapLandmark, M_LandmarkAreaId) == 0x000004, "Member 'FMinimapLandmark::M_LandmarkAreaId' has a wrong offset!");
static_assert(offsetof(FMinimapLandmark, M_LandmarkLocationX) == 0x000008, "Member 'FMinimapLandmark::M_LandmarkLocationX' has a wrong offset!");
static_assert(offsetof(FMinimapLandmark, M_LandmarkLocationY) == 0x00000C, "Member 'FMinimapLandmark::M_LandmarkLocationY' has a wrong offset!");

// ScriptStruct Project.CameraAnimationLocKey
// 0x0010 (0x0010 - 0x0000)
struct FCameraAnimationLocKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraAnimationLocKey) == 0x000004, "Wrong alignment on FCameraAnimationLocKey");
static_assert(sizeof(FCameraAnimationLocKey) == 0x000010, "Wrong size on FCameraAnimationLocKey");
static_assert(offsetof(FCameraAnimationLocKey, Time) == 0x000000, "Member 'FCameraAnimationLocKey::Time' has a wrong offset!");
static_assert(offsetof(FCameraAnimationLocKey, Location) == 0x000004, "Member 'FCameraAnimationLocKey::Location' has a wrong offset!");

// ScriptStruct Project.CameraViewPresetData
// 0x000C (0x000C - 0x0000)
struct FCameraViewPresetData final
{
public:
	int32                                         M_CameraDistance;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CameraFOV;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CameraRootHeight;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraViewPresetData) == 0x000004, "Wrong alignment on FCameraViewPresetData");
static_assert(sizeof(FCameraViewPresetData) == 0x00000C, "Wrong size on FCameraViewPresetData");
static_assert(offsetof(FCameraViewPresetData, M_CameraDistance) == 0x000000, "Member 'FCameraViewPresetData::M_CameraDistance' has a wrong offset!");
static_assert(offsetof(FCameraViewPresetData, M_CameraFOV) == 0x000004, "Member 'FCameraViewPresetData::M_CameraFOV' has a wrong offset!");
static_assert(offsetof(FCameraViewPresetData, M_CameraRootHeight) == 0x000008, "Member 'FCameraViewPresetData::M_CameraRootHeight' has a wrong offset!");

// ScriptStruct Project.CameraMapPresetData
// 0x0034 (0x0034 - 0x0000)
struct FCameraMapPresetData final
{
public:
	E_CAMERA_MAP_TYPE                             M_MapType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_CameraHeight;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CameraRadius;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CameraTraceSpeed;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraViewPresetData                  M_Camera_Narrow;                                   // 0x0010(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraViewPresetData                  M_Camera_Standard;                                 // 0x001C(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraViewPresetData                  M_Camera_Wide;                                     // 0x0028(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraMapPresetData) == 0x000004, "Wrong alignment on FCameraMapPresetData");
static_assert(sizeof(FCameraMapPresetData) == 0x000034, "Wrong size on FCameraMapPresetData");
static_assert(offsetof(FCameraMapPresetData, M_MapType) == 0x000000, "Member 'FCameraMapPresetData::M_MapType' has a wrong offset!");
static_assert(offsetof(FCameraMapPresetData, M_CameraHeight) == 0x000004, "Member 'FCameraMapPresetData::M_CameraHeight' has a wrong offset!");
static_assert(offsetof(FCameraMapPresetData, M_CameraRadius) == 0x000008, "Member 'FCameraMapPresetData::M_CameraRadius' has a wrong offset!");
static_assert(offsetof(FCameraMapPresetData, M_CameraTraceSpeed) == 0x00000C, "Member 'FCameraMapPresetData::M_CameraTraceSpeed' has a wrong offset!");
static_assert(offsetof(FCameraMapPresetData, M_Camera_Narrow) == 0x000010, "Member 'FCameraMapPresetData::M_Camera_Narrow' has a wrong offset!");
static_assert(offsetof(FCameraMapPresetData, M_Camera_Standard) == 0x00001C, "Member 'FCameraMapPresetData::M_Camera_Standard' has a wrong offset!");
static_assert(offsetof(FCameraMapPresetData, M_Camera_Wide) == 0x000028, "Member 'FCameraMapPresetData::M_Camera_Wide' has a wrong offset!");

// ScriptStruct Project.CameraPlayerPresetData
// 0x000C (0x000C - 0x0000)
struct FCameraPlayerPresetData final
{
public:
	E_CAMERA_PLAYER_TYPE                          M_PlayerType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_MinCameraPitch;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MaxCameraPitch;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraPlayerPresetData) == 0x000004, "Wrong alignment on FCameraPlayerPresetData");
static_assert(sizeof(FCameraPlayerPresetData) == 0x00000C, "Wrong size on FCameraPlayerPresetData");
static_assert(offsetof(FCameraPlayerPresetData, M_PlayerType) == 0x000000, "Member 'FCameraPlayerPresetData::M_PlayerType' has a wrong offset!");
static_assert(offsetof(FCameraPlayerPresetData, M_MinCameraPitch) == 0x000004, "Member 'FCameraPlayerPresetData::M_MinCameraPitch' has a wrong offset!");
static_assert(offsetof(FCameraPlayerPresetData, M_MaxCameraPitch) == 0x000008, "Member 'FCameraPlayerPresetData::M_MaxCameraPitch' has a wrong offset!");

// ScriptStruct Project.CameraMapData
// 0x0044 (0x0044 - 0x0000)
struct FCameraMapData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraMapPresetData                   MapPreset;                                         // 0x0004(0x0034)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraPlayerPresetData                PlayerPreset;                                      // 0x0038(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraMapData) == 0x000004, "Wrong alignment on FCameraMapData");
static_assert(sizeof(FCameraMapData) == 0x000044, "Wrong size on FCameraMapData");
static_assert(offsetof(FCameraMapData, M_MapID) == 0x000000, "Member 'FCameraMapData::M_MapID' has a wrong offset!");
static_assert(offsetof(FCameraMapData, MapPreset) == 0x000004, "Member 'FCameraMapData::MapPreset' has a wrong offset!");
static_assert(offsetof(FCameraMapData, PlayerPreset) == 0x000038, "Member 'FCameraMapData::PlayerPreset' has a wrong offset!");

// ScriptStruct Project.GardenDevilData
// 0x0010 (0x0010 - 0x0000)
struct FGardenDevilData final
{
public:
	int32                                         M_TrustPoint;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TalkDesirePoint;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_bTrustHappened;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TrustTalkFlag;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_PowerUpTalkFlag;                                 // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ItemTalkFlag;                                    // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_QuestTalkFlag;                                   // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TalkIconFlag;                                    // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_bTalkInfoFlag;                                   // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenDevilData) == 0x000004, "Wrong alignment on FGardenDevilData");
static_assert(sizeof(FGardenDevilData) == 0x000010, "Wrong size on FGardenDevilData");
static_assert(offsetof(FGardenDevilData, M_TrustPoint) == 0x000000, "Member 'FGardenDevilData::M_TrustPoint' has a wrong offset!");
static_assert(offsetof(FGardenDevilData, M_TalkDesirePoint) == 0x000004, "Member 'FGardenDevilData::M_TalkDesirePoint' has a wrong offset!");
static_assert(offsetof(FGardenDevilData, M_bTrustHappened) == 0x000008, "Member 'FGardenDevilData::M_bTrustHappened' has a wrong offset!");
static_assert(offsetof(FGardenDevilData, M_TrustTalkFlag) == 0x000009, "Member 'FGardenDevilData::M_TrustTalkFlag' has a wrong offset!");
static_assert(offsetof(FGardenDevilData, M_PowerUpTalkFlag) == 0x00000A, "Member 'FGardenDevilData::M_PowerUpTalkFlag' has a wrong offset!");
static_assert(offsetof(FGardenDevilData, M_ItemTalkFlag) == 0x00000B, "Member 'FGardenDevilData::M_ItemTalkFlag' has a wrong offset!");
static_assert(offsetof(FGardenDevilData, M_QuestTalkFlag) == 0x00000C, "Member 'FGardenDevilData::M_QuestTalkFlag' has a wrong offset!");
static_assert(offsetof(FGardenDevilData, M_TalkIconFlag) == 0x00000D, "Member 'FGardenDevilData::M_TalkIconFlag' has a wrong offset!");
static_assert(offsetof(FGardenDevilData, M_bTalkInfoFlag) == 0x00000E, "Member 'FGardenDevilData::M_bTalkInfoFlag' has a wrong offset!");

// ScriptStruct Project.LearnSkill
// 0x0008 (0x0008 - 0x0000)
struct FLearnSkill final
{
public:
	E_LEARN_SKILL_TYPE                            M_LearnType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SkillId;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLearnSkill) == 0x000004, "Wrong alignment on FLearnSkill");
static_assert(sizeof(FLearnSkill) == 0x000008, "Wrong size on FLearnSkill");
static_assert(offsetof(FLearnSkill, M_LearnType) == 0x000000, "Member 'FLearnSkill::M_LearnType' has a wrong offset!");
static_assert(offsetof(FLearnSkill, M_SkillId) == 0x000004, "Member 'FLearnSkill::M_SkillId' has a wrong offset!");

// ScriptStruct Project.BibleData
// 0x00A8 (0x00A8 - 0x0000)
struct FBibleData final
{
public:
	int32                                         M_DevilID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Level;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAbilData                              M_NaturalParam;                                    // 0x0008(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAbilData                              M_BuildParam;                                      // 0x0024(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGardenDevilData                       M_GardenDevilData;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_IsEntry;                                         // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLearnSkill>                    M_Skill;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_UniqueSkill;                                     // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_DefenceAishou;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_SkillTekisei;                                    // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_BuildSkillTekisei;                               // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         M_GaveSoulGift;                                    // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BtlEntryCnt;                                     // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkillSlotNum;                                    // 0x00A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsBonusDevil;                                    // 0x00A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBibleData) == 0x000008, "Wrong alignment on FBibleData");
static_assert(sizeof(FBibleData) == 0x0000A8, "Wrong size on FBibleData");
static_assert(offsetof(FBibleData, M_DevilID) == 0x000000, "Member 'FBibleData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FBibleData, M_Level) == 0x000004, "Member 'FBibleData::M_Level' has a wrong offset!");
static_assert(offsetof(FBibleData, M_NaturalParam) == 0x000008, "Member 'FBibleData::M_NaturalParam' has a wrong offset!");
static_assert(offsetof(FBibleData, M_BuildParam) == 0x000024, "Member 'FBibleData::M_BuildParam' has a wrong offset!");
static_assert(offsetof(FBibleData, M_GardenDevilData) == 0x000040, "Member 'FBibleData::M_GardenDevilData' has a wrong offset!");
static_assert(offsetof(FBibleData, M_IsEntry) == 0x000050, "Member 'FBibleData::M_IsEntry' has a wrong offset!");
static_assert(offsetof(FBibleData, M_Skill) == 0x000058, "Member 'FBibleData::M_Skill' has a wrong offset!");
static_assert(offsetof(FBibleData, M_UniqueSkill) == 0x000068, "Member 'FBibleData::M_UniqueSkill' has a wrong offset!");
static_assert(offsetof(FBibleData, M_Exp) == 0x00006C, "Member 'FBibleData::M_Exp' has a wrong offset!");
static_assert(offsetof(FBibleData, M_DefenceAishou) == 0x000070, "Member 'FBibleData::M_DefenceAishou' has a wrong offset!");
static_assert(offsetof(FBibleData, M_SkillTekisei) == 0x000080, "Member 'FBibleData::M_SkillTekisei' has a wrong offset!");
static_assert(offsetof(FBibleData, M_BuildSkillTekisei) == 0x000090, "Member 'FBibleData::M_BuildSkillTekisei' has a wrong offset!");
static_assert(offsetof(FBibleData, M_GaveSoulGift) == 0x0000A0, "Member 'FBibleData::M_GaveSoulGift' has a wrong offset!");
static_assert(offsetof(FBibleData, M_BtlEntryCnt) == 0x0000A1, "Member 'FBibleData::M_BtlEntryCnt' has a wrong offset!");
static_assert(offsetof(FBibleData, M_SkillSlotNum) == 0x0000A2, "Member 'FBibleData::M_SkillSlotNum' has a wrong offset!");
static_assert(offsetof(FBibleData, M_IsBonusDevil) == 0x0000A3, "Member 'FBibleData::M_IsBonusDevil' has a wrong offset!");

// ScriptStruct Project.BibleSaveData
// 0x0010 (0x0010 - 0x0000)
struct FBibleSaveData final
{
public:
	TArray<struct FBibleData>                     M_BibleList;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBibleSaveData) == 0x000008, "Wrong alignment on FBibleSaveData");
static_assert(sizeof(FBibleSaveData) == 0x000010, "Wrong size on FBibleSaveData");
static_assert(offsetof(FBibleSaveData, M_BibleList) == 0x000000, "Member 'FBibleSaveData::M_BibleList' has a wrong offset!");

// ScriptStruct Project.DataBase
// 0x00E0 (0x00E0 - 0x0000)
struct FDataBase final
{
public:
	TArray<struct FAnalyzeData>                   M_AnalyzeData;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0xD0];                                      // 0x0010(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDataBase) == 0x000008, "Wrong alignment on FDataBase");
static_assert(sizeof(FDataBase) == 0x0000E0, "Wrong size on FDataBase");
static_assert(offsetof(FDataBase, M_AnalyzeData) == 0x000000, "Member 'FDataBase::M_AnalyzeData' has a wrong offset!");

// ScriptStruct Project.CameraMapRefData
// 0x0008 (0x0008 - 0x0000)
struct FCameraMapRefData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MapPresetIndex;                                    // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PlayerPresetIndex;                                 // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraMapRefData) == 0x000004, "Wrong alignment on FCameraMapRefData");
static_assert(sizeof(FCameraMapRefData) == 0x000008, "Wrong size on FCameraMapRefData");
static_assert(offsetof(FCameraMapRefData, M_MapID) == 0x000000, "Member 'FCameraMapRefData::M_MapID' has a wrong offset!");
static_assert(offsetof(FCameraMapRefData, MapPresetIndex) == 0x000004, "Member 'FCameraMapRefData::MapPresetIndex' has a wrong offset!");
static_assert(offsetof(FCameraMapRefData, PlayerPresetIndex) == 0x000005, "Member 'FCameraMapRefData::PlayerPresetIndex' has a wrong offset!");

// ScriptStruct Project.BattleData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FBattleData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleData) == 0x000004, "Wrong alignment on FBattleData");
static_assert(sizeof(FBattleData) == 0x00000C, "Wrong size on FBattleData");

// ScriptStruct Project.TreeDitherData
// 0x000C (0x000C - 0x0000)
struct FTreeDitherData final
{
public:
	float                                         TreeHeight;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreeRadius;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NearCameraOnly;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTreeDitherData) == 0x000004, "Wrong alignment on FTreeDitherData");
static_assert(sizeof(FTreeDitherData) == 0x00000C, "Wrong size on FTreeDitherData");
static_assert(offsetof(FTreeDitherData, TreeHeight) == 0x000000, "Member 'FTreeDitherData::TreeHeight' has a wrong offset!");
static_assert(offsetof(FTreeDitherData, TreeRadius) == 0x000004, "Member 'FTreeDitherData::TreeRadius' has a wrong offset!");
static_assert(offsetof(FTreeDitherData, NearCameraOnly) == 0x000008, "Member 'FTreeDitherData::NearCameraOnly' has a wrong offset!");

// ScriptStruct Project.MaskedMeshStructure
// 0x0010 (0x0010 - 0x0000)
struct FMaskedMeshStructure final
{
public:
	class UPrimitiveComponent*                    MaskedMesh;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceID;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaskedMeshStructure) == 0x000008, "Wrong alignment on FMaskedMeshStructure");
static_assert(sizeof(FMaskedMeshStructure) == 0x000010, "Wrong size on FMaskedMeshStructure");
static_assert(offsetof(FMaskedMeshStructure, MaskedMesh) == 0x000000, "Member 'FMaskedMeshStructure::MaskedMesh' has a wrong offset!");
static_assert(offsetof(FMaskedMeshStructure, InstanceID) == 0x000008, "Member 'FMaskedMeshStructure::InstanceID' has a wrong offset!");

// ScriptStruct Project.FadeInMeshStructure
// 0x0018 (0x0018 - 0x0000)
struct FFadeInMeshStructure final
{
public:
	struct FMaskedMeshStructure                   MaskedMeshStruct;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingFadeTime;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFadeInMeshStructure) == 0x000008, "Wrong alignment on FFadeInMeshStructure");
static_assert(sizeof(FFadeInMeshStructure) == 0x000018, "Wrong size on FFadeInMeshStructure");
static_assert(offsetof(FFadeInMeshStructure, MaskedMeshStruct) == 0x000000, "Member 'FFadeInMeshStructure::MaskedMeshStruct' has a wrong offset!");
static_assert(offsetof(FFadeInMeshStructure, RemainingFadeTime) == 0x000010, "Member 'FFadeInMeshStructure::RemainingFadeTime' has a wrong offset!");

// ScriptStruct Project.CharData
// 0x0130 (0x0130 - 0x0000)
struct FCharData final
{
public:
	struct FAbilData                              M_NaturalParam;                                    // 0x0000(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAbilData                              M_BuildParam;                                      // 0x001C(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAbilData                              M_FortifyParam;                                    // 0x0038(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         M_GlobalFlag;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP;                                              // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BadStatus;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Level;                                           // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ParamPoint;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_Name;                                            // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_FamilyName;                                      // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_GivenName;                                       // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_FullName;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_PLAYER_TYPE                                 M_PlayerType;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkillSlotNum;                                    // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AutoSkillSlotNum;                                // 0x00B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLearnSkill>                    M_Skill;                                           // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLearnSkill>                    M_AutoSkill;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_DefenceAishou;                                   // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_FortifyDefenceAishou;                            // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_SkillTekisei;                                    // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_BuildSkillTekisei;                               // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_FortifySkillTekisei;                             // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_UniqueSkill;                                     // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharData) == 0x000008, "Wrong alignment on FCharData");
static_assert(sizeof(FCharData) == 0x000130, "Wrong size on FCharData");
static_assert(offsetof(FCharData, M_NaturalParam) == 0x000000, "Member 'FCharData::M_NaturalParam' has a wrong offset!");
static_assert(offsetof(FCharData, M_BuildParam) == 0x00001C, "Member 'FCharData::M_BuildParam' has a wrong offset!");
static_assert(offsetof(FCharData, M_FortifyParam) == 0x000038, "Member 'FCharData::M_FortifyParam' has a wrong offset!");
static_assert(offsetof(FCharData, M_GlobalFlag) == 0x000054, "Member 'FCharData::M_GlobalFlag' has a wrong offset!");
static_assert(offsetof(FCharData, M_HP) == 0x000058, "Member 'FCharData::M_HP' has a wrong offset!");
static_assert(offsetof(FCharData, M_MP) == 0x00005C, "Member 'FCharData::M_MP' has a wrong offset!");
static_assert(offsetof(FCharData, M_Exp) == 0x000060, "Member 'FCharData::M_Exp' has a wrong offset!");
static_assert(offsetof(FCharData, M_BadStatus) == 0x000064, "Member 'FCharData::M_BadStatus' has a wrong offset!");
static_assert(offsetof(FCharData, M_Level) == 0x000068, "Member 'FCharData::M_Level' has a wrong offset!");
static_assert(offsetof(FCharData, M_ParamPoint) == 0x00006C, "Member 'FCharData::M_ParamPoint' has a wrong offset!");
static_assert(offsetof(FCharData, M_Name) == 0x000070, "Member 'FCharData::M_Name' has a wrong offset!");
static_assert(offsetof(FCharData, M_FamilyName) == 0x000080, "Member 'FCharData::M_FamilyName' has a wrong offset!");
static_assert(offsetof(FCharData, M_GivenName) == 0x000090, "Member 'FCharData::M_GivenName' has a wrong offset!");
static_assert(offsetof(FCharData, M_FullName) == 0x0000A0, "Member 'FCharData::M_FullName' has a wrong offset!");
static_assert(offsetof(FCharData, M_PlayerType) == 0x0000B0, "Member 'FCharData::M_PlayerType' has a wrong offset!");
static_assert(offsetof(FCharData, M_SkillSlotNum) == 0x0000B1, "Member 'FCharData::M_SkillSlotNum' has a wrong offset!");
static_assert(offsetof(FCharData, M_AutoSkillSlotNum) == 0x0000B2, "Member 'FCharData::M_AutoSkillSlotNum' has a wrong offset!");
static_assert(offsetof(FCharData, M_Skill) == 0x0000B8, "Member 'FCharData::M_Skill' has a wrong offset!");
static_assert(offsetof(FCharData, M_AutoSkill) == 0x0000C8, "Member 'FCharData::M_AutoSkill' has a wrong offset!");
static_assert(offsetof(FCharData, M_DefenceAishou) == 0x0000D8, "Member 'FCharData::M_DefenceAishou' has a wrong offset!");
static_assert(offsetof(FCharData, M_FortifyDefenceAishou) == 0x0000E8, "Member 'FCharData::M_FortifyDefenceAishou' has a wrong offset!");
static_assert(offsetof(FCharData, M_SkillTekisei) == 0x0000F8, "Member 'FCharData::M_SkillTekisei' has a wrong offset!");
static_assert(offsetof(FCharData, M_BuildSkillTekisei) == 0x000108, "Member 'FCharData::M_BuildSkillTekisei' has a wrong offset!");
static_assert(offsetof(FCharData, M_FortifySkillTekisei) == 0x000118, "Member 'FCharData::M_FortifySkillTekisei' has a wrong offset!");
static_assert(offsetof(FCharData, M_UniqueSkill) == 0x000128, "Member 'FCharData::M_UniqueSkill' has a wrong offset!");

// ScriptStruct Project.NkmData
// 0x0120 (0x0120 - 0x0000)
struct FNkmData final
{
public:
	struct FAbilData                              M_NaturalParam;                                    // 0x0000(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAbilData                              M_BuildParam;                                      // 0x001C(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAbilData                              M_FortifyParam;                                    // 0x0038(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAbilData                              M_StdParam;                                        // 0x0054(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGardenDevilData                       M_GardenDevilData;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         M_GlobalFlag;                                      // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP;                                              // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BadStatus;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Level;                                           // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Id;                                              // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_EncountCnt;                                      // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkillSlotNum;                                    // 0x009D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AutoSkillSlotNum;                                // 0x009E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F[0x1];                                       // 0x009F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLearnSkill>                    M_Skill;                                           // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLearnSkill>                    M_AutoSkill;                                       // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_DefenceAishou;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_FortifyDefenceAishou;                            // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_SkillTekisei;                                    // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_BuildSkillTekisei;                               // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_FortifySkillTekisei;                             // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         M_BtlEntryCnt;                                     // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_skillExIntervalCnt;                              // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_GaveSoulGift;                                    // 0x0112(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_113[0x1];                                      // 0x0113(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_UniqueSkill;                                     // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsBonusDevil;                                    // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_GlobalEntryId;                                   // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNkmData) == 0x000008, "Wrong alignment on FNkmData");
static_assert(sizeof(FNkmData) == 0x000120, "Wrong size on FNkmData");
static_assert(offsetof(FNkmData, M_NaturalParam) == 0x000000, "Member 'FNkmData::M_NaturalParam' has a wrong offset!");
static_assert(offsetof(FNkmData, M_BuildParam) == 0x00001C, "Member 'FNkmData::M_BuildParam' has a wrong offset!");
static_assert(offsetof(FNkmData, M_FortifyParam) == 0x000038, "Member 'FNkmData::M_FortifyParam' has a wrong offset!");
static_assert(offsetof(FNkmData, M_StdParam) == 0x000054, "Member 'FNkmData::M_StdParam' has a wrong offset!");
static_assert(offsetof(FNkmData, M_GardenDevilData) == 0x000070, "Member 'FNkmData::M_GardenDevilData' has a wrong offset!");
static_assert(offsetof(FNkmData, M_GlobalFlag) == 0x000080, "Member 'FNkmData::M_GlobalFlag' has a wrong offset!");
static_assert(offsetof(FNkmData, M_HP) == 0x000084, "Member 'FNkmData::M_HP' has a wrong offset!");
static_assert(offsetof(FNkmData, M_MP) == 0x000088, "Member 'FNkmData::M_MP' has a wrong offset!");
static_assert(offsetof(FNkmData, M_Exp) == 0x00008C, "Member 'FNkmData::M_Exp' has a wrong offset!");
static_assert(offsetof(FNkmData, M_BadStatus) == 0x000090, "Member 'FNkmData::M_BadStatus' has a wrong offset!");
static_assert(offsetof(FNkmData, M_Level) == 0x000094, "Member 'FNkmData::M_Level' has a wrong offset!");
static_assert(offsetof(FNkmData, M_Id) == 0x000098, "Member 'FNkmData::M_Id' has a wrong offset!");
static_assert(offsetof(FNkmData, M_EncountCnt) == 0x00009C, "Member 'FNkmData::M_EncountCnt' has a wrong offset!");
static_assert(offsetof(FNkmData, M_SkillSlotNum) == 0x00009D, "Member 'FNkmData::M_SkillSlotNum' has a wrong offset!");
static_assert(offsetof(FNkmData, M_AutoSkillSlotNum) == 0x00009E, "Member 'FNkmData::M_AutoSkillSlotNum' has a wrong offset!");
static_assert(offsetof(FNkmData, M_Skill) == 0x0000A0, "Member 'FNkmData::M_Skill' has a wrong offset!");
static_assert(offsetof(FNkmData, M_AutoSkill) == 0x0000B0, "Member 'FNkmData::M_AutoSkill' has a wrong offset!");
static_assert(offsetof(FNkmData, M_DefenceAishou) == 0x0000C0, "Member 'FNkmData::M_DefenceAishou' has a wrong offset!");
static_assert(offsetof(FNkmData, M_FortifyDefenceAishou) == 0x0000D0, "Member 'FNkmData::M_FortifyDefenceAishou' has a wrong offset!");
static_assert(offsetof(FNkmData, M_SkillTekisei) == 0x0000E0, "Member 'FNkmData::M_SkillTekisei' has a wrong offset!");
static_assert(offsetof(FNkmData, M_BuildSkillTekisei) == 0x0000F0, "Member 'FNkmData::M_BuildSkillTekisei' has a wrong offset!");
static_assert(offsetof(FNkmData, M_FortifySkillTekisei) == 0x000100, "Member 'FNkmData::M_FortifySkillTekisei' has a wrong offset!");
static_assert(offsetof(FNkmData, M_BtlEntryCnt) == 0x000110, "Member 'FNkmData::M_BtlEntryCnt' has a wrong offset!");
static_assert(offsetof(FNkmData, M_skillExIntervalCnt) == 0x000111, "Member 'FNkmData::M_skillExIntervalCnt' has a wrong offset!");
static_assert(offsetof(FNkmData, M_GaveSoulGift) == 0x000112, "Member 'FNkmData::M_GaveSoulGift' has a wrong offset!");
static_assert(offsetof(FNkmData, M_UniqueSkill) == 0x000114, "Member 'FNkmData::M_UniqueSkill' has a wrong offset!");
static_assert(offsetof(FNkmData, M_IsBonusDevil) == 0x000118, "Member 'FNkmData::M_IsBonusDevil' has a wrong offset!");
static_assert(offsetof(FNkmData, M_GlobalEntryId) == 0x00011C, "Member 'FNkmData::M_GlobalEntryId' has a wrong offset!");

// ScriptStruct Project.PartnerData
// 0x0140 (0x0140 - 0x0000)
struct FPartnerData final
{
public:
	struct FNkmData                               M_BaseData;                                        // 0x0000(0x0120)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_Name;                                            // 0x0120(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	E_PARTNER_ID                                  M_PartnerID;                                       // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartnerData) == 0x000008, "Wrong alignment on FPartnerData");
static_assert(sizeof(FPartnerData) == 0x000140, "Wrong size on FPartnerData");
static_assert(offsetof(FPartnerData, M_BaseData) == 0x000000, "Member 'FPartnerData::M_BaseData' has a wrong offset!");
static_assert(offsetof(FPartnerData, M_Name) == 0x000120, "Member 'FPartnerData::M_Name' has a wrong offset!");
static_assert(offsetof(FPartnerData, M_PartnerID) == 0x000138, "Member 'FPartnerData::M_PartnerID' has a wrong offset!");

// ScriptStruct Project.GodParameter
// 0x0018 (0x0018 - 0x0000)
struct FGodParameter final
{
public:
	int32                                         M_Pad;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GodParameterPoint;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_Skill;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGodParameter) == 0x000008, "Wrong alignment on FGodParameter");
static_assert(sizeof(FGodParameter) == 0x000018, "Wrong size on FGodParameter");
static_assert(offsetof(FGodParameter, M_Pad) == 0x000000, "Member 'FGodParameter::M_Pad' has a wrong offset!");
static_assert(offsetof(FGodParameter, M_GodParameterPoint) == 0x000004, "Member 'FGodParameter::M_GodParameterPoint' has a wrong offset!");
static_assert(offsetof(FGodParameter, M_Skill) == 0x000008, "Member 'FGodParameter::M_Skill' has a wrong offset!");

// ScriptStruct Project.SortWindowData
// 0x0020 (0x0020 - 0x0000)
struct FSortWindowData final
{
public:
	TArray<uint8>                                 M_SelectSortIndex;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_SelectSortOrder;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSortWindowData) == 0x000008, "Wrong alignment on FSortWindowData");
static_assert(sizeof(FSortWindowData) == 0x000020, "Wrong size on FSortWindowData");
static_assert(offsetof(FSortWindowData, M_SelectSortIndex) == 0x000000, "Member 'FSortWindowData::M_SelectSortIndex' has a wrong offset!");
static_assert(offsetof(FSortWindowData, M_SelectSortOrder) == 0x000010, "Member 'FSortWindowData::M_SelectSortOrder' has a wrong offset!");

// ScriptStruct Project.ResultData
// 0x0068 (0x0068 - 0x0000)
struct FResultData final
{
public:
	ERESULT_JOINDATA                              M_JoinData_Player;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERESULT_JOINDATA>                      M_JoinData_Nkm;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_ItemID;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_ItemCnt;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_Makka;                                           // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MaxLevel;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NewNkmIndex;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_EnableBattleResult;                              // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x1F];                                      // 0x0049(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResultData) == 0x000008, "Wrong alignment on FResultData");
static_assert(sizeof(FResultData) == 0x000068, "Wrong size on FResultData");
static_assert(offsetof(FResultData, M_JoinData_Player) == 0x000000, "Member 'FResultData::M_JoinData_Player' has a wrong offset!");
static_assert(offsetof(FResultData, M_JoinData_Nkm) == 0x000008, "Member 'FResultData::M_JoinData_Nkm' has a wrong offset!");
static_assert(offsetof(FResultData, M_ItemID) == 0x000018, "Member 'FResultData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FResultData, M_ItemCnt) == 0x000028, "Member 'FResultData::M_ItemCnt' has a wrong offset!");
static_assert(offsetof(FResultData, M_Makka) == 0x000038, "Member 'FResultData::M_Makka' has a wrong offset!");
static_assert(offsetof(FResultData, M_Exp) == 0x00003C, "Member 'FResultData::M_Exp' has a wrong offset!");
static_assert(offsetof(FResultData, M_MaxLevel) == 0x000040, "Member 'FResultData::M_MaxLevel' has a wrong offset!");
static_assert(offsetof(FResultData, M_NewNkmIndex) == 0x000044, "Member 'FResultData::M_NewNkmIndex' has a wrong offset!");
static_assert(offsetof(FResultData, M_EnableBattleResult) == 0x000048, "Member 'FResultData::M_EnableBattleResult' has a wrong offset!");

// ScriptStruct Project.BossRushOneData
// 0x0004 (0x0004 - 0x0000)
struct FBossRushOneData final
{
public:
	uint8                                         M_EventEncountID;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ChallengeModeClearCount;                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_OriginalModeFirstClear;                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_OriginalModeFirstClearByCreation;                // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBossRushOneData) == 0x000001, "Wrong alignment on FBossRushOneData");
static_assert(sizeof(FBossRushOneData) == 0x000004, "Wrong size on FBossRushOneData");
static_assert(offsetof(FBossRushOneData, M_EventEncountID) == 0x000000, "Member 'FBossRushOneData::M_EventEncountID' has a wrong offset!");
static_assert(offsetof(FBossRushOneData, M_ChallengeModeClearCount) == 0x000001, "Member 'FBossRushOneData::M_ChallengeModeClearCount' has a wrong offset!");
static_assert(offsetof(FBossRushOneData, M_OriginalModeFirstClear) == 0x000002, "Member 'FBossRushOneData::M_OriginalModeFirstClear' has a wrong offset!");
static_assert(offsetof(FBossRushOneData, M_OriginalModeFirstClearByCreation) == 0x000003, "Member 'FBossRushOneData::M_OriginalModeFirstClearByCreation' has a wrong offset!");

// ScriptStruct Project.PartyData
// 0x0168 (0x0168 - 0x0000)
struct FPartyData final
{
public:
	TArray<struct FCharData>                      M_PlayerData;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNkmData>                       M_NkmData;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_EntryNkmIndex;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_BattleNkmIndex;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPartnerData>                   M_PartnerData;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_Makka;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NkmEntryMax;                                     // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SkillSource;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HeroStatFlag;                                    // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_HERO_KIND                                   M_MainHero;                                        // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_LowChaosValue;                                   // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MAGGauge;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MAGGaugeStockNum;                                // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UnionLevel;                                      // 0x006D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGodParameter                          M_GodParameter;                                    // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSortWindowData                        M_SortWindowData;                                  // 0x0088(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FResultData                            M_ResultData;                                      // 0x00A8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         M_BattlePlayerIndex;                               // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_UpliftingGauge;                                  // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNkmData>                       M_GuestBackupData;                                 // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_GardenTalkPoint;                                 // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBossRushOneData>               M_BossRushOneData;                                 // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_ShiseijoWinCount;                                // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNkmData>                       M_ShiseijoBackupData;                              // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_GlobalEntryIdCount;                              // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartyData) == 0x000008, "Wrong alignment on FPartyData");
static_assert(sizeof(FPartyData) == 0x000168, "Wrong size on FPartyData");
static_assert(offsetof(FPartyData, M_PlayerData) == 0x000000, "Member 'FPartyData::M_PlayerData' has a wrong offset!");
static_assert(offsetof(FPartyData, M_NkmData) == 0x000010, "Member 'FPartyData::M_NkmData' has a wrong offset!");
static_assert(offsetof(FPartyData, M_EntryNkmIndex) == 0x000020, "Member 'FPartyData::M_EntryNkmIndex' has a wrong offset!");
static_assert(offsetof(FPartyData, M_BattleNkmIndex) == 0x000030, "Member 'FPartyData::M_BattleNkmIndex' has a wrong offset!");
static_assert(offsetof(FPartyData, M_PartnerData) == 0x000040, "Member 'FPartyData::M_PartnerData' has a wrong offset!");
static_assert(offsetof(FPartyData, M_Makka) == 0x000050, "Member 'FPartyData::M_Makka' has a wrong offset!");
static_assert(offsetof(FPartyData, M_NkmEntryMax) == 0x000054, "Member 'FPartyData::M_NkmEntryMax' has a wrong offset!");
static_assert(offsetof(FPartyData, M_SkillSource) == 0x000058, "Member 'FPartyData::M_SkillSource' has a wrong offset!");
static_assert(offsetof(FPartyData, M_HeroStatFlag) == 0x00005C, "Member 'FPartyData::M_HeroStatFlag' has a wrong offset!");
static_assert(offsetof(FPartyData, M_MainHero) == 0x000060, "Member 'FPartyData::M_MainHero' has a wrong offset!");
static_assert(offsetof(FPartyData, M_LowChaosValue) == 0x000064, "Member 'FPartyData::M_LowChaosValue' has a wrong offset!");
static_assert(offsetof(FPartyData, M_MAGGauge) == 0x000068, "Member 'FPartyData::M_MAGGauge' has a wrong offset!");
static_assert(offsetof(FPartyData, M_MAGGaugeStockNum) == 0x00006C, "Member 'FPartyData::M_MAGGaugeStockNum' has a wrong offset!");
static_assert(offsetof(FPartyData, M_UnionLevel) == 0x00006D, "Member 'FPartyData::M_UnionLevel' has a wrong offset!");
static_assert(offsetof(FPartyData, M_GodParameter) == 0x000070, "Member 'FPartyData::M_GodParameter' has a wrong offset!");
static_assert(offsetof(FPartyData, M_SortWindowData) == 0x000088, "Member 'FPartyData::M_SortWindowData' has a wrong offset!");
static_assert(offsetof(FPartyData, M_ResultData) == 0x0000A8, "Member 'FPartyData::M_ResultData' has a wrong offset!");
static_assert(offsetof(FPartyData, M_BattlePlayerIndex) == 0x000110, "Member 'FPartyData::M_BattlePlayerIndex' has a wrong offset!");
static_assert(offsetof(FPartyData, M_UpliftingGauge) == 0x000114, "Member 'FPartyData::M_UpliftingGauge' has a wrong offset!");
static_assert(offsetof(FPartyData, M_GuestBackupData) == 0x000118, "Member 'FPartyData::M_GuestBackupData' has a wrong offset!");
static_assert(offsetof(FPartyData, M_GardenTalkPoint) == 0x000128, "Member 'FPartyData::M_GardenTalkPoint' has a wrong offset!");
static_assert(offsetof(FPartyData, M_BossRushOneData) == 0x000130, "Member 'FPartyData::M_BossRushOneData' has a wrong offset!");
static_assert(offsetof(FPartyData, M_ShiseijoWinCount) == 0x000140, "Member 'FPartyData::M_ShiseijoWinCount' has a wrong offset!");
static_assert(offsetof(FPartyData, M_ShiseijoBackupData) == 0x000150, "Member 'FPartyData::M_ShiseijoBackupData' has a wrong offset!");
static_assert(offsetof(FPartyData, M_GlobalEntryIdCount) == 0x000160, "Member 'FPartyData::M_GlobalEntryIdCount' has a wrong offset!");

// ScriptStruct Project.GardenSPTFlagData
// 0x0010 (0x0010 - 0x0000)
struct FGardenSPTFlagData final
{
public:
	TArray<uint8>                                 M_MessageTalkFlag;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenSPTFlagData) == 0x000008, "Wrong alignment on FGardenSPTFlagData");
static_assert(sizeof(FGardenSPTFlagData) == 0x000010, "Wrong size on FGardenSPTFlagData");
static_assert(offsetof(FGardenSPTFlagData, M_MessageTalkFlag) == 0x000000, "Member 'FGardenSPTFlagData::M_MessageTalkFlag' has a wrong offset!");

// ScriptStruct Project.CampCharaPanelStockListData
// 0x0008 (0x0008 - 0x0000)
struct FCampCharaPanelStockListData final
{
public:
	uint8                                         M_NkmIndex;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_GlobalEntryId;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampCharaPanelStockListData) == 0x000004, "Wrong alignment on FCampCharaPanelStockListData");
static_assert(sizeof(FCampCharaPanelStockListData) == 0x000008, "Wrong size on FCampCharaPanelStockListData");
static_assert(offsetof(FCampCharaPanelStockListData, M_NkmIndex) == 0x000000, "Member 'FCampCharaPanelStockListData::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FCampCharaPanelStockListData, M_GlobalEntryId) == 0x000004, "Member 'FCampCharaPanelStockListData::M_GlobalEntryId' has a wrong offset!");

// ScriptStruct Project.CampCommandData
// 0x0030 (0x0030 - 0x0000)
struct FCampCommandData final
{
public:
	E_CAMP_COMMAND_ID                             M_CommandId;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_Name;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          M_IsHide;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_OpenFlag;                                        // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCampCommandData) == 0x000008, "Wrong alignment on FCampCommandData");
static_assert(sizeof(FCampCommandData) == 0x000030, "Wrong size on FCampCommandData");
static_assert(offsetof(FCampCommandData, M_CommandId) == 0x000000, "Member 'FCampCommandData::M_CommandId' has a wrong offset!");
static_assert(offsetof(FCampCommandData, M_Name) == 0x000008, "Member 'FCampCommandData::M_Name' has a wrong offset!");
static_assert(offsetof(FCampCommandData, M_IsHide) == 0x000020, "Member 'FCampCommandData::M_IsHide' has a wrong offset!");
static_assert(offsetof(FCampCommandData, M_OpenFlag) == 0x000024, "Member 'FCampCommandData::M_OpenFlag' has a wrong offset!");

// ScriptStruct Project.CampDataLogUIData
// 0x0038 (0x0038 - 0x0000)
struct FCampDataLogUIData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_DATALOG_TYPE                                M_Type;                                            // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_Name;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_ImgArray;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_IsNew;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCampDataLogUIData) == 0x000008, "Wrong alignment on FCampDataLogUIData");
static_assert(sizeof(FCampDataLogUIData) == 0x000038, "Wrong size on FCampDataLogUIData");
static_assert(offsetof(FCampDataLogUIData, M_Id) == 0x000000, "Member 'FCampDataLogUIData::M_Id' has a wrong offset!");
static_assert(offsetof(FCampDataLogUIData, M_Type) == 0x000004, "Member 'FCampDataLogUIData::M_Type' has a wrong offset!");
static_assert(offsetof(FCampDataLogUIData, M_Name) == 0x000008, "Member 'FCampDataLogUIData::M_Name' has a wrong offset!");
static_assert(offsetof(FCampDataLogUIData, M_ImgArray) == 0x000020, "Member 'FCampDataLogUIData::M_ImgArray' has a wrong offset!");
static_assert(offsetof(FCampDataLogUIData, M_IsNew) == 0x000030, "Member 'FCampDataLogUIData::M_IsNew' has a wrong offset!");

// ScriptStruct Project.CampHelpData
// 0x0034 (0x0034 - 0x0000)
struct FCampHelpData final
{
public:
	int32                                         M_Number;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAscendingFlag;                                  // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_HelpSortType;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCursorBaseData                        M_Cursor;                                          // 0x000C(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCursorBaseData                        M_SortCursor;                                      // 0x0020(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampHelpData) == 0x000004, "Wrong alignment on FCampHelpData");
static_assert(sizeof(FCampHelpData) == 0x000034, "Wrong size on FCampHelpData");
static_assert(offsetof(FCampHelpData, M_Number) == 0x000000, "Member 'FCampHelpData::M_Number' has a wrong offset!");
static_assert(offsetof(FCampHelpData, M_bAscendingFlag) == 0x000004, "Member 'FCampHelpData::M_bAscendingFlag' has a wrong offset!");
static_assert(offsetof(FCampHelpData, M_HelpSortType) == 0x000008, "Member 'FCampHelpData::M_HelpSortType' has a wrong offset!");
static_assert(offsetof(FCampHelpData, M_Cursor) == 0x00000C, "Member 'FCampHelpData::M_Cursor' has a wrong offset!");
static_assert(offsetof(FCampHelpData, M_SortCursor) == 0x000020, "Member 'FCampHelpData::M_SortCursor' has a wrong offset!");

// ScriptStruct Project.SkillMasterData
// 0x0010 (0x0010 - 0x0000)
struct FSkillMasterData final
{
public:
	TArray<uint8>                                 M_Data;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillMasterData) == 0x000008, "Wrong alignment on FSkillMasterData");
static_assert(sizeof(FSkillMasterData) == 0x000010, "Wrong size on FSkillMasterData");
static_assert(offsetof(FSkillMasterData, M_Data) == 0x000000, "Member 'FSkillMasterData::M_Data' has a wrong offset!");

// ScriptStruct Project.CampHelpListData
// 0x0014 (0x0014 - 0x0000)
struct FCampHelpListData final
{
public:
	int32                                         M_TutorialId;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TutorialMessageId;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Use;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortId;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bNewIcon;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCampHelpListData) == 0x000004, "Wrong alignment on FCampHelpListData");
static_assert(sizeof(FCampHelpListData) == 0x000014, "Wrong size on FCampHelpListData");
static_assert(offsetof(FCampHelpListData, M_TutorialId) == 0x000000, "Member 'FCampHelpListData::M_TutorialId' has a wrong offset!");
static_assert(offsetof(FCampHelpListData, M_TutorialMessageId) == 0x000004, "Member 'FCampHelpListData::M_TutorialMessageId' has a wrong offset!");
static_assert(offsetof(FCampHelpListData, M_Use) == 0x000008, "Member 'FCampHelpListData::M_Use' has a wrong offset!");
static_assert(offsetof(FCampHelpListData, M_SortId) == 0x00000C, "Member 'FCampHelpListData::M_SortId' has a wrong offset!");
static_assert(offsetof(FCampHelpListData, M_bNewIcon) == 0x000010, "Member 'FCampHelpListData::M_bNewIcon' has a wrong offset!");

// ScriptStruct Project.CampItemResult
// 0x0044 (0x0044 - 0x0000)
struct FCampItemResult final
{
public:
	bool                                          IsUsed;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CureHp;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CureMp;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CureBst;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_HpMax;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_MpMax;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_Hp;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_Mp;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_Str;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_Vit;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_Mgi;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_Agi;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_Luc;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpParam_GodParameter;                              // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseCount;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Tekisei;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelUp;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampItemResult) == 0x000004, "Wrong alignment on FCampItemResult");
static_assert(sizeof(FCampItemResult) == 0x000044, "Wrong size on FCampItemResult");
static_assert(offsetof(FCampItemResult, IsUsed) == 0x000000, "Member 'FCampItemResult::IsUsed' has a wrong offset!");
static_assert(offsetof(FCampItemResult, CureHp) == 0x000004, "Member 'FCampItemResult::CureHp' has a wrong offset!");
static_assert(offsetof(FCampItemResult, CureMp) == 0x000008, "Member 'FCampItemResult::CureMp' has a wrong offset!");
static_assert(offsetof(FCampItemResult, CureBst) == 0x00000C, "Member 'FCampItemResult::CureBst' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_HpMax) == 0x000010, "Member 'FCampItemResult::UpParam_HpMax' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_MpMax) == 0x000014, "Member 'FCampItemResult::UpParam_MpMax' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_Hp) == 0x000018, "Member 'FCampItemResult::UpParam_Hp' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_Mp) == 0x00001C, "Member 'FCampItemResult::UpParam_Mp' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_Str) == 0x000020, "Member 'FCampItemResult::UpParam_Str' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_Vit) == 0x000024, "Member 'FCampItemResult::UpParam_Vit' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_Mgi) == 0x000028, "Member 'FCampItemResult::UpParam_Mgi' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_Agi) == 0x00002C, "Member 'FCampItemResult::UpParam_Agi' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_Luc) == 0x000030, "Member 'FCampItemResult::UpParam_Luc' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UpParam_GodParameter) == 0x000034, "Member 'FCampItemResult::UpParam_GodParameter' has a wrong offset!");
static_assert(offsetof(FCampItemResult, UseCount) == 0x000038, "Member 'FCampItemResult::UseCount' has a wrong offset!");
static_assert(offsetof(FCampItemResult, Tekisei) == 0x00003C, "Member 'FCampItemResult::Tekisei' has a wrong offset!");
static_assert(offsetof(FCampItemResult, LevelUp) == 0x000040, "Member 'FCampItemResult::LevelUp' has a wrong offset!");

// ScriptStruct Project.PartnerSkillParam
// 0x0008 (0x0008 - 0x0000)
struct FPartnerSkillParam final
{
public:
	int32                                         M_ActCategory;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Ratio;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartnerSkillParam) == 0x000004, "Wrong alignment on FPartnerSkillParam");
static_assert(sizeof(FPartnerSkillParam) == 0x000008, "Wrong size on FPartnerSkillParam");
static_assert(offsetof(FPartnerSkillParam, M_ActCategory) == 0x000000, "Member 'FPartnerSkillParam::M_ActCategory' has a wrong offset!");
static_assert(offsetof(FPartnerSkillParam, M_Ratio) == 0x000004, "Member 'FPartnerSkillParam::M_Ratio' has a wrong offset!");

// ScriptStruct Project.CampItemListData
// 0x000C (0x000C - 0x0000)
struct FCampItemListData final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Use;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Kind;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampItemListData) == 0x000004, "Wrong alignment on FCampItemListData");
static_assert(sizeof(FCampItemListData) == 0x00000C, "Wrong size on FCampItemListData");
static_assert(offsetof(FCampItemListData, M_ItemID) == 0x000000, "Member 'FCampItemListData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FCampItemListData, M_Use) == 0x000004, "Member 'FCampItemListData::M_Use' has a wrong offset!");
static_assert(offsetof(FCampItemListData, M_Kind) == 0x000008, "Member 'FCampItemListData::M_Kind' has a wrong offset!");

// ScriptStruct Project.CharaPanelData
// 0x0058 (0x0058 - 0x0000)
struct FCharaPanelData final
{
public:
	class FText                                   M_Name;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         M_Level;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP;                                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPMax;                                           // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPMax;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BadStatus;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ParamPoint;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DevilID;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NkmIndex;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsPlayer;                                        // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_PLAYER_TYPE                                 M_PlayerType;                                      // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsParty;                                         // 0x003E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsEmpty;                                         // 0x003F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsSummon;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsStray;                                         // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsTarget;                                        // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsUse;                                           // 0x0043(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsNoSel;                                         // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_CureHp;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CureMp;                                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CostMp;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharaPanelData) == 0x000008, "Wrong alignment on FCharaPanelData");
static_assert(sizeof(FCharaPanelData) == 0x000058, "Wrong size on FCharaPanelData");
static_assert(offsetof(FCharaPanelData, M_Name) == 0x000000, "Member 'FCharaPanelData::M_Name' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_Level) == 0x000018, "Member 'FCharaPanelData::M_Level' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_HP) == 0x00001C, "Member 'FCharaPanelData::M_HP' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_HPMax) == 0x000020, "Member 'FCharaPanelData::M_HPMax' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_MP) == 0x000024, "Member 'FCharaPanelData::M_MP' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_MPMax) == 0x000028, "Member 'FCharaPanelData::M_MPMax' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_BadStatus) == 0x00002C, "Member 'FCharaPanelData::M_BadStatus' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_ParamPoint) == 0x000030, "Member 'FCharaPanelData::M_ParamPoint' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_DevilID) == 0x000034, "Member 'FCharaPanelData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_NkmIndex) == 0x000038, "Member 'FCharaPanelData::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_IsPlayer) == 0x00003C, "Member 'FCharaPanelData::M_IsPlayer' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_PlayerType) == 0x00003D, "Member 'FCharaPanelData::M_PlayerType' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_IsParty) == 0x00003E, "Member 'FCharaPanelData::M_IsParty' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_IsEmpty) == 0x00003F, "Member 'FCharaPanelData::M_IsEmpty' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_IsSummon) == 0x000040, "Member 'FCharaPanelData::M_IsSummon' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_IsStray) == 0x000041, "Member 'FCharaPanelData::M_IsStray' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_IsTarget) == 0x000042, "Member 'FCharaPanelData::M_IsTarget' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_IsUse) == 0x000043, "Member 'FCharaPanelData::M_IsUse' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_IsNoSel) == 0x000044, "Member 'FCharaPanelData::M_IsNoSel' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_CureHp) == 0x000048, "Member 'FCharaPanelData::M_CureHp' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_CureMp) == 0x00004C, "Member 'FCharaPanelData::M_CureMp' has a wrong offset!");
static_assert(offsetof(FCharaPanelData, M_CostMp) == 0x000050, "Member 'FCharaPanelData::M_CostMp' has a wrong offset!");

// ScriptStruct Project.CampQuestListData
// 0x000C (0x000C - 0x0000)
struct FCampQuestListData final
{
public:
	int32                                         QuestID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortID;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MISSION_TYPE                                QuestType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CAMP_QUEST_PROGRESS_STATE                   ProgressState;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewIcon;                                         // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUpdateIcon;                                      // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampQuestListData) == 0x000004, "Wrong alignment on FCampQuestListData");
static_assert(sizeof(FCampQuestListData) == 0x00000C, "Wrong size on FCampQuestListData");
static_assert(offsetof(FCampQuestListData, QuestID) == 0x000000, "Member 'FCampQuestListData::QuestID' has a wrong offset!");
static_assert(offsetof(FCampQuestListData, SortID) == 0x000004, "Member 'FCampQuestListData::SortID' has a wrong offset!");
static_assert(offsetof(FCampQuestListData, QuestType) == 0x000008, "Member 'FCampQuestListData::QuestType' has a wrong offset!");
static_assert(offsetof(FCampQuestListData, ProgressState) == 0x000009, "Member 'FCampQuestListData::ProgressState' has a wrong offset!");
static_assert(offsetof(FCampQuestListData, IsNewIcon) == 0x00000A, "Member 'FCampQuestListData::IsNewIcon' has a wrong offset!");
static_assert(offsetof(FCampQuestListData, IsUpdateIcon) == 0x00000B, "Member 'FCampQuestListData::IsUpdateIcon' has a wrong offset!");

// ScriptStruct Project.CampSkilResult
// 0x0010 (0x0010 - 0x0000)
struct FCampSkilResult final
{
public:
	bool                                          IsUsed;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CureHp;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CureMp;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CureBst;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampSkilResult) == 0x000004, "Wrong alignment on FCampSkilResult");
static_assert(sizeof(FCampSkilResult) == 0x000010, "Wrong size on FCampSkilResult");
static_assert(offsetof(FCampSkilResult, IsUsed) == 0x000000, "Member 'FCampSkilResult::IsUsed' has a wrong offset!");
static_assert(offsetof(FCampSkilResult, CureHp) == 0x000004, "Member 'FCampSkilResult::CureHp' has a wrong offset!");
static_assert(offsetof(FCampSkilResult, CureMp) == 0x000008, "Member 'FCampSkilResult::CureMp' has a wrong offset!");
static_assert(offsetof(FCampSkilResult, CureBst) == 0x00000C, "Member 'FCampSkilResult::CureBst' has a wrong offset!");

// ScriptStruct Project.MapInfoData
// 0x0058 (0x0058 - 0x0000)
struct FMapInfoData final
{
public:
	class FName                                   M_Label;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_TagParam;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_MakkaWindow;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_PrevMakka;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AddMakka;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundAtomCue>           M_OpenSE;                                          // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MissionID;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapInfoData) == 0x000008, "Wrong alignment on FMapInfoData");
static_assert(sizeof(FMapInfoData) == 0x000058, "Wrong size on FMapInfoData");
static_assert(offsetof(FMapInfoData, M_Label) == 0x000000, "Member 'FMapInfoData::M_Label' has a wrong offset!");
static_assert(offsetof(FMapInfoData, M_TagParam) == 0x000008, "Member 'FMapInfoData::M_TagParam' has a wrong offset!");
static_assert(offsetof(FMapInfoData, M_MakkaWindow) == 0x000018, "Member 'FMapInfoData::M_MakkaWindow' has a wrong offset!");
static_assert(offsetof(FMapInfoData, M_PrevMakka) == 0x00001C, "Member 'FMapInfoData::M_PrevMakka' has a wrong offset!");
static_assert(offsetof(FMapInfoData, M_AddMakka) == 0x000020, "Member 'FMapInfoData::M_AddMakka' has a wrong offset!");
static_assert(offsetof(FMapInfoData, M_OpenSE) == 0x000028, "Member 'FMapInfoData::M_OpenSE' has a wrong offset!");
static_assert(offsetof(FMapInfoData, M_MissionID) == 0x000050, "Member 'FMapInfoData::M_MissionID' has a wrong offset!");

// ScriptStruct Project.CampSkillListData
// 0x0018 (0x0018 - 0x0000)
struct FCampSkillListData final
{
public:
	int32                                         M_SkillId;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Use;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NkmIndex;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Type;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Kind;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Tekisei;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CampPartyIndex;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampSkillListData) == 0x000004, "Wrong alignment on FCampSkillListData");
static_assert(sizeof(FCampSkillListData) == 0x000018, "Wrong size on FCampSkillListData");
static_assert(offsetof(FCampSkillListData, M_SkillId) == 0x000000, "Member 'FCampSkillListData::M_SkillId' has a wrong offset!");
static_assert(offsetof(FCampSkillListData, M_Use) == 0x000004, "Member 'FCampSkillListData::M_Use' has a wrong offset!");
static_assert(offsetof(FCampSkillListData, M_NkmIndex) == 0x000008, "Member 'FCampSkillListData::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FCampSkillListData, M_Type) == 0x000009, "Member 'FCampSkillListData::M_Type' has a wrong offset!");
static_assert(offsetof(FCampSkillListData, M_Kind) == 0x00000C, "Member 'FCampSkillListData::M_Kind' has a wrong offset!");
static_assert(offsetof(FCampSkillListData, M_Tekisei) == 0x000010, "Member 'FCampSkillListData::M_Tekisei' has a wrong offset!");
static_assert(offsetof(FCampSkillListData, M_CampPartyIndex) == 0x000014, "Member 'FCampSkillListData::M_CampPartyIndex' has a wrong offset!");

// ScriptStruct Project.CampCommonCharaData
// 0x0008 (0x0008 - 0x0000)
struct FCampCommonCharaData final
{
public:
	int32                                         M_NkmIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_PLAYER_TYPE                                 M_PlayerType;                                      // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCampCommonCharaData) == 0x000004, "Wrong alignment on FCampCommonCharaData");
static_assert(sizeof(FCampCommonCharaData) == 0x000008, "Wrong size on FCampCommonCharaData");
static_assert(offsetof(FCampCommonCharaData, M_NkmIndex) == 0x000000, "Member 'FCampCommonCharaData::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FCampCommonCharaData, M_PlayerType) == 0x000004, "Member 'FCampCommonCharaData::M_PlayerType' has a wrong offset!");

// ScriptStruct Project.CharaMoveParam
// 0x0038 (0x0038 - 0x0000)
struct FCharaMoveParam final
{
public:
	float                                         M_MoveTime;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_MoveLength;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_MoveVec;                                         // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_MoveStartPos;                                    // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_MoveEndPos;                                      // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_LookAtPos;                                       // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaMoveParam) == 0x000004, "Wrong alignment on FCharaMoveParam");
static_assert(sizeof(FCharaMoveParam) == 0x000038, "Wrong size on FCharaMoveParam");
static_assert(offsetof(FCharaMoveParam, M_MoveTime) == 0x000000, "Member 'FCharaMoveParam::M_MoveTime' has a wrong offset!");
static_assert(offsetof(FCharaMoveParam, M_MoveLength) == 0x000004, "Member 'FCharaMoveParam::M_MoveLength' has a wrong offset!");
static_assert(offsetof(FCharaMoveParam, M_MoveVec) == 0x000008, "Member 'FCharaMoveParam::M_MoveVec' has a wrong offset!");
static_assert(offsetof(FCharaMoveParam, M_MoveStartPos) == 0x000014, "Member 'FCharaMoveParam::M_MoveStartPos' has a wrong offset!");
static_assert(offsetof(FCharaMoveParam, M_MoveEndPos) == 0x000020, "Member 'FCharaMoveParam::M_MoveEndPos' has a wrong offset!");
static_assert(offsetof(FCharaMoveParam, M_LookAtPos) == 0x00002C, "Member 'FCharaMoveParam::M_LookAtPos' has a wrong offset!");

// ScriptStruct Project.CharaActionState
// 0x0010 (0x0010 - 0x0000)
struct FCharaActionState final
{
public:
	TArray<uint8>                                 M_State;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaActionState) == 0x000008, "Wrong alignment on FCharaActionState");
static_assert(sizeof(FCharaActionState) == 0x000010, "Wrong size on FCharaActionState");
static_assert(offsetof(FCharaActionState, M_State) == 0x000000, "Member 'FCharaActionState::M_State' has a wrong offset!");

// ScriptStruct Project.GardenQuestInfo
// 0x0030 (0x0038 - 0x0008)
struct FGardenQuestInfo final : public FTableRowBase
{
public:
	int32                                         DevilID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionId;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  QuestSublevelSoftObj;                              // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenQuestInfo) == 0x000008, "Wrong alignment on FGardenQuestInfo");
static_assert(sizeof(FGardenQuestInfo) == 0x000038, "Wrong size on FGardenQuestInfo");
static_assert(offsetof(FGardenQuestInfo, DevilID) == 0x000008, "Member 'FGardenQuestInfo::DevilID' has a wrong offset!");
static_assert(offsetof(FGardenQuestInfo, MissionId) == 0x00000C, "Member 'FGardenQuestInfo::MissionId' has a wrong offset!");
static_assert(offsetof(FGardenQuestInfo, QuestSublevelSoftObj) == 0x000010, "Member 'FGardenQuestInfo::QuestSublevelSoftObj' has a wrong offset!");

// ScriptStruct Project.CharaBlinkValue
// 0x000C (0x000C - 0x0000)
struct FCharaBlinkValue final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CHARA_LID_ID                                LidID;                                             // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaBlinkValue) == 0x000004, "Wrong alignment on FCharaBlinkValue");
static_assert(sizeof(FCharaBlinkValue) == 0x00000C, "Wrong size on FCharaBlinkValue");
static_assert(offsetof(FCharaBlinkValue, Time) == 0x000000, "Member 'FCharaBlinkValue::Time' has a wrong offset!");
static_assert(offsetof(FCharaBlinkValue, LidID) == 0x000004, "Member 'FCharaBlinkValue::LidID' has a wrong offset!");
static_assert(offsetof(FCharaBlinkValue, Duration) == 0x000008, "Member 'FCharaBlinkValue::Duration' has a wrong offset!");

// ScriptStruct Project.CharaBlinkBlend
// 0x0008 (0x0008 - 0x0000)
struct FCharaBlinkBlend final
{
public:
	float                                         InTime;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutTime;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaBlinkBlend) == 0x000004, "Wrong alignment on FCharaBlinkBlend");
static_assert(sizeof(FCharaBlinkBlend) == 0x000008, "Wrong size on FCharaBlinkBlend");
static_assert(offsetof(FCharaBlinkBlend, InTime) == 0x000000, "Member 'FCharaBlinkBlend::InTime' has a wrong offset!");
static_assert(offsetof(FCharaBlinkBlend, OutTime) == 0x000004, "Member 'FCharaBlinkBlend::OutTime' has a wrong offset!");

// ScriptStruct Project.CharaBlinkKey
// 0x0014 (0x0014 - 0x0000)
struct FCharaBlinkKey final
{
public:
	struct FCharaBlinkValue                       Value;                                             // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharaBlinkBlend                       Blend;                                             // 0x000C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaBlinkKey) == 0x000004, "Wrong alignment on FCharaBlinkKey");
static_assert(sizeof(FCharaBlinkKey) == 0x000014, "Wrong size on FCharaBlinkKey");
static_assert(offsetof(FCharaBlinkKey, Value) == 0x000000, "Member 'FCharaBlinkKey::Value' has a wrong offset!");
static_assert(offsetof(FCharaBlinkKey, Blend) == 0x00000C, "Member 'FCharaBlinkKey::Blend' has a wrong offset!");

// ScriptStruct Project.CharaExpressionLidParam
// 0x0004 (0x0004 - 0x0000)
struct FCharaExpressionLidParam final
{
public:
	int32                                         LidTableIndex;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaExpressionLidParam) == 0x000004, "Wrong alignment on FCharaExpressionLidParam");
static_assert(sizeof(FCharaExpressionLidParam) == 0x000004, "Wrong size on FCharaExpressionLidParam");
static_assert(offsetof(FCharaExpressionLidParam, LidTableIndex) == 0x000000, "Member 'FCharaExpressionLidParam::LidTableIndex' has a wrong offset!");

// ScriptStruct Project.CharaExpressionLipParam
// 0x000C (0x000C - 0x0000)
struct FCharaExpressionLipParam final
{
public:
	int32                                         LipTableIndex;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LipScale;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpressionScale;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaExpressionLipParam) == 0x000004, "Wrong alignment on FCharaExpressionLipParam");
static_assert(sizeof(FCharaExpressionLipParam) == 0x00000C, "Wrong size on FCharaExpressionLipParam");
static_assert(offsetof(FCharaExpressionLipParam, LipTableIndex) == 0x000000, "Member 'FCharaExpressionLipParam::LipTableIndex' has a wrong offset!");
static_assert(offsetof(FCharaExpressionLipParam, LipScale) == 0x000004, "Member 'FCharaExpressionLipParam::LipScale' has a wrong offset!");
static_assert(offsetof(FCharaExpressionLipParam, ExpressionScale) == 0x000008, "Member 'FCharaExpressionLipParam::ExpressionScale' has a wrong offset!");

// ScriptStruct Project.CharaExpressionEx
// 0x0030 (0x0030 - 0x0000)
struct FCharaExpressionEx final
{
public:
	TSoftObjectPtr<class UTexture>                Texture;                                           // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityL;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpacityR;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaExpressionEx) == 0x000008, "Wrong alignment on FCharaExpressionEx");
static_assert(sizeof(FCharaExpressionEx) == 0x000030, "Wrong size on FCharaExpressionEx");
static_assert(offsetof(FCharaExpressionEx, Texture) == 0x000000, "Member 'FCharaExpressionEx::Texture' has a wrong offset!");
static_assert(offsetof(FCharaExpressionEx, OpacityL) == 0x000028, "Member 'FCharaExpressionEx::OpacityL' has a wrong offset!");
static_assert(offsetof(FCharaExpressionEx, OpacityR) == 0x00002C, "Member 'FCharaExpressionEx::OpacityR' has a wrong offset!");

// ScriptStruct Project.CharaExpression
// 0x00B0 (0x00B0 - 0x0000)
struct FCharaExpression final
{
public:
	class UAnimSequenceBase*                      Animation;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharaExpressionLidParam               LidParam;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharaExpressionLipParam               LipParam;                                          // 0x0010(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharaExpressionEx                     BrowParam;                                         // 0x0020(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCharaExpressionEx                     MouthParam;                                        // 0x0050(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCharaExpressionEx                     NoseParam;                                         // 0x0080(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaExpression) == 0x000008, "Wrong alignment on FCharaExpression");
static_assert(sizeof(FCharaExpression) == 0x0000B0, "Wrong size on FCharaExpression");
static_assert(offsetof(FCharaExpression, Animation) == 0x000000, "Member 'FCharaExpression::Animation' has a wrong offset!");
static_assert(offsetof(FCharaExpression, BlendTime) == 0x000008, "Member 'FCharaExpression::BlendTime' has a wrong offset!");
static_assert(offsetof(FCharaExpression, LidParam) == 0x00000C, "Member 'FCharaExpression::LidParam' has a wrong offset!");
static_assert(offsetof(FCharaExpression, LipParam) == 0x000010, "Member 'FCharaExpression::LipParam' has a wrong offset!");
static_assert(offsetof(FCharaExpression, BrowParam) == 0x000020, "Member 'FCharaExpression::BrowParam' has a wrong offset!");
static_assert(offsetof(FCharaExpression, MouthParam) == 0x000050, "Member 'FCharaExpression::MouthParam' has a wrong offset!");
static_assert(offsetof(FCharaExpression, NoseParam) == 0x000080, "Member 'FCharaExpression::NoseParam' has a wrong offset!");

// ScriptStruct Project.GardenPlayerTalkFlagData
// 0x000C (0x000C - 0x0000)
struct FGardenPlayerTalkFlagData final
{
public:
	int32                                         M_Flag1;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Flag2;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Flag3;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenPlayerTalkFlagData) == 0x000004, "Wrong alignment on FGardenPlayerTalkFlagData");
static_assert(sizeof(FGardenPlayerTalkFlagData) == 0x00000C, "Wrong size on FGardenPlayerTalkFlagData");
static_assert(offsetof(FGardenPlayerTalkFlagData, M_Flag1) == 0x000000, "Member 'FGardenPlayerTalkFlagData::M_Flag1' has a wrong offset!");
static_assert(offsetof(FGardenPlayerTalkFlagData, M_Flag2) == 0x000004, "Member 'FGardenPlayerTalkFlagData::M_Flag2' has a wrong offset!");
static_assert(offsetof(FGardenPlayerTalkFlagData, M_Flag3) == 0x000008, "Member 'FGardenPlayerTalkFlagData::M_Flag3' has a wrong offset!");

// ScriptStruct Project.GardenPlayerTalkData
// 0x0020 (0x0020 - 0x0000)
struct FGardenPlayerTalkData final
{
public:
	int32                                         M_ReadFlag;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGardenPlayerTalkFlagData              M_StartFlag;                                       // 0x0004(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenPlayerTalkFlagData              M_EndFlag;                                         // 0x0010(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	E_OldNewRoute                                 M_RouteType;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_RYUKETSU_GARDEN_TYPE                        M_GardenType;                                      // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenPlayerTalkData) == 0x000004, "Wrong alignment on FGardenPlayerTalkData");
static_assert(sizeof(FGardenPlayerTalkData) == 0x000020, "Wrong size on FGardenPlayerTalkData");
static_assert(offsetof(FGardenPlayerTalkData, M_ReadFlag) == 0x000000, "Member 'FGardenPlayerTalkData::M_ReadFlag' has a wrong offset!");
static_assert(offsetof(FGardenPlayerTalkData, M_StartFlag) == 0x000004, "Member 'FGardenPlayerTalkData::M_StartFlag' has a wrong offset!");
static_assert(offsetof(FGardenPlayerTalkData, M_EndFlag) == 0x000010, "Member 'FGardenPlayerTalkData::M_EndFlag' has a wrong offset!");
static_assert(offsetof(FGardenPlayerTalkData, M_RouteType) == 0x00001C, "Member 'FGardenPlayerTalkData::M_RouteType' has a wrong offset!");
static_assert(offsetof(FGardenPlayerTalkData, M_GardenType) == 0x00001D, "Member 'FGardenPlayerTalkData::M_GardenType' has a wrong offset!");

// ScriptStruct Project.CharaLipTable
// 0x0050 (0x0050 - 0x0000)
struct FCharaLipTable final
{
public:
	TMap<E_CHARA_LIP_ID, class FName>             Map;                                               // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaLipTable) == 0x000008, "Wrong alignment on FCharaLipTable");
static_assert(sizeof(FCharaLipTable) == 0x000050, "Wrong size on FCharaLipTable");
static_assert(offsetof(FCharaLipTable, Map) == 0x000000, "Member 'FCharaLipTable::Map' has a wrong offset!");

// ScriptStruct Project.GardenChatMsgData
// 0x0004 (0x0004 - 0x0000)
struct FGardenChatMsgData final
{
public:
	E_GARDEN_MSG_USE_TYPE                         M_MsgType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDevilVoiceType                               M_DevilTalkVoice;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_CHAT_MSG_TYPE                        M_UseConditionType;                                // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UseCondition;                                    // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenChatMsgData) == 0x000001, "Wrong alignment on FGardenChatMsgData");
static_assert(sizeof(FGardenChatMsgData) == 0x000004, "Wrong size on FGardenChatMsgData");
static_assert(offsetof(FGardenChatMsgData, M_MsgType) == 0x000000, "Member 'FGardenChatMsgData::M_MsgType' has a wrong offset!");
static_assert(offsetof(FGardenChatMsgData, M_DevilTalkVoice) == 0x000001, "Member 'FGardenChatMsgData::M_DevilTalkVoice' has a wrong offset!");
static_assert(offsetof(FGardenChatMsgData, M_UseConditionType) == 0x000002, "Member 'FGardenChatMsgData::M_UseConditionType' has a wrong offset!");
static_assert(offsetof(FGardenChatMsgData, M_UseCondition) == 0x000003, "Member 'FGardenChatMsgData::M_UseCondition' has a wrong offset!");

// ScriptStruct Project.GardenRespawnChatInfo
// 0x0008 (0x0008 - 0x0000)
struct FGardenRespawnChatInfo final
{
public:
	struct FGardenChatMsgData                     UsedChatMsgData;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         UsedRawChatIndex;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenRespawnChatInfo) == 0x000004, "Wrong alignment on FGardenRespawnChatInfo");
static_assert(sizeof(FGardenRespawnChatInfo) == 0x000008, "Wrong size on FGardenRespawnChatInfo");
static_assert(offsetof(FGardenRespawnChatInfo, UsedChatMsgData) == 0x000000, "Member 'FGardenRespawnChatInfo::UsedChatMsgData' has a wrong offset!");
static_assert(offsetof(FGardenRespawnChatInfo, UsedRawChatIndex) == 0x000004, "Member 'FGardenRespawnChatInfo::UsedRawChatIndex' has a wrong offset!");

// ScriptStruct Project.CharaLidTable
// 0x0050 (0x0050 - 0x0000)
struct FCharaLidTable final
{
public:
	TMap<E_CHARA_LID_ID, class FName>             Map;                                               // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaLidTable) == 0x000008, "Wrong alignment on FCharaLidTable");
static_assert(sizeof(FCharaLidTable) == 0x000050, "Wrong size on FCharaLidTable");
static_assert(offsetof(FCharaLidTable, Map) == 0x000000, "Member 'FCharaLidTable::Map' has a wrong offset!");

// ScriptStruct Project.CharaLipSyncValue
// 0x000C (0x000C - 0x0000)
struct FCharaLipSyncValue final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CHARA_LIP_ID                                LipID;                                             // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaLipSyncValue) == 0x000004, "Wrong alignment on FCharaLipSyncValue");
static_assert(sizeof(FCharaLipSyncValue) == 0x00000C, "Wrong size on FCharaLipSyncValue");
static_assert(offsetof(FCharaLipSyncValue, Time) == 0x000000, "Member 'FCharaLipSyncValue::Time' has a wrong offset!");
static_assert(offsetof(FCharaLipSyncValue, LipID) == 0x000004, "Member 'FCharaLipSyncValue::LipID' has a wrong offset!");
static_assert(offsetof(FCharaLipSyncValue, Duration) == 0x000008, "Member 'FCharaLipSyncValue::Duration' has a wrong offset!");

// ScriptStruct Project.CharaLipSyncBlend
// 0x0008 (0x0008 - 0x0000)
struct FCharaLipSyncBlend final
{
public:
	float                                         InTime;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutTime;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaLipSyncBlend) == 0x000004, "Wrong alignment on FCharaLipSyncBlend");
static_assert(sizeof(FCharaLipSyncBlend) == 0x000008, "Wrong size on FCharaLipSyncBlend");
static_assert(offsetof(FCharaLipSyncBlend, InTime) == 0x000000, "Member 'FCharaLipSyncBlend::InTime' has a wrong offset!");
static_assert(offsetof(FCharaLipSyncBlend, OutTime) == 0x000004, "Member 'FCharaLipSyncBlend::OutTime' has a wrong offset!");

// ScriptStruct Project.CharaLipSyncKey
// 0x0014 (0x0014 - 0x0000)
struct FCharaLipSyncKey final
{
public:
	struct FCharaLipSyncValue                     Value;                                             // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharaLipSyncBlend                     Blend;                                             // 0x000C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaLipSyncKey) == 0x000004, "Wrong alignment on FCharaLipSyncKey");
static_assert(sizeof(FCharaLipSyncKey) == 0x000014, "Wrong size on FCharaLipSyncKey");
static_assert(offsetof(FCharaLipSyncKey, Value) == 0x000000, "Member 'FCharaLipSyncKey::Value' has a wrong offset!");
static_assert(offsetof(FCharaLipSyncKey, Blend) == 0x00000C, "Member 'FCharaLipSyncKey::Blend' has a wrong offset!");

// ScriptStruct Project.GardenPhaseData
// 0x0028 (0x0028 - 0x0000)
struct FGardenPhaseData final
{
public:
	uint8                                         M_Phase;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_StartFlags;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_EndFlags;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenPhaseData) == 0x000008, "Wrong alignment on FGardenPhaseData");
static_assert(sizeof(FGardenPhaseData) == 0x000028, "Wrong size on FGardenPhaseData");
static_assert(offsetof(FGardenPhaseData, M_Phase) == 0x000000, "Member 'FGardenPhaseData::M_Phase' has a wrong offset!");
static_assert(offsetof(FGardenPhaseData, M_StartFlags) == 0x000008, "Member 'FGardenPhaseData::M_StartFlags' has a wrong offset!");
static_assert(offsetof(FGardenPhaseData, M_EndFlags) == 0x000018, "Member 'FGardenPhaseData::M_EndFlags' has a wrong offset!");

// ScriptStruct Project.GardenBenchGodray
// 0x0060 (0x0060 - 0x0000)
struct FGardenBenchGodray final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimatedEffect;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AnimateSpeed;                                      // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenBenchGodray) == 0x000010, "Wrong alignment on FGardenBenchGodray");
static_assert(sizeof(FGardenBenchGodray) == 0x000060, "Wrong size on FGardenBenchGodray");
static_assert(offsetof(FGardenBenchGodray, Transform) == 0x000000, "Member 'FGardenBenchGodray::Transform' has a wrong offset!");
static_assert(offsetof(FGardenBenchGodray, Width) == 0x000030, "Member 'FGardenBenchGodray::Width' has a wrong offset!");
static_assert(offsetof(FGardenBenchGodray, Length) == 0x000034, "Member 'FGardenBenchGodray::Length' has a wrong offset!");
static_assert(offsetof(FGardenBenchGodray, Color) == 0x000038, "Member 'FGardenBenchGodray::Color' has a wrong offset!");
static_assert(offsetof(FGardenBenchGodray, Brightness) == 0x000048, "Member 'FGardenBenchGodray::Brightness' has a wrong offset!");
static_assert(offsetof(FGardenBenchGodray, AnimatedEffect) == 0x00004C, "Member 'FGardenBenchGodray::AnimatedEffect' has a wrong offset!");
static_assert(offsetof(FGardenBenchGodray, AnimateSpeed) == 0x000050, "Member 'FGardenBenchGodray::AnimateSpeed' has a wrong offset!");

// ScriptStruct Project.CharaMotionOverrideBlendTime
// 0x0050 (0x0050 - 0x0000)
struct FCharaMotionOverrideBlendTime final
{
public:
	TMap<E_CHARA_MOTION_ID, float>                OverrideBlendTime;                                 // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaMotionOverrideBlendTime) == 0x000008, "Wrong alignment on FCharaMotionOverrideBlendTime");
static_assert(sizeof(FCharaMotionOverrideBlendTime) == 0x000050, "Wrong size on FCharaMotionOverrideBlendTime");
static_assert(offsetof(FCharaMotionOverrideBlendTime, OverrideBlendTime) == 0x000000, "Member 'FCharaMotionOverrideBlendTime::OverrideBlendTime' has a wrong offset!");

// ScriptStruct Project.CharaMotion
// 0x0018 (0x0018 - 0x0000)
struct FCharaMotion final
{
public:
	class UAnimSequenceBase*                      AnimationDefault;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimationLoop;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharaMotion) == 0x000008, "Wrong alignment on FCharaMotion");
static_assert(sizeof(FCharaMotion) == 0x000018, "Wrong size on FCharaMotion");
static_assert(offsetof(FCharaMotion, AnimationDefault) == 0x000000, "Member 'FCharaMotion::AnimationDefault' has a wrong offset!");
static_assert(offsetof(FCharaMotion, AnimationLoop) == 0x000008, "Member 'FCharaMotion::AnimationLoop' has a wrong offset!");
static_assert(offsetof(FCharaMotion, BlendTime) == 0x000010, "Member 'FCharaMotion::BlendTime' has a wrong offset!");

// ScriptStruct Project.GardenMsgData
// 0x0003 (0x0003 - 0x0000)
struct FGardenMsgData final
{
public:
	E_GARDEN_MSG_USE_TYPE                         M_MsgType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDevilVoiceType                               M_DevilTalkVoice;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CHARA_MOTION_ID                             M_CharaMotion;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenMsgData) == 0x000001, "Wrong alignment on FGardenMsgData");
static_assert(sizeof(FGardenMsgData) == 0x000003, "Wrong size on FGardenMsgData");
static_assert(offsetof(FGardenMsgData, M_MsgType) == 0x000000, "Member 'FGardenMsgData::M_MsgType' has a wrong offset!");
static_assert(offsetof(FGardenMsgData, M_DevilTalkVoice) == 0x000001, "Member 'FGardenMsgData::M_DevilTalkVoice' has a wrong offset!");
static_assert(offsetof(FGardenMsgData, M_CharaMotion) == 0x000002, "Member 'FGardenMsgData::M_CharaMotion' has a wrong offset!");

// ScriptStruct Project.CharaPanelBaseData
// 0x0068 (0x0068 - 0x0000)
struct FCharaPanelBaseData final
{
public:
	int32                                         M_HP;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPMax;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPParam;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPAnimeCount;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPAnimeFrameCount;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPMax;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPParam;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPAnimeCount;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPAnimeFrameCount;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_NameText;                                        // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_RaceText;                                        // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         M_charatype;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PartyIndex;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StockIndex;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharaPanelBaseData) == 0x000008, "Wrong alignment on FCharaPanelBaseData");
static_assert(sizeof(FCharaPanelBaseData) == 0x000068, "Wrong size on FCharaPanelBaseData");
static_assert(offsetof(FCharaPanelBaseData, M_HP) == 0x000000, "Member 'FCharaPanelBaseData::M_HP' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_HPMax) == 0x000004, "Member 'FCharaPanelBaseData::M_HPMax' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_HPParam) == 0x000008, "Member 'FCharaPanelBaseData::M_HPParam' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_HPAnimeCount) == 0x00000C, "Member 'FCharaPanelBaseData::M_HPAnimeCount' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_HPAnimeFrameCount) == 0x000010, "Member 'FCharaPanelBaseData::M_HPAnimeFrameCount' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_MP) == 0x000014, "Member 'FCharaPanelBaseData::M_MP' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_MPMax) == 0x000018, "Member 'FCharaPanelBaseData::M_MPMax' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_MPParam) == 0x00001C, "Member 'FCharaPanelBaseData::M_MPParam' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_MPAnimeCount) == 0x000020, "Member 'FCharaPanelBaseData::M_MPAnimeCount' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_MPAnimeFrameCount) == 0x000024, "Member 'FCharaPanelBaseData::M_MPAnimeFrameCount' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_NameText) == 0x000028, "Member 'FCharaPanelBaseData::M_NameText' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_RaceText) == 0x000040, "Member 'FCharaPanelBaseData::M_RaceText' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_charatype) == 0x000058, "Member 'FCharaPanelBaseData::M_charatype' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_PartyIndex) == 0x00005C, "Member 'FCharaPanelBaseData::M_PartyIndex' has a wrong offset!");
static_assert(offsetof(FCharaPanelBaseData, M_StockIndex) == 0x000060, "Member 'FCharaPanelBaseData::M_StockIndex' has a wrong offset!");

// ScriptStruct Project.CharaPanelPAnimeStackData
// 0x0008 (0x0008 - 0x0000)
struct FCharaPanelPAnimeStackData final
{
public:
	int32                                         M_Type;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_StartTime;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaPanelPAnimeStackData) == 0x000004, "Wrong alignment on FCharaPanelPAnimeStackData");
static_assert(sizeof(FCharaPanelPAnimeStackData) == 0x000008, "Wrong size on FCharaPanelPAnimeStackData");
static_assert(offsetof(FCharaPanelPAnimeStackData, M_Type) == 0x000000, "Member 'FCharaPanelPAnimeStackData::M_Type' has a wrong offset!");
static_assert(offsetof(FCharaPanelPAnimeStackData, M_StartTime) == 0x000004, "Member 'FCharaPanelPAnimeStackData::M_StartTime' has a wrong offset!");

// ScriptStruct Project.GardenReplacementCharaID
// 0x0008 (0x0010 - 0x0008)
struct FGardenReplacementCharaID final : public FTableRowBase
{
public:
	int32                                         M_DevilID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ReplacementCharaID;                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenReplacementCharaID) == 0x000008, "Wrong alignment on FGardenReplacementCharaID");
static_assert(sizeof(FGardenReplacementCharaID) == 0x000010, "Wrong size on FGardenReplacementCharaID");
static_assert(offsetof(FGardenReplacementCharaID, M_DevilID) == 0x000008, "Member 'FGardenReplacementCharaID::M_DevilID' has a wrong offset!");
static_assert(offsetof(FGardenReplacementCharaID, M_ReplacementCharaID) == 0x00000C, "Member 'FGardenReplacementCharaID::M_ReplacementCharaID' has a wrong offset!");

// ScriptStruct Project.CharaStampEffect_Particle
// 0x0038 (0x0038 - 0x0000)
struct FCharaStampEffect_Particle final
{
public:
	class UParticleSystem*                        Walk;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Run;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Dash;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LandingLow;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LandingHigh;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        SlideLoop;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Turn;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaStampEffect_Particle) == 0x000008, "Wrong alignment on FCharaStampEffect_Particle");
static_assert(sizeof(FCharaStampEffect_Particle) == 0x000038, "Wrong size on FCharaStampEffect_Particle");
static_assert(offsetof(FCharaStampEffect_Particle, Walk) == 0x000000, "Member 'FCharaStampEffect_Particle::Walk' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Particle, Run) == 0x000008, "Member 'FCharaStampEffect_Particle::Run' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Particle, Dash) == 0x000010, "Member 'FCharaStampEffect_Particle::Dash' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Particle, LandingLow) == 0x000018, "Member 'FCharaStampEffect_Particle::LandingLow' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Particle, LandingHigh) == 0x000020, "Member 'FCharaStampEffect_Particle::LandingHigh' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Particle, SlideLoop) == 0x000028, "Member 'FCharaStampEffect_Particle::SlideLoop' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Particle, Turn) == 0x000030, "Member 'FCharaStampEffect_Particle::Turn' has a wrong offset!");

// ScriptStruct Project.CharaStampEffect_Sound
// 0x0040 (0x0040 - 0x0000)
struct FCharaStampEffect_Sound final
{
public:
	class USoundAtomCue*                          Walk;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Run;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Dash;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          LandingLow;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          LandingHigh;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          SlideStart;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          SlideLoop;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          Turn;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaStampEffect_Sound) == 0x000008, "Wrong alignment on FCharaStampEffect_Sound");
static_assert(sizeof(FCharaStampEffect_Sound) == 0x000040, "Wrong size on FCharaStampEffect_Sound");
static_assert(offsetof(FCharaStampEffect_Sound, Walk) == 0x000000, "Member 'FCharaStampEffect_Sound::Walk' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Sound, Run) == 0x000008, "Member 'FCharaStampEffect_Sound::Run' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Sound, Dash) == 0x000010, "Member 'FCharaStampEffect_Sound::Dash' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Sound, LandingLow) == 0x000018, "Member 'FCharaStampEffect_Sound::LandingLow' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Sound, LandingHigh) == 0x000020, "Member 'FCharaStampEffect_Sound::LandingHigh' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Sound, SlideStart) == 0x000028, "Member 'FCharaStampEffect_Sound::SlideStart' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Sound, SlideLoop) == 0x000030, "Member 'FCharaStampEffect_Sound::SlideLoop' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Sound, Turn) == 0x000038, "Member 'FCharaStampEffect_Sound::Turn' has a wrong offset!");

// ScriptStruct Project.CharaStampEffect_Print
// 0x0010 (0x0010 - 0x0000)
struct FCharaStampEffect_Print final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharaStampEffect_Print) == 0x000008, "Wrong alignment on FCharaStampEffect_Print");
static_assert(sizeof(FCharaStampEffect_Print) == 0x000010, "Wrong size on FCharaStampEffect_Print");
static_assert(offsetof(FCharaStampEffect_Print, Material) == 0x000000, "Member 'FCharaStampEffect_Print::Material' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect_Print, Scale) == 0x000008, "Member 'FCharaStampEffect_Print::Scale' has a wrong offset!");

// ScriptStruct Project.CharaStampEffect
// 0x0088 (0x0088 - 0x0000)
struct FCharaStampEffect final
{
public:
	struct FCharaStampEffect_Particle             Particles;                                         // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharaStampEffect_Sound                Sounds;                                            // 0x0038(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharaStampEffect_Print                Prints;                                            // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaStampEffect) == 0x000008, "Wrong alignment on FCharaStampEffect");
static_assert(sizeof(FCharaStampEffect) == 0x000088, "Wrong size on FCharaStampEffect");
static_assert(offsetof(FCharaStampEffect, Particles) == 0x000000, "Member 'FCharaStampEffect::Particles' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect, Sounds) == 0x000038, "Member 'FCharaStampEffect::Sounds' has a wrong offset!");
static_assert(offsetof(FCharaStampEffect, Prints) == 0x000078, "Member 'FCharaStampEffect::Prints' has a wrong offset!");

// ScriptStruct Project.GardenTalkCameraParam
// 0x0010 (0x0010 - 0x0000)
struct FGardenTalkCameraParam final
{
public:
	float                                         TargetDevilHeight;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraAdjustHeight;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraArmlength;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOV;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenTalkCameraParam) == 0x000004, "Wrong alignment on FGardenTalkCameraParam");
static_assert(sizeof(FGardenTalkCameraParam) == 0x000010, "Wrong size on FGardenTalkCameraParam");
static_assert(offsetof(FGardenTalkCameraParam, TargetDevilHeight) == 0x000000, "Member 'FGardenTalkCameraParam::TargetDevilHeight' has a wrong offset!");
static_assert(offsetof(FGardenTalkCameraParam, CameraAdjustHeight) == 0x000004, "Member 'FGardenTalkCameraParam::CameraAdjustHeight' has a wrong offset!");
static_assert(offsetof(FGardenTalkCameraParam, CameraArmlength) == 0x000008, "Member 'FGardenTalkCameraParam::CameraArmlength' has a wrong offset!");
static_assert(offsetof(FGardenTalkCameraParam, CameraFOV) == 0x00000C, "Member 'FGardenTalkCameraParam::CameraFOV' has a wrong offset!");

// ScriptStruct Project.GardenTalkHeightOverride
// 0x0020 (0x0028 - 0x0008)
struct FGardenTalkHeightOverride final : public FTableRowBase
{
public:
	int32                                         M_DevilID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGardenTalkCameraParam                 M_CamParam;                                        // 0x000C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_Gaze_Target;                                     // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenTalkHeightOverride) == 0x000008, "Wrong alignment on FGardenTalkHeightOverride");
static_assert(sizeof(FGardenTalkHeightOverride) == 0x000028, "Wrong size on FGardenTalkHeightOverride");
static_assert(offsetof(FGardenTalkHeightOverride, M_DevilID) == 0x000008, "Member 'FGardenTalkHeightOverride::M_DevilID' has a wrong offset!");
static_assert(offsetof(FGardenTalkHeightOverride, M_CamParam) == 0x00000C, "Member 'FGardenTalkHeightOverride::M_CamParam' has a wrong offset!");
static_assert(offsetof(FGardenTalkHeightOverride, M_Gaze_Target) == 0x00001C, "Member 'FGardenTalkHeightOverride::M_Gaze_Target' has a wrong offset!");

// ScriptStruct Project.DevilPosData_Raw
// 0x0028 (0x0028 - 0x0000)
struct FDevilPosData_Raw final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ValidArea;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VerticalMax;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HorizontalMax;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TallMax;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PostChip;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevilPosData_Raw) == 0x000008, "Wrong alignment on FDevilPosData_Raw");
static_assert(sizeof(FDevilPosData_Raw) == 0x000028, "Wrong size on FDevilPosData_Raw");
static_assert(offsetof(FDevilPosData_Raw, ValidArea) == 0x000008, "Member 'FDevilPosData_Raw::ValidArea' has a wrong offset!");
static_assert(offsetof(FDevilPosData_Raw, VerticalMax) == 0x00000C, "Member 'FDevilPosData_Raw::VerticalMax' has a wrong offset!");
static_assert(offsetof(FDevilPosData_Raw, HorizontalMax) == 0x000010, "Member 'FDevilPosData_Raw::HorizontalMax' has a wrong offset!");
static_assert(offsetof(FDevilPosData_Raw, TallMax) == 0x000014, "Member 'FDevilPosData_Raw::TallMax' has a wrong offset!");
static_assert(offsetof(FDevilPosData_Raw, PostChip) == 0x000018, "Member 'FDevilPosData_Raw::PostChip' has a wrong offset!");

// ScriptStruct Project.DevilAssetTable_Raw
// 0x00A8 (0x00B0 - 0x0008)
struct FDevilAssetTable_Raw final : public FTableRowBase
{
public:
	int32                                         DevilID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ClassAssetID;                                      // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlayerBaseAssetID;                                 // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 DMAssetID;                                         // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDevilPosData_Raw                      DevilPostData;                                     // 0x0088(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevilAssetTable_Raw) == 0x000008, "Wrong alignment on FDevilAssetTable_Raw");
static_assert(sizeof(FDevilAssetTable_Raw) == 0x0000B0, "Wrong size on FDevilAssetTable_Raw");
static_assert(offsetof(FDevilAssetTable_Raw, DevilID) == 0x000008, "Member 'FDevilAssetTable_Raw::DevilID' has a wrong offset!");
static_assert(offsetof(FDevilAssetTable_Raw, ClassAssetID) == 0x000010, "Member 'FDevilAssetTable_Raw::ClassAssetID' has a wrong offset!");
static_assert(offsetof(FDevilAssetTable_Raw, PlayerBaseAssetID) == 0x000038, "Member 'FDevilAssetTable_Raw::PlayerBaseAssetID' has a wrong offset!");
static_assert(offsetof(FDevilAssetTable_Raw, DMAssetID) == 0x000060, "Member 'FDevilAssetTable_Raw::DMAssetID' has a wrong offset!");
static_assert(offsetof(FDevilAssetTable_Raw, DevilPostData) == 0x000088, "Member 'FDevilAssetTable_Raw::DevilPostData' has a wrong offset!");

// ScriptStruct Project.GardenDevilInfo_Truncated
// 0x0010 (0x0018 - 0x0008)
struct FGardenDevilInfo_Truncated final : public FTableRowBase
{
public:
	int32                                         DevilID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevilScale;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_SPAWN_SIZE                           Size;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_SPAWN_ANIMATION                      Animation;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenDevilInfo_Truncated) == 0x000008, "Wrong alignment on FGardenDevilInfo_Truncated");
static_assert(sizeof(FGardenDevilInfo_Truncated) == 0x000018, "Wrong size on FGardenDevilInfo_Truncated");
static_assert(offsetof(FGardenDevilInfo_Truncated, DevilID) == 0x000008, "Member 'FGardenDevilInfo_Truncated::DevilID' has a wrong offset!");
static_assert(offsetof(FGardenDevilInfo_Truncated, DevilScale) == 0x00000C, "Member 'FGardenDevilInfo_Truncated::DevilScale' has a wrong offset!");
static_assert(offsetof(FGardenDevilInfo_Truncated, Size) == 0x000010, "Member 'FGardenDevilInfo_Truncated::Size' has a wrong offset!");
static_assert(offsetof(FGardenDevilInfo_Truncated, Animation) == 0x000011, "Member 'FGardenDevilInfo_Truncated::Animation' has a wrong offset!");

// ScriptStruct Project.GodParameterData
// 0x0028 (0x0028 - 0x0000)
struct FGodParameterData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PremiseGodSkill;                                 // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GODPARAMETER_TYPE                           M_Type;                                            // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_RequiredLevel;                                   // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PrimiseEventFlag;                                // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RequiredPoint;                                   // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_EnableSkillOFF;                                  // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SkillId;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UserData;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGodParameterData) == 0x000004, "Wrong alignment on FGodParameterData");
static_assert(sizeof(FGodParameterData) == 0x000028, "Wrong size on FGodParameterData");
static_assert(offsetof(FGodParameterData, M_Id) == 0x000000, "Member 'FGodParameterData::M_Id' has a wrong offset!");
static_assert(offsetof(FGodParameterData, M_SortId) == 0x000004, "Member 'FGodParameterData::M_SortId' has a wrong offset!");
static_assert(offsetof(FGodParameterData, M_PremiseGodSkill) == 0x000008, "Member 'FGodParameterData::M_PremiseGodSkill' has a wrong offset!");
static_assert(offsetof(FGodParameterData, M_Type) == 0x00000C, "Member 'FGodParameterData::M_Type' has a wrong offset!");
static_assert(offsetof(FGodParameterData, M_RequiredLevel) == 0x000010, "Member 'FGodParameterData::M_RequiredLevel' has a wrong offset!");
static_assert(offsetof(FGodParameterData, M_PrimiseEventFlag) == 0x000014, "Member 'FGodParameterData::M_PrimiseEventFlag' has a wrong offset!");
static_assert(offsetof(FGodParameterData, M_RequiredPoint) == 0x000018, "Member 'FGodParameterData::M_RequiredPoint' has a wrong offset!");
static_assert(offsetof(FGodParameterData, M_EnableSkillOFF) == 0x00001C, "Member 'FGodParameterData::M_EnableSkillOFF' has a wrong offset!");
static_assert(offsetof(FGodParameterData, M_SkillId) == 0x000020, "Member 'FGodParameterData::M_SkillId' has a wrong offset!");
static_assert(offsetof(FGodParameterData, M_UserData) == 0x000024, "Member 'FGodParameterData::M_UserData' has a wrong offset!");

// ScriptStruct Project.PlayeAishouTekiseiTable
// 0x0020 (0x0020 - 0x0000)
struct FPlayeAishouTekiseiTable final
{
public:
	TArray<int32>                                 M_DefenceAishou;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_SkillTekisei;                                    // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayeAishouTekiseiTable) == 0x000008, "Wrong alignment on FPlayeAishouTekiseiTable");
static_assert(sizeof(FPlayeAishouTekiseiTable) == 0x000020, "Wrong size on FPlayeAishouTekiseiTable");
static_assert(offsetof(FPlayeAishouTekiseiTable, M_DefenceAishou) == 0x000000, "Member 'FPlayeAishouTekiseiTable::M_DefenceAishou' has a wrong offset!");
static_assert(offsetof(FPlayeAishouTekiseiTable, M_SkillTekisei) == 0x000010, "Member 'FPlayeAishouTekiseiTable::M_SkillTekisei' has a wrong offset!");

// ScriptStruct Project.GardenTalkArea
// 0x0010 (0x0018 - 0x0008)
struct FGardenTalkArea final : public FTableRowBase
{
public:
	int32                                         M_DevilID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_TalkAreaXYScale;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_TalkAreaZScale;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenTalkArea) == 0x000008, "Wrong alignment on FGardenTalkArea");
static_assert(sizeof(FGardenTalkArea) == 0x000018, "Wrong size on FGardenTalkArea");
static_assert(offsetof(FGardenTalkArea, M_DevilID) == 0x000008, "Member 'FGardenTalkArea::M_DevilID' has a wrong offset!");
static_assert(offsetof(FGardenTalkArea, M_TalkAreaXYScale) == 0x00000C, "Member 'FGardenTalkArea::M_TalkAreaXYScale' has a wrong offset!");
static_assert(offsetof(FGardenTalkArea, M_TalkAreaZScale) == 0x000010, "Member 'FGardenTalkArea::M_TalkAreaZScale' has a wrong offset!");

// ScriptStruct Project.AddGetSkill
// 0x0008 (0x0008 - 0x0000)
struct FAddGetSkill final
{
public:
	int32                                         M_Level;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Skill;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddGetSkill) == 0x000004, "Wrong alignment on FAddGetSkill");
static_assert(sizeof(FAddGetSkill) == 0x000008, "Wrong size on FAddGetSkill");
static_assert(offsetof(FAddGetSkill, M_Level) == 0x000000, "Member 'FAddGetSkill::M_Level' has a wrong offset!");
static_assert(offsetof(FAddGetSkill, M_Skill) == 0x000004, "Member 'FAddGetSkill::M_Skill' has a wrong offset!");

// ScriptStruct Project.PlayerAddGetSkillTable
// 0x0010 (0x0010 - 0x0000)
struct FPlayerAddGetSkillTable final
{
public:
	TArray<struct FAddGetSkill>                   M_Data;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAddGetSkillTable) == 0x000008, "Wrong alignment on FPlayerAddGetSkillTable");
static_assert(sizeof(FPlayerAddGetSkillTable) == 0x000010, "Wrong size on FPlayerAddGetSkillTable");
static_assert(offsetof(FPlayerAddGetSkillTable, M_Data) == 0x000000, "Member 'FPlayerAddGetSkillTable::M_Data' has a wrong offset!");

// ScriptStruct Project.GardenDevilSpawnInfo
// 0x0040 (0x0040 - 0x0000)
struct FGardenDevilSpawnInfo final
{
public:
	struct FTransform                             DevilSpawnTransform;                               // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AGardenActorSpawner*                    DevilSpawner;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenDevilSpawnInfo) == 0x000010, "Wrong alignment on FGardenDevilSpawnInfo");
static_assert(sizeof(FGardenDevilSpawnInfo) == 0x000040, "Wrong size on FGardenDevilSpawnInfo");
static_assert(offsetof(FGardenDevilSpawnInfo, DevilSpawnTransform) == 0x000000, "Member 'FGardenDevilSpawnInfo::DevilSpawnTransform' has a wrong offset!");
static_assert(offsetof(FGardenDevilSpawnInfo, DevilSpawner) == 0x000030, "Member 'FGardenDevilSpawnInfo::DevilSpawner' has a wrong offset!");

// ScriptStruct Project.PlayerExpTable
// 0x0010 (0x0010 - 0x0000)
struct FPlayerExpTable final
{
public:
	TArray<int32>                                 M_Data;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerExpTable) == 0x000008, "Wrong alignment on FPlayerExpTable");
static_assert(sizeof(FPlayerExpTable) == 0x000010, "Wrong size on FPlayerExpTable");
static_assert(offsetof(FPlayerExpTable, M_Data) == 0x000000, "Member 'FPlayerExpTable::M_Data' has a wrong offset!");

// ScriptStruct Project.PlayerGrowData
// 0x001C (0x001C - 0x0000)
struct FPlayerGrowData final
{
public:
	int32                                         M_HPMax;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPMax;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Str;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Vit;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Mgi;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Agi;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Luc;                                             // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerGrowData) == 0x000004, "Wrong alignment on FPlayerGrowData");
static_assert(sizeof(FPlayerGrowData) == 0x00001C, "Wrong size on FPlayerGrowData");
static_assert(offsetof(FPlayerGrowData, M_HPMax) == 0x000000, "Member 'FPlayerGrowData::M_HPMax' has a wrong offset!");
static_assert(offsetof(FPlayerGrowData, M_MPMax) == 0x000004, "Member 'FPlayerGrowData::M_MPMax' has a wrong offset!");
static_assert(offsetof(FPlayerGrowData, M_Str) == 0x000008, "Member 'FPlayerGrowData::M_Str' has a wrong offset!");
static_assert(offsetof(FPlayerGrowData, M_Vit) == 0x00000C, "Member 'FPlayerGrowData::M_Vit' has a wrong offset!");
static_assert(offsetof(FPlayerGrowData, M_Mgi) == 0x000010, "Member 'FPlayerGrowData::M_Mgi' has a wrong offset!");
static_assert(offsetof(FPlayerGrowData, M_Agi) == 0x000014, "Member 'FPlayerGrowData::M_Agi' has a wrong offset!");
static_assert(offsetof(FPlayerGrowData, M_Luc) == 0x000018, "Member 'FPlayerGrowData::M_Luc' has a wrong offset!");

// ScriptStruct Project.PlayerGrowTable
// 0x0010 (0x0010 - 0x0000)
struct FPlayerGrowTable final
{
public:
	TArray<struct FPlayerGrowData>                M_Data;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerGrowTable) == 0x000008, "Wrong alignment on FPlayerGrowTable");
static_assert(sizeof(FPlayerGrowTable) == 0x000010, "Wrong size on FPlayerGrowTable");
static_assert(offsetof(FPlayerGrowTable, M_Data) == 0x000000, "Member 'FPlayerGrowTable::M_Data' has a wrong offset!");

// ScriptStruct Project.NaviDevilData
// 0x0010 (0x0010 - 0x0000)
struct FNaviDevilData final
{
public:
	int32                                         M_DevilID;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AddItemRate;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ExcavateType;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OpenFlag;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNaviDevilData) == 0x000004, "Wrong alignment on FNaviDevilData");
static_assert(sizeof(FNaviDevilData) == 0x000010, "Wrong size on FNaviDevilData");
static_assert(offsetof(FNaviDevilData, M_DevilID) == 0x000000, "Member 'FNaviDevilData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FNaviDevilData, M_AddItemRate) == 0x000004, "Member 'FNaviDevilData::M_AddItemRate' has a wrong offset!");
static_assert(offsetof(FNaviDevilData, M_ExcavateType) == 0x000008, "Member 'FNaviDevilData::M_ExcavateType' has a wrong offset!");
static_assert(offsetof(FNaviDevilData, M_OpenFlag) == 0x00000C, "Member 'FNaviDevilData::M_OpenFlag' has a wrong offset!");

// ScriptStruct Project.PartnerSkillData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPartnerSkillData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartnerSkillData) == 0x000008, "Wrong alignment on FPartnerSkillData");
static_assert(sizeof(FPartnerSkillData) == 0x000010, "Wrong size on FPartnerSkillData");

// ScriptStruct Project.ImportantItemData
// 0x0010 (0x0010 - 0x0000)
struct FImportantItemData final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ItemKind;                                        // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_HaveMax;                                         // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UseGroupMagatsuhiSkill;                          // 0x0006(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SortId;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NameSortId;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImportantItemData) == 0x000004, "Wrong alignment on FImportantItemData");
static_assert(sizeof(FImportantItemData) == 0x000010, "Wrong size on FImportantItemData");
static_assert(offsetof(FImportantItemData, M_ItemID) == 0x000000, "Member 'FImportantItemData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FImportantItemData, M_ItemKind) == 0x000004, "Member 'FImportantItemData::M_ItemKind' has a wrong offset!");
static_assert(offsetof(FImportantItemData, M_HaveMax) == 0x000005, "Member 'FImportantItemData::M_HaveMax' has a wrong offset!");
static_assert(offsetof(FImportantItemData, M_UseGroupMagatsuhiSkill) == 0x000006, "Member 'FImportantItemData::M_UseGroupMagatsuhiSkill' has a wrong offset!");
static_assert(offsetof(FImportantItemData, M_SortId) == 0x000008, "Member 'FImportantItemData::M_SortId' has a wrong offset!");
static_assert(offsetof(FImportantItemData, M_NameSortId) == 0x00000C, "Member 'FImportantItemData::M_NameSortId' has a wrong offset!");

// ScriptStruct Project.PartnerSkillDataOne
// 0x0014 (0x0014 - 0x0000)
struct FPartnerSkillDataOne final
{
public:
	int32                                         M_Skill;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Level;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ActCategory;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Ratio;                                           // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ChangeSkill;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartnerSkillDataOne) == 0x000004, "Wrong alignment on FPartnerSkillDataOne");
static_assert(sizeof(FPartnerSkillDataOne) == 0x000014, "Wrong size on FPartnerSkillDataOne");
static_assert(offsetof(FPartnerSkillDataOne, M_Skill) == 0x000000, "Member 'FPartnerSkillDataOne::M_Skill' has a wrong offset!");
static_assert(offsetof(FPartnerSkillDataOne, M_Level) == 0x000004, "Member 'FPartnerSkillDataOne::M_Level' has a wrong offset!");
static_assert(offsetof(FPartnerSkillDataOne, M_ActCategory) == 0x000008, "Member 'FPartnerSkillDataOne::M_ActCategory' has a wrong offset!");
static_assert(offsetof(FPartnerSkillDataOne, M_Ratio) == 0x00000C, "Member 'FPartnerSkillDataOne::M_Ratio' has a wrong offset!");
static_assert(offsetof(FPartnerSkillDataOne, M_ChangeSkill) == 0x000010, "Member 'FPartnerSkillDataOne::M_ChangeSkill' has a wrong offset!");

// ScriptStruct Project.PlayerEtcStatusData
// 0x000C (0x000C - 0x0000)
struct FPlayerEtcStatusData final
{
public:
	int32                                         M_RaceID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GraphicsID;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UniqueSkillID;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerEtcStatusData) == 0x000004, "Wrong alignment on FPlayerEtcStatusData");
static_assert(sizeof(FPlayerEtcStatusData) == 0x00000C, "Wrong size on FPlayerEtcStatusData");
static_assert(offsetof(FPlayerEtcStatusData, M_RaceID) == 0x000000, "Member 'FPlayerEtcStatusData::M_RaceID' has a wrong offset!");
static_assert(offsetof(FPlayerEtcStatusData, M_GraphicsID) == 0x000004, "Member 'FPlayerEtcStatusData::M_GraphicsID' has a wrong offset!");
static_assert(offsetof(FPlayerEtcStatusData, M_UniqueSkillID) == 0x000008, "Member 'FPlayerEtcStatusData::M_UniqueSkillID' has a wrong offset!");

// ScriptStruct Project.AxisMappingInfoRow
// 0x0028 (0x0030 - 0x0008)
struct FAxisMappingInfoRow final : public FTableRowBase
{
public:
	E_AXIS_MAPPING_TYPE                           AxisMapping;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0010(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MainKey;                                           // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAxisMappingInfoRow) == 0x000008, "Wrong alignment on FAxisMappingInfoRow");
static_assert(sizeof(FAxisMappingInfoRow) == 0x000030, "Wrong size on FAxisMappingInfoRow");
static_assert(offsetof(FAxisMappingInfoRow, AxisMapping) == 0x000008, "Member 'FAxisMappingInfoRow::AxisMapping' has a wrong offset!");
static_assert(offsetof(FAxisMappingInfoRow, Key) == 0x000010, "Member 'FAxisMappingInfoRow::Key' has a wrong offset!");
static_assert(offsetof(FAxisMappingInfoRow, Scale) == 0x000028, "Member 'FAxisMappingInfoRow::Scale' has a wrong offset!");
static_assert(offsetof(FAxisMappingInfoRow, MainKey) == 0x00002C, "Member 'FAxisMappingInfoRow::MainKey' has a wrong offset!");

// ScriptStruct Project.GrowGetMiitsuData
// 0x0008 (0x0008 - 0x0000)
struct FGrowGetMiitsuData final
{
public:
	int32                                         M_threshold_Lv;                                    // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_growGetMiitsu;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGrowGetMiitsuData) == 0x000004, "Wrong alignment on FGrowGetMiitsuData");
static_assert(sizeof(FGrowGetMiitsuData) == 0x000008, "Wrong size on FGrowGetMiitsuData");
static_assert(offsetof(FGrowGetMiitsuData, M_threshold_Lv) == 0x000000, "Member 'FGrowGetMiitsuData::M_threshold_Lv' has a wrong offset!");
static_assert(offsetof(FGrowGetMiitsuData, M_growGetMiitsu) == 0x000004, "Member 'FGrowGetMiitsuData::M_growGetMiitsu' has a wrong offset!");

// ScriptStruct Project.PlayerStockNumData
// 0x0008 (0x0008 - 0x0000)
struct FPlayerStockNumData final
{
public:
	int32                                         M_Level;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StockNum;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerStockNumData) == 0x000004, "Wrong alignment on FPlayerStockNumData");
static_assert(sizeof(FPlayerStockNumData) == 0x000008, "Wrong size on FPlayerStockNumData");
static_assert(offsetof(FPlayerStockNumData, M_Level) == 0x000000, "Member 'FPlayerStockNumData::M_Level' has a wrong offset!");
static_assert(offsetof(FPlayerStockNumData, M_StockNum) == 0x000004, "Member 'FPlayerStockNumData::M_StockNum' has a wrong offset!");

// ScriptStruct Project.MovieSceneFacialEventSectionData
// 0x0000 (0x0088 - 0x0088)
struct FMovieSceneFacialEventSectionData final : public FMovieSceneEventSectionData
{
};
static_assert(alignof(FMovieSceneFacialEventSectionData) == 0x000008, "Wrong alignment on FMovieSceneFacialEventSectionData");
static_assert(sizeof(FMovieSceneFacialEventSectionData) == 0x000088, "Wrong size on FMovieSceneFacialEventSectionData");

// ScriptStruct Project.MovieSceneFacialAnimationPresetTemplate
// 0x0088 (0x00A8 - 0x0020)
struct FMovieSceneFacialAnimationPresetTemplate final : public FMovieSceneEvalTemplate
{
public:
	struct FMovieSceneFacialEventSectionData      EventData;                                         // 0x0020(0x0088)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSceneFacialAnimationPresetTemplate) == 0x000008, "Wrong alignment on FMovieSceneFacialAnimationPresetTemplate");
static_assert(sizeof(FMovieSceneFacialAnimationPresetTemplate) == 0x0000A8, "Wrong size on FMovieSceneFacialAnimationPresetTemplate");
static_assert(offsetof(FMovieSceneFacialAnimationPresetTemplate, EventData) == 0x000020, "Member 'FMovieSceneFacialAnimationPresetTemplate::EventData' has a wrong offset!");

// ScriptStruct Project.PropertyItemData
// 0x0008 (0x0008 - 0x0000)
struct FPropertyItemData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Num;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropertyItemData) == 0x000004, "Wrong alignment on FPropertyItemData");
static_assert(sizeof(FPropertyItemData) == 0x000008, "Wrong size on FPropertyItemData");
static_assert(offsetof(FPropertyItemData, M_Id) == 0x000000, "Member 'FPropertyItemData::M_Id' has a wrong offset!");
static_assert(offsetof(FPropertyItemData, M_Num) == 0x000004, "Member 'FPropertyItemData::M_Num' has a wrong offset!");

// ScriptStruct Project.PropertyStorageData
// 0x0008 (0x0008 - 0x0000)
struct FPropertyStorageData final
{
public:
	int32                                         M_Level;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Storage;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropertyStorageData) == 0x000004, "Wrong alignment on FPropertyStorageData");
static_assert(sizeof(FPropertyStorageData) == 0x000008, "Wrong size on FPropertyStorageData");
static_assert(offsetof(FPropertyStorageData, M_Level) == 0x000000, "Member 'FPropertyStorageData::M_Level' has a wrong offset!");
static_assert(offsetof(FPropertyStorageData, M_Storage) == 0x000004, "Member 'FPropertyStorageData::M_Storage' has a wrong offset!");

// ScriptStruct Project.MagatsuhiItemData
// 0x0004 (0x0004 - 0x0000)
struct FMagatsuhiItemData final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMagatsuhiItemData) == 0x000004, "Wrong alignment on FMagatsuhiItemData");
static_assert(sizeof(FMagatsuhiItemData) == 0x000004, "Wrong size on FMagatsuhiItemData");
static_assert(offsetof(FMagatsuhiItemData, M_ItemID) == 0x000000, "Member 'FMagatsuhiItemData::M_ItemID' has a wrong offset!");

// ScriptStruct Project.CharGrowAttenuation
// 0x000C (0x000C - 0x0000)
struct FCharGrowAttenuation final
{
public:
	int32                                         M_MinLv;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MaxLv;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Type;                                            // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AttHP;                                           // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AttMP;                                           // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AttParam;                                        // 0x000B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharGrowAttenuation) == 0x000004, "Wrong alignment on FCharGrowAttenuation");
static_assert(sizeof(FCharGrowAttenuation) == 0x00000C, "Wrong size on FCharGrowAttenuation");
static_assert(offsetof(FCharGrowAttenuation, M_MinLv) == 0x000000, "Member 'FCharGrowAttenuation::M_MinLv' has a wrong offset!");
static_assert(offsetof(FCharGrowAttenuation, M_MaxLv) == 0x000004, "Member 'FCharGrowAttenuation::M_MaxLv' has a wrong offset!");
static_assert(offsetof(FCharGrowAttenuation, M_Type) == 0x000008, "Member 'FCharGrowAttenuation::M_Type' has a wrong offset!");
static_assert(offsetof(FCharGrowAttenuation, M_AttHP) == 0x000009, "Member 'FCharGrowAttenuation::M_AttHP' has a wrong offset!");
static_assert(offsetof(FCharGrowAttenuation, M_AttMP) == 0x00000A, "Member 'FCharGrowAttenuation::M_AttMP' has a wrong offset!");
static_assert(offsetof(FCharGrowAttenuation, M_AttParam) == 0x00000B, "Member 'FCharGrowAttenuation::M_AttParam' has a wrong offset!");

// ScriptStruct Project.CoasterSaveBuffer
// 0x0008 (0x0008 - 0x0000)
struct FCoasterSaveBuffer final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Buffer;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoasterSaveBuffer) == 0x000004, "Wrong alignment on FCoasterSaveBuffer");
static_assert(sizeof(FCoasterSaveBuffer) == 0x000008, "Wrong size on FCoasterSaveBuffer");
static_assert(offsetof(FCoasterSaveBuffer, M_MapID) == 0x000000, "Member 'FCoasterSaveBuffer::M_MapID' has a wrong offset!");
static_assert(offsetof(FCoasterSaveBuffer, M_Buffer) == 0x000004, "Member 'FCoasterSaveBuffer::M_Buffer' has a wrong offset!");

// ScriptStruct Project.BGMState
// 0x0018 (0x0018 - 0x0000)
struct FBGMState final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          Cue;                                               // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFadeType                                     FadeType;                                          // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBGMState) == 0x000008, "Wrong alignment on FBGMState");
static_assert(sizeof(FBGMState) == 0x000018, "Wrong size on FBGMState");
static_assert(offsetof(FBGMState, Priority) == 0x000000, "Member 'FBGMState::Priority' has a wrong offset!");
static_assert(offsetof(FBGMState, Cue) == 0x000008, "Member 'FBGMState::Cue' has a wrong offset!");
static_assert(offsetof(FBGMState, FadeType) == 0x000010, "Member 'FBGMState::FadeType' has a wrong offset!");

// ScriptStruct Project.RigRailPlayInfo
// 0x0034 (0x0034 - 0x0000)
struct FRigRailPlayInfo final
{
public:
	bool                                          M_LockTarget;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Reverse;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Loop;                                            // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Closed;                                          // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsPanCamera;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_TargetOffset;                                    // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_RIG_RAIL_ORIGIN_TYPE                        M_OriginType;                                      // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_RIG_RAIL_COORDINATE_TYPE                    M_CoordinateType;                                  // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_TargetSocketName;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ChangeSpeedPoint;                                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_FirstPlaySpeed;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_SecondPlaySpeed;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_InterpRatio;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Fovy;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigRailPlayInfo) == 0x000004, "Wrong alignment on FRigRailPlayInfo");
static_assert(sizeof(FRigRailPlayInfo) == 0x000034, "Wrong size on FRigRailPlayInfo");
static_assert(offsetof(FRigRailPlayInfo, M_LockTarget) == 0x000000, "Member 'FRigRailPlayInfo::M_LockTarget' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_Reverse) == 0x000001, "Member 'FRigRailPlayInfo::M_Reverse' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_Loop) == 0x000002, "Member 'FRigRailPlayInfo::M_Loop' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_Closed) == 0x000003, "Member 'FRigRailPlayInfo::M_Closed' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_IsPanCamera) == 0x000004, "Member 'FRigRailPlayInfo::M_IsPanCamera' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_TargetOffset) == 0x000008, "Member 'FRigRailPlayInfo::M_TargetOffset' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_OriginType) == 0x000014, "Member 'FRigRailPlayInfo::M_OriginType' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_CoordinateType) == 0x000015, "Member 'FRigRailPlayInfo::M_CoordinateType' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_TargetSocketName) == 0x000018, "Member 'FRigRailPlayInfo::M_TargetSocketName' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_ChangeSpeedPoint) == 0x000020, "Member 'FRigRailPlayInfo::M_ChangeSpeedPoint' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_FirstPlaySpeed) == 0x000024, "Member 'FRigRailPlayInfo::M_FirstPlaySpeed' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_SecondPlaySpeed) == 0x000028, "Member 'FRigRailPlayInfo::M_SecondPlaySpeed' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_InterpRatio) == 0x00002C, "Member 'FRigRailPlayInfo::M_InterpRatio' has a wrong offset!");
static_assert(offsetof(FRigRailPlayInfo, M_Fovy) == 0x000030, "Member 'FRigRailPlayInfo::M_Fovy' has a wrong offset!");

// ScriptStruct Project.CustomSplinePoint
// 0x0034 (0x0034 - 0x0000)
struct FCustomSplinePoint final
{
public:
	struct FVector                                M_Position;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_ArriveTangent;                                   // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_LeaveTangent;                                    // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_Rotation;                                        // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESplinePointType                              M_Type;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomSplinePoint) == 0x000004, "Wrong alignment on FCustomSplinePoint");
static_assert(sizeof(FCustomSplinePoint) == 0x000034, "Wrong size on FCustomSplinePoint");
static_assert(offsetof(FCustomSplinePoint, M_Position) == 0x000000, "Member 'FCustomSplinePoint::M_Position' has a wrong offset!");
static_assert(offsetof(FCustomSplinePoint, M_ArriveTangent) == 0x00000C, "Member 'FCustomSplinePoint::M_ArriveTangent' has a wrong offset!");
static_assert(offsetof(FCustomSplinePoint, M_LeaveTangent) == 0x000018, "Member 'FCustomSplinePoint::M_LeaveTangent' has a wrong offset!");
static_assert(offsetof(FCustomSplinePoint, M_Rotation) == 0x000024, "Member 'FCustomSplinePoint::M_Rotation' has a wrong offset!");
static_assert(offsetof(FCustomSplinePoint, M_Type) == 0x000030, "Member 'FCustomSplinePoint::M_Type' has a wrong offset!");

// ScriptStruct Project.SkillGetNeedItem
// 0x0008 (0x0008 - 0x0000)
struct FSkillGetNeedItem final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NeedNum;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillGetNeedItem) == 0x000004, "Wrong alignment on FSkillGetNeedItem");
static_assert(sizeof(FSkillGetNeedItem) == 0x000008, "Wrong size on FSkillGetNeedItem");
static_assert(offsetof(FSkillGetNeedItem, M_ItemID) == 0x000000, "Member 'FSkillGetNeedItem::M_ItemID' has a wrong offset!");
static_assert(offsetof(FSkillGetNeedItem, M_NeedNum) == 0x000004, "Member 'FSkillGetNeedItem::M_NeedNum' has a wrong offset!");

// ScriptStruct Project.DaathMeshPlacerSplineMeshData
// 0x0020 (0x0020 - 0x0000)
struct FDaathMeshPlacerSplineMeshData final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStepCollision;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDaathMeshPlacerSplineMeshData) == 0x000008, "Wrong alignment on FDaathMeshPlacerSplineMeshData");
static_assert(sizeof(FDaathMeshPlacerSplineMeshData) == 0x000020, "Wrong size on FDaathMeshPlacerSplineMeshData");
static_assert(offsetof(FDaathMeshPlacerSplineMeshData, Mesh) == 0x000000, "Member 'FDaathMeshPlacerSplineMeshData::Mesh' has a wrong offset!");
static_assert(offsetof(FDaathMeshPlacerSplineMeshData, RotationOffset) == 0x000008, "Member 'FDaathMeshPlacerSplineMeshData::RotationOffset' has a wrong offset!");
static_assert(offsetof(FDaathMeshPlacerSplineMeshData, Scale) == 0x000014, "Member 'FDaathMeshPlacerSplineMeshData::Scale' has a wrong offset!");
static_assert(offsetof(FDaathMeshPlacerSplineMeshData, bStepCollision) == 0x000018, "Member 'FDaathMeshPlacerSplineMeshData::bStepCollision' has a wrong offset!");

// ScriptStruct Project.DaathSplineMeshData
// 0x0010 (0x0010 - 0x0000)
struct FDaathSplineMeshData final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineMeshAxis                               ForwardAxis;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseAxis;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Offset;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDaathSplineMeshData) == 0x000008, "Wrong alignment on FDaathSplineMeshData");
static_assert(sizeof(FDaathSplineMeshData) == 0x000010, "Wrong size on FDaathSplineMeshData");
static_assert(offsetof(FDaathSplineMeshData, Mesh) == 0x000000, "Member 'FDaathSplineMeshData::Mesh' has a wrong offset!");
static_assert(offsetof(FDaathSplineMeshData, ForwardAxis) == 0x000008, "Member 'FDaathSplineMeshData::ForwardAxis' has a wrong offset!");
static_assert(offsetof(FDaathSplineMeshData, bReverseAxis) == 0x000009, "Member 'FDaathSplineMeshData::bReverseAxis' has a wrong offset!");
static_assert(offsetof(FDaathSplineMeshData, Offset) == 0x00000C, "Member 'FDaathSplineMeshData::Offset' has a wrong offset!");

// ScriptStruct Project.UtsusemiItemData
// 0x0018 (0x0018 - 0x0000)
struct FUtsusemiItemData final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DevilID;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortId;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NameSortId;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BuyingPrice;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ShopListId;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUtsusemiItemData) == 0x000004, "Wrong alignment on FUtsusemiItemData");
static_assert(sizeof(FUtsusemiItemData) == 0x000018, "Wrong size on FUtsusemiItemData");
static_assert(offsetof(FUtsusemiItemData, M_ItemID) == 0x000000, "Member 'FUtsusemiItemData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FUtsusemiItemData, M_DevilID) == 0x000004, "Member 'FUtsusemiItemData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FUtsusemiItemData, M_SortId) == 0x000008, "Member 'FUtsusemiItemData::M_SortId' has a wrong offset!");
static_assert(offsetof(FUtsusemiItemData, M_NameSortId) == 0x00000C, "Member 'FUtsusemiItemData::M_NameSortId' has a wrong offset!");
static_assert(offsetof(FUtsusemiItemData, M_BuyingPrice) == 0x000010, "Member 'FUtsusemiItemData::M_BuyingPrice' has a wrong offset!");
static_assert(offsetof(FUtsusemiItemData, M_ShopListId) == 0x000014, "Member 'FUtsusemiItemData::M_ShopListId' has a wrong offset!");

// ScriptStruct Project.MapDBaseData
// 0x0030 (0x0030 - 0x0000)
struct FMapDBaseData final
{
public:
	int32                                         M_StartFlagName;                                   // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndFlagName;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AfterFlagName;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EncountID;                                       // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EventEncountID;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MaskRadius;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EncountType;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_GodParams;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapDBaseData) == 0x000008, "Wrong alignment on FMapDBaseData");
static_assert(sizeof(FMapDBaseData) == 0x000030, "Wrong size on FMapDBaseData");
static_assert(offsetof(FMapDBaseData, M_StartFlagName) == 0x000000, "Member 'FMapDBaseData::M_StartFlagName' has a wrong offset!");
static_assert(offsetof(FMapDBaseData, M_EndFlagName) == 0x000004, "Member 'FMapDBaseData::M_EndFlagName' has a wrong offset!");
static_assert(offsetof(FMapDBaseData, M_AfterFlagName) == 0x000008, "Member 'FMapDBaseData::M_AfterFlagName' has a wrong offset!");
static_assert(offsetof(FMapDBaseData, M_EncountID) == 0x00000C, "Member 'FMapDBaseData::M_EncountID' has a wrong offset!");
static_assert(offsetof(FMapDBaseData, M_EventEncountID) == 0x000010, "Member 'FMapDBaseData::M_EventEncountID' has a wrong offset!");
static_assert(offsetof(FMapDBaseData, M_MaskRadius) == 0x000014, "Member 'FMapDBaseData::M_MaskRadius' has a wrong offset!");
static_assert(offsetof(FMapDBaseData, M_EncountType) == 0x000018, "Member 'FMapDBaseData::M_EncountType' has a wrong offset!");
static_assert(offsetof(FMapDBaseData, M_GodParams) == 0x000020, "Member 'FMapDBaseData::M_GodParams' has a wrong offset!");

// ScriptStruct Project.DebugBtlAITempViewData
// 0x0030 (0x0030 - 0x0000)
struct FDebugBtlAITempViewData final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DispName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugBtlAITempViewData) == 0x000008, "Wrong alignment on FDebugBtlAITempViewData");
static_assert(sizeof(FDebugBtlAITempViewData) == 0x000030, "Wrong size on FDebugBtlAITempViewData");
static_assert(offsetof(FDebugBtlAITempViewData, Index) == 0x000000, "Member 'FDebugBtlAITempViewData::Index' has a wrong offset!");
static_assert(offsetof(FDebugBtlAITempViewData, DispName) == 0x000008, "Member 'FDebugBtlAITempViewData::DispName' has a wrong offset!");
static_assert(offsetof(FDebugBtlAITempViewData, Comment) == 0x000018, "Member 'FDebugBtlAITempViewData::Comment' has a wrong offset!");
static_assert(offsetof(FDebugBtlAITempViewData, Param) == 0x000028, "Member 'FDebugBtlAITempViewData::Param' has a wrong offset!");

// ScriptStruct Project.MinimapPOIParam
// 0x0040 (0x0040 - 0x0000)
struct FMinimapPOIParam final
{
public:
	E_MINIMAP_POI_TYPE                            M_POIType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_POI_ICON                            M_MinimapIcon;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_MapID;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DataId;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SaveUniqueId;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_InvisibleTillSave;                               // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_HideInOtherMap;                                  // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ShowFar;                                         // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_OldNewRoute                                 M_MainRoute;                                       // 0x0017(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Not2D;                                           // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_OnFlag;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OffFlag;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_InactiveFlag;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_WorldLocation;                                   // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RotateZ;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_DrawOffset;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapPOIParam) == 0x000004, "Wrong alignment on FMinimapPOIParam");
static_assert(sizeof(FMinimapPOIParam) == 0x000040, "Wrong size on FMinimapPOIParam");
static_assert(offsetof(FMinimapPOIParam, M_POIType) == 0x000000, "Member 'FMinimapPOIParam::M_POIType' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_MinimapIcon) == 0x000001, "Member 'FMinimapPOIParam::M_MinimapIcon' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_MapID) == 0x000004, "Member 'FMinimapPOIParam::M_MapID' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_AreaId) == 0x000008, "Member 'FMinimapPOIParam::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_DataId) == 0x00000C, "Member 'FMinimapPOIParam::M_DataId' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_SaveUniqueId) == 0x000010, "Member 'FMinimapPOIParam::M_SaveUniqueId' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_InvisibleTillSave) == 0x000014, "Member 'FMinimapPOIParam::M_InvisibleTillSave' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_HideInOtherMap) == 0x000015, "Member 'FMinimapPOIParam::M_HideInOtherMap' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_ShowFar) == 0x000016, "Member 'FMinimapPOIParam::M_ShowFar' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_MainRoute) == 0x000017, "Member 'FMinimapPOIParam::M_MainRoute' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_Not2D) == 0x000018, "Member 'FMinimapPOIParam::M_Not2D' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_OnFlag) == 0x00001C, "Member 'FMinimapPOIParam::M_OnFlag' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_OffFlag) == 0x000020, "Member 'FMinimapPOIParam::M_OffFlag' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_InactiveFlag) == 0x000024, "Member 'FMinimapPOIParam::M_InactiveFlag' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_WorldLocation) == 0x000028, "Member 'FMinimapPOIParam::M_WorldLocation' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_RotateZ) == 0x000034, "Member 'FMinimapPOIParam::M_RotateZ' has a wrong offset!");
static_assert(offsetof(FMinimapPOIParam, M_DrawOffset) == 0x000038, "Member 'FMinimapPOIParam::M_DrawOffset' has a wrong offset!");

// ScriptStruct Project.DebugMenuItemDataParam
// 0x00A8 (0x00A8 - 0x0000)
struct FDebugMenuItemDataParam final
{
public:
	int32                                         Param;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRet;                                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Text;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ArrText;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	E_D_MENU_NAME_CHANGE_TYPE                     NameChangeType;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   NameChangeObj;                                     // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FuncBaseObj;                                       // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEndDelete;                                       // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBtlEndDelete;                                    // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DispName;                                          // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoLimit;                                           // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugMenuItemDataParam) == 0x000008, "Wrong alignment on FDebugMenuItemDataParam");
static_assert(sizeof(FDebugMenuItemDataParam) == 0x0000A8, "Wrong size on FDebugMenuItemDataParam");
static_assert(offsetof(FDebugMenuItemDataParam, Param) == 0x000000, "Member 'FDebugMenuItemDataParam::Param' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, Min) == 0x000004, "Member 'FDebugMenuItemDataParam::Min' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, Max) == 0x000008, "Member 'FDebugMenuItemDataParam::Max' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, bRet) == 0x00000C, "Member 'FDebugMenuItemDataParam::bRet' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, Text) == 0x000010, "Member 'FDebugMenuItemDataParam::Text' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, ArrText) == 0x000020, "Member 'FDebugMenuItemDataParam::ArrText' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, NameChangeType) == 0x000030, "Member 'FDebugMenuItemDataParam::NameChangeType' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, NameChangeObj) == 0x000038, "Member 'FDebugMenuItemDataParam::NameChangeObj' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, FuncBaseObj) == 0x000060, "Member 'FDebugMenuItemDataParam::FuncBaseObj' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, IsEndDelete) == 0x000088, "Member 'FDebugMenuItemDataParam::IsEndDelete' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, IsBtlEndDelete) == 0x000089, "Member 'FDebugMenuItemDataParam::IsBtlEndDelete' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, DispName) == 0x000090, "Member 'FDebugMenuItemDataParam::DispName' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemDataParam, NoLimit) == 0x0000A0, "Member 'FDebugMenuItemDataParam::NoLimit' has a wrong offset!");

// ScriptStruct Project.DebugMenuItem
// 0x00C8 (0x00C8 - 0x0000)
struct FDebugMenuItem final
{
public:
	class FName                                   M_Name;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   M_PathName;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	E_D_MENU_TYPE                                 M_Type;                                            // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsLock;                                          // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_PageId;                                          // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         M_ItemID;                                          // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDebugMenuItemDataParam                M_Data;                                            // 0x0020(0x00A8)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDebugMenuItem) == 0x000008, "Wrong alignment on FDebugMenuItem");
static_assert(sizeof(FDebugMenuItem) == 0x0000C8, "Wrong size on FDebugMenuItem");
static_assert(offsetof(FDebugMenuItem, M_Name) == 0x000000, "Member 'FDebugMenuItem::M_Name' has a wrong offset!");
static_assert(offsetof(FDebugMenuItem, M_PathName) == 0x000008, "Member 'FDebugMenuItem::M_PathName' has a wrong offset!");
static_assert(offsetof(FDebugMenuItem, M_Type) == 0x000010, "Member 'FDebugMenuItem::M_Type' has a wrong offset!");
static_assert(offsetof(FDebugMenuItem, M_IsLock) == 0x000011, "Member 'FDebugMenuItem::M_IsLock' has a wrong offset!");
static_assert(offsetof(FDebugMenuItem, M_PageId) == 0x000014, "Member 'FDebugMenuItem::M_PageId' has a wrong offset!");
static_assert(offsetof(FDebugMenuItem, M_ItemID) == 0x000018, "Member 'FDebugMenuItem::M_ItemID' has a wrong offset!");
static_assert(offsetof(FDebugMenuItem, M_Data) == 0x000020, "Member 'FDebugMenuItem::M_Data' has a wrong offset!");

// ScriptStruct Project.MimanData
// 0x0008 (0x0008 - 0x0000)
struct FMimanData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Miitsu;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMimanData) == 0x000004, "Wrong alignment on FMimanData");
static_assert(sizeof(FMimanData) == 0x000008, "Wrong size on FMimanData");
static_assert(offsetof(FMimanData, M_MapID) == 0x000000, "Member 'FMimanData::M_MapID' has a wrong offset!");
static_assert(offsetof(FMimanData, M_Miitsu) == 0x000004, "Member 'FMimanData::M_Miitsu' has a wrong offset!");

// ScriptStruct Project.DebugMenuNameChangeObj
// 0x0028 (0x0028 - 0x0000)
struct FDebugMenuNameChangeObj final
{
public:
	TSoftClassPtr<class UClass>                   Obj;                                               // 0x0000(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugMenuNameChangeObj) == 0x000008, "Wrong alignment on FDebugMenuNameChangeObj");
static_assert(sizeof(FDebugMenuNameChangeObj) == 0x000028, "Wrong size on FDebugMenuNameChangeObj");
static_assert(offsetof(FDebugMenuNameChangeObj, Obj) == 0x000000, "Member 'FDebugMenuNameChangeObj::Obj' has a wrong offset!");

// ScriptStruct Project.DebugMenuPage
// 0x0030 (0x0030 - 0x0000)
struct FDebugMenuPage final
{
public:
	class FName                                   M_Name;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         M_PageId;                                          // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         M_ParentItemId;                                    // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsVisibility;                                    // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_PathName;                                        // 0x0014(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDebugMenuItem>                 M_Items;                                           // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDebugMenuPage) == 0x000008, "Wrong alignment on FDebugMenuPage");
static_assert(sizeof(FDebugMenuPage) == 0x000030, "Wrong size on FDebugMenuPage");
static_assert(offsetof(FDebugMenuPage, M_Name) == 0x000000, "Member 'FDebugMenuPage::M_Name' has a wrong offset!");
static_assert(offsetof(FDebugMenuPage, M_PageId) == 0x000008, "Member 'FDebugMenuPage::M_PageId' has a wrong offset!");
static_assert(offsetof(FDebugMenuPage, M_ParentItemId) == 0x00000C, "Member 'FDebugMenuPage::M_ParentItemId' has a wrong offset!");
static_assert(offsetof(FDebugMenuPage, M_IsVisibility) == 0x000010, "Member 'FDebugMenuPage::M_IsVisibility' has a wrong offset!");
static_assert(offsetof(FDebugMenuPage, M_PathName) == 0x000014, "Member 'FDebugMenuPage::M_PathName' has a wrong offset!");
static_assert(offsetof(FDebugMenuPage, M_Items) == 0x000020, "Member 'FDebugMenuPage::M_Items' has a wrong offset!");

// ScriptStruct Project.MapSymbolConnectNode
// 0x0008 (0x0008 - 0x0000)
struct FMapSymbolConnectNode final
{
public:
	int32                                         M_Index;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Cost;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapSymbolConnectNode) == 0x000004, "Wrong alignment on FMapSymbolConnectNode");
static_assert(sizeof(FMapSymbolConnectNode) == 0x000008, "Wrong size on FMapSymbolConnectNode");
static_assert(offsetof(FMapSymbolConnectNode, M_Index) == 0x000000, "Member 'FMapSymbolConnectNode::M_Index' has a wrong offset!");
static_assert(offsetof(FMapSymbolConnectNode, M_Cost) == 0x000004, "Member 'FMapSymbolConnectNode::M_Cost' has a wrong offset!");

// ScriptStruct Project.DebugMenuItemData
// 0x00D0 (0x00D0 - 0x0000)
struct FDebugMenuItemData final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageId;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathName;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PathName_Name;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DispName;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_D_MENU_TYPE                                 Type;                                              // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Data01;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Data02;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Data03;                                            // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bData01;                                           // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   FuncBaseObj;                                       // 0x0050(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DataText;                                          // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         DataArrText;                                       // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	E_D_MENU_NAME_CHANGE_TYPE                     NameChangeType;                                    // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   NameChangeObj;                                     // 0x00A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLock;                                            // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNoLimit;                                         // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugMenuItemData) == 0x000008, "Wrong alignment on FDebugMenuItemData");
static_assert(sizeof(FDebugMenuItemData) == 0x0000D0, "Wrong size on FDebugMenuItemData");
static_assert(offsetof(FDebugMenuItemData, ItemId) == 0x000000, "Member 'FDebugMenuItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, PageId) == 0x000004, "Member 'FDebugMenuItemData::PageId' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, Name) == 0x000008, "Member 'FDebugMenuItemData::Name' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, PathName) == 0x000010, "Member 'FDebugMenuItemData::PathName' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, PathName_Name) == 0x000020, "Member 'FDebugMenuItemData::PathName_Name' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, DispName) == 0x000028, "Member 'FDebugMenuItemData::DispName' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, Type) == 0x000038, "Member 'FDebugMenuItemData::Type' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, Data01) == 0x00003C, "Member 'FDebugMenuItemData::Data01' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, Data02) == 0x000040, "Member 'FDebugMenuItemData::Data02' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, Data03) == 0x000044, "Member 'FDebugMenuItemData::Data03' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, bData01) == 0x000048, "Member 'FDebugMenuItemData::bData01' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, FuncBaseObj) == 0x000050, "Member 'FDebugMenuItemData::FuncBaseObj' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, DataText) == 0x000078, "Member 'FDebugMenuItemData::DataText' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, DataArrText) == 0x000088, "Member 'FDebugMenuItemData::DataArrText' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, NameChangeType) == 0x000098, "Member 'FDebugMenuItemData::NameChangeType' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, NameChangeObj) == 0x0000A0, "Member 'FDebugMenuItemData::NameChangeObj' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, IsLock) == 0x0000C8, "Member 'FDebugMenuItemData::IsLock' has a wrong offset!");
static_assert(offsetof(FDebugMenuItemData, IsNoLimit) == 0x0000C9, "Member 'FDebugMenuItemData::IsNoLimit' has a wrong offset!");

// ScriptStruct Project.DebugMenuPageData
// 0x0018 (0x0018 - 0x0000)
struct FDebugMenuPageData final
{
public:
	int32                                         PageId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PathName;                                          // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugMenuPageData) == 0x000004, "Wrong alignment on FDebugMenuPageData");
static_assert(sizeof(FDebugMenuPageData) == 0x000018, "Wrong size on FDebugMenuPageData");
static_assert(offsetof(FDebugMenuPageData, PageId) == 0x000000, "Member 'FDebugMenuPageData::PageId' has a wrong offset!");
static_assert(offsetof(FDebugMenuPageData, Name) == 0x000004, "Member 'FDebugMenuPageData::Name' has a wrong offset!");
static_assert(offsetof(FDebugMenuPageData, PathName) == 0x00000C, "Member 'FDebugMenuPageData::PathName' has a wrong offset!");
static_assert(offsetof(FDebugMenuPageData, ItemNum) == 0x000014, "Member 'FDebugMenuPageData::ItemNum' has a wrong offset!");

// ScriptStruct Project.KawaiiHairBundleParameter
// 0x0060 (0x0060 - 0x0000)
struct FKawaiiHairBundleParameter final
{
public:
	struct FVector                                WorldDampingLocation;                              // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceCenter;                                       // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceRightA;                                       // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceRightB;                                       // 0x0024(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceRightC;                                       // 0x0030(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceLeftA;                                        // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceLeftB;                                        // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceLeftC;                                        // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKawaiiHairBundleParameter) == 0x000004, "Wrong alignment on FKawaiiHairBundleParameter");
static_assert(sizeof(FKawaiiHairBundleParameter) == 0x000060, "Wrong size on FKawaiiHairBundleParameter");
static_assert(offsetof(FKawaiiHairBundleParameter, WorldDampingLocation) == 0x000000, "Member 'FKawaiiHairBundleParameter::WorldDampingLocation' has a wrong offset!");
static_assert(offsetof(FKawaiiHairBundleParameter, ForceCenter) == 0x00000C, "Member 'FKawaiiHairBundleParameter::ForceCenter' has a wrong offset!");
static_assert(offsetof(FKawaiiHairBundleParameter, ForceRightA) == 0x000018, "Member 'FKawaiiHairBundleParameter::ForceRightA' has a wrong offset!");
static_assert(offsetof(FKawaiiHairBundleParameter, ForceRightB) == 0x000024, "Member 'FKawaiiHairBundleParameter::ForceRightB' has a wrong offset!");
static_assert(offsetof(FKawaiiHairBundleParameter, ForceRightC) == 0x000030, "Member 'FKawaiiHairBundleParameter::ForceRightC' has a wrong offset!");
static_assert(offsetof(FKawaiiHairBundleParameter, ForceLeftA) == 0x00003C, "Member 'FKawaiiHairBundleParameter::ForceLeftA' has a wrong offset!");
static_assert(offsetof(FKawaiiHairBundleParameter, ForceLeftB) == 0x000048, "Member 'FKawaiiHairBundleParameter::ForceLeftB' has a wrong offset!");
static_assert(offsetof(FKawaiiHairBundleParameter, ForceLeftC) == 0x000054, "Member 'FKawaiiHairBundleParameter::ForceLeftC' has a wrong offset!");

// ScriptStruct Project.MotionViewerTableData
// 0x0038 (0x0040 - 0x0008)
struct FMotionViewerTableData final : public FTableRowBase
{
public:
	class FString                                 DispName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CustomPawn;                                        // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionViewerTableData) == 0x000008, "Wrong alignment on FMotionViewerTableData");
static_assert(sizeof(FMotionViewerTableData) == 0x000040, "Wrong size on FMotionViewerTableData");
static_assert(offsetof(FMotionViewerTableData, DispName) == 0x000008, "Member 'FMotionViewerTableData::DispName' has a wrong offset!");
static_assert(offsetof(FMotionViewerTableData, CustomPawn) == 0x000018, "Member 'FMotionViewerTableData::CustomPawn' has a wrong offset!");

// ScriptStruct Project.CreateModeDevilRate
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FCreateModeDevilRate final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreateModeDevilRate) == 0x000004, "Wrong alignment on FCreateModeDevilRate");
static_assert(sizeof(FCreateModeDevilRate) == 0x00000C, "Wrong size on FCreateModeDevilRate");

// ScriptStruct Project.MessageData
// 0x0070 (0x0070 - 0x0000)
struct FMessageData final
{
public:
	int32                                         MessageID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageLabel;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Voice;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAtomCue>           Cue;                                               // 0x0020(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCharaLipSync>           LipSync;                                           // 0x0048(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMessageData) == 0x000008, "Wrong alignment on FMessageData");
static_assert(sizeof(FMessageData) == 0x000070, "Wrong size on FMessageData");
static_assert(offsetof(FMessageData, MessageID) == 0x000000, "Member 'FMessageData::MessageID' has a wrong offset!");
static_assert(offsetof(FMessageData, MessageLabel) == 0x000004, "Member 'FMessageData::MessageLabel' has a wrong offset!");
static_assert(offsetof(FMessageData, Voice) == 0x000010, "Member 'FMessageData::Voice' has a wrong offset!");
static_assert(offsetof(FMessageData, Cue) == 0x000020, "Member 'FMessageData::Cue' has a wrong offset!");
static_assert(offsetof(FMessageData, LipSync) == 0x000048, "Member 'FMessageData::LipSync' has a wrong offset!");

// ScriptStruct Project.MessageSelData
// 0x0018 (0x0018 - 0x0000)
struct FMessageSelData final
{
public:
	class UScriptMessageAsset*                    ScriptMessage;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMessageData>                   MessArray;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMessageSelData) == 0x000008, "Wrong alignment on FMessageSelData");
static_assert(sizeof(FMessageSelData) == 0x000018, "Wrong size on FMessageSelData");
static_assert(offsetof(FMessageSelData, ScriptMessage) == 0x000000, "Member 'FMessageSelData::ScriptMessage' has a wrong offset!");
static_assert(offsetof(FMessageSelData, MessArray) == 0x000008, "Member 'FMessageSelData::MessArray' has a wrong offset!");

// ScriptStruct Project.CreateModeDevilData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCreateModeDevilData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreateModeDevilData) == 0x000008, "Wrong alignment on FCreateModeDevilData");
static_assert(sizeof(FCreateModeDevilData) == 0x000010, "Wrong size on FCreateModeDevilData");

// ScriptStruct Project.CreateModeDevilParamBase
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FCreateModeDevilParamBase final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreateModeDevilParamBase) == 0x000004, "Wrong alignment on FCreateModeDevilParamBase");
static_assert(sizeof(FCreateModeDevilParamBase) == 0x000014, "Wrong size on FCreateModeDevilParamBase");

// ScriptStruct Project.MinimapFootprintEntry
// 0x0060 (0x0060 - 0x0000)
struct FMinimapFootprintEntry final
{
public:
	bool                                          M_IsExist;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_MapID;                                           // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_WorldTransform;                                  // 0x0010(0x0030)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_ShouldBeVisible;                                 // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_ScreenLocation;                                  // 0x0044(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ScreenAngle;                                     // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Alpha;                                           // 0x0054(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimapFootprintEntry) == 0x000010, "Wrong alignment on FMinimapFootprintEntry");
static_assert(sizeof(FMinimapFootprintEntry) == 0x000060, "Wrong size on FMinimapFootprintEntry");
static_assert(offsetof(FMinimapFootprintEntry, M_IsExist) == 0x000000, "Member 'FMinimapFootprintEntry::M_IsExist' has a wrong offset!");
static_assert(offsetof(FMinimapFootprintEntry, M_MapID) == 0x000004, "Member 'FMinimapFootprintEntry::M_MapID' has a wrong offset!");
static_assert(offsetof(FMinimapFootprintEntry, M_AreaId) == 0x000008, "Member 'FMinimapFootprintEntry::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMinimapFootprintEntry, M_WorldTransform) == 0x000010, "Member 'FMinimapFootprintEntry::M_WorldTransform' has a wrong offset!");
static_assert(offsetof(FMinimapFootprintEntry, M_ShouldBeVisible) == 0x000040, "Member 'FMinimapFootprintEntry::M_ShouldBeVisible' has a wrong offset!");
static_assert(offsetof(FMinimapFootprintEntry, M_ScreenLocation) == 0x000044, "Member 'FMinimapFootprintEntry::M_ScreenLocation' has a wrong offset!");
static_assert(offsetof(FMinimapFootprintEntry, M_ScreenAngle) == 0x000050, "Member 'FMinimapFootprintEntry::M_ScreenAngle' has a wrong offset!");
static_assert(offsetof(FMinimapFootprintEntry, M_Alpha) == 0x000054, "Member 'FMinimapFootprintEntry::M_Alpha' has a wrong offset!");

// ScriptStruct Project.DevilBaseData
// 0x0108 (0x0108 - 0x0000)
struct FDevilBaseData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CharacterNameIndex;                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Group;                                           // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Weapon;                                          // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Physical;                                        // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Needle;                                          // 0x000B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Bite;                                            // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Claw;                                            // 0x000D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Magic;                                           // 0x000E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Attr1;                                           // 0x000F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Attr2;                                           // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsGuest;                                         // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_JoinAssumptionLevel;                             // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Lv;                                              // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Nakama;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkTarget;                                       // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkNum;                                          // 0x001A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkNumMax;                                       // 0x001B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkAttr;                                         // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_HitRate;                                         // 0x001D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AddBst;                                          // 0x001E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AddHitRate;                                      // 0x001F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AtkCoe;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StanHP;                                          // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_WaitRev;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DevilDescDevilID;                                // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP;                                              // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPPlus;                                          // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPPlus;                                          // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Str;                                             // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Vit;                                             // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Mgi;                                             // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Agi;                                             // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Luc;                                             // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StrUp;                                           // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_VitUp;                                           // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MgiUp;                                           // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AgiUp;                                           // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LucUp;                                           // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_GiftEv;                                          // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_GiftType;                                        // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UniteLimit;                                      // 0x006A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AccidentLimit;                                   // 0x006B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TalkType;                                        // 0x006C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ReplacementTalkType;                             // 0x006D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NonTalkType;                                     // 0x006E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NoritoVoice;                                     // 0x006F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_VoiceType;                                       // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BadVoice;                                        // 0x0071(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_CriticalAddValue;                                // 0x0072(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BibleFromSummonCanNot;                           // 0x0073(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EventLimit;                                      // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DicParam;                                        // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillSlotNum;                                    // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AutoSkillSlotNum;                                // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_Skill;                                           // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_AutoSkill;                                       // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_UniqueSkill;                                     // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAddGetSkill>                   M_AddGetSkill;                                     // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAddGetSkill>                   M_AddGetAutoSkill;                                 // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_DefenceAishou;                                   // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_SkillTekisei;                                    // 0x00E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_NotDeleteFlag;                                   // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AntiNotDeleteFlag;                               // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PopLocationLabelOldRoute1;                       // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PopLocationLabelOldRoute2;                       // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PopLocationLabelNewRoute1;                       // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PopLocationLabelNewRoute2;                       // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevilBaseData) == 0x000008, "Wrong alignment on FDevilBaseData");
static_assert(sizeof(FDevilBaseData) == 0x000108, "Wrong size on FDevilBaseData");
static_assert(offsetof(FDevilBaseData, M_Id) == 0x000000, "Member 'FDevilBaseData::M_Id' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_CharacterNameIndex) == 0x000004, "Member 'FDevilBaseData::M_CharacterNameIndex' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Group) == 0x000008, "Member 'FDevilBaseData::M_Group' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Weapon) == 0x000009, "Member 'FDevilBaseData::M_Weapon' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Physical) == 0x00000A, "Member 'FDevilBaseData::M_Physical' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Needle) == 0x00000B, "Member 'FDevilBaseData::M_Needle' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Bite) == 0x00000C, "Member 'FDevilBaseData::M_Bite' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Claw) == 0x00000D, "Member 'FDevilBaseData::M_Claw' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Magic) == 0x00000E, "Member 'FDevilBaseData::M_Magic' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Attr1) == 0x00000F, "Member 'FDevilBaseData::M_Attr1' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Attr2) == 0x000010, "Member 'FDevilBaseData::M_Attr2' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_IsGuest) == 0x000011, "Member 'FDevilBaseData::M_IsGuest' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_JoinAssumptionLevel) == 0x000012, "Member 'FDevilBaseData::M_JoinAssumptionLevel' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Lv) == 0x000014, "Member 'FDevilBaseData::M_Lv' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Nakama) == 0x000018, "Member 'FDevilBaseData::M_Nakama' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AtkTarget) == 0x000019, "Member 'FDevilBaseData::M_AtkTarget' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AtkNum) == 0x00001A, "Member 'FDevilBaseData::M_AtkNum' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AtkNumMax) == 0x00001B, "Member 'FDevilBaseData::M_AtkNumMax' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AtkAttr) == 0x00001C, "Member 'FDevilBaseData::M_AtkAttr' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_HitRate) == 0x00001D, "Member 'FDevilBaseData::M_HitRate' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AddBst) == 0x00001E, "Member 'FDevilBaseData::M_AddBst' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AddHitRate) == 0x00001F, "Member 'FDevilBaseData::M_AddHitRate' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AtkCoe) == 0x000020, "Member 'FDevilBaseData::M_AtkCoe' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_StanHP) == 0x000024, "Member 'FDevilBaseData::M_StanHP' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_WaitRev) == 0x000028, "Member 'FDevilBaseData::M_WaitRev' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_DevilDescDevilID) == 0x00002C, "Member 'FDevilBaseData::M_DevilDescDevilID' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_HP) == 0x000030, "Member 'FDevilBaseData::M_HP' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_MP) == 0x000034, "Member 'FDevilBaseData::M_MP' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_HPPlus) == 0x000038, "Member 'FDevilBaseData::M_HPPlus' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_MPPlus) == 0x00003C, "Member 'FDevilBaseData::M_MPPlus' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Str) == 0x000040, "Member 'FDevilBaseData::M_Str' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Vit) == 0x000044, "Member 'FDevilBaseData::M_Vit' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Mgi) == 0x000048, "Member 'FDevilBaseData::M_Mgi' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Agi) == 0x00004C, "Member 'FDevilBaseData::M_Agi' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Luc) == 0x000050, "Member 'FDevilBaseData::M_Luc' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_StrUp) == 0x000054, "Member 'FDevilBaseData::M_StrUp' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_VitUp) == 0x000058, "Member 'FDevilBaseData::M_VitUp' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_MgiUp) == 0x00005C, "Member 'FDevilBaseData::M_MgiUp' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AgiUp) == 0x000060, "Member 'FDevilBaseData::M_AgiUp' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_LucUp) == 0x000064, "Member 'FDevilBaseData::M_LucUp' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_GiftEv) == 0x000068, "Member 'FDevilBaseData::M_GiftEv' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_GiftType) == 0x000069, "Member 'FDevilBaseData::M_GiftType' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_UniteLimit) == 0x00006A, "Member 'FDevilBaseData::M_UniteLimit' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AccidentLimit) == 0x00006B, "Member 'FDevilBaseData::M_AccidentLimit' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_TalkType) == 0x00006C, "Member 'FDevilBaseData::M_TalkType' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_ReplacementTalkType) == 0x00006D, "Member 'FDevilBaseData::M_ReplacementTalkType' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_NonTalkType) == 0x00006E, "Member 'FDevilBaseData::M_NonTalkType' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_NoritoVoice) == 0x00006F, "Member 'FDevilBaseData::M_NoritoVoice' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_VoiceType) == 0x000070, "Member 'FDevilBaseData::M_VoiceType' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_BadVoice) == 0x000071, "Member 'FDevilBaseData::M_BadVoice' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_CriticalAddValue) == 0x000072, "Member 'FDevilBaseData::M_CriticalAddValue' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_BibleFromSummonCanNot) == 0x000073, "Member 'FDevilBaseData::M_BibleFromSummonCanNot' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_EventLimit) == 0x000074, "Member 'FDevilBaseData::M_EventLimit' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_DicParam) == 0x000078, "Member 'FDevilBaseData::M_DicParam' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_SkillSlotNum) == 0x00007C, "Member 'FDevilBaseData::M_SkillSlotNum' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AutoSkillSlotNum) == 0x000080, "Member 'FDevilBaseData::M_AutoSkillSlotNum' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_Skill) == 0x000088, "Member 'FDevilBaseData::M_Skill' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AutoSkill) == 0x000098, "Member 'FDevilBaseData::M_AutoSkill' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_UniqueSkill) == 0x0000A8, "Member 'FDevilBaseData::M_UniqueSkill' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AddGetSkill) == 0x0000B0, "Member 'FDevilBaseData::M_AddGetSkill' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AddGetAutoSkill) == 0x0000C0, "Member 'FDevilBaseData::M_AddGetAutoSkill' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_DefenceAishou) == 0x0000D0, "Member 'FDevilBaseData::M_DefenceAishou' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_SkillTekisei) == 0x0000E0, "Member 'FDevilBaseData::M_SkillTekisei' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_NotDeleteFlag) == 0x0000F0, "Member 'FDevilBaseData::M_NotDeleteFlag' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_AntiNotDeleteFlag) == 0x0000F4, "Member 'FDevilBaseData::M_AntiNotDeleteFlag' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_PopLocationLabelOldRoute1) == 0x0000F8, "Member 'FDevilBaseData::M_PopLocationLabelOldRoute1' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_PopLocationLabelOldRoute2) == 0x0000FC, "Member 'FDevilBaseData::M_PopLocationLabelOldRoute2' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_PopLocationLabelNewRoute1) == 0x000100, "Member 'FDevilBaseData::M_PopLocationLabelNewRoute1' has a wrong offset!");
static_assert(offsetof(FDevilBaseData, M_PopLocationLabelNewRoute2) == 0x000104, "Member 'FDevilBaseData::M_PopLocationLabelNewRoute2' has a wrong offset!");

// ScriptStruct Project.ItemDrop
// 0x000C (0x000C - 0x0000)
struct FItemDrop final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Rate;                                            // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Flag;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDrop) == 0x000004, "Wrong alignment on FItemDrop");
static_assert(sizeof(FItemDrop) == 0x00000C, "Wrong size on FItemDrop");
static_assert(offsetof(FItemDrop, M_ItemID) == 0x000000, "Member 'FItemDrop::M_ItemID' has a wrong offset!");
static_assert(offsetof(FItemDrop, M_Rate) == 0x000004, "Member 'FItemDrop::M_Rate' has a wrong offset!");
static_assert(offsetof(FItemDrop, M_Flag) == 0x000008, "Member 'FItemDrop::M_Flag' has a wrong offset!");

// ScriptStruct Project.EnemyData
// 0x00D8 (0x00D8 - 0x0000)
struct FEnemyData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Lv;                                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP;                                              // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Str;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Vit;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Mgi;                                             // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Agi;                                             // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Luc;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_DispAnalyze;                                     // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsNoBegLife;                                     // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_EnableScout;                                     // 0x0026(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsNoMercyTalk;                                   // 0x0027(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsBusinessRare;                                  // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsFriendTalk;                                    // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_MOON_TEMPER_DATA                       M_MoonTemper;                                      // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsBoss;                                          // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x1];                                       // 0x002C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         M_RandAishou;                                      // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_PressNum;                                        // 0x002E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ActNum;                                          // 0x002F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkTarget;                                       // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkNum;                                          // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkNumMax;                                       // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkAttr;                                         // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_HitRate;                                         // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AddBst;                                          // 0x0035(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AddHitRate;                                      // 0x0036(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AtkCoe;                                          // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StanHP;                                          // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AddMagatushiSkill;                               // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DefenceAishouRootDevilID;                        // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Macca;                                           // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Reichi;                                          // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AIID;                                            // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ModelID;                                         // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AnalizeID;                                       // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AcquaintanceID;                                  // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_WorshipHealRate;                                 // 0x0064(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BlackmailRate;                                   // 0x0065(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_CriticalAddValue;                                // 0x0066(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_DeathAddPerc;                                    // 0x0067(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemDrop>                      M_ItemDrop;                                        // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_Skill;                                           // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_AutoSkill;                                       // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_UniqueSkill;                                     // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_DefenceAishou;                                   // 0x00A0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_SkillTekisei;                                    // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         M_SymbolScaleType;                                 // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_QuizChoices;                                     // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyData) == 0x000008, "Wrong alignment on FEnemyData");
static_assert(sizeof(FEnemyData) == 0x0000D8, "Wrong size on FEnemyData");
static_assert(offsetof(FEnemyData, M_Id) == 0x000000, "Member 'FEnemyData::M_Id' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Lv) == 0x000004, "Member 'FEnemyData::M_Lv' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_HP) == 0x000008, "Member 'FEnemyData::M_HP' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_MP) == 0x00000C, "Member 'FEnemyData::M_MP' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Str) == 0x000010, "Member 'FEnemyData::M_Str' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Vit) == 0x000014, "Member 'FEnemyData::M_Vit' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Mgi) == 0x000018, "Member 'FEnemyData::M_Mgi' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Agi) == 0x00001C, "Member 'FEnemyData::M_Agi' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Luc) == 0x000020, "Member 'FEnemyData::M_Luc' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_DispAnalyze) == 0x000024, "Member 'FEnemyData::M_DispAnalyze' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_IsNoBegLife) == 0x000025, "Member 'FEnemyData::M_IsNoBegLife' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_EnableScout) == 0x000026, "Member 'FEnemyData::M_EnableScout' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_IsNoMercyTalk) == 0x000027, "Member 'FEnemyData::M_IsNoMercyTalk' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_IsBusinessRare) == 0x000028, "Member 'FEnemyData::M_IsBusinessRare' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_IsFriendTalk) == 0x000029, "Member 'FEnemyData::M_IsFriendTalk' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_MoonTemper) == 0x00002A, "Member 'FEnemyData::M_MoonTemper' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_IsBoss) == 0x00002B, "Member 'FEnemyData::M_IsBoss' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_RandAishou) == 0x00002D, "Member 'FEnemyData::M_RandAishou' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_PressNum) == 0x00002E, "Member 'FEnemyData::M_PressNum' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_ActNum) == 0x00002F, "Member 'FEnemyData::M_ActNum' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AtkTarget) == 0x000030, "Member 'FEnemyData::M_AtkTarget' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AtkNum) == 0x000031, "Member 'FEnemyData::M_AtkNum' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AtkNumMax) == 0x000032, "Member 'FEnemyData::M_AtkNumMax' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AtkAttr) == 0x000033, "Member 'FEnemyData::M_AtkAttr' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_HitRate) == 0x000034, "Member 'FEnemyData::M_HitRate' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AddBst) == 0x000035, "Member 'FEnemyData::M_AddBst' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AddHitRate) == 0x000036, "Member 'FEnemyData::M_AddHitRate' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AtkCoe) == 0x000038, "Member 'FEnemyData::M_AtkCoe' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_StanHP) == 0x00003C, "Member 'FEnemyData::M_StanHP' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AddMagatushiSkill) == 0x000040, "Member 'FEnemyData::M_AddMagatushiSkill' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_DefenceAishouRootDevilID) == 0x000044, "Member 'FEnemyData::M_DefenceAishouRootDevilID' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Exp) == 0x000048, "Member 'FEnemyData::M_Exp' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Macca) == 0x00004C, "Member 'FEnemyData::M_Macca' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Reichi) == 0x000050, "Member 'FEnemyData::M_Reichi' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AIID) == 0x000054, "Member 'FEnemyData::M_AIID' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_ModelID) == 0x000058, "Member 'FEnemyData::M_ModelID' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AnalizeID) == 0x00005C, "Member 'FEnemyData::M_AnalizeID' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AcquaintanceID) == 0x000060, "Member 'FEnemyData::M_AcquaintanceID' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_WorshipHealRate) == 0x000064, "Member 'FEnemyData::M_WorshipHealRate' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_BlackmailRate) == 0x000065, "Member 'FEnemyData::M_BlackmailRate' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_CriticalAddValue) == 0x000066, "Member 'FEnemyData::M_CriticalAddValue' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_DeathAddPerc) == 0x000067, "Member 'FEnemyData::M_DeathAddPerc' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_ItemDrop) == 0x000068, "Member 'FEnemyData::M_ItemDrop' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_Skill) == 0x000078, "Member 'FEnemyData::M_Skill' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_AutoSkill) == 0x000088, "Member 'FEnemyData::M_AutoSkill' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_UniqueSkill) == 0x000098, "Member 'FEnemyData::M_UniqueSkill' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_DefenceAishou) == 0x0000A0, "Member 'FEnemyData::M_DefenceAishou' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_SkillTekisei) == 0x0000B0, "Member 'FEnemyData::M_SkillTekisei' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_SymbolScaleType) == 0x0000C0, "Member 'FEnemyData::M_SymbolScaleType' has a wrong offset!");
static_assert(offsetof(FEnemyData, M_QuizChoices) == 0x0000C8, "Member 'FEnemyData::M_QuizChoices' has a wrong offset!");

// ScriptStruct Project.MinimapAreaTableItem
// 0x0058 (0x0058 - 0x0000)
struct FMinimapAreaTableItem final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Dimension;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_MiniZoomDefault;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AllZoomMin;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AllZoomMax;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AllZoomDefault;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AllZoomOpenRateMin;                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AllZoomOpenRateMax;                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_TexLeft;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_TexTop;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_TexRight;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_TexBottom;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_PosDefaultX;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_PosDefaultY;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RyuketsuZoom;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RyuketsuPosX;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RyuketsuPosY;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_FootprintDistance;                               // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_FogGridNumX;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_FogGridNumY;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_FogGridSaveId;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapAreaTableItem) == 0x000004, "Wrong alignment on FMinimapAreaTableItem");
static_assert(sizeof(FMinimapAreaTableItem) == 0x000058, "Wrong size on FMinimapAreaTableItem");
static_assert(offsetof(FMinimapAreaTableItem, M_MapID) == 0x000000, "Member 'FMinimapAreaTableItem::M_MapID' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_AreaId) == 0x000004, "Member 'FMinimapAreaTableItem::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_Dimension) == 0x000008, "Member 'FMinimapAreaTableItem::M_Dimension' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_MiniZoomDefault) == 0x00000C, "Member 'FMinimapAreaTableItem::M_MiniZoomDefault' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_AllZoomMin) == 0x000010, "Member 'FMinimapAreaTableItem::M_AllZoomMin' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_AllZoomMax) == 0x000014, "Member 'FMinimapAreaTableItem::M_AllZoomMax' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_AllZoomDefault) == 0x000018, "Member 'FMinimapAreaTableItem::M_AllZoomDefault' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_AllZoomOpenRateMin) == 0x00001C, "Member 'FMinimapAreaTableItem::M_AllZoomOpenRateMin' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_AllZoomOpenRateMax) == 0x000020, "Member 'FMinimapAreaTableItem::M_AllZoomOpenRateMax' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_TexLeft) == 0x000024, "Member 'FMinimapAreaTableItem::M_TexLeft' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_TexTop) == 0x000028, "Member 'FMinimapAreaTableItem::M_TexTop' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_TexRight) == 0x00002C, "Member 'FMinimapAreaTableItem::M_TexRight' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_TexBottom) == 0x000030, "Member 'FMinimapAreaTableItem::M_TexBottom' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_PosDefaultX) == 0x000034, "Member 'FMinimapAreaTableItem::M_PosDefaultX' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_PosDefaultY) == 0x000038, "Member 'FMinimapAreaTableItem::M_PosDefaultY' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_RyuketsuZoom) == 0x00003C, "Member 'FMinimapAreaTableItem::M_RyuketsuZoom' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_RyuketsuPosX) == 0x000040, "Member 'FMinimapAreaTableItem::M_RyuketsuPosX' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_RyuketsuPosY) == 0x000044, "Member 'FMinimapAreaTableItem::M_RyuketsuPosY' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_FootprintDistance) == 0x000048, "Member 'FMinimapAreaTableItem::M_FootprintDistance' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_FogGridNumX) == 0x00004C, "Member 'FMinimapAreaTableItem::M_FogGridNumX' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_FogGridNumY) == 0x000050, "Member 'FMinimapAreaTableItem::M_FogGridNumY' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTableItem, M_FogGridSaveId) == 0x000054, "Member 'FMinimapAreaTableItem::M_FogGridSaveId' has a wrong offset!");

// ScriptStruct Project.MinimapAreaOverrideTableItem
// 0x0018 (0x0018 - 0x0000)
struct FMinimapAreaOverrideTableItem final
{
public:
	int32                                         M_StartFlag;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndFlag;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MapID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_AREA_TABLE_OVERRIDE_TARGET          M_OverrideTarget;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_OverrideValue;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapAreaOverrideTableItem) == 0x000004, "Wrong alignment on FMinimapAreaOverrideTableItem");
static_assert(sizeof(FMinimapAreaOverrideTableItem) == 0x000018, "Wrong size on FMinimapAreaOverrideTableItem");
static_assert(offsetof(FMinimapAreaOverrideTableItem, M_StartFlag) == 0x000000, "Member 'FMinimapAreaOverrideTableItem::M_StartFlag' has a wrong offset!");
static_assert(offsetof(FMinimapAreaOverrideTableItem, M_EndFlag) == 0x000004, "Member 'FMinimapAreaOverrideTableItem::M_EndFlag' has a wrong offset!");
static_assert(offsetof(FMinimapAreaOverrideTableItem, M_MapID) == 0x000008, "Member 'FMinimapAreaOverrideTableItem::M_MapID' has a wrong offset!");
static_assert(offsetof(FMinimapAreaOverrideTableItem, M_AreaId) == 0x00000C, "Member 'FMinimapAreaOverrideTableItem::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMinimapAreaOverrideTableItem, M_OverrideTarget) == 0x000010, "Member 'FMinimapAreaOverrideTableItem::M_OverrideTarget' has a wrong offset!");
static_assert(offsetof(FMinimapAreaOverrideTableItem, M_OverrideValue) == 0x000014, "Member 'FMinimapAreaOverrideTableItem::M_OverrideValue' has a wrong offset!");

// ScriptStruct Project.MinimapAreaTable
// 0x0020 (0x0020 - 0x0000)
struct FMinimapAreaTable final
{
public:
	TArray<struct FMinimapAreaTableItem>          M_ItemArray;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMinimapAreaOverrideTableItem>  M_OverrideItemArray;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapAreaTable) == 0x000008, "Wrong alignment on FMinimapAreaTable");
static_assert(sizeof(FMinimapAreaTable) == 0x000020, "Wrong size on FMinimapAreaTable");
static_assert(offsetof(FMinimapAreaTable, M_ItemArray) == 0x000000, "Member 'FMinimapAreaTable::M_ItemArray' has a wrong offset!");
static_assert(offsetof(FMinimapAreaTable, M_OverrideItemArray) == 0x000010, "Member 'FMinimapAreaTable::M_OverrideItemArray' has a wrong offset!");

// ScriptStruct Project.DevilUILocalizedNameSortIdData
// 0x0008 (0x0010 - 0x0008)
struct FDevilUILocalizedNameSortIdData final : public FTableRowBase
{
public:
	int32                                         SortID;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NameSortId;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevilUILocalizedNameSortIdData) == 0x000008, "Wrong alignment on FDevilUILocalizedNameSortIdData");
static_assert(sizeof(FDevilUILocalizedNameSortIdData) == 0x000010, "Wrong size on FDevilUILocalizedNameSortIdData");
static_assert(offsetof(FDevilUILocalizedNameSortIdData, SortID) == 0x000008, "Member 'FDevilUILocalizedNameSortIdData::SortID' has a wrong offset!");
static_assert(offsetof(FDevilUILocalizedNameSortIdData, NameSortId) == 0x00000C, "Member 'FDevilUILocalizedNameSortIdData::NameSortId' has a wrong offset!");

// ScriptStruct Project.MaterialParameterApplier_ScalarParam
// 0x000C (0x000C - 0x0000)
struct FMaterialParameterApplier_ScalarParam final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0004(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialParameterApplier_ScalarParam) == 0x000004, "Wrong alignment on FMaterialParameterApplier_ScalarParam");
static_assert(sizeof(FMaterialParameterApplier_ScalarParam) == 0x00000C, "Wrong size on FMaterialParameterApplier_ScalarParam");
static_assert(offsetof(FMaterialParameterApplier_ScalarParam, Value) == 0x000000, "Member 'FMaterialParameterApplier_ScalarParam::Value' has a wrong offset!");
static_assert(offsetof(FMaterialParameterApplier_ScalarParam, ParamName) == 0x000004, "Member 'FMaterialParameterApplier_ScalarParam::ParamName' has a wrong offset!");

// ScriptStruct Project.DevilUIGraphicsData
// 0x000C (0x000C - 0x0000)
struct FDevilUIGraphicsData final
{
public:
	int32                                         M_FaceId;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NameSortId;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevilUIGraphicsData) == 0x000004, "Wrong alignment on FDevilUIGraphicsData");
static_assert(sizeof(FDevilUIGraphicsData) == 0x00000C, "Wrong size on FDevilUIGraphicsData");
static_assert(offsetof(FDevilUIGraphicsData, M_FaceId) == 0x000000, "Member 'FDevilUIGraphicsData::M_FaceId' has a wrong offset!");
static_assert(offsetof(FDevilUIGraphicsData, M_SortId) == 0x000004, "Member 'FDevilUIGraphicsData::M_SortId' has a wrong offset!");
static_assert(offsetof(FDevilUIGraphicsData, M_NameSortId) == 0x000008, "Member 'FDevilUIGraphicsData::M_NameSortId' has a wrong offset!");

// ScriptStruct Project.DevilVoiceContainer
// 0x0050 (0x0050 - 0x0000)
struct FDevilVoiceContainer final
{
public:
	TMap<EDevilVoiceType, TSoftObjectPtr<class USoundAtomCue>> VoiceMap;                                          // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevilVoiceContainer) == 0x000008, "Wrong alignment on FDevilVoiceContainer");
static_assert(sizeof(FDevilVoiceContainer) == 0x000050, "Wrong size on FDevilVoiceContainer");
static_assert(offsetof(FDevilVoiceContainer, VoiceMap) == 0x000000, "Member 'FDevilVoiceContainer::VoiceMap' has a wrong offset!");

// ScriptStruct Project.DG_RoomRotatorDynamicActor
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x10) FDG_RoomRotatorDynamicActor final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDG_RoomRotatorDynamicActor) == 0x000010, "Wrong alignment on FDG_RoomRotatorDynamicActor");
static_assert(sizeof(FDG_RoomRotatorDynamicActor) == 0x000040, "Wrong size on FDG_RoomRotatorDynamicActor");

// ScriptStruct Project.DlcSubIdTableData_One
// 0x0008 (0x0008 - 0x0000)
struct FDlcSubIdTableData_One final
{
public:
	class FName                                   NameTag;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDlcSubIdTableData_One) == 0x000004, "Wrong alignment on FDlcSubIdTableData_One");
static_assert(sizeof(FDlcSubIdTableData_One) == 0x000008, "Wrong size on FDlcSubIdTableData_One");
static_assert(offsetof(FDlcSubIdTableData_One, NameTag) == 0x000000, "Member 'FDlcSubIdTableData_One::NameTag' has a wrong offset!");

// ScriptStruct Project.MinimapPOIEntry
// 0x0084 (0x0084 - 0x0000)
struct FMinimapPOIEntry final
{
public:
	struct FMinimapPOIParam                       M_Param;                                           // 0x0000(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_IsExist;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsMasked;                                        // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ControlledByActor;                               // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Show3D;                                          // 0x0043(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_Owner;                                           // 0x0044(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ACustomPawn>             M_OwnerPawn;                                       // 0x004C(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_VISIBILITY                          M_Visibility;                                      // 0x0054(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_WorldLocation;                                   // 0x0058(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_WorldLocationOffset;                             // 0x0064(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_ScreenLocation;                                  // 0x0070(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RenderAngle;                                     // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_POI_ICON                            M_IconToRender;                                    // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsHiddenByUI;                                    // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsHiddenByRyuketsu;                              // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0x1];                                       // 0x0083(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimapPOIEntry) == 0x000004, "Wrong alignment on FMinimapPOIEntry");
static_assert(sizeof(FMinimapPOIEntry) == 0x000084, "Wrong size on FMinimapPOIEntry");
static_assert(offsetof(FMinimapPOIEntry, M_Param) == 0x000000, "Member 'FMinimapPOIEntry::M_Param' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_IsExist) == 0x000040, "Member 'FMinimapPOIEntry::M_IsExist' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_IsMasked) == 0x000041, "Member 'FMinimapPOIEntry::M_IsMasked' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_ControlledByActor) == 0x000042, "Member 'FMinimapPOIEntry::M_ControlledByActor' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_Show3D) == 0x000043, "Member 'FMinimapPOIEntry::M_Show3D' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_Owner) == 0x000044, "Member 'FMinimapPOIEntry::M_Owner' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_OwnerPawn) == 0x00004C, "Member 'FMinimapPOIEntry::M_OwnerPawn' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_Visibility) == 0x000054, "Member 'FMinimapPOIEntry::M_Visibility' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_WorldLocation) == 0x000058, "Member 'FMinimapPOIEntry::M_WorldLocation' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_WorldLocationOffset) == 0x000064, "Member 'FMinimapPOIEntry::M_WorldLocationOffset' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_ScreenLocation) == 0x000070, "Member 'FMinimapPOIEntry::M_ScreenLocation' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_RenderAngle) == 0x00007C, "Member 'FMinimapPOIEntry::M_RenderAngle' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_IconToRender) == 0x000080, "Member 'FMinimapPOIEntry::M_IconToRender' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_IsHiddenByUI) == 0x000081, "Member 'FMinimapPOIEntry::M_IsHiddenByUI' has a wrong offset!");
static_assert(offsetof(FMinimapPOIEntry, M_IsHiddenByRyuketsu) == 0x000082, "Member 'FMinimapPOIEntry::M_IsHiddenByRyuketsu' has a wrong offset!");

// ScriptStruct Project.DlcTableData_One
// 0x0020 (0x0020 - 0x0000)
struct FDlcTableData_One final
{
public:
	int32                                         SaveId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameTag;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlatformContentId;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StoreID;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppID;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableContent;                                    // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDlcTableData_One) == 0x000004, "Wrong alignment on FDlcTableData_One");
static_assert(sizeof(FDlcTableData_One) == 0x000020, "Wrong size on FDlcTableData_One");
static_assert(offsetof(FDlcTableData_One, SaveId) == 0x000000, "Member 'FDlcTableData_One::SaveId' has a wrong offset!");
static_assert(offsetof(FDlcTableData_One, NameTag) == 0x000004, "Member 'FDlcTableData_One::NameTag' has a wrong offset!");
static_assert(offsetof(FDlcTableData_One, PlatformContentId) == 0x00000C, "Member 'FDlcTableData_One::PlatformContentId' has a wrong offset!");
static_assert(offsetof(FDlcTableData_One, StoreID) == 0x000010, "Member 'FDlcTableData_One::StoreID' has a wrong offset!");
static_assert(offsetof(FDlcTableData_One, AppID) == 0x000018, "Member 'FDlcTableData_One::AppID' has a wrong offset!");
static_assert(offsetof(FDlcTableData_One, bEnableContent) == 0x00001C, "Member 'FDlcTableData_One::bEnableContent' has a wrong offset!");

// ScriptStruct Project.OneEncountData
// 0x0040 (0x0040 - 0x0000)
struct FOneEncountData final
{
public:
	uint8                                         M_IsForceSurprise;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsForcePreemptive;                               // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NormalEnemyGroupLine;                            // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_BGM;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OverrideBGM;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_EnemyNotAutoUplifting;                           // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SubQuestId;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RowEncountRate;                                  // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RowEncountId;                                    // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RowEncountRate2;                                 // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RowEncountId2;                                   // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_EnemyID;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_IsDummy;                                         // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOneEncountData) == 0x000008, "Wrong alignment on FOneEncountData");
static_assert(sizeof(FOneEncountData) == 0x000040, "Wrong size on FOneEncountData");
static_assert(offsetof(FOneEncountData, M_IsForceSurprise) == 0x000000, "Member 'FOneEncountData::M_IsForceSurprise' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_IsForcePreemptive) == 0x000001, "Member 'FOneEncountData::M_IsForcePreemptive' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_NormalEnemyGroupLine) == 0x000002, "Member 'FOneEncountData::M_NormalEnemyGroupLine' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_BGM) == 0x000004, "Member 'FOneEncountData::M_BGM' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_OverrideBGM) == 0x000008, "Member 'FOneEncountData::M_OverrideBGM' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_EnemyNotAutoUplifting) == 0x00000C, "Member 'FOneEncountData::M_EnemyNotAutoUplifting' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_SubQuestId) == 0x000010, "Member 'FOneEncountData::M_SubQuestId' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_RowEncountRate) == 0x000014, "Member 'FOneEncountData::M_RowEncountRate' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_RowEncountId) == 0x000018, "Member 'FOneEncountData::M_RowEncountId' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_RowEncountRate2) == 0x00001C, "Member 'FOneEncountData::M_RowEncountRate2' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_RowEncountId2) == 0x000020, "Member 'FOneEncountData::M_RowEncountId2' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_EnemyID) == 0x000028, "Member 'FOneEncountData::M_EnemyID' has a wrong offset!");
static_assert(offsetof(FOneEncountData, M_IsDummy) == 0x000038, "Member 'FOneEncountData::M_IsDummy' has a wrong offset!");

// ScriptStruct Project.EndureWeakData
// 0x0008 (0x0008 - 0x0000)
struct FEndureWeakData final
{
public:
	int32                                         M_Endure;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Weak;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEndureWeakData) == 0x000004, "Wrong alignment on FEndureWeakData");
static_assert(sizeof(FEndureWeakData) == 0x000008, "Wrong size on FEndureWeakData");
static_assert(offsetof(FEndureWeakData, M_Endure) == 0x000000, "Member 'FEndureWeakData::M_Endure' has a wrong offset!");
static_assert(offsetof(FEndureWeakData, M_Weak) == 0x000004, "Member 'FEndureWeakData::M_Weak' has a wrong offset!");

// ScriptStruct Project.PackEncountCore
// 0x0008 (0x0008 - 0x0000)
struct FPackEncountCore final
{
public:
	int32                                         M_Encount_id;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Rate;                                            // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackEncountCore) == 0x000004, "Wrong alignment on FPackEncountCore");
static_assert(sizeof(FPackEncountCore) == 0x000008, "Wrong size on FPackEncountCore");
static_assert(offsetof(FPackEncountCore, M_Encount_id) == 0x000000, "Member 'FPackEncountCore::M_Encount_id' has a wrong offset!");
static_assert(offsetof(FPackEncountCore, M_Rate) == 0x000004, "Member 'FPackEncountCore::M_Rate' has a wrong offset!");

// ScriptStruct Project.PackEncount
// 0x0058 (0x0058 - 0x0000)
struct FPackEncount final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Index;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SymbolId;                                        // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ChainEncountRate;                                // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ChainEncount_NotEntry;                           // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_NoChainEncount;                                  // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_AllSymbolKill;                                   // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_StartFlag;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndFlag;                                         // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaIndex_Makka;                               // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaIndex_Hero;                                // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaIndex_Nkm;                                 // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaIndex_Miitsu;                              // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaRate;                                      // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaRate_NotDLC;                               // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaRate_Makka;                                // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaRate_Hero;                                 // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaRate_Nkm;                                  // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MitamaRate_Miitsu;                               // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MagatsuhiRate;                                   // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPackEncountCore>               M_List;                                            // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackEncount) == 0x000008, "Wrong alignment on FPackEncount");
static_assert(sizeof(FPackEncount) == 0x000058, "Wrong size on FPackEncount");
static_assert(offsetof(FPackEncount, M_MapID) == 0x000000, "Member 'FPackEncount::M_MapID' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_Index) == 0x000004, "Member 'FPackEncount::M_Index' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_SymbolId) == 0x000008, "Member 'FPackEncount::M_SymbolId' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_ChainEncountRate) == 0x00000C, "Member 'FPackEncount::M_ChainEncountRate' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_ChainEncount_NotEntry) == 0x000010, "Member 'FPackEncount::M_ChainEncount_NotEntry' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_NoChainEncount) == 0x000011, "Member 'FPackEncount::M_NoChainEncount' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_AllSymbolKill) == 0x000012, "Member 'FPackEncount::M_AllSymbolKill' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_StartFlag) == 0x000014, "Member 'FPackEncount::M_StartFlag' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_EndFlag) == 0x000018, "Member 'FPackEncount::M_EndFlag' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaIndex_Makka) == 0x00001C, "Member 'FPackEncount::M_MitamaIndex_Makka' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaIndex_Hero) == 0x000020, "Member 'FPackEncount::M_MitamaIndex_Hero' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaIndex_Nkm) == 0x000024, "Member 'FPackEncount::M_MitamaIndex_Nkm' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaIndex_Miitsu) == 0x000028, "Member 'FPackEncount::M_MitamaIndex_Miitsu' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaRate) == 0x00002C, "Member 'FPackEncount::M_MitamaRate' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaRate_NotDLC) == 0x000030, "Member 'FPackEncount::M_MitamaRate_NotDLC' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaRate_Makka) == 0x000034, "Member 'FPackEncount::M_MitamaRate_Makka' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaRate_Hero) == 0x000038, "Member 'FPackEncount::M_MitamaRate_Hero' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaRate_Nkm) == 0x00003C, "Member 'FPackEncount::M_MitamaRate_Nkm' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MitamaRate_Miitsu) == 0x000040, "Member 'FPackEncount::M_MitamaRate_Miitsu' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_MagatsuhiRate) == 0x000044, "Member 'FPackEncount::M_MagatsuhiRate' has a wrong offset!");
static_assert(offsetof(FPackEncount, M_List) == 0x000048, "Member 'FPackEncount::M_List' has a wrong offset!");

// ScriptStruct Project.EvtBtlWinCond
// 0x0003 (0x0003 - 0x0000)
struct FEvtBtlWinCond final
{
public:
	E_EVTBTL_WIN_COND                             M_Cond;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Value;                                           // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Type;                                            // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEvtBtlWinCond) == 0x000001, "Wrong alignment on FEvtBtlWinCond");
static_assert(sizeof(FEvtBtlWinCond) == 0x000003, "Wrong size on FEvtBtlWinCond");
static_assert(offsetof(FEvtBtlWinCond, M_Cond) == 0x000000, "Member 'FEvtBtlWinCond::M_Cond' has a wrong offset!");
static_assert(offsetof(FEvtBtlWinCond, M_Value) == 0x000001, "Member 'FEvtBtlWinCond::M_Value' has a wrong offset!");
static_assert(offsetof(FEvtBtlWinCond, M_Type) == 0x000002, "Member 'FEvtBtlWinCond::M_Type' has a wrong offset!");

// ScriptStruct Project.EventEncountData
// 0x0068 (0x0068 - 0x0000)
struct FEventEncountData final
{
public:
	uint8                                         M_EncountID;                                       // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_RenzokuEncountID;                                // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_EndEnemyHPRate;                                  // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_EVT_ENCOUNT_TYPE                            M_EventType;                                       // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BattleFieldID;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NoDeadEffect;                                      // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NoDestroyMdl;                                      // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_EnemyHPRate;                                     // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkipResult;                                      // 0x000B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InvalidEscape;                                     // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_EnemyNotAutoUplifting;                           // 0x000D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_BgmID;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OverrideBgmID;                                   // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PreAttack;                                       // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Pat;                                             // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SymbolId;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CheckEndLeaderDead;                              // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEvtBtlWinCond>                 M_WinCond;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_EnemyID;                                         // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_AfterEventID;                                    // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_GardenPointType;                                 // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsBossRush;                                      // 0x004D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BossRushExpRate;                                 // 0x004E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BossRushMakkaRate;                               // 0x004F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_SubLevelName;                                    // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventEncountData) == 0x000008, "Wrong alignment on FEventEncountData");
static_assert(sizeof(FEventEncountData) == 0x000068, "Wrong size on FEventEncountData");
static_assert(offsetof(FEventEncountData, M_EncountID) == 0x000000, "Member 'FEventEncountData::M_EncountID' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_RenzokuEncountID) == 0x000001, "Member 'FEventEncountData::M_RenzokuEncountID' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_EndEnemyHPRate) == 0x000002, "Member 'FEventEncountData::M_EndEnemyHPRate' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_EventType) == 0x000003, "Member 'FEventEncountData::M_EventType' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_BattleFieldID) == 0x000004, "Member 'FEventEncountData::M_BattleFieldID' has a wrong offset!");
static_assert(offsetof(FEventEncountData, NoDeadEffect) == 0x000008, "Member 'FEventEncountData::NoDeadEffect' has a wrong offset!");
static_assert(offsetof(FEventEncountData, NoDestroyMdl) == 0x000009, "Member 'FEventEncountData::NoDestroyMdl' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_EnemyHPRate) == 0x00000A, "Member 'FEventEncountData::M_EnemyHPRate' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_SkipResult) == 0x00000B, "Member 'FEventEncountData::M_SkipResult' has a wrong offset!");
static_assert(offsetof(FEventEncountData, InvalidEscape) == 0x00000C, "Member 'FEventEncountData::InvalidEscape' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_EnemyNotAutoUplifting) == 0x00000D, "Member 'FEventEncountData::M_EnemyNotAutoUplifting' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_BgmID) == 0x000010, "Member 'FEventEncountData::M_BgmID' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_OverrideBgmID) == 0x000014, "Member 'FEventEncountData::M_OverrideBgmID' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_PreAttack) == 0x000018, "Member 'FEventEncountData::M_PreAttack' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_Pat) == 0x00001C, "Member 'FEventEncountData::M_Pat' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_SymbolId) == 0x000020, "Member 'FEventEncountData::M_SymbolId' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_CheckEndLeaderDead) == 0x000024, "Member 'FEventEncountData::M_CheckEndLeaderDead' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_WinCond) == 0x000028, "Member 'FEventEncountData::M_WinCond' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_EnemyID) == 0x000038, "Member 'FEventEncountData::M_EnemyID' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_AfterEventID) == 0x000048, "Member 'FEventEncountData::M_AfterEventID' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_GardenPointType) == 0x00004C, "Member 'FEventEncountData::M_GardenPointType' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_IsBossRush) == 0x00004D, "Member 'FEventEncountData::M_IsBossRush' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_BossRushExpRate) == 0x00004E, "Member 'FEventEncountData::M_BossRushExpRate' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_BossRushMakkaRate) == 0x00004F, "Member 'FEventEncountData::M_BossRushMakkaRate' has a wrong offset!");
static_assert(offsetof(FEventEncountData, M_SubLevelName) == 0x000050, "Member 'FEventEncountData::M_SubLevelName' has a wrong offset!");

// ScriptStruct Project.MinimapMapSelectItem
// 0x0024 (0x0024 - 0x0000)
struct FMinimapMapSelectItem final
{
public:
	E_MAP_SELECT_ITEM_TYPE                        M_ItemType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_MapID;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ParentIndex;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ReachFlag;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OffFlag;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortOrder;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_MessageLabel;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapMapSelectItem) == 0x000004, "Wrong alignment on FMinimapMapSelectItem");
static_assert(sizeof(FMinimapMapSelectItem) == 0x000024, "Wrong size on FMinimapMapSelectItem");
static_assert(offsetof(FMinimapMapSelectItem, M_ItemType) == 0x000000, "Member 'FMinimapMapSelectItem::M_ItemType' has a wrong offset!");
static_assert(offsetof(FMinimapMapSelectItem, M_MapID) == 0x000004, "Member 'FMinimapMapSelectItem::M_MapID' has a wrong offset!");
static_assert(offsetof(FMinimapMapSelectItem, M_AreaId) == 0x000008, "Member 'FMinimapMapSelectItem::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMinimapMapSelectItem, M_ParentIndex) == 0x00000C, "Member 'FMinimapMapSelectItem::M_ParentIndex' has a wrong offset!");
static_assert(offsetof(FMinimapMapSelectItem, M_ReachFlag) == 0x000010, "Member 'FMinimapMapSelectItem::M_ReachFlag' has a wrong offset!");
static_assert(offsetof(FMinimapMapSelectItem, M_OffFlag) == 0x000014, "Member 'FMinimapMapSelectItem::M_OffFlag' has a wrong offset!");
static_assert(offsetof(FMinimapMapSelectItem, M_SortOrder) == 0x000018, "Member 'FMinimapMapSelectItem::M_SortOrder' has a wrong offset!");
static_assert(offsetof(FMinimapMapSelectItem, M_MessageLabel) == 0x00001C, "Member 'FMinimapMapSelectItem::M_MessageLabel' has a wrong offset!");

// ScriptStruct Project.FacialAnimationPreset_EVT08_PresetData
// 0x0058 (0x0058 - 0x0000)
struct FFacialAnimationPreset_EVT08_PresetData final
{
public:
	bool                                          bMaskTexture_Enable;                               // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MaskTexture;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNumA_Enable;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumA;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUmoveA_Enable;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UmoveA;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVmoveA_Enable;                                    // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VmoveA;                                            // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNumB_Enable;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumB;                                              // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUmoveB_Enable;                                    // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UmoveB;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVmoveB_Enable;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VmoveB;                                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNumC_Enable;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumC;                                              // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUmoveC_Enable;                                    // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UmoveC;                                            // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVmoveC_Enable;                                    // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VmoveC;                                            // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacialAnimationPreset_EVT08_PresetData) == 0x000008, "Wrong alignment on FFacialAnimationPreset_EVT08_PresetData");
static_assert(sizeof(FFacialAnimationPreset_EVT08_PresetData) == 0x000058, "Wrong size on FFacialAnimationPreset_EVT08_PresetData");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bMaskTexture_Enable) == 0x000000, "Member 'FFacialAnimationPreset_EVT08_PresetData::bMaskTexture_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, MaskTexture) == 0x000008, "Member 'FFacialAnimationPreset_EVT08_PresetData::MaskTexture' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bNumA_Enable) == 0x000010, "Member 'FFacialAnimationPreset_EVT08_PresetData::bNumA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, NumA) == 0x000014, "Member 'FFacialAnimationPreset_EVT08_PresetData::NumA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bUmoveA_Enable) == 0x000018, "Member 'FFacialAnimationPreset_EVT08_PresetData::bUmoveA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, UmoveA) == 0x00001C, "Member 'FFacialAnimationPreset_EVT08_PresetData::UmoveA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bVmoveA_Enable) == 0x000020, "Member 'FFacialAnimationPreset_EVT08_PresetData::bVmoveA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, VmoveA) == 0x000024, "Member 'FFacialAnimationPreset_EVT08_PresetData::VmoveA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bNumB_Enable) == 0x000028, "Member 'FFacialAnimationPreset_EVT08_PresetData::bNumB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, NumB) == 0x00002C, "Member 'FFacialAnimationPreset_EVT08_PresetData::NumB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bUmoveB_Enable) == 0x000030, "Member 'FFacialAnimationPreset_EVT08_PresetData::bUmoveB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, UmoveB) == 0x000034, "Member 'FFacialAnimationPreset_EVT08_PresetData::UmoveB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bVmoveB_Enable) == 0x000038, "Member 'FFacialAnimationPreset_EVT08_PresetData::bVmoveB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, VmoveB) == 0x00003C, "Member 'FFacialAnimationPreset_EVT08_PresetData::VmoveB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bNumC_Enable) == 0x000040, "Member 'FFacialAnimationPreset_EVT08_PresetData::bNumC_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, NumC) == 0x000044, "Member 'FFacialAnimationPreset_EVT08_PresetData::NumC' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bUmoveC_Enable) == 0x000048, "Member 'FFacialAnimationPreset_EVT08_PresetData::bUmoveC_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, UmoveC) == 0x00004C, "Member 'FFacialAnimationPreset_EVT08_PresetData::UmoveC' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, bVmoveC_Enable) == 0x000050, "Member 'FFacialAnimationPreset_EVT08_PresetData::bVmoveC_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT08_PresetData, VmoveC) == 0x000054, "Member 'FFacialAnimationPreset_EVT08_PresetData::VmoveC' has a wrong offset!");

// ScriptStruct Project.FacialAnimationPreset_EVT07_PresetData
// 0x0050 (0x0050 - 0x0000)
struct FFacialAnimationPreset_EVT07_PresetData final
{
public:
	bool                                          bMaskTextureB_Enable;                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MaskTextureB;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddColorB_Enable;                                 // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           AddColorB;                                         // 0x0014(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiplyColorB_Enable;                            // 0x0024(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           MultiplyColorB;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNumB_Enable;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumB;                                              // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpositionB_Enable;                                // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpositionB;                                        // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVpositionB_Enable;                                // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VpositionB;                                        // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacialAnimationPreset_EVT07_PresetData) == 0x000008, "Wrong alignment on FFacialAnimationPreset_EVT07_PresetData");
static_assert(sizeof(FFacialAnimationPreset_EVT07_PresetData) == 0x000050, "Wrong size on FFacialAnimationPreset_EVT07_PresetData");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, bMaskTextureB_Enable) == 0x000000, "Member 'FFacialAnimationPreset_EVT07_PresetData::bMaskTextureB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, MaskTextureB) == 0x000008, "Member 'FFacialAnimationPreset_EVT07_PresetData::MaskTextureB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, bAddColorB_Enable) == 0x000010, "Member 'FFacialAnimationPreset_EVT07_PresetData::bAddColorB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, AddColorB) == 0x000014, "Member 'FFacialAnimationPreset_EVT07_PresetData::AddColorB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, bMultiplyColorB_Enable) == 0x000024, "Member 'FFacialAnimationPreset_EVT07_PresetData::bMultiplyColorB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, MultiplyColorB) == 0x000028, "Member 'FFacialAnimationPreset_EVT07_PresetData::MultiplyColorB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, bNumB_Enable) == 0x000038, "Member 'FFacialAnimationPreset_EVT07_PresetData::bNumB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, NumB) == 0x00003C, "Member 'FFacialAnimationPreset_EVT07_PresetData::NumB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, bUpositionB_Enable) == 0x000040, "Member 'FFacialAnimationPreset_EVT07_PresetData::bUpositionB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, UpositionB) == 0x000044, "Member 'FFacialAnimationPreset_EVT07_PresetData::UpositionB' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, bVpositionB_Enable) == 0x000048, "Member 'FFacialAnimationPreset_EVT07_PresetData::bVpositionB_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT07_PresetData, VpositionB) == 0x00004C, "Member 'FFacialAnimationPreset_EVT07_PresetData::VpositionB' has a wrong offset!");

// ScriptStruct Project.MissionEntryCond
// 0x0020 (0x0020 - 0x0000)
struct FMissionEntryCond final
{
public:
	TArray<int32>                                 MissionIds;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CommonFlag;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldFlag;                                           // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewFlag;                                           // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionEntryCond) == 0x000008, "Wrong alignment on FMissionEntryCond");
static_assert(sizeof(FMissionEntryCond) == 0x000020, "Wrong size on FMissionEntryCond");
static_assert(offsetof(FMissionEntryCond, MissionIds) == 0x000000, "Member 'FMissionEntryCond::MissionIds' has a wrong offset!");
static_assert(offsetof(FMissionEntryCond, Level) == 0x000010, "Member 'FMissionEntryCond::Level' has a wrong offset!");
static_assert(offsetof(FMissionEntryCond, CommonFlag) == 0x000014, "Member 'FMissionEntryCond::CommonFlag' has a wrong offset!");
static_assert(offsetof(FMissionEntryCond, OldFlag) == 0x000018, "Member 'FMissionEntryCond::OldFlag' has a wrong offset!");
static_assert(offsetof(FMissionEntryCond, NewFlag) == 0x00001C, "Member 'FMissionEntryCond::NewFlag' has a wrong offset!");

// ScriptStruct Project.FacialAnimationPreset_EVT06_PresetData
// 0x0050 (0x0050 - 0x0000)
struct FFacialAnimationPreset_EVT06_PresetData final
{
public:
	bool                                          bMaskTextureA_Enable;                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MaskTextureA;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddColorA_Enable;                                 // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           AddColorA;                                         // 0x0014(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiplyColorA_Enable;                            // 0x0024(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           MultiplyColorA;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNumA_Enable;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumA;                                              // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpositionA_Enable;                                // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpositionA;                                        // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVpositionA_Enable;                                // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VpositionA;                                        // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacialAnimationPreset_EVT06_PresetData) == 0x000008, "Wrong alignment on FFacialAnimationPreset_EVT06_PresetData");
static_assert(sizeof(FFacialAnimationPreset_EVT06_PresetData) == 0x000050, "Wrong size on FFacialAnimationPreset_EVT06_PresetData");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, bMaskTextureA_Enable) == 0x000000, "Member 'FFacialAnimationPreset_EVT06_PresetData::bMaskTextureA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, MaskTextureA) == 0x000008, "Member 'FFacialAnimationPreset_EVT06_PresetData::MaskTextureA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, bAddColorA_Enable) == 0x000010, "Member 'FFacialAnimationPreset_EVT06_PresetData::bAddColorA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, AddColorA) == 0x000014, "Member 'FFacialAnimationPreset_EVT06_PresetData::AddColorA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, bMultiplyColorA_Enable) == 0x000024, "Member 'FFacialAnimationPreset_EVT06_PresetData::bMultiplyColorA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, MultiplyColorA) == 0x000028, "Member 'FFacialAnimationPreset_EVT06_PresetData::MultiplyColorA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, bNumA_Enable) == 0x000038, "Member 'FFacialAnimationPreset_EVT06_PresetData::bNumA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, NumA) == 0x00003C, "Member 'FFacialAnimationPreset_EVT06_PresetData::NumA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, bUpositionA_Enable) == 0x000040, "Member 'FFacialAnimationPreset_EVT06_PresetData::bUpositionA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, UpositionA) == 0x000044, "Member 'FFacialAnimationPreset_EVT06_PresetData::UpositionA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, bVpositionA_Enable) == 0x000048, "Member 'FFacialAnimationPreset_EVT06_PresetData::bVpositionA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT06_PresetData, VpositionA) == 0x00004C, "Member 'FFacialAnimationPreset_EVT06_PresetData::VpositionA' has a wrong offset!");

// ScriptStruct Project.FacialAnimationPreset_EVT05_PresetData
// 0x0014 (0x0014 - 0x0000)
struct FFacialAnimationPreset_EVT05_PresetData final
{
public:
	bool                                          bShadowColor_Enable;                               // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ShadowColor;                                       // 0x0004(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacialAnimationPreset_EVT05_PresetData) == 0x000004, "Wrong alignment on FFacialAnimationPreset_EVT05_PresetData");
static_assert(sizeof(FFacialAnimationPreset_EVT05_PresetData) == 0x000014, "Wrong size on FFacialAnimationPreset_EVT05_PresetData");
static_assert(offsetof(FFacialAnimationPreset_EVT05_PresetData, bShadowColor_Enable) == 0x000000, "Member 'FFacialAnimationPreset_EVT05_PresetData::bShadowColor_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT05_PresetData, ShadowColor) == 0x000004, "Member 'FFacialAnimationPreset_EVT05_PresetData::ShadowColor' has a wrong offset!");

// ScriptStruct Project.FacialAnimationPreset_EVT03_PresetData
// 0x0040 (0x0040 - 0x0000)
struct FFacialAnimationPreset_EVT03_PresetData final
{
public:
	bool                                          bLightPositionA_Enable;                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LightPositionA;                                    // 0x0004(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightColorA_Enable;                               // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LightColorA;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightContrastA_Enable;                            // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightContrastA;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightRadiusA_Enable;                              // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightRadiusA;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightRangeA_Enable;                               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightRangeA;                                       // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacialAnimationPreset_EVT03_PresetData) == 0x000004, "Wrong alignment on FFacialAnimationPreset_EVT03_PresetData");
static_assert(sizeof(FFacialAnimationPreset_EVT03_PresetData) == 0x000040, "Wrong size on FFacialAnimationPreset_EVT03_PresetData");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, bLightPositionA_Enable) == 0x000000, "Member 'FFacialAnimationPreset_EVT03_PresetData::bLightPositionA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, LightPositionA) == 0x000004, "Member 'FFacialAnimationPreset_EVT03_PresetData::LightPositionA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, bLightColorA_Enable) == 0x000014, "Member 'FFacialAnimationPreset_EVT03_PresetData::bLightColorA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, LightColorA) == 0x000018, "Member 'FFacialAnimationPreset_EVT03_PresetData::LightColorA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, bLightContrastA_Enable) == 0x000028, "Member 'FFacialAnimationPreset_EVT03_PresetData::bLightContrastA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, LightContrastA) == 0x00002C, "Member 'FFacialAnimationPreset_EVT03_PresetData::LightContrastA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, bLightRadiusA_Enable) == 0x000030, "Member 'FFacialAnimationPreset_EVT03_PresetData::bLightRadiusA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, LightRadiusA) == 0x000034, "Member 'FFacialAnimationPreset_EVT03_PresetData::LightRadiusA' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, bLightRangeA_Enable) == 0x000038, "Member 'FFacialAnimationPreset_EVT03_PresetData::bLightRangeA_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT03_PresetData, LightRangeA) == 0x00003C, "Member 'FFacialAnimationPreset_EVT03_PresetData::LightRangeA' has a wrong offset!");

// ScriptStruct Project.ListMinimapIconTableRow
// 0x0010 (0x0018 - 0x0008)
struct FListMinimapIconTableRow final : public FTableRowBase
{
public:
	int32                                         MapId;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DataTable;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FListMinimapIconTableRow) == 0x000008, "Wrong alignment on FListMinimapIconTableRow");
static_assert(sizeof(FListMinimapIconTableRow) == 0x000018, "Wrong size on FListMinimapIconTableRow");
static_assert(offsetof(FListMinimapIconTableRow, MapId) == 0x000008, "Member 'FListMinimapIconTableRow::MapId' has a wrong offset!");
static_assert(offsetof(FListMinimapIconTableRow, AreaId) == 0x00000C, "Member 'FListMinimapIconTableRow::AreaId' has a wrong offset!");
static_assert(offsetof(FListMinimapIconTableRow, DataTable) == 0x000010, "Member 'FListMinimapIconTableRow::DataTable' has a wrong offset!");

// ScriptStruct Project.FacialAnimationPreset_EVT02_PresetData
// 0x0014 (0x0014 - 0x0000)
struct FFacialAnimationPreset_EVT02_PresetData final
{
public:
	bool                                          bSilhouetteColor_Enable;                           // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SilhouetteColor;                                   // 0x0004(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacialAnimationPreset_EVT02_PresetData) == 0x000004, "Wrong alignment on FFacialAnimationPreset_EVT02_PresetData");
static_assert(sizeof(FFacialAnimationPreset_EVT02_PresetData) == 0x000014, "Wrong size on FFacialAnimationPreset_EVT02_PresetData");
static_assert(offsetof(FFacialAnimationPreset_EVT02_PresetData, bSilhouetteColor_Enable) == 0x000000, "Member 'FFacialAnimationPreset_EVT02_PresetData::bSilhouetteColor_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT02_PresetData, SilhouetteColor) == 0x000004, "Member 'FFacialAnimationPreset_EVT02_PresetData::SilhouetteColor' has a wrong offset!");

// ScriptStruct Project.FacialAnimationPreset_EVT01_PresetData
// 0x0024 (0x0024 - 0x0000)
struct FFacialAnimationPreset_EVT01_PresetData final
{
public:
	bool                                          bFresnelColor_Enable;                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           FresnelColor;                                      // 0x0004(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFresnelContrast_Enable;                           // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FresnelContrast;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFresnelRange_Enable;                              // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FresnelRange;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacialAnimationPreset_EVT01_PresetData) == 0x000004, "Wrong alignment on FFacialAnimationPreset_EVT01_PresetData");
static_assert(sizeof(FFacialAnimationPreset_EVT01_PresetData) == 0x000024, "Wrong size on FFacialAnimationPreset_EVT01_PresetData");
static_assert(offsetof(FFacialAnimationPreset_EVT01_PresetData, bFresnelColor_Enable) == 0x000000, "Member 'FFacialAnimationPreset_EVT01_PresetData::bFresnelColor_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT01_PresetData, FresnelColor) == 0x000004, "Member 'FFacialAnimationPreset_EVT01_PresetData::FresnelColor' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT01_PresetData, bFresnelContrast_Enable) == 0x000014, "Member 'FFacialAnimationPreset_EVT01_PresetData::bFresnelContrast_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT01_PresetData, FresnelContrast) == 0x000018, "Member 'FFacialAnimationPreset_EVT01_PresetData::FresnelContrast' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT01_PresetData, bFresnelRange_Enable) == 0x00001C, "Member 'FFacialAnimationPreset_EVT01_PresetData::bFresnelRange_Enable' has a wrong offset!");
static_assert(offsetof(FFacialAnimationPreset_EVT01_PresetData, FresnelRange) == 0x000020, "Member 'FFacialAnimationPreset_EVT01_PresetData::FresnelRange' has a wrong offset!");

// ScriptStruct Project.MissionTargetIcon
// 0x0010 (0x0010 - 0x0000)
struct FMissionTargetIcon final
{
public:
	E_MINIMAP_POI_TYPE                            POIType;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapId;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataId;                                            // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionTargetIcon) == 0x000004, "Wrong alignment on FMissionTargetIcon");
static_assert(sizeof(FMissionTargetIcon) == 0x000010, "Wrong size on FMissionTargetIcon");
static_assert(offsetof(FMissionTargetIcon, POIType) == 0x000000, "Member 'FMissionTargetIcon::POIType' has a wrong offset!");
static_assert(offsetof(FMissionTargetIcon, MapId) == 0x000004, "Member 'FMissionTargetIcon::MapId' has a wrong offset!");
static_assert(offsetof(FMissionTargetIcon, AreaId) == 0x000008, "Member 'FMissionTargetIcon::AreaId' has a wrong offset!");
static_assert(offsetof(FMissionTargetIcon, DataId) == 0x00000C, "Member 'FMissionTargetIcon::DataId' has a wrong offset!");

// ScriptStruct Project.ShopSaveData
// 0x0030 (0x0030 - 0x0000)
struct FShopSaveData final
{
public:
	TArray<uint8>                                 M_MimanRewardFlag;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_NewItemFlag;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_CommonFlag;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopSaveData) == 0x000008, "Wrong alignment on FShopSaveData");
static_assert(sizeof(FShopSaveData) == 0x000030, "Wrong size on FShopSaveData");
static_assert(offsetof(FShopSaveData, M_MimanRewardFlag) == 0x000000, "Member 'FShopSaveData::M_MimanRewardFlag' has a wrong offset!");
static_assert(offsetof(FShopSaveData, M_NewItemFlag) == 0x000010, "Member 'FShopSaveData::M_NewItemFlag' has a wrong offset!");
static_assert(offsetof(FShopSaveData, M_CommonFlag) == 0x000020, "Member 'FShopSaveData::M_CommonFlag' has a wrong offset!");

// ScriptStruct Project.FacilitySaveData
// 0x0050 (0x0050 - 0x0000)
struct FFacilitySaveData final
{
public:
	struct FShopSaveData                          M_ShopSaveData;                                    // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_TerminalFirstFlag;                               // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_FountainFirstFlag;                               // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ShopFirstFlag;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ReturnMapId;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ReturnAreaId;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ReturnWarpPoint;                                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacilitySaveData) == 0x000008, "Wrong alignment on FFacilitySaveData");
static_assert(sizeof(FFacilitySaveData) == 0x000050, "Wrong size on FFacilitySaveData");
static_assert(offsetof(FFacilitySaveData, M_ShopSaveData) == 0x000000, "Member 'FFacilitySaveData::M_ShopSaveData' has a wrong offset!");
static_assert(offsetof(FFacilitySaveData, M_TerminalFirstFlag) == 0x000030, "Member 'FFacilitySaveData::M_TerminalFirstFlag' has a wrong offset!");
static_assert(offsetof(FFacilitySaveData, M_FountainFirstFlag) == 0x000040, "Member 'FFacilitySaveData::M_FountainFirstFlag' has a wrong offset!");
static_assert(offsetof(FFacilitySaveData, M_ShopFirstFlag) == 0x000041, "Member 'FFacilitySaveData::M_ShopFirstFlag' has a wrong offset!");
static_assert(offsetof(FFacilitySaveData, M_ReturnMapId) == 0x000044, "Member 'FFacilitySaveData::M_ReturnMapId' has a wrong offset!");
static_assert(offsetof(FFacilitySaveData, M_ReturnAreaId) == 0x000048, "Member 'FFacilitySaveData::M_ReturnAreaId' has a wrong offset!");
static_assert(offsetof(FFacilitySaveData, M_ReturnWarpPoint) == 0x00004C, "Member 'FFacilitySaveData::M_ReturnWarpPoint' has a wrong offset!");

// ScriptStruct Project.ShopMimanItemData
// 0x0008 (0x0008 - 0x0000)
struct FShopMimanItemData final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopMimanItemData) == 0x000004, "Wrong alignment on FShopMimanItemData");
static_assert(sizeof(FShopMimanItemData) == 0x000008, "Wrong size on FShopMimanItemData");
static_assert(offsetof(FShopMimanItemData, ItemId) == 0x000000, "Member 'FShopMimanItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FShopMimanItemData, Num) == 0x000004, "Member 'FShopMimanItemData::Num' has a wrong offset!");

// ScriptStruct Project.ShopMimanItemTable
// 0x0018 (0x0018 - 0x0000)
struct FShopMimanItemTable final
{
public:
	int32                                         MimanNum;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DispNameID;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FShopMimanItemData>             ItemList;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopMimanItemTable) == 0x000008, "Wrong alignment on FShopMimanItemTable");
static_assert(sizeof(FShopMimanItemTable) == 0x000018, "Wrong size on FShopMimanItemTable");
static_assert(offsetof(FShopMimanItemTable, MimanNum) == 0x000000, "Member 'FShopMimanItemTable::MimanNum' has a wrong offset!");
static_assert(offsetof(FShopMimanItemTable, DispNameID) == 0x000004, "Member 'FShopMimanItemTable::DispNameID' has a wrong offset!");
static_assert(offsetof(FShopMimanItemTable, ItemList) == 0x000008, "Member 'FShopMimanItemTable::ItemList' has a wrong offset!");

// ScriptStruct Project.MovieSceneActorEventSectionTemplate
// 0x00A0 (0x00C0 - 0x0020)
struct FMovieSceneActorEventSectionTemplate final : public FMovieSceneEvalTemplate
{
public:
	struct FMovieSceneEventSectionData            EventData;                                         // 0x0020(0x0088)(NativeAccessSpecifierPublic)
	TArray<struct FMovieSceneObjectBindingID>     EventReceivers;                                    // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovieSceneActorEventSectionTemplate) == 0x000008, "Wrong alignment on FMovieSceneActorEventSectionTemplate");
static_assert(sizeof(FMovieSceneActorEventSectionTemplate) == 0x0000C0, "Wrong size on FMovieSceneActorEventSectionTemplate");
static_assert(offsetof(FMovieSceneActorEventSectionTemplate, EventData) == 0x000020, "Member 'FMovieSceneActorEventSectionTemplate::EventData' has a wrong offset!");
static_assert(offsetof(FMovieSceneActorEventSectionTemplate, EventReceivers) == 0x0000A8, "Member 'FMovieSceneActorEventSectionTemplate::EventReceivers' has a wrong offset!");

// ScriptStruct Project.ShopBuyTable
// 0x0014 (0x0014 - 0x0000)
struct FShopBuyTable final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShopListId;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartFlag1;                                        // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartFlag2;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndFlag;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopBuyTable) == 0x000004, "Wrong alignment on FShopBuyTable");
static_assert(sizeof(FShopBuyTable) == 0x000014, "Wrong size on FShopBuyTable");
static_assert(offsetof(FShopBuyTable, ItemId) == 0x000000, "Member 'FShopBuyTable::ItemId' has a wrong offset!");
static_assert(offsetof(FShopBuyTable, ShopListId) == 0x000004, "Member 'FShopBuyTable::ShopListId' has a wrong offset!");
static_assert(offsetof(FShopBuyTable, StartFlag1) == 0x000008, "Member 'FShopBuyTable::StartFlag1' has a wrong offset!");
static_assert(offsetof(FShopBuyTable, StartFlag2) == 0x00000C, "Member 'FShopBuyTable::StartFlag2' has a wrong offset!");
static_assert(offsetof(FShopBuyTable, EndFlag) == 0x000010, "Member 'FShopBuyTable::EndFlag' has a wrong offset!");

// ScriptStruct Project.FoliageHitEffectData
// 0x0010 (0x0010 - 0x0000)
struct FFoliageHitEffectData final
{
public:
	class UParticleSystem*                        Particle;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          SE;                                                // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFoliageHitEffectData) == 0x000008, "Wrong alignment on FFoliageHitEffectData");
static_assert(sizeof(FFoliageHitEffectData) == 0x000010, "Wrong size on FFoliageHitEffectData");
static_assert(offsetof(FFoliageHitEffectData, Particle) == 0x000000, "Member 'FFoliageHitEffectData::Particle' has a wrong offset!");
static_assert(offsetof(FFoliageHitEffectData, SE) == 0x000008, "Member 'FFoliageHitEffectData::SE' has a wrong offset!");

// ScriptStruct Project.MissionCondData
// 0x0010 (0x0010 - 0x0000)
struct FMissionCondData final
{
public:
	E_MISSION_COND_TYPE                           Type;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompleteOnFlag;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionCondData) == 0x000004, "Wrong alignment on FMissionCondData");
static_assert(sizeof(FMissionCondData) == 0x000010, "Wrong size on FMissionCondData");
static_assert(offsetof(FMissionCondData, Type) == 0x000000, "Member 'FMissionCondData::Type' has a wrong offset!");
static_assert(offsetof(FMissionCondData, ID) == 0x000004, "Member 'FMissionCondData::ID' has a wrong offset!");
static_assert(offsetof(FMissionCondData, Num) == 0x000008, "Member 'FMissionCondData::Num' has a wrong offset!");
static_assert(offsetof(FMissionCondData, CompleteOnFlag) == 0x00000C, "Member 'FMissionCondData::CompleteOnFlag' has a wrong offset!");

// ScriptStruct Project.FoliageMoveEffectData
// 0x0018 (0x0018 - 0x0000)
struct FFoliageMoveEffectData final
{
public:
	class USoundAtomCue*                          HitSE;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTallTree;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TreeHeight;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreeRadius;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoliageMoveEffectData) == 0x000008, "Wrong alignment on FFoliageMoveEffectData");
static_assert(sizeof(FFoliageMoveEffectData) == 0x000018, "Wrong size on FFoliageMoveEffectData");
static_assert(offsetof(FFoliageMoveEffectData, HitSE) == 0x000000, "Member 'FFoliageMoveEffectData::HitSE' has a wrong offset!");
static_assert(offsetof(FFoliageMoveEffectData, bIsTallTree) == 0x000008, "Member 'FFoliageMoveEffectData::bIsTallTree' has a wrong offset!");
static_assert(offsetof(FFoliageMoveEffectData, TreeHeight) == 0x00000C, "Member 'FFoliageMoveEffectData::TreeHeight' has a wrong offset!");
static_assert(offsetof(FFoliageMoveEffectData, TreeRadius) == 0x000010, "Member 'FFoliageMoveEffectData::TreeRadius' has a wrong offset!");

// ScriptStruct Project.ItemSaveData
// 0x0020 (0x0020 - 0x0000)
struct FItemSaveData final
{
public:
	TArray<uint8>                                 M_HaveItem;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_Get;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSaveData) == 0x000008, "Wrong alignment on FItemSaveData");
static_assert(sizeof(FItemSaveData) == 0x000020, "Wrong size on FItemSaveData");
static_assert(offsetof(FItemSaveData, M_HaveItem) == 0x000000, "Member 'FItemSaveData::M_HaveItem' has a wrong offset!");
static_assert(offsetof(FItemSaveData, M_Get) == 0x000010, "Member 'FItemSaveData::M_Get' has a wrong offset!");

// ScriptStruct Project.GardenUNQFlagData
// 0x0010 (0x0010 - 0x0000)
struct FGardenUNQFlagData final
{
public:
	TArray<uint8>                                 M_MessageTalkFlag;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenUNQFlagData) == 0x000008, "Wrong alignment on FGardenUNQFlagData");
static_assert(sizeof(FGardenUNQFlagData) == 0x000010, "Wrong size on FGardenUNQFlagData");
static_assert(offsetof(FGardenUNQFlagData, M_MessageTalkFlag) == 0x000000, "Member 'FGardenUNQFlagData::M_MessageTalkFlag' has a wrong offset!");

// ScriptStruct Project.MinimapFogGridOneMapData
// 0x0040 (0x0040 - 0x0000)
struct FMinimapFogGridOneMapData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_FOG_GRID_MAP_TYPE                   M_Type;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SaveId;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_MiniZoom;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_WorldDimensions;                                 // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             M_GridDimensions;                                  // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_OpenFlag;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapFogGridOneMapData) == 0x000008, "Wrong alignment on FMinimapFogGridOneMapData");
static_assert(sizeof(FMinimapFogGridOneMapData) == 0x000040, "Wrong size on FMinimapFogGridOneMapData");
static_assert(offsetof(FMinimapFogGridOneMapData, M_MapID) == 0x000000, "Member 'FMinimapFogGridOneMapData::M_MapID' has a wrong offset!");
static_assert(offsetof(FMinimapFogGridOneMapData, M_AreaId) == 0x000004, "Member 'FMinimapFogGridOneMapData::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMinimapFogGridOneMapData, M_Type) == 0x000008, "Member 'FMinimapFogGridOneMapData::M_Type' has a wrong offset!");
static_assert(offsetof(FMinimapFogGridOneMapData, M_SaveId) == 0x00000C, "Member 'FMinimapFogGridOneMapData::M_SaveId' has a wrong offset!");
static_assert(offsetof(FMinimapFogGridOneMapData, M_MiniZoom) == 0x000010, "Member 'FMinimapFogGridOneMapData::M_MiniZoom' has a wrong offset!");
static_assert(offsetof(FMinimapFogGridOneMapData, M_WorldDimensions) == 0x000014, "Member 'FMinimapFogGridOneMapData::M_WorldDimensions' has a wrong offset!");
static_assert(offsetof(FMinimapFogGridOneMapData, M_GridDimensions) == 0x000020, "Member 'FMinimapFogGridOneMapData::M_GridDimensions' has a wrong offset!");
static_assert(offsetof(FMinimapFogGridOneMapData, M_OpenFlag) == 0x000030, "Member 'FMinimapFogGridOneMapData::M_OpenFlag' has a wrong offset!");

// ScriptStruct Project.MapData
// 0x03A0 (0x03A0 - 0x0000)
struct FMapData final
{
public:
	int32                                         M_Type;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MapID;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AutoMapID;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             M_PlayerPos;                                       // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_TakaraFlag;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_TakaraBreakFlag;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_MinimapMaskOpenFlag;                             // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<E_MAGATSUKA_STATE>                     M_MagatsukaState;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_RyuketsuFlag;                                    // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_LastRyuketsuTableIndex;                          // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_AccessingRyuketsuSave;                           // 0x0094(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0xB];                                       // 0x0095(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_RyuketsuSaveTransform;                           // 0x00A0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_NaviDevilGimmickExistFlag;                       // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_NaviDevilGimmickUniqueSave;                      // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	E_NAVI_DEVIL                                  M_CurrentNaviDevilEnum;                            // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_NaviDevilGimmickCheckCounter;                    // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_ShinseiFlag;                                     // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_RelicFlag;                                       // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 M_RelicTimer;                                      // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_RelicUniqueSkillNum;                             // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RelicUniqueSkillCalcCounter;                     // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_OneRelicUniqueSkillRate;                         // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_RelicOnceFlag;                                   // 0x0138(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_RelicTableIndex;                                 // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_RelicGetIcon;                                    // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_RelicGetIconUpdate;                              // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_RelicGetCounter;                                 // 0x0178(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RelicSaveIDStart_CurrentMap;                     // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RelicSaveIDEnd_CurrentMap;                       // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_AogamiDebrisFlag;                                // 0x0188(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 M_AogamiDebrisTimer;                               // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_AogamiDebrisGetIcon;                             // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_AogamiDebrisGetIconUpdate;                       // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_AogamiDebrisGetCounter;                          // 0x01C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_MimanFlag;                                       // 0x01D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_MimanPositionFlag;                               // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_CoasterOpenFlag_Start;                           // 0x01F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_CoasterOpenFlag_End;                             // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x20];                                     // 0x0210(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_MapSymbolDeadFlag;                               // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_IsCustomMap;                                     // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_MapSymbolActors;                                 // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_MapSymbolSpawners;                               // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            M_MapSymbolParamIndex;                             // 0x0268(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         M_NearbySymbolCounter;                             // 0x02B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_NearbySymbolAfterBattle;                         // 0x02BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_MinimapIconShowFlag;                             // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_MinimapIconFogGridFlag;                          // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_CheckRyuketsuIDList;                             // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMapInfoData>                   M_WaitingMapInfo;                                  // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMinimapFogGridOneMapData>      M_FogGrid;                                         // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_MinimapIconHideFlag;                             // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_RyuketsuMinimapIconHideFlag;                     // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_RotatorRotateCountX;                             // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_RotatorRotateCountY;                             // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_TimeAttackMapId;                                 // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGardenSPTFlagData>             M_GardenSpeechTypeFlags;                           // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGardenUNQFlagData>             M_GardenUniqueDevilFlags;                          // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_GardenTributeCounter;                            // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GardenTrustCounter;                              // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_TopCameraHeight;                                 // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinimapLandmark                       M_Landmark;                                        // 0x037C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x14];                                     // 0x038C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapData) == 0x000010, "Wrong alignment on FMapData");
static_assert(sizeof(FMapData) == 0x0003A0, "Wrong size on FMapData");
static_assert(offsetof(FMapData, M_Type) == 0x000000, "Member 'FMapData::M_Type' has a wrong offset!");
static_assert(offsetof(FMapData, M_MapID) == 0x000004, "Member 'FMapData::M_MapID' has a wrong offset!");
static_assert(offsetof(FMapData, M_AreaId) == 0x000008, "Member 'FMapData::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMapData, M_AutoMapID) == 0x00000C, "Member 'FMapData::M_AutoMapID' has a wrong offset!");
static_assert(offsetof(FMapData, M_PlayerPos) == 0x000010, "Member 'FMapData::M_PlayerPos' has a wrong offset!");
static_assert(offsetof(FMapData, M_TakaraFlag) == 0x000040, "Member 'FMapData::M_TakaraFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_TakaraBreakFlag) == 0x000050, "Member 'FMapData::M_TakaraBreakFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_MinimapMaskOpenFlag) == 0x000060, "Member 'FMapData::M_MinimapMaskOpenFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_MagatsukaState) == 0x000070, "Member 'FMapData::M_MagatsukaState' has a wrong offset!");
static_assert(offsetof(FMapData, M_RyuketsuFlag) == 0x000080, "Member 'FMapData::M_RyuketsuFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_LastRyuketsuTableIndex) == 0x000090, "Member 'FMapData::M_LastRyuketsuTableIndex' has a wrong offset!");
static_assert(offsetof(FMapData, M_AccessingRyuketsuSave) == 0x000094, "Member 'FMapData::M_AccessingRyuketsuSave' has a wrong offset!");
static_assert(offsetof(FMapData, M_RyuketsuSaveTransform) == 0x0000A0, "Member 'FMapData::M_RyuketsuSaveTransform' has a wrong offset!");
static_assert(offsetof(FMapData, M_NaviDevilGimmickExistFlag) == 0x0000D0, "Member 'FMapData::M_NaviDevilGimmickExistFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_NaviDevilGimmickUniqueSave) == 0x0000E0, "Member 'FMapData::M_NaviDevilGimmickUniqueSave' has a wrong offset!");
static_assert(offsetof(FMapData, M_CurrentNaviDevilEnum) == 0x0000F0, "Member 'FMapData::M_CurrentNaviDevilEnum' has a wrong offset!");
static_assert(offsetof(FMapData, M_NaviDevilGimmickCheckCounter) == 0x0000F4, "Member 'FMapData::M_NaviDevilGimmickCheckCounter' has a wrong offset!");
static_assert(offsetof(FMapData, M_ShinseiFlag) == 0x0000F8, "Member 'FMapData::M_ShinseiFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicFlag) == 0x000108, "Member 'FMapData::M_RelicFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicTimer) == 0x000118, "Member 'FMapData::M_RelicTimer' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicUniqueSkillNum) == 0x000128, "Member 'FMapData::M_RelicUniqueSkillNum' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicUniqueSkillCalcCounter) == 0x00012C, "Member 'FMapData::M_RelicUniqueSkillCalcCounter' has a wrong offset!");
static_assert(offsetof(FMapData, M_OneRelicUniqueSkillRate) == 0x000130, "Member 'FMapData::M_OneRelicUniqueSkillRate' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicOnceFlag) == 0x000138, "Member 'FMapData::M_RelicOnceFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicTableIndex) == 0x000148, "Member 'FMapData::M_RelicTableIndex' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicGetIcon) == 0x000158, "Member 'FMapData::M_RelicGetIcon' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicGetIconUpdate) == 0x000168, "Member 'FMapData::M_RelicGetIconUpdate' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicGetCounter) == 0x000178, "Member 'FMapData::M_RelicGetCounter' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicSaveIDStart_CurrentMap) == 0x00017C, "Member 'FMapData::M_RelicSaveIDStart_CurrentMap' has a wrong offset!");
static_assert(offsetof(FMapData, M_RelicSaveIDEnd_CurrentMap) == 0x000180, "Member 'FMapData::M_RelicSaveIDEnd_CurrentMap' has a wrong offset!");
static_assert(offsetof(FMapData, M_AogamiDebrisFlag) == 0x000188, "Member 'FMapData::M_AogamiDebrisFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_AogamiDebrisTimer) == 0x000198, "Member 'FMapData::M_AogamiDebrisTimer' has a wrong offset!");
static_assert(offsetof(FMapData, M_AogamiDebrisGetIcon) == 0x0001A8, "Member 'FMapData::M_AogamiDebrisGetIcon' has a wrong offset!");
static_assert(offsetof(FMapData, M_AogamiDebrisGetIconUpdate) == 0x0001B8, "Member 'FMapData::M_AogamiDebrisGetIconUpdate' has a wrong offset!");
static_assert(offsetof(FMapData, M_AogamiDebrisGetCounter) == 0x0001C8, "Member 'FMapData::M_AogamiDebrisGetCounter' has a wrong offset!");
static_assert(offsetof(FMapData, M_MimanFlag) == 0x0001D0, "Member 'FMapData::M_MimanFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_MimanPositionFlag) == 0x0001E0, "Member 'FMapData::M_MimanPositionFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_CoasterOpenFlag_Start) == 0x0001F0, "Member 'FMapData::M_CoasterOpenFlag_Start' has a wrong offset!");
static_assert(offsetof(FMapData, M_CoasterOpenFlag_End) == 0x000200, "Member 'FMapData::M_CoasterOpenFlag_End' has a wrong offset!");
static_assert(offsetof(FMapData, M_MapSymbolDeadFlag) == 0x000230, "Member 'FMapData::M_MapSymbolDeadFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_IsCustomMap) == 0x000240, "Member 'FMapData::M_IsCustomMap' has a wrong offset!");
static_assert(offsetof(FMapData, M_MapSymbolActors) == 0x000248, "Member 'FMapData::M_MapSymbolActors' has a wrong offset!");
static_assert(offsetof(FMapData, M_MapSymbolSpawners) == 0x000258, "Member 'FMapData::M_MapSymbolSpawners' has a wrong offset!");
static_assert(offsetof(FMapData, M_MapSymbolParamIndex) == 0x000268, "Member 'FMapData::M_MapSymbolParamIndex' has a wrong offset!");
static_assert(offsetof(FMapData, M_NearbySymbolCounter) == 0x0002B8, "Member 'FMapData::M_NearbySymbolCounter' has a wrong offset!");
static_assert(offsetof(FMapData, M_NearbySymbolAfterBattle) == 0x0002BC, "Member 'FMapData::M_NearbySymbolAfterBattle' has a wrong offset!");
static_assert(offsetof(FMapData, M_MinimapIconShowFlag) == 0x0002C0, "Member 'FMapData::M_MinimapIconShowFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_MinimapIconFogGridFlag) == 0x0002D0, "Member 'FMapData::M_MinimapIconFogGridFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_CheckRyuketsuIDList) == 0x0002E0, "Member 'FMapData::M_CheckRyuketsuIDList' has a wrong offset!");
static_assert(offsetof(FMapData, M_WaitingMapInfo) == 0x0002F0, "Member 'FMapData::M_WaitingMapInfo' has a wrong offset!");
static_assert(offsetof(FMapData, M_FogGrid) == 0x000300, "Member 'FMapData::M_FogGrid' has a wrong offset!");
static_assert(offsetof(FMapData, M_MinimapIconHideFlag) == 0x000310, "Member 'FMapData::M_MinimapIconHideFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_RyuketsuMinimapIconHideFlag) == 0x000320, "Member 'FMapData::M_RyuketsuMinimapIconHideFlag' has a wrong offset!");
static_assert(offsetof(FMapData, M_RotatorRotateCountX) == 0x000328, "Member 'FMapData::M_RotatorRotateCountX' has a wrong offset!");
static_assert(offsetof(FMapData, M_RotatorRotateCountY) == 0x000338, "Member 'FMapData::M_RotatorRotateCountY' has a wrong offset!");
static_assert(offsetof(FMapData, M_TimeAttackMapId) == 0x000348, "Member 'FMapData::M_TimeAttackMapId' has a wrong offset!");
static_assert(offsetof(FMapData, M_GardenSpeechTypeFlags) == 0x000350, "Member 'FMapData::M_GardenSpeechTypeFlags' has a wrong offset!");
static_assert(offsetof(FMapData, M_GardenUniqueDevilFlags) == 0x000360, "Member 'FMapData::M_GardenUniqueDevilFlags' has a wrong offset!");
static_assert(offsetof(FMapData, M_GardenTributeCounter) == 0x000370, "Member 'FMapData::M_GardenTributeCounter' has a wrong offset!");
static_assert(offsetof(FMapData, M_GardenTrustCounter) == 0x000374, "Member 'FMapData::M_GardenTrustCounter' has a wrong offset!");
static_assert(offsetof(FMapData, M_TopCameraHeight) == 0x000378, "Member 'FMapData::M_TopCameraHeight' has a wrong offset!");
static_assert(offsetof(FMapData, M_Landmark) == 0x00037C, "Member 'FMapData::M_Landmark' has a wrong offset!");

// ScriptStruct Project.PropertySaveData
// 0x0010 (0x0010 - 0x0000)
struct FPropertySaveData final
{
public:
	TArray<uint8>                                 M_PropertyData;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropertySaveData) == 0x000008, "Wrong alignment on FPropertySaveData");
static_assert(sizeof(FPropertySaveData) == 0x000010, "Wrong size on FPropertySaveData");
static_assert(offsetof(FPropertySaveData, M_PropertyData) == 0x000000, "Member 'FPropertySaveData::M_PropertyData' has a wrong offset!");

// ScriptStruct Project.UniteSaveData
// 0x0028 (0x0028 - 0x0000)
struct FUniteSaveData final
{
public:
	TArray<uint8>                                 M_MenuNewFlags;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_AnnounceFlags;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         M_UtsusemiUnionCounter;                            // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniteSaveData) == 0x000008, "Wrong alignment on FUniteSaveData");
static_assert(sizeof(FUniteSaveData) == 0x000028, "Wrong size on FUniteSaveData");
static_assert(offsetof(FUniteSaveData, M_MenuNewFlags) == 0x000000, "Member 'FUniteSaveData::M_MenuNewFlags' has a wrong offset!");
static_assert(offsetof(FUniteSaveData, M_AnnounceFlags) == 0x000010, "Member 'FUniteSaveData::M_AnnounceFlags' has a wrong offset!");
static_assert(offsetof(FUniteSaveData, M_UtsusemiUnionCounter) == 0x000020, "Member 'FUniteSaveData::M_UtsusemiUnionCounter' has a wrong offset!");

// ScriptStruct Project.ActionKeyConfigSaveData
// 0x000C (0x000C - 0x0000)
struct FActionKeyConfigSaveData final
{
public:
	int32                                         M_KeyIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ActionMappingType;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Change;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionKeyConfigSaveData) == 0x000004, "Wrong alignment on FActionKeyConfigSaveData");
static_assert(sizeof(FActionKeyConfigSaveData) == 0x00000C, "Wrong size on FActionKeyConfigSaveData");
static_assert(offsetof(FActionKeyConfigSaveData, M_KeyIndex) == 0x000000, "Member 'FActionKeyConfigSaveData::M_KeyIndex' has a wrong offset!");
static_assert(offsetof(FActionKeyConfigSaveData, M_ActionMappingType) == 0x000004, "Member 'FActionKeyConfigSaveData::M_ActionMappingType' has a wrong offset!");
static_assert(offsetof(FActionKeyConfigSaveData, M_Change) == 0x000008, "Member 'FActionKeyConfigSaveData::M_Change' has a wrong offset!");

// ScriptStruct Project.SystemData
// 0x00F8 (0x00F8 - 0x0000)
struct FSystemData final
{
public:
	int32                                         M_BattleTempo;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsAutoSaveOn;                                    // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_MasterVolume;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_BGMVolume;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EnvVolume;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_SEVolume;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_VoiceVolume;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_VoiceLanguage;                                   // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ControllerVibration;                             // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_CameraSpeed;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_CameraReverseLR;                                 // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_CameraReverseUD;                                 // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_CameraAutoCentering;                             // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_CameraInputLR;                                   // 0x0027(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Difficulty;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_TotalPlayTimeSec;                                // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_LastSelectSlotIndex;                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MessageSpeedType;                                // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MoveDisplayMinimap;                              // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MoveDisplayPanel;                                // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MoveDisplayOther;                                // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_FontSizeOffset;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BattleCursorPosition;                            // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AutoBattle;                                      // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkillDisplayPanel;                               // 0x003E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkillShortening;                                 // 0x003F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActionKeyConfigSaveData>       M_GamepadActionKeyconfig;                          // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAxisKeyConfigSaveData>         M_GamepadAxisKeyconfig;                            // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActionKeyConfigSaveData>       M_KeyboardActionKeyconfig;                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAxisKeyConfigSaveData>         M_KeyboardAxisKeyconfig;                           // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_ActionMappingMax;                                // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AxisMappingMax;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x4];                                       // 0x0088(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         M_StrictTricks;                                    // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MakkaTricks;                                     // 0x008D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ExperienceTricks;                                // 0x008E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F[0x1];                                       // 0x008F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_DlcEnableFlag;                                   // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_AnnouncedDlcEnableFlag;                          // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         M_CameraCtrlSpeed;                                 // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MessageAutoMaintain;                             // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MovieSubtitleType;                               // 0x00B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_StickSensitivity;                                // 0x00B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MouseSensitivity;                                // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_DecideControlType;                               // 0x00B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MoviewSkipType;                                  // 0x00B6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ButtonIconType;                                  // 0x00B7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_LoadGamePause;                                   // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_FOVType;                                         // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MoveMagatsuhiGauge;                              // 0x00BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_RotateMiniMap;                                   // 0x00BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_FieldPushLStick;                                 // 0x00BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_FieldPushRStick;                                 // 0x00BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_EstomaConfirm;                                   // 0x00BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NearbyObjectVisibility;                          // 0x00BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BattleItemSortType;                              // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AutoBattleType;                                  // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkillSpeedNormal;                                // 0x00C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkillSpeedAuto;                                  // 0x00C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkillSpeedDecide;                                // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_DisplayBrightness;                               // 0x00C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Brightness;                                      // 0x00C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AmbientOcclusion;                                // 0x00C7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MotionBlur;                                      // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Antialiasing;                                    // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_DisplaySelection;                                // 0x00CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ScreenMode;                                      // 0x00CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              M_WindowResolution;                                // 0x00CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              M_FullscreenResolution;                            // 0x00D4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_VSync;                                           // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_FrameRate;                                       // 0x00DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x1A];                                      // 0x00DE(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSystemData) == 0x000008, "Wrong alignment on FSystemData");
static_assert(sizeof(FSystemData) == 0x0000F8, "Wrong size on FSystemData");
static_assert(offsetof(FSystemData, M_BattleTempo) == 0x000000, "Member 'FSystemData::M_BattleTempo' has a wrong offset!");
static_assert(offsetof(FSystemData, M_IsAutoSaveOn) == 0x000004, "Member 'FSystemData::M_IsAutoSaveOn' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MasterVolume) == 0x000008, "Member 'FSystemData::M_MasterVolume' has a wrong offset!");
static_assert(offsetof(FSystemData, M_BGMVolume) == 0x00000C, "Member 'FSystemData::M_BGMVolume' has a wrong offset!");
static_assert(offsetof(FSystemData, M_EnvVolume) == 0x000010, "Member 'FSystemData::M_EnvVolume' has a wrong offset!");
static_assert(offsetof(FSystemData, M_SEVolume) == 0x000014, "Member 'FSystemData::M_SEVolume' has a wrong offset!");
static_assert(offsetof(FSystemData, M_VoiceVolume) == 0x000018, "Member 'FSystemData::M_VoiceVolume' has a wrong offset!");
static_assert(offsetof(FSystemData, M_VoiceLanguage) == 0x00001C, "Member 'FSystemData::M_VoiceLanguage' has a wrong offset!");
static_assert(offsetof(FSystemData, M_ControllerVibration) == 0x00001D, "Member 'FSystemData::M_ControllerVibration' has a wrong offset!");
static_assert(offsetof(FSystemData, M_CameraSpeed) == 0x000020, "Member 'FSystemData::M_CameraSpeed' has a wrong offset!");
static_assert(offsetof(FSystemData, M_CameraReverseLR) == 0x000024, "Member 'FSystemData::M_CameraReverseLR' has a wrong offset!");
static_assert(offsetof(FSystemData, M_CameraReverseUD) == 0x000025, "Member 'FSystemData::M_CameraReverseUD' has a wrong offset!");
static_assert(offsetof(FSystemData, M_CameraAutoCentering) == 0x000026, "Member 'FSystemData::M_CameraAutoCentering' has a wrong offset!");
static_assert(offsetof(FSystemData, M_CameraInputLR) == 0x000027, "Member 'FSystemData::M_CameraInputLR' has a wrong offset!");
static_assert(offsetof(FSystemData, M_Difficulty) == 0x000028, "Member 'FSystemData::M_Difficulty' has a wrong offset!");
static_assert(offsetof(FSystemData, M_TotalPlayTimeSec) == 0x00002C, "Member 'FSystemData::M_TotalPlayTimeSec' has a wrong offset!");
static_assert(offsetof(FSystemData, M_LastSelectSlotIndex) == 0x000030, "Member 'FSystemData::M_LastSelectSlotIndex' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MessageSpeedType) == 0x000031, "Member 'FSystemData::M_MessageSpeedType' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MoveDisplayMinimap) == 0x000032, "Member 'FSystemData::M_MoveDisplayMinimap' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MoveDisplayPanel) == 0x000033, "Member 'FSystemData::M_MoveDisplayPanel' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MoveDisplayOther) == 0x000034, "Member 'FSystemData::M_MoveDisplayOther' has a wrong offset!");
static_assert(offsetof(FSystemData, M_FontSizeOffset) == 0x000038, "Member 'FSystemData::M_FontSizeOffset' has a wrong offset!");
static_assert(offsetof(FSystemData, M_BattleCursorPosition) == 0x00003C, "Member 'FSystemData::M_BattleCursorPosition' has a wrong offset!");
static_assert(offsetof(FSystemData, M_AutoBattle) == 0x00003D, "Member 'FSystemData::M_AutoBattle' has a wrong offset!");
static_assert(offsetof(FSystemData, M_SkillDisplayPanel) == 0x00003E, "Member 'FSystemData::M_SkillDisplayPanel' has a wrong offset!");
static_assert(offsetof(FSystemData, M_SkillShortening) == 0x00003F, "Member 'FSystemData::M_SkillShortening' has a wrong offset!");
static_assert(offsetof(FSystemData, M_GamepadActionKeyconfig) == 0x000040, "Member 'FSystemData::M_GamepadActionKeyconfig' has a wrong offset!");
static_assert(offsetof(FSystemData, M_GamepadAxisKeyconfig) == 0x000050, "Member 'FSystemData::M_GamepadAxisKeyconfig' has a wrong offset!");
static_assert(offsetof(FSystemData, M_KeyboardActionKeyconfig) == 0x000060, "Member 'FSystemData::M_KeyboardActionKeyconfig' has a wrong offset!");
static_assert(offsetof(FSystemData, M_KeyboardAxisKeyconfig) == 0x000070, "Member 'FSystemData::M_KeyboardAxisKeyconfig' has a wrong offset!");
static_assert(offsetof(FSystemData, M_ActionMappingMax) == 0x000080, "Member 'FSystemData::M_ActionMappingMax' has a wrong offset!");
static_assert(offsetof(FSystemData, M_AxisMappingMax) == 0x000084, "Member 'FSystemData::M_AxisMappingMax' has a wrong offset!");
static_assert(offsetof(FSystemData, M_StrictTricks) == 0x00008C, "Member 'FSystemData::M_StrictTricks' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MakkaTricks) == 0x00008D, "Member 'FSystemData::M_MakkaTricks' has a wrong offset!");
static_assert(offsetof(FSystemData, M_ExperienceTricks) == 0x00008E, "Member 'FSystemData::M_ExperienceTricks' has a wrong offset!");
static_assert(offsetof(FSystemData, M_DlcEnableFlag) == 0x000090, "Member 'FSystemData::M_DlcEnableFlag' has a wrong offset!");
static_assert(offsetof(FSystemData, M_AnnouncedDlcEnableFlag) == 0x0000A0, "Member 'FSystemData::M_AnnouncedDlcEnableFlag' has a wrong offset!");
static_assert(offsetof(FSystemData, M_CameraCtrlSpeed) == 0x0000B0, "Member 'FSystemData::M_CameraCtrlSpeed' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MessageAutoMaintain) == 0x0000B1, "Member 'FSystemData::M_MessageAutoMaintain' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MovieSubtitleType) == 0x0000B2, "Member 'FSystemData::M_MovieSubtitleType' has a wrong offset!");
static_assert(offsetof(FSystemData, M_StickSensitivity) == 0x0000B3, "Member 'FSystemData::M_StickSensitivity' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MouseSensitivity) == 0x0000B4, "Member 'FSystemData::M_MouseSensitivity' has a wrong offset!");
static_assert(offsetof(FSystemData, M_DecideControlType) == 0x0000B5, "Member 'FSystemData::M_DecideControlType' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MoviewSkipType) == 0x0000B6, "Member 'FSystemData::M_MoviewSkipType' has a wrong offset!");
static_assert(offsetof(FSystemData, M_ButtonIconType) == 0x0000B7, "Member 'FSystemData::M_ButtonIconType' has a wrong offset!");
static_assert(offsetof(FSystemData, M_LoadGamePause) == 0x0000B8, "Member 'FSystemData::M_LoadGamePause' has a wrong offset!");
static_assert(offsetof(FSystemData, M_FOVType) == 0x0000B9, "Member 'FSystemData::M_FOVType' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MoveMagatsuhiGauge) == 0x0000BA, "Member 'FSystemData::M_MoveMagatsuhiGauge' has a wrong offset!");
static_assert(offsetof(FSystemData, M_RotateMiniMap) == 0x0000BB, "Member 'FSystemData::M_RotateMiniMap' has a wrong offset!");
static_assert(offsetof(FSystemData, M_FieldPushLStick) == 0x0000BC, "Member 'FSystemData::M_FieldPushLStick' has a wrong offset!");
static_assert(offsetof(FSystemData, M_FieldPushRStick) == 0x0000BD, "Member 'FSystemData::M_FieldPushRStick' has a wrong offset!");
static_assert(offsetof(FSystemData, M_EstomaConfirm) == 0x0000BE, "Member 'FSystemData::M_EstomaConfirm' has a wrong offset!");
static_assert(offsetof(FSystemData, M_NearbyObjectVisibility) == 0x0000BF, "Member 'FSystemData::M_NearbyObjectVisibility' has a wrong offset!");
static_assert(offsetof(FSystemData, M_BattleItemSortType) == 0x0000C0, "Member 'FSystemData::M_BattleItemSortType' has a wrong offset!");
static_assert(offsetof(FSystemData, M_AutoBattleType) == 0x0000C1, "Member 'FSystemData::M_AutoBattleType' has a wrong offset!");
static_assert(offsetof(FSystemData, M_SkillSpeedNormal) == 0x0000C2, "Member 'FSystemData::M_SkillSpeedNormal' has a wrong offset!");
static_assert(offsetof(FSystemData, M_SkillSpeedAuto) == 0x0000C3, "Member 'FSystemData::M_SkillSpeedAuto' has a wrong offset!");
static_assert(offsetof(FSystemData, M_SkillSpeedDecide) == 0x0000C4, "Member 'FSystemData::M_SkillSpeedDecide' has a wrong offset!");
static_assert(offsetof(FSystemData, M_DisplayBrightness) == 0x0000C5, "Member 'FSystemData::M_DisplayBrightness' has a wrong offset!");
static_assert(offsetof(FSystemData, M_Brightness) == 0x0000C6, "Member 'FSystemData::M_Brightness' has a wrong offset!");
static_assert(offsetof(FSystemData, M_AmbientOcclusion) == 0x0000C7, "Member 'FSystemData::M_AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(FSystemData, M_MotionBlur) == 0x0000C8, "Member 'FSystemData::M_MotionBlur' has a wrong offset!");
static_assert(offsetof(FSystemData, M_Antialiasing) == 0x0000C9, "Member 'FSystemData::M_Antialiasing' has a wrong offset!");
static_assert(offsetof(FSystemData, M_DisplaySelection) == 0x0000CA, "Member 'FSystemData::M_DisplaySelection' has a wrong offset!");
static_assert(offsetof(FSystemData, M_ScreenMode) == 0x0000CB, "Member 'FSystemData::M_ScreenMode' has a wrong offset!");
static_assert(offsetof(FSystemData, M_WindowResolution) == 0x0000CC, "Member 'FSystemData::M_WindowResolution' has a wrong offset!");
static_assert(offsetof(FSystemData, M_FullscreenResolution) == 0x0000D4, "Member 'FSystemData::M_FullscreenResolution' has a wrong offset!");
static_assert(offsetof(FSystemData, M_VSync) == 0x0000DC, "Member 'FSystemData::M_VSync' has a wrong offset!");
static_assert(offsetof(FSystemData, M_FrameRate) == 0x0000DD, "Member 'FSystemData::M_FrameRate' has a wrong offset!");

// ScriptStruct Project.EventSave
// 0x0004 (0x0004 - 0x0000)
struct FEventSave final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventSave) == 0x000001, "Wrong alignment on FEventSave");
static_assert(sizeof(FEventSave) == 0x000004, "Wrong size on FEventSave");

// ScriptStruct Project.TutorialSaveData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FTutorialSaveData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialSaveData) == 0x000008, "Wrong alignment on FTutorialSaveData");
static_assert(sizeof(FTutorialSaveData) == 0x000010, "Wrong size on FTutorialSaveData");

// ScriptStruct Project.PieceSaveData
// 0x0020 (0x0020 - 0x0000)
struct FPieceSaveData final
{
public:
	TArray<int32>                                 M_PieceHaveNum;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  M_PieceHaveFlag;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPieceSaveData) == 0x000008, "Wrong alignment on FPieceSaveData");
static_assert(sizeof(FPieceSaveData) == 0x000020, "Wrong size on FPieceSaveData");
static_assert(offsetof(FPieceSaveData, M_PieceHaveNum) == 0x000000, "Member 'FPieceSaveData::M_PieceHaveNum' has a wrong offset!");
static_assert(offsetof(FPieceSaveData, M_PieceHaveFlag) == 0x000010, "Member 'FPieceSaveData::M_PieceHaveFlag' has a wrong offset!");

// ScriptStruct Project.TalkDevilSaveData
// 0x000C (0x000C - 0x0000)
struct FTalkDevilSaveData final
{
public:
	E_TALK_WANT_KIND                              M_TalkWantWait;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_TalkLevelWait;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_TalkStockWait;                                   // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_TalkApologyWait;                                 // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TalkWantWaitValue;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TalkQuizCount;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkDevilSaveData) == 0x000004, "Wrong alignment on FTalkDevilSaveData");
static_assert(sizeof(FTalkDevilSaveData) == 0x00000C, "Wrong size on FTalkDevilSaveData");
static_assert(offsetof(FTalkDevilSaveData, M_TalkWantWait) == 0x000000, "Member 'FTalkDevilSaveData::M_TalkWantWait' has a wrong offset!");
static_assert(offsetof(FTalkDevilSaveData, M_TalkLevelWait) == 0x000001, "Member 'FTalkDevilSaveData::M_TalkLevelWait' has a wrong offset!");
static_assert(offsetof(FTalkDevilSaveData, M_TalkStockWait) == 0x000002, "Member 'FTalkDevilSaveData::M_TalkStockWait' has a wrong offset!");
static_assert(offsetof(FTalkDevilSaveData, M_TalkApologyWait) == 0x000003, "Member 'FTalkDevilSaveData::M_TalkApologyWait' has a wrong offset!");
static_assert(offsetof(FTalkDevilSaveData, M_TalkWantWaitValue) == 0x000004, "Member 'FTalkDevilSaveData::M_TalkWantWaitValue' has a wrong offset!");
static_assert(offsetof(FTalkDevilSaveData, M_TalkQuizCount) == 0x000008, "Member 'FTalkDevilSaveData::M_TalkQuizCount' has a wrong offset!");

// ScriptStruct Project.TalkToneSaveData
// 0x0004 (0x0004 - 0x0000)
struct FTalkToneSaveData final
{
public:
	int32                                         M_LastTopicID;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkToneSaveData) == 0x000004, "Wrong alignment on FTalkToneSaveData");
static_assert(sizeof(FTalkToneSaveData) == 0x000004, "Wrong size on FTalkToneSaveData");
static_assert(offsetof(FTalkToneSaveData, M_LastTopicID) == 0x000000, "Member 'FTalkToneSaveData::M_LastTopicID' has a wrong offset!");

// ScriptStruct Project.TalkSaveData
// 0x0040 (0x0040 - 0x0000)
struct FTalkSaveData final
{
public:
	TArray<struct FTalkDevilSaveData>             M_DevilData;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTalkToneSaveData>              M_ToneData;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_MythHappenedFlag;                                // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_QuizNotCount;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ScoutSuccessCount;                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PaidMoneyTotal;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkSaveData) == 0x000008, "Wrong alignment on FTalkSaveData");
static_assert(sizeof(FTalkSaveData) == 0x000040, "Wrong size on FTalkSaveData");
static_assert(offsetof(FTalkSaveData, M_DevilData) == 0x000000, "Member 'FTalkSaveData::M_DevilData' has a wrong offset!");
static_assert(offsetof(FTalkSaveData, M_ToneData) == 0x000010, "Member 'FTalkSaveData::M_ToneData' has a wrong offset!");
static_assert(offsetof(FTalkSaveData, M_MythHappenedFlag) == 0x000020, "Member 'FTalkSaveData::M_MythHappenedFlag' has a wrong offset!");
static_assert(offsetof(FTalkSaveData, M_QuizNotCount) == 0x000030, "Member 'FTalkSaveData::M_QuizNotCount' has a wrong offset!");
static_assert(offsetof(FTalkSaveData, M_ScoutSuccessCount) == 0x000034, "Member 'FTalkSaveData::M_ScoutSuccessCount' has a wrong offset!");
static_assert(offsetof(FTalkSaveData, M_PaidMoneyTotal) == 0x000038, "Member 'FTalkSaveData::M_PaidMoneyTotal' has a wrong offset!");

// ScriptStruct Project.UISystemData
// 0x0130 (0x0130 - 0x0000)
struct alignas(0x08) FUISystemData final
{
public:
	int32                                         M_sUIListSpeedType;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_sUtsusemiSortSkillId;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUtsusemiSortUnusedOffFlag;                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x127];                                      // 0x0009(0x0127)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUISystemData) == 0x000008, "Wrong alignment on FUISystemData");
static_assert(sizeof(FUISystemData) == 0x000130, "Wrong size on FUISystemData");
static_assert(offsetof(FUISystemData, M_sUIListSpeedType) == 0x000000, "Member 'FUISystemData::M_sUIListSpeedType' has a wrong offset!");
static_assert(offsetof(FUISystemData, M_sUtsusemiSortSkillId) == 0x000004, "Member 'FUISystemData::M_sUtsusemiSortSkillId' has a wrong offset!");
static_assert(offsetof(FUISystemData, M_bUtsusemiSortUnusedOffFlag) == 0x000008, "Member 'FUISystemData::M_bUtsusemiSortUnusedOffFlag' has a wrong offset!");

// ScriptStruct Project.GameData
// 0x0990 (0x0990 - 0x0000)
struct FGameData final
{
public:
	struct FPartyData                             M_Party;                                           // 0x0000(0x0168)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FItemSaveData                          M_Item;                                            // 0x0168(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSkillMasterData                       M_SkillMasterData;                                 // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPropertySaveData                      M_PropertySaveData;                                // 0x0198(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         M_TotalPlayTimeSec;                                // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMapData                               M_Map;                                             // 0x01B0(0x03A0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBattleData                            M_BattleData;                                      // 0x0550(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniteSaveData                         M_UniteSaveData;                                   // 0x0560(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBibleSaveData                         M_BibleSaveData;                                   // 0x0588(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFacilitySaveData                      M_FacilitySaveData;                                // 0x0598(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMissionSaveData                       M_MissionSaveData;                                 // 0x05E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSystemData                            M_SystemData;                                      // 0x05F8(0x00F8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDataBase                              M_DataBase;                                        // 0x06F0(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	E_MOON_AGE                                    M_MoonAge;                                         // 0x07D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D1[0x3];                                      // 0x07D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_MoonAgeCounter;                                  // 0x07D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTutorialSaveData                      M_TutorialData;                                    // 0x07D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPieceSaveData                         M_PieceSaveData;                                   // 0x07E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTalkSaveData                          M_TalkSaveData;                                    // 0x0808(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEventSave                             M_EventSaveData;                                   // 0x0848(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84C[0x4];                                      // 0x084C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUISystemData                          M_UISystemData;                                    // 0x0850(0x0130)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	E_OldNewRoute                                 M_OldNewRoute;                                     // 0x0980(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActivityTaskID                               M_ProgressActivityID;                              // 0x0981(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActivityType                                 M_ActivityCardType;                                // 0x0982(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_983[0xD];                                      // 0x0983(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameData) == 0x000010, "Wrong alignment on FGameData");
static_assert(sizeof(FGameData) == 0x000990, "Wrong size on FGameData");
static_assert(offsetof(FGameData, M_Party) == 0x000000, "Member 'FGameData::M_Party' has a wrong offset!");
static_assert(offsetof(FGameData, M_Item) == 0x000168, "Member 'FGameData::M_Item' has a wrong offset!");
static_assert(offsetof(FGameData, M_SkillMasterData) == 0x000188, "Member 'FGameData::M_SkillMasterData' has a wrong offset!");
static_assert(offsetof(FGameData, M_PropertySaveData) == 0x000198, "Member 'FGameData::M_PropertySaveData' has a wrong offset!");
static_assert(offsetof(FGameData, M_TotalPlayTimeSec) == 0x0001A8, "Member 'FGameData::M_TotalPlayTimeSec' has a wrong offset!");
static_assert(offsetof(FGameData, M_Map) == 0x0001B0, "Member 'FGameData::M_Map' has a wrong offset!");
static_assert(offsetof(FGameData, M_BattleData) == 0x000550, "Member 'FGameData::M_BattleData' has a wrong offset!");
static_assert(offsetof(FGameData, M_UniteSaveData) == 0x000560, "Member 'FGameData::M_UniteSaveData' has a wrong offset!");
static_assert(offsetof(FGameData, M_BibleSaveData) == 0x000588, "Member 'FGameData::M_BibleSaveData' has a wrong offset!");
static_assert(offsetof(FGameData, M_FacilitySaveData) == 0x000598, "Member 'FGameData::M_FacilitySaveData' has a wrong offset!");
static_assert(offsetof(FGameData, M_MissionSaveData) == 0x0005E8, "Member 'FGameData::M_MissionSaveData' has a wrong offset!");
static_assert(offsetof(FGameData, M_SystemData) == 0x0005F8, "Member 'FGameData::M_SystemData' has a wrong offset!");
static_assert(offsetof(FGameData, M_DataBase) == 0x0006F0, "Member 'FGameData::M_DataBase' has a wrong offset!");
static_assert(offsetof(FGameData, M_MoonAge) == 0x0007D0, "Member 'FGameData::M_MoonAge' has a wrong offset!");
static_assert(offsetof(FGameData, M_MoonAgeCounter) == 0x0007D4, "Member 'FGameData::M_MoonAgeCounter' has a wrong offset!");
static_assert(offsetof(FGameData, M_TutorialData) == 0x0007D8, "Member 'FGameData::M_TutorialData' has a wrong offset!");
static_assert(offsetof(FGameData, M_PieceSaveData) == 0x0007E8, "Member 'FGameData::M_PieceSaveData' has a wrong offset!");
static_assert(offsetof(FGameData, M_TalkSaveData) == 0x000808, "Member 'FGameData::M_TalkSaveData' has a wrong offset!");
static_assert(offsetof(FGameData, M_EventSaveData) == 0x000848, "Member 'FGameData::M_EventSaveData' has a wrong offset!");
static_assert(offsetof(FGameData, M_UISystemData) == 0x000850, "Member 'FGameData::M_UISystemData' has a wrong offset!");
static_assert(offsetof(FGameData, M_OldNewRoute) == 0x000980, "Member 'FGameData::M_OldNewRoute' has a wrong offset!");
static_assert(offsetof(FGameData, M_ProgressActivityID) == 0x000981, "Member 'FGameData::M_ProgressActivityID' has a wrong offset!");
static_assert(offsetof(FGameData, M_ActivityCardType) == 0x000982, "Member 'FGameData::M_ActivityCardType' has a wrong offset!");

// ScriptStruct Project.NaviDevilGimmickItemData
// 0x0018 (0x0018 - 0x0000)
struct FNaviDevilGimmickItemData final
{
public:
	bool                                          M_IsItem;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsMakka;                                         // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ItemID;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Num;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RandomNum;                                       // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Rate;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OnFlag;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNaviDevilGimmickItemData) == 0x000004, "Wrong alignment on FNaviDevilGimmickItemData");
static_assert(sizeof(FNaviDevilGimmickItemData) == 0x000018, "Wrong size on FNaviDevilGimmickItemData");
static_assert(offsetof(FNaviDevilGimmickItemData, M_IsItem) == 0x000000, "Member 'FNaviDevilGimmickItemData::M_IsItem' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickItemData, M_IsMakka) == 0x000001, "Member 'FNaviDevilGimmickItemData::M_IsMakka' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickItemData, M_ItemID) == 0x000004, "Member 'FNaviDevilGimmickItemData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickItemData, M_Num) == 0x000008, "Member 'FNaviDevilGimmickItemData::M_Num' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickItemData, M_RandomNum) == 0x00000C, "Member 'FNaviDevilGimmickItemData::M_RandomNum' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickItemData, M_Rate) == 0x000010, "Member 'FNaviDevilGimmickItemData::M_Rate' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickItemData, M_OnFlag) == 0x000014, "Member 'FNaviDevilGimmickItemData::M_OnFlag' has a wrong offset!");

// ScriptStruct Project.PartnerActData
// 0x0008 (0x0008 - 0x0000)
struct FPartnerActData final
{
public:
	int32                                         M_ActCategory;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Timing;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartnerActData) == 0x000004, "Wrong alignment on FPartnerActData");
static_assert(sizeof(FPartnerActData) == 0x000008, "Wrong size on FPartnerActData");
static_assert(offsetof(FPartnerActData, M_ActCategory) == 0x000000, "Member 'FPartnerActData::M_ActCategory' has a wrong offset!");
static_assert(offsetof(FPartnerActData, M_Timing) == 0x000004, "Member 'FPartnerActData::M_Timing' has a wrong offset!");

// ScriptStruct Project.EquipData
// 0x0010 (0x0010 - 0x0000)
struct FEquipData final
{
public:
	int32                                         M_WeaponID;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GunID;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BulletID;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AccessoryID;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipData) == 0x000004, "Wrong alignment on FEquipData");
static_assert(sizeof(FEquipData) == 0x000010, "Wrong size on FEquipData");
static_assert(offsetof(FEquipData, M_WeaponID) == 0x000000, "Member 'FEquipData::M_WeaponID' has a wrong offset!");
static_assert(offsetof(FEquipData, M_GunID) == 0x000004, "Member 'FEquipData::M_GunID' has a wrong offset!");
static_assert(offsetof(FEquipData, M_BulletID) == 0x000008, "Member 'FEquipData::M_BulletID' has a wrong offset!");
static_assert(offsetof(FEquipData, M_AccessoryID) == 0x00000C, "Member 'FEquipData::M_AccessoryID' has a wrong offset!");

// ScriptStruct Project.GardenBenchEffect
// 0x0020 (0x0020 - 0x0000)
struct FGardenBenchEffect final
{
public:
	float                                         BlurDuration;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlurGlobalIntensityCurve;                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectStartTime;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeStartTime;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeDuration;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndDelay;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenBenchEffect) == 0x000008, "Wrong alignment on FGardenBenchEffect");
static_assert(sizeof(FGardenBenchEffect) == 0x000020, "Wrong size on FGardenBenchEffect");
static_assert(offsetof(FGardenBenchEffect, BlurDuration) == 0x000000, "Member 'FGardenBenchEffect::BlurDuration' has a wrong offset!");
static_assert(offsetof(FGardenBenchEffect, BlurGlobalIntensityCurve) == 0x000008, "Member 'FGardenBenchEffect::BlurGlobalIntensityCurve' has a wrong offset!");
static_assert(offsetof(FGardenBenchEffect, EffectStartTime) == 0x000010, "Member 'FGardenBenchEffect::EffectStartTime' has a wrong offset!");
static_assert(offsetof(FGardenBenchEffect, FadeStartTime) == 0x000014, "Member 'FGardenBenchEffect::FadeStartTime' has a wrong offset!");
static_assert(offsetof(FGardenBenchEffect, FadeDuration) == 0x000018, "Member 'FGardenBenchEffect::FadeDuration' has a wrong offset!");
static_assert(offsetof(FGardenBenchEffect, FadeEndDelay) == 0x00001C, "Member 'FGardenBenchEffect::FadeEndDelay' has a wrong offset!");

// ScriptStruct Project.GardenPlayerTalkData_PWR
// 0x0024 (0x0024 - 0x0000)
struct FGardenPlayerTalkData_PWR final
{
public:
	int32                                         M_InfoFlag;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGardenPlayerTalkData                  M_GardenPlayerTalkData;                            // 0x0004(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenPlayerTalkData_PWR) == 0x000004, "Wrong alignment on FGardenPlayerTalkData_PWR");
static_assert(sizeof(FGardenPlayerTalkData_PWR) == 0x000024, "Wrong size on FGardenPlayerTalkData_PWR");
static_assert(offsetof(FGardenPlayerTalkData_PWR, M_InfoFlag) == 0x000000, "Member 'FGardenPlayerTalkData_PWR::M_InfoFlag' has a wrong offset!");
static_assert(offsetof(FGardenPlayerTalkData_PWR, M_GardenPlayerTalkData) == 0x000004, "Member 'FGardenPlayerTalkData_PWR::M_GardenPlayerTalkData' has a wrong offset!");

// ScriptStruct Project.GardenTypeData
// 0x000C (0x000C - 0x0000)
struct FGardenTypeData final
{
public:
	E_RYUKETSU_GARDEN_TYPE                        M_GardenType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_MinDistanceBtwnSpawner;                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DesiredDistanceBtwnSpawner;                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenTypeData) == 0x000004, "Wrong alignment on FGardenTypeData");
static_assert(sizeof(FGardenTypeData) == 0x00000C, "Wrong size on FGardenTypeData");
static_assert(offsetof(FGardenTypeData, M_GardenType) == 0x000000, "Member 'FGardenTypeData::M_GardenType' has a wrong offset!");
static_assert(offsetof(FGardenTypeData, M_MinDistanceBtwnSpawner) == 0x000004, "Member 'FGardenTypeData::M_MinDistanceBtwnSpawner' has a wrong offset!");
static_assert(offsetof(FGardenTypeData, M_DesiredDistanceBtwnSpawner) == 0x000008, "Member 'FGardenTypeData::M_DesiredDistanceBtwnSpawner' has a wrong offset!");

// ScriptStruct Project.GardenTributeMsgData
// 0x0003 (0x0003 - 0x0000)
struct FGardenTributeMsgData final
{
public:
	E_GARDEN_MSG_USE_TYPE                         M_MsgTypeNormal;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_MSG_USE_TYPE                         M_MsgTypeRare;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDevilVoiceType                               M_DevilTalkVoice;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenTributeMsgData) == 0x000001, "Wrong alignment on FGardenTributeMsgData");
static_assert(sizeof(FGardenTributeMsgData) == 0x000003, "Wrong size on FGardenTributeMsgData");
static_assert(offsetof(FGardenTributeMsgData, M_MsgTypeNormal) == 0x000000, "Member 'FGardenTributeMsgData::M_MsgTypeNormal' has a wrong offset!");
static_assert(offsetof(FGardenTributeMsgData, M_MsgTypeRare) == 0x000001, "Member 'FGardenTributeMsgData::M_MsgTypeRare' has a wrong offset!");
static_assert(offsetof(FGardenTributeMsgData, M_DevilTalkVoice) == 0x000002, "Member 'FGardenTributeMsgData::M_DevilTalkVoice' has a wrong offset!");

// ScriptStruct Project.GardenSpeechTypeMsgData
// 0x0040 (0x0040 - 0x0000)
struct FGardenSpeechTypeMsgData final
{
public:
	E_TALK_TONE_TYPE                              M_SpeechType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGardenMsgData                         M_TrustMsgData;                                    // 0x0001(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGardenMsgData>                 M_PowerUpMsgData;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGardenMsgData>                 M_ItemMsgData;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGardenTributeMsgData                  M_TributeMsgData;                                  // 0x0028(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGardenChatMsgData>             M_ChatMsgData;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenSpeechTypeMsgData) == 0x000008, "Wrong alignment on FGardenSpeechTypeMsgData");
static_assert(sizeof(FGardenSpeechTypeMsgData) == 0x000040, "Wrong size on FGardenSpeechTypeMsgData");
static_assert(offsetof(FGardenSpeechTypeMsgData, M_SpeechType) == 0x000000, "Member 'FGardenSpeechTypeMsgData::M_SpeechType' has a wrong offset!");
static_assert(offsetof(FGardenSpeechTypeMsgData, M_TrustMsgData) == 0x000001, "Member 'FGardenSpeechTypeMsgData::M_TrustMsgData' has a wrong offset!");
static_assert(offsetof(FGardenSpeechTypeMsgData, M_PowerUpMsgData) == 0x000008, "Member 'FGardenSpeechTypeMsgData::M_PowerUpMsgData' has a wrong offset!");
static_assert(offsetof(FGardenSpeechTypeMsgData, M_ItemMsgData) == 0x000018, "Member 'FGardenSpeechTypeMsgData::M_ItemMsgData' has a wrong offset!");
static_assert(offsetof(FGardenSpeechTypeMsgData, M_TributeMsgData) == 0x000028, "Member 'FGardenSpeechTypeMsgData::M_TributeMsgData' has a wrong offset!");
static_assert(offsetof(FGardenSpeechTypeMsgData, M_ChatMsgData) == 0x000030, "Member 'FGardenSpeechTypeMsgData::M_ChatMsgData' has a wrong offset!");

// ScriptStruct Project.GardenUniqueDevilMsgData
// 0x0020 (0x0020 - 0x0000)
struct FGardenUniqueDevilMsgData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGardenMsgData                         M_TrustMsgData;                                    // 0x0004(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenMsgData                         M_PowerUpMsgData;                                  // 0x0007(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenMsgData                         M_ItemMsgData;                                     // 0x000A(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenTributeMsgData                  M_TributeMsgData;                                  // 0x000D(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGardenChatMsgData>             M_ChatMsgData;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenUniqueDevilMsgData) == 0x000008, "Wrong alignment on FGardenUniqueDevilMsgData");
static_assert(sizeof(FGardenUniqueDevilMsgData) == 0x000020, "Wrong size on FGardenUniqueDevilMsgData");
static_assert(offsetof(FGardenUniqueDevilMsgData, M_Id) == 0x000000, "Member 'FGardenUniqueDevilMsgData::M_Id' has a wrong offset!");
static_assert(offsetof(FGardenUniqueDevilMsgData, M_TrustMsgData) == 0x000004, "Member 'FGardenUniqueDevilMsgData::M_TrustMsgData' has a wrong offset!");
static_assert(offsetof(FGardenUniqueDevilMsgData, M_PowerUpMsgData) == 0x000007, "Member 'FGardenUniqueDevilMsgData::M_PowerUpMsgData' has a wrong offset!");
static_assert(offsetof(FGardenUniqueDevilMsgData, M_ItemMsgData) == 0x00000A, "Member 'FGardenUniqueDevilMsgData::M_ItemMsgData' has a wrong offset!");
static_assert(offsetof(FGardenUniqueDevilMsgData, M_TributeMsgData) == 0x00000D, "Member 'FGardenUniqueDevilMsgData::M_TributeMsgData' has a wrong offset!");
static_assert(offsetof(FGardenUniqueDevilMsgData, M_ChatMsgData) == 0x000010, "Member 'FGardenUniqueDevilMsgData::M_ChatMsgData' has a wrong offset!");

// ScriptStruct Project.GardenFreeCameraSizeOverride
// 0x0008 (0x0010 - 0x0008)
struct FGardenFreeCameraSizeOverride final : public FTableRowBase
{
public:
	int32                                         M_DevilID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Rate;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenFreeCameraSizeOverride) == 0x000008, "Wrong alignment on FGardenFreeCameraSizeOverride");
static_assert(sizeof(FGardenFreeCameraSizeOverride) == 0x000010, "Wrong size on FGardenFreeCameraSizeOverride");
static_assert(offsetof(FGardenFreeCameraSizeOverride, M_DevilID) == 0x000008, "Member 'FGardenFreeCameraSizeOverride::M_DevilID' has a wrong offset!");
static_assert(offsetof(FGardenFreeCameraSizeOverride, M_Rate) == 0x00000C, "Member 'FGardenFreeCameraSizeOverride::M_Rate' has a wrong offset!");

// ScriptStruct Project.GardenDevilSitInfo
// 0x0018 (0x0020 - 0x0008)
struct FGardenDevilSitInfo final : public FTableRowBase
{
public:
	int32                                         DevilID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_CHARA_MOTION_ID                      MotionID;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SitHeightOffset;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IconOffset;                                        // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenDevilSitInfo) == 0x000008, "Wrong alignment on FGardenDevilSitInfo");
static_assert(sizeof(FGardenDevilSitInfo) == 0x000020, "Wrong size on FGardenDevilSitInfo");
static_assert(offsetof(FGardenDevilSitInfo, DevilID) == 0x000008, "Member 'FGardenDevilSitInfo::DevilID' has a wrong offset!");
static_assert(offsetof(FGardenDevilSitInfo, MotionID) == 0x00000C, "Member 'FGardenDevilSitInfo::MotionID' has a wrong offset!");
static_assert(offsetof(FGardenDevilSitInfo, SitHeightOffset) == 0x000010, "Member 'FGardenDevilSitInfo::SitHeightOffset' has a wrong offset!");
static_assert(offsetof(FGardenDevilSitInfo, IconOffset) == 0x000014, "Member 'FGardenDevilSitInfo::IconOffset' has a wrong offset!");

// ScriptStruct Project.GardenDevilInfo
// 0x0010 (0x0018 - 0x0008)
struct FGardenDevilInfo final : public FTableRowBase
{
public:
	int32                                         DevilID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevilScale;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_SPAWN_SIZE                           Size;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_SPAWN_ANIMATION                      Animation;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_SPAWN_AREA                           Area;                                              // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGardenDevilInfo) == 0x000008, "Wrong alignment on FGardenDevilInfo");
static_assert(sizeof(FGardenDevilInfo) == 0x000018, "Wrong size on FGardenDevilInfo");
static_assert(offsetof(FGardenDevilInfo, DevilID) == 0x000008, "Member 'FGardenDevilInfo::DevilID' has a wrong offset!");
static_assert(offsetof(FGardenDevilInfo, DevilScale) == 0x00000C, "Member 'FGardenDevilInfo::DevilScale' has a wrong offset!");
static_assert(offsetof(FGardenDevilInfo, Size) == 0x000010, "Member 'FGardenDevilInfo::Size' has a wrong offset!");
static_assert(offsetof(FGardenDevilInfo, Animation) == 0x000011, "Member 'FGardenDevilInfo::Animation' has a wrong offset!");
static_assert(offsetof(FGardenDevilInfo, Area) == 0x000012, "Member 'FGardenDevilInfo::Area' has a wrong offset!");

// ScriptStruct Project.GardenTalkCollision
// 0x0010 (0x0018 - 0x0008)
struct FGardenTalkCollision final : public FTableRowBase
{
public:
	int32                                         M_DevilID;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_CollisionHalfHeight;                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_CollisionRadius;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_CollisionLocationZ;                              // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenTalkCollision) == 0x000008, "Wrong alignment on FGardenTalkCollision");
static_assert(sizeof(FGardenTalkCollision) == 0x000018, "Wrong size on FGardenTalkCollision");
static_assert(offsetof(FGardenTalkCollision, M_DevilID) == 0x000008, "Member 'FGardenTalkCollision::M_DevilID' has a wrong offset!");
static_assert(offsetof(FGardenTalkCollision, M_CollisionHalfHeight) == 0x00000C, "Member 'FGardenTalkCollision::M_CollisionHalfHeight' has a wrong offset!");
static_assert(offsetof(FGardenTalkCollision, M_CollisionRadius) == 0x000010, "Member 'FGardenTalkCollision::M_CollisionRadius' has a wrong offset!");
static_assert(offsetof(FGardenTalkCollision, M_CollisionLocationZ) == 0x000014, "Member 'FGardenTalkCollision::M_CollisionLocationZ' has a wrong offset!");

// ScriptStruct Project.GardenSPTData
// 0x0008 (0x0008 - 0x0000)
struct FGardenSPTData final
{
public:
	E_TALK_TONE_TYPE                              M_SpeechType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ChosenSPT;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenSPTData) == 0x000004, "Wrong alignment on FGardenSPTData");
static_assert(sizeof(FGardenSPTData) == 0x000008, "Wrong size on FGardenSPTData");
static_assert(offsetof(FGardenSPTData, M_SpeechType) == 0x000000, "Member 'FGardenSPTData::M_SpeechType' has a wrong offset!");
static_assert(offsetof(FGardenSPTData, M_ChosenSPT) == 0x000004, "Member 'FGardenSPTData::M_ChosenSPT' has a wrong offset!");

// ScriptStruct Project.GardenTutorialSpotSettings
// 0x00F0 (0x00F0 - 0x0000)
struct FGardenTutorialSpotSettings final
{
public:
	struct FGardenTutorialSpot                    SpawnSpot1;                                        // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenTutorialSpot                    SpawnSpot2;                                        // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenTutorialSpot                    SpawnSpot3;                                        // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenTutorialSpotSettings) == 0x000010, "Wrong alignment on FGardenTutorialSpotSettings");
static_assert(sizeof(FGardenTutorialSpotSettings) == 0x0000F0, "Wrong size on FGardenTutorialSpotSettings");
static_assert(offsetof(FGardenTutorialSpotSettings, SpawnSpot1) == 0x000000, "Member 'FGardenTutorialSpotSettings::SpawnSpot1' has a wrong offset!");
static_assert(offsetof(FGardenTutorialSpotSettings, SpawnSpot2) == 0x000050, "Member 'FGardenTutorialSpotSettings::SpawnSpot2' has a wrong offset!");
static_assert(offsetof(FGardenTutorialSpotSettings, SpawnSpot3) == 0x0000A0, "Member 'FGardenTutorialSpotSettings::SpawnSpot3' has a wrong offset!");

// ScriptStruct Project.GazeParameter
// 0x000C (0x000C - 0x0000)
struct FGazeParameter final
{
public:
	float                                         TypeWeight;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleLimit;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGazeParameter) == 0x000004, "Wrong alignment on FGazeParameter");
static_assert(sizeof(FGazeParameter) == 0x00000C, "Wrong size on FGazeParameter");
static_assert(offsetof(FGazeParameter, TypeWeight) == 0x000000, "Member 'FGazeParameter::TypeWeight' has a wrong offset!");
static_assert(offsetof(FGazeParameter, MaxDistance) == 0x000004, "Member 'FGazeParameter::MaxDistance' has a wrong offset!");
static_assert(offsetof(FGazeParameter, AngleLimit) == 0x000008, "Member 'FGazeParameter::AngleLimit' has a wrong offset!");

// ScriptStruct Project.SkillRankData
// 0x0002 (0x0002 - 0x0000)
struct FSkillRankData final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillRankData) == 0x000001, "Wrong alignment on FSkillRankData");
static_assert(sizeof(FSkillRankData) == 0x000002, "Wrong size on FSkillRankData");

// ScriptStruct Project.KeyboardNameTable
// 0x0078 (0x0078 - 0x0000)
struct FKeyboardNameTable final
{
public:
	E_KeyboardLanguage                            M_Language;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_Enter;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_Esc;                                             // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_Ctrl;                                            // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_Shift;                                           // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_Del;                                             // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_Space;                                           // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_Caps;                                            // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyboardNameTable) == 0x000008, "Wrong alignment on FKeyboardNameTable");
static_assert(sizeof(FKeyboardNameTable) == 0x000078, "Wrong size on FKeyboardNameTable");
static_assert(offsetof(FKeyboardNameTable, M_Language) == 0x000000, "Member 'FKeyboardNameTable::M_Language' has a wrong offset!");
static_assert(offsetof(FKeyboardNameTable, M_Enter) == 0x000008, "Member 'FKeyboardNameTable::M_Enter' has a wrong offset!");
static_assert(offsetof(FKeyboardNameTable, M_Esc) == 0x000018, "Member 'FKeyboardNameTable::M_Esc' has a wrong offset!");
static_assert(offsetof(FKeyboardNameTable, M_Ctrl) == 0x000028, "Member 'FKeyboardNameTable::M_Ctrl' has a wrong offset!");
static_assert(offsetof(FKeyboardNameTable, M_Shift) == 0x000038, "Member 'FKeyboardNameTable::M_Shift' has a wrong offset!");
static_assert(offsetof(FKeyboardNameTable, M_Del) == 0x000048, "Member 'FKeyboardNameTable::M_Del' has a wrong offset!");
static_assert(offsetof(FKeyboardNameTable, M_Space) == 0x000058, "Member 'FKeyboardNameTable::M_Space' has a wrong offset!");
static_assert(offsetof(FKeyboardNameTable, M_Caps) == 0x000068, "Member 'FKeyboardNameTable::M_Caps' has a wrong offset!");

// ScriptStruct Project.UseItemData
// 0x005C (0x005C - 0x0000)
struct FUseItemData final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillId;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortId;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NameSortId;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPRecovery;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MPRecovery;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_HPRcvPercent;                                    // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MPRcvPercent;                                    // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_RecBst;                                          // 0x001A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_All;                                             // 0x001B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Kind;                                            // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ItemIcon;                                        // 0x001D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UseScene;                                        // 0x001E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsUseInfinite;                                   // 0x001F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_HPUp;                                            // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MPUp;                                            // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_StrUp;                                           // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_VitUp;                                           // 0x0023(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MgiUp;                                           // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AgiUp;                                           // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_LucUp;                                           // 0x0026(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsNotBuy;                                        // 0x0027(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsNotRelease;                                    // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NkmUseType;                                      // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_HaveMax;                                         // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_GetExp;                                          // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MoonTime;                                        // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NahobinoMotion;                                  // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UseTarget;                                       // 0x002E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiPhysics;                                  // 0x002F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiFire;                                     // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiIce;                                      // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiThunder;                                  // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiWind;                                     // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiLight;                                    // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiDark;                                     // 0x0035(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiAll;                                      // 0x0036(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiAtk;                                      // 0x0037(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiAid;                                      // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiRecovery_HP;                              // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TekiseiRecovery_NA;                              // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_GodParameter;                                    // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UseCondition;                                    // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ShopListId;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ValidTurn;                                       // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ValidTime;                                       // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillSource;                                     // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BuyingPrice;                                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SellingPrice;                                    // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BattleSortType;                                  // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUseItemData) == 0x000004, "Wrong alignment on FUseItemData");
static_assert(sizeof(FUseItemData) == 0x00005C, "Wrong size on FUseItemData");
static_assert(offsetof(FUseItemData, M_ItemID) == 0x000000, "Member 'FUseItemData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_SkillId) == 0x000004, "Member 'FUseItemData::M_SkillId' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_SortId) == 0x000008, "Member 'FUseItemData::M_SortId' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_NameSortId) == 0x00000C, "Member 'FUseItemData::M_NameSortId' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_HPRecovery) == 0x000010, "Member 'FUseItemData::M_HPRecovery' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_MPRecovery) == 0x000014, "Member 'FUseItemData::M_MPRecovery' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_HPRcvPercent) == 0x000018, "Member 'FUseItemData::M_HPRcvPercent' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_MPRcvPercent) == 0x000019, "Member 'FUseItemData::M_MPRcvPercent' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_RecBst) == 0x00001A, "Member 'FUseItemData::M_RecBst' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_All) == 0x00001B, "Member 'FUseItemData::M_All' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_Kind) == 0x00001C, "Member 'FUseItemData::M_Kind' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_ItemIcon) == 0x00001D, "Member 'FUseItemData::M_ItemIcon' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_UseScene) == 0x00001E, "Member 'FUseItemData::M_UseScene' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_IsUseInfinite) == 0x00001F, "Member 'FUseItemData::M_IsUseInfinite' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_HPUp) == 0x000020, "Member 'FUseItemData::M_HPUp' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_MPUp) == 0x000021, "Member 'FUseItemData::M_MPUp' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_StrUp) == 0x000022, "Member 'FUseItemData::M_StrUp' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_VitUp) == 0x000023, "Member 'FUseItemData::M_VitUp' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_MgiUp) == 0x000024, "Member 'FUseItemData::M_MgiUp' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_AgiUp) == 0x000025, "Member 'FUseItemData::M_AgiUp' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_LucUp) == 0x000026, "Member 'FUseItemData::M_LucUp' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_IsNotBuy) == 0x000027, "Member 'FUseItemData::M_IsNotBuy' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_IsNotRelease) == 0x000028, "Member 'FUseItemData::M_IsNotRelease' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_NkmUseType) == 0x000029, "Member 'FUseItemData::M_NkmUseType' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_HaveMax) == 0x00002A, "Member 'FUseItemData::M_HaveMax' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_GetExp) == 0x00002B, "Member 'FUseItemData::M_GetExp' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_MoonTime) == 0x00002C, "Member 'FUseItemData::M_MoonTime' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_NahobinoMotion) == 0x00002D, "Member 'FUseItemData::M_NahobinoMotion' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_UseTarget) == 0x00002E, "Member 'FUseItemData::M_UseTarget' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiPhysics) == 0x00002F, "Member 'FUseItemData::M_TekiseiPhysics' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiFire) == 0x000030, "Member 'FUseItemData::M_TekiseiFire' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiIce) == 0x000031, "Member 'FUseItemData::M_TekiseiIce' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiThunder) == 0x000032, "Member 'FUseItemData::M_TekiseiThunder' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiWind) == 0x000033, "Member 'FUseItemData::M_TekiseiWind' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiLight) == 0x000034, "Member 'FUseItemData::M_TekiseiLight' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiDark) == 0x000035, "Member 'FUseItemData::M_TekiseiDark' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiAll) == 0x000036, "Member 'FUseItemData::M_TekiseiAll' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiAtk) == 0x000037, "Member 'FUseItemData::M_TekiseiAtk' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiAid) == 0x000038, "Member 'FUseItemData::M_TekiseiAid' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiRecovery_HP) == 0x000039, "Member 'FUseItemData::M_TekiseiRecovery_HP' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_TekiseiRecovery_NA) == 0x00003A, "Member 'FUseItemData::M_TekiseiRecovery_NA' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_GodParameter) == 0x00003B, "Member 'FUseItemData::M_GodParameter' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_UseCondition) == 0x00003C, "Member 'FUseItemData::M_UseCondition' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_ShopListId) == 0x000040, "Member 'FUseItemData::M_ShopListId' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_ValidTurn) == 0x000044, "Member 'FUseItemData::M_ValidTurn' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_ValidTime) == 0x000048, "Member 'FUseItemData::M_ValidTime' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_SkillSource) == 0x00004C, "Member 'FUseItemData::M_SkillSource' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_BuyingPrice) == 0x000050, "Member 'FUseItemData::M_BuyingPrice' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_SellingPrice) == 0x000054, "Member 'FUseItemData::M_SellingPrice' has a wrong offset!");
static_assert(offsetof(FUseItemData, M_BattleSortType) == 0x000058, "Member 'FUseItemData::M_BattleSortType' has a wrong offset!");

// ScriptStruct Project.RelicItemData
// 0x0018 (0x0018 - 0x0000)
struct FRelicItemData final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ItemKind;                                        // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_SellingPrice;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_CreationModePrice;                               // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortId;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NameSortId;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRelicItemData) == 0x000004, "Wrong alignment on FRelicItemData");
static_assert(sizeof(FRelicItemData) == 0x000018, "Wrong size on FRelicItemData");
static_assert(offsetof(FRelicItemData, M_ItemID) == 0x000000, "Member 'FRelicItemData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FRelicItemData, M_ItemKind) == 0x000004, "Member 'FRelicItemData::M_ItemKind' has a wrong offset!");
static_assert(offsetof(FRelicItemData, M_SellingPrice) == 0x000008, "Member 'FRelicItemData::M_SellingPrice' has a wrong offset!");
static_assert(offsetof(FRelicItemData, M_CreationModePrice) == 0x00000C, "Member 'FRelicItemData::M_CreationModePrice' has a wrong offset!");
static_assert(offsetof(FRelicItemData, M_SortId) == 0x000010, "Member 'FRelicItemData::M_SortId' has a wrong offset!");
static_assert(offsetof(FRelicItemData, M_NameSortId) == 0x000014, "Member 'FRelicItemData::M_NameSortId' has a wrong offset!");

// ScriptStruct Project.SkillGetItemData
// 0x0030 (0x0030 - 0x0000)
struct FSkillGetItemData final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LerningSkillID;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortId;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NameSortId;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Kind;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HaveMax;                                         // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BuyingPrice;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SellingPrice;                                    // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkillGetNeedItem>              M_NeedItemArray;                                   // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillGetItemData) == 0x000008, "Wrong alignment on FSkillGetItemData");
static_assert(sizeof(FSkillGetItemData) == 0x000030, "Wrong size on FSkillGetItemData");
static_assert(offsetof(FSkillGetItemData, M_ItemID) == 0x000000, "Member 'FSkillGetItemData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FSkillGetItemData, M_LerningSkillID) == 0x000004, "Member 'FSkillGetItemData::M_LerningSkillID' has a wrong offset!");
static_assert(offsetof(FSkillGetItemData, M_SortId) == 0x000008, "Member 'FSkillGetItemData::M_SortId' has a wrong offset!");
static_assert(offsetof(FSkillGetItemData, M_NameSortId) == 0x00000C, "Member 'FSkillGetItemData::M_NameSortId' has a wrong offset!");
static_assert(offsetof(FSkillGetItemData, M_Kind) == 0x000010, "Member 'FSkillGetItemData::M_Kind' has a wrong offset!");
static_assert(offsetof(FSkillGetItemData, M_HaveMax) == 0x000014, "Member 'FSkillGetItemData::M_HaveMax' has a wrong offset!");
static_assert(offsetof(FSkillGetItemData, M_BuyingPrice) == 0x000018, "Member 'FSkillGetItemData::M_BuyingPrice' has a wrong offset!");
static_assert(offsetof(FSkillGetItemData, M_SellingPrice) == 0x00001C, "Member 'FSkillGetItemData::M_SellingPrice' has a wrong offset!");
static_assert(offsetof(FSkillGetItemData, M_NeedItemArray) == 0x000020, "Member 'FSkillGetItemData::M_NeedItemArray' has a wrong offset!");

// ScriptStruct Project.RuntimeKawaiiHairParameter
// 0x007C (0x007C - 0x0000)
struct FRuntimeKawaiiHairParameter final
{
public:
	struct FKawaiiPhysicsSettings                 Settings;                                          // 0x0000(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ForceCenter;                                       // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceRightA;                                       // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceRightB;                                       // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceRightC;                                       // 0x0044(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceLeftA;                                        // 0x0050(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceLeftB;                                        // 0x005C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceLeftC;                                        // 0x0068(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoseLocationApplyRate;                             // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeKawaiiHairParameter) == 0x000004, "Wrong alignment on FRuntimeKawaiiHairParameter");
static_assert(sizeof(FRuntimeKawaiiHairParameter) == 0x00007C, "Wrong size on FRuntimeKawaiiHairParameter");
static_assert(offsetof(FRuntimeKawaiiHairParameter, Settings) == 0x000000, "Member 'FRuntimeKawaiiHairParameter::Settings' has a wrong offset!");
static_assert(offsetof(FRuntimeKawaiiHairParameter, ForceCenter) == 0x000020, "Member 'FRuntimeKawaiiHairParameter::ForceCenter' has a wrong offset!");
static_assert(offsetof(FRuntimeKawaiiHairParameter, ForceRightA) == 0x00002C, "Member 'FRuntimeKawaiiHairParameter::ForceRightA' has a wrong offset!");
static_assert(offsetof(FRuntimeKawaiiHairParameter, ForceRightB) == 0x000038, "Member 'FRuntimeKawaiiHairParameter::ForceRightB' has a wrong offset!");
static_assert(offsetof(FRuntimeKawaiiHairParameter, ForceRightC) == 0x000044, "Member 'FRuntimeKawaiiHairParameter::ForceRightC' has a wrong offset!");
static_assert(offsetof(FRuntimeKawaiiHairParameter, ForceLeftA) == 0x000050, "Member 'FRuntimeKawaiiHairParameter::ForceLeftA' has a wrong offset!");
static_assert(offsetof(FRuntimeKawaiiHairParameter, ForceLeftB) == 0x00005C, "Member 'FRuntimeKawaiiHairParameter::ForceLeftB' has a wrong offset!");
static_assert(offsetof(FRuntimeKawaiiHairParameter, ForceLeftC) == 0x000068, "Member 'FRuntimeKawaiiHairParameter::ForceLeftC' has a wrong offset!");
static_assert(offsetof(FRuntimeKawaiiHairParameter, Alpha) == 0x000074, "Member 'FRuntimeKawaiiHairParameter::Alpha' has a wrong offset!");
static_assert(offsetof(FRuntimeKawaiiHairParameter, PoseLocationApplyRate) == 0x000078, "Member 'FRuntimeKawaiiHairParameter::PoseLocationApplyRate' has a wrong offset!");

// ScriptStruct Project.Map3DIconEntry
// 0x0070 (0x0070 - 0x0000)
struct FMap3DIconEntry final
{
public:
	bool                                          M_IsExist;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_MyIndex;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_WorldLocation;                                   // 0x0008(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_ScreenLocation;                                  // 0x0014(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ImageScale;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Dist2;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_RotateZ;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_POI_ICON                            M_IconToRender;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimapPOIParam                       M_POIParam;                                        // 0x0030(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMap3DIconEntry) == 0x000004, "Wrong alignment on FMap3DIconEntry");
static_assert(sizeof(FMap3DIconEntry) == 0x000070, "Wrong size on FMap3DIconEntry");
static_assert(offsetof(FMap3DIconEntry, M_IsExist) == 0x000000, "Member 'FMap3DIconEntry::M_IsExist' has a wrong offset!");
static_assert(offsetof(FMap3DIconEntry, M_MyIndex) == 0x000004, "Member 'FMap3DIconEntry::M_MyIndex' has a wrong offset!");
static_assert(offsetof(FMap3DIconEntry, M_WorldLocation) == 0x000008, "Member 'FMap3DIconEntry::M_WorldLocation' has a wrong offset!");
static_assert(offsetof(FMap3DIconEntry, M_ScreenLocation) == 0x000014, "Member 'FMap3DIconEntry::M_ScreenLocation' has a wrong offset!");
static_assert(offsetof(FMap3DIconEntry, M_ImageScale) == 0x000020, "Member 'FMap3DIconEntry::M_ImageScale' has a wrong offset!");
static_assert(offsetof(FMap3DIconEntry, M_Dist2) == 0x000024, "Member 'FMap3DIconEntry::M_Dist2' has a wrong offset!");
static_assert(offsetof(FMap3DIconEntry, M_RotateZ) == 0x000028, "Member 'FMap3DIconEntry::M_RotateZ' has a wrong offset!");
static_assert(offsetof(FMap3DIconEntry, M_IconToRender) == 0x00002C, "Member 'FMap3DIconEntry::M_IconToRender' has a wrong offset!");
static_assert(offsetof(FMap3DIconEntry, M_POIParam) == 0x000030, "Member 'FMap3DIconEntry::M_POIParam' has a wrong offset!");

// ScriptStruct Project.MapEventData
// 0x0098 (0x0098 - 0x0000)
struct FMapEventData final
{
public:
	int32                                         M_MapEventID;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_StartFlagValues;                                 // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_EndFlagValue;                                    // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AfterFlagValue;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MapID;                                           // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_EventName;                                       // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Type;                                            // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_OldNewRoute                                 M_OldNewRoute;                                     // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_HitManaged;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_IconManaged;                                     // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ManualBattleEnd;                                 // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ManualEventEnd;                                  // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SimpleEvent;                                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BeforOtherMap;                                   // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BeforOtherArea;                                  // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BeforOtherPoint;                                 // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_IsAfterBattle;                                   // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AfterBattleID;                                   // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StartFlagValue_Evt1;                             // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndFlagValue_Evt1;                               // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_IsAfterOtherMap;                                 // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_IsAfterOtherArea;                                // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_IsAfterOtherPoint;                               // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AfterEventID;                                    // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StartFlagValue_Evt2;                             // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndFlagValue_Evt2;                               // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_IsAfterOtherMap_2;                               // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_IsAfterOtherArea_2;                              // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_IsAfterOtherPoint_2;                             // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AfterEventID_2;                                  // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapEventData) == 0x000008, "Wrong alignment on FMapEventData");
static_assert(sizeof(FMapEventData) == 0x000098, "Wrong size on FMapEventData");
static_assert(offsetof(FMapEventData, M_MapEventID) == 0x000000, "Member 'FMapEventData::M_MapEventID' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_StartFlagValues) == 0x000008, "Member 'FMapEventData::M_StartFlagValues' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_EndFlagValue) == 0x000018, "Member 'FMapEventData::M_EndFlagValue' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_AfterFlagValue) == 0x00001C, "Member 'FMapEventData::M_AfterFlagValue' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_MapID) == 0x000020, "Member 'FMapEventData::M_MapID' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_AreaId) == 0x000024, "Member 'FMapEventData::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_EventName) == 0x000028, "Member 'FMapEventData::M_EventName' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_Type) == 0x000038, "Member 'FMapEventData::M_Type' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_OldNewRoute) == 0x00003C, "Member 'FMapEventData::M_OldNewRoute' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_HitManaged) == 0x000040, "Member 'FMapEventData::M_HitManaged' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_IconManaged) == 0x000044, "Member 'FMapEventData::M_IconManaged' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_ManualBattleEnd) == 0x000048, "Member 'FMapEventData::M_ManualBattleEnd' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_ManualEventEnd) == 0x00004C, "Member 'FMapEventData::M_ManualEventEnd' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_SimpleEvent) == 0x000050, "Member 'FMapEventData::M_SimpleEvent' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_BeforOtherMap) == 0x000054, "Member 'FMapEventData::M_BeforOtherMap' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_BeforOtherArea) == 0x000058, "Member 'FMapEventData::M_BeforOtherArea' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_BeforOtherPoint) == 0x00005C, "Member 'FMapEventData::M_BeforOtherPoint' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_IsAfterBattle) == 0x000060, "Member 'FMapEventData::M_IsAfterBattle' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_AfterBattleID) == 0x000064, "Member 'FMapEventData::M_AfterBattleID' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_StartFlagValue_Evt1) == 0x000068, "Member 'FMapEventData::M_StartFlagValue_Evt1' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_EndFlagValue_Evt1) == 0x00006C, "Member 'FMapEventData::M_EndFlagValue_Evt1' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_IsAfterOtherMap) == 0x000070, "Member 'FMapEventData::M_IsAfterOtherMap' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_IsAfterOtherArea) == 0x000074, "Member 'FMapEventData::M_IsAfterOtherArea' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_IsAfterOtherPoint) == 0x000078, "Member 'FMapEventData::M_IsAfterOtherPoint' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_AfterEventID) == 0x00007C, "Member 'FMapEventData::M_AfterEventID' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_StartFlagValue_Evt2) == 0x000080, "Member 'FMapEventData::M_StartFlagValue_Evt2' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_EndFlagValue_Evt2) == 0x000084, "Member 'FMapEventData::M_EndFlagValue_Evt2' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_IsAfterOtherMap_2) == 0x000088, "Member 'FMapEventData::M_IsAfterOtherMap_2' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_IsAfterOtherArea_2) == 0x00008C, "Member 'FMapEventData::M_IsAfterOtherArea_2' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_IsAfterOtherPoint_2) == 0x000090, "Member 'FMapEventData::M_IsAfterOtherPoint_2' has a wrong offset!");
static_assert(offsetof(FMapEventData, M_AfterEventID_2) == 0x000094, "Member 'FMapEventData::M_AfterEventID_2' has a wrong offset!");

// ScriptStruct Project.MapSymbolRouteNode
// 0x0038 (0x0038 - 0x0000)
struct FMapSymbolRouteNode final
{
public:
	TArray<struct FMapSymbolConnectNode>          M_ConnectList;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_Done;                                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_Cost;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PrevConnectIndex;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_Location;                                        // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Slope;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_X;                                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Y;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapSymbolRouteNode) == 0x000008, "Wrong alignment on FMapSymbolRouteNode");
static_assert(sizeof(FMapSymbolRouteNode) == 0x000038, "Wrong size on FMapSymbolRouteNode");
static_assert(offsetof(FMapSymbolRouteNode, M_ConnectList) == 0x000000, "Member 'FMapSymbolRouteNode::M_ConnectList' has a wrong offset!");
static_assert(offsetof(FMapSymbolRouteNode, M_Done) == 0x000010, "Member 'FMapSymbolRouteNode::M_Done' has a wrong offset!");
static_assert(offsetof(FMapSymbolRouteNode, M_Cost) == 0x000014, "Member 'FMapSymbolRouteNode::M_Cost' has a wrong offset!");
static_assert(offsetof(FMapSymbolRouteNode, M_PrevConnectIndex) == 0x000018, "Member 'FMapSymbolRouteNode::M_PrevConnectIndex' has a wrong offset!");
static_assert(offsetof(FMapSymbolRouteNode, M_Location) == 0x00001C, "Member 'FMapSymbolRouteNode::M_Location' has a wrong offset!");
static_assert(offsetof(FMapSymbolRouteNode, M_Slope) == 0x000028, "Member 'FMapSymbolRouteNode::M_Slope' has a wrong offset!");
static_assert(offsetof(FMapSymbolRouteNode, M_X) == 0x00002C, "Member 'FMapSymbolRouteNode::M_X' has a wrong offset!");
static_assert(offsetof(FMapSymbolRouteNode, M_Y) == 0x000030, "Member 'FMapSymbolRouteNode::M_Y' has a wrong offset!");

// ScriptStruct Project.MapTopCameraTransitionParam
// 0x0010 (0x0010 - 0x0000)
struct FMapTopCameraTransitionParam final
{
public:
	float                                         DurationSeconds;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightRate;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapTopCameraTransitionParam) == 0x000008, "Wrong alignment on FMapTopCameraTransitionParam");
static_assert(sizeof(FMapTopCameraTransitionParam) == 0x000010, "Wrong size on FMapTopCameraTransitionParam");
static_assert(offsetof(FMapTopCameraTransitionParam, DurationSeconds) == 0x000000, "Member 'FMapTopCameraTransitionParam::DurationSeconds' has a wrong offset!");
static_assert(offsetof(FMapTopCameraTransitionParam, HeightRate) == 0x000004, "Member 'FMapTopCameraTransitionParam::HeightRate' has a wrong offset!");
static_assert(offsetof(FMapTopCameraTransitionParam, Curve) == 0x000008, "Member 'FMapTopCameraTransitionParam::Curve' has a wrong offset!");

// ScriptStruct Project.MaterialParameterApplier_VectorParam
// 0x0018 (0x0018 - 0x0000)
struct FMaterialParameterApplier_VectorParam final
{
public:
	struct FLinearColor                           Value;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialParameterApplier_VectorParam) == 0x000004, "Wrong alignment on FMaterialParameterApplier_VectorParam");
static_assert(sizeof(FMaterialParameterApplier_VectorParam) == 0x000018, "Wrong size on FMaterialParameterApplier_VectorParam");
static_assert(offsetof(FMaterialParameterApplier_VectorParam, Value) == 0x000000, "Member 'FMaterialParameterApplier_VectorParam::Value' has a wrong offset!");
static_assert(offsetof(FMaterialParameterApplier_VectorParam, ParamName) == 0x000010, "Member 'FMaterialParameterApplier_VectorParam::ParamName' has a wrong offset!");

// ScriptStruct Project.MimanSaveBuffer
// 0x000C (0x000C - 0x0000)
struct FMimanSaveBuffer final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Buffer;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMimanSaveBuffer) == 0x000004, "Wrong alignment on FMimanSaveBuffer");
static_assert(sizeof(FMimanSaveBuffer) == 0x00000C, "Wrong size on FMimanSaveBuffer");
static_assert(offsetof(FMimanSaveBuffer, M_MapID) == 0x000000, "Member 'FMimanSaveBuffer::M_MapID' has a wrong offset!");
static_assert(offsetof(FMimanSaveBuffer, M_AreaId) == 0x000004, "Member 'FMimanSaveBuffer::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMimanSaveBuffer, M_Buffer) == 0x000008, "Member 'FMimanSaveBuffer::M_Buffer' has a wrong offset!");

// ScriptStruct Project.MinimapCoasterLineRenderEntry
// 0x0010 (0x0010 - 0x0000)
struct FMinimapCoasterLineRenderEntry final
{
public:
	struct FVector2D                              Point_0;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Point_1;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapCoasterLineRenderEntry) == 0x000004, "Wrong alignment on FMinimapCoasterLineRenderEntry");
static_assert(sizeof(FMinimapCoasterLineRenderEntry) == 0x000010, "Wrong size on FMinimapCoasterLineRenderEntry");
static_assert(offsetof(FMinimapCoasterLineRenderEntry, Point_0) == 0x000000, "Member 'FMinimapCoasterLineRenderEntry::Point_0' has a wrong offset!");
static_assert(offsetof(FMinimapCoasterLineRenderEntry, Point_1) == 0x000008, "Member 'FMinimapCoasterLineRenderEntry::Point_1' has a wrong offset!");

// ScriptStruct Project.MinimapCoasterLine
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x04) FMinimapCoasterLine final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimapCoasterLine) == 0x000004, "Wrong alignment on FMinimapCoasterLine");
static_assert(sizeof(FMinimapCoasterLine) == 0x000040, "Wrong size on FMinimapCoasterLine");

// ScriptStruct Project.MinimapRenderParam
// 0x0090 (0x0090 - 0x0000)
struct FMinimapRenderParam final
{
public:
	E_MINIMAP_MODE                                MinimapMode;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Dimensions;                                        // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CanvasSize;                                        // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CanvasLocation;                                    // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterLocation;                                    // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerTransform;                                   // 0x0040(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Zoom;                                              // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShowingMapId;                                      // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShowingAreaId;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_ICON_SORT_TYPE                      IconSortType;                                      // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotateMinimap;                                     // 0x007D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraAngle;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimapRenderParam) == 0x000010, "Wrong alignment on FMinimapRenderParam");
static_assert(sizeof(FMinimapRenderParam) == 0x000090, "Wrong size on FMinimapRenderParam");
static_assert(offsetof(FMinimapRenderParam, MinimapMode) == 0x000000, "Member 'FMinimapRenderParam::MinimapMode' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, Dimensions) == 0x000004, "Member 'FMinimapRenderParam::Dimensions' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, CanvasSize) == 0x000010, "Member 'FMinimapRenderParam::CanvasSize' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, CanvasLocation) == 0x00001C, "Member 'FMinimapRenderParam::CanvasLocation' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, CenterLocation) == 0x000028, "Member 'FMinimapRenderParam::CenterLocation' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, PlayerTransform) == 0x000040, "Member 'FMinimapRenderParam::PlayerTransform' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, Zoom) == 0x000070, "Member 'FMinimapRenderParam::Zoom' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, ShowingMapId) == 0x000074, "Member 'FMinimapRenderParam::ShowingMapId' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, ShowingAreaId) == 0x000078, "Member 'FMinimapRenderParam::ShowingAreaId' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, IconSortType) == 0x00007C, "Member 'FMinimapRenderParam::IconSortType' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, RotateMinimap) == 0x00007D, "Member 'FMinimapRenderParam::RotateMinimap' has a wrong offset!");
static_assert(offsetof(FMinimapRenderParam, CameraAngle) == 0x000080, "Member 'FMinimapRenderParam::CameraAngle' has a wrong offset!");

// ScriptStruct Project.MinimapIconHelpEntry
// 0x0048 (0x0048 - 0x0000)
struct FMinimapIconHelpEntry final
{
public:
	E_MINIMAP_POI_ICON                            M_MinimapIcon;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_NameText;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_HelpText;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   M_HelpLabel;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsHide;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_ICON_HELP_TYPE                      M_Type;                                            // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimapIconHelpEntry) == 0x000008, "Wrong alignment on FMinimapIconHelpEntry");
static_assert(sizeof(FMinimapIconHelpEntry) == 0x000048, "Wrong size on FMinimapIconHelpEntry");
static_assert(offsetof(FMinimapIconHelpEntry, M_MinimapIcon) == 0x000000, "Member 'FMinimapIconHelpEntry::M_MinimapIcon' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpEntry, M_NameText) == 0x000008, "Member 'FMinimapIconHelpEntry::M_NameText' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpEntry, M_HelpText) == 0x000020, "Member 'FMinimapIconHelpEntry::M_HelpText' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpEntry, M_HelpLabel) == 0x000038, "Member 'FMinimapIconHelpEntry::M_HelpLabel' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpEntry, M_IsHide) == 0x000040, "Member 'FMinimapIconHelpEntry::M_IsHide' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpEntry, M_Type) == 0x000041, "Member 'FMinimapIconHelpEntry::M_Type' has a wrong offset!");

// ScriptStruct Project.MinimapIconHelpData
// 0x001C (0x001C - 0x0000)
struct FMinimapIconHelpData final
{
public:
	E_MINIMAP_POI_ICON                            M_MinimapIcon;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Daath;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Map030;                                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Map016;                                          // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Map035;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Map036;                                          // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Map038;                                          // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_SchoolNormal;                                    // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_SchoolAttack;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Tokyo;                                           // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_MyRoom;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Labo;                                            // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_NameLabel;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_HelpLabel;                                       // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapIconHelpData) == 0x000004, "Wrong alignment on FMinimapIconHelpData");
static_assert(sizeof(FMinimapIconHelpData) == 0x00001C, "Wrong size on FMinimapIconHelpData");
static_assert(offsetof(FMinimapIconHelpData, M_MinimapIcon) == 0x000000, "Member 'FMinimapIconHelpData::M_MinimapIcon' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_Daath) == 0x000001, "Member 'FMinimapIconHelpData::M_Daath' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_Map030) == 0x000002, "Member 'FMinimapIconHelpData::M_Map030' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_Map016) == 0x000003, "Member 'FMinimapIconHelpData::M_Map016' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_Map035) == 0x000004, "Member 'FMinimapIconHelpData::M_Map035' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_Map036) == 0x000005, "Member 'FMinimapIconHelpData::M_Map036' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_Map038) == 0x000006, "Member 'FMinimapIconHelpData::M_Map038' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_SchoolNormal) == 0x000007, "Member 'FMinimapIconHelpData::M_SchoolNormal' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_SchoolAttack) == 0x000008, "Member 'FMinimapIconHelpData::M_SchoolAttack' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_Tokyo) == 0x000009, "Member 'FMinimapIconHelpData::M_Tokyo' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_MyRoom) == 0x00000A, "Member 'FMinimapIconHelpData::M_MyRoom' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_Labo) == 0x00000B, "Member 'FMinimapIconHelpData::M_Labo' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_NameLabel) == 0x00000C, "Member 'FMinimapIconHelpData::M_NameLabel' has a wrong offset!");
static_assert(offsetof(FMinimapIconHelpData, M_HelpLabel) == 0x000014, "Member 'FMinimapIconHelpData::M_HelpLabel' has a wrong offset!");

// ScriptStruct Project.MinimapIconTableHelper
// 0x000C (0x000C - 0x0000)
struct FMinimapIconTableHelper final
{
public:
	E_MINIMAP_POI_TYPE                            POIType;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_POI_ICON                            MinimapIcon;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DataId;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CalcDataId;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvisibleTillSave;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimapIconTableHelper) == 0x000004, "Wrong alignment on FMinimapIconTableHelper");
static_assert(sizeof(FMinimapIconTableHelper) == 0x00000C, "Wrong size on FMinimapIconTableHelper");
static_assert(offsetof(FMinimapIconTableHelper, POIType) == 0x000000, "Member 'FMinimapIconTableHelper::POIType' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableHelper, MinimapIcon) == 0x000001, "Member 'FMinimapIconTableHelper::MinimapIcon' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableHelper, DataId) == 0x000004, "Member 'FMinimapIconTableHelper::DataId' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableHelper, CalcDataId) == 0x000008, "Member 'FMinimapIconTableHelper::CalcDataId' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableHelper, InvisibleTillSave) == 0x000009, "Member 'FMinimapIconTableHelper::InvisibleTillSave' has a wrong offset!");

// ScriptStruct Project.MinimapIconTableRow
// 0x0050 (0x0058 - 0x0008)
struct FMinimapIconTableRow final : public FTableRowBase
{
public:
	E_MINIMAP_POI_TYPE                            POIType;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_POI_ICON                            MinimapIcon;                                       // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapId;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataId;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveId;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvisibleTillSave;                                 // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideInOtherMap;                                    // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowFar;                                           // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MainRoute;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Not2D;                                             // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OnFlag;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OffFlag;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InactiveFlag;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RotateZ;                                           // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DrawOffset;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapIconTableRow) == 0x000008, "Wrong alignment on FMinimapIconTableRow");
static_assert(sizeof(FMinimapIconTableRow) == 0x000058, "Wrong size on FMinimapIconTableRow");
static_assert(offsetof(FMinimapIconTableRow, POIType) == 0x000008, "Member 'FMinimapIconTableRow::POIType' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, MinimapIcon) == 0x000009, "Member 'FMinimapIconTableRow::MinimapIcon' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, MapId) == 0x00000C, "Member 'FMinimapIconTableRow::MapId' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, AreaId) == 0x000010, "Member 'FMinimapIconTableRow::AreaId' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, DataId) == 0x000014, "Member 'FMinimapIconTableRow::DataId' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, SaveId) == 0x000018, "Member 'FMinimapIconTableRow::SaveId' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, InvisibleTillSave) == 0x00001C, "Member 'FMinimapIconTableRow::InvisibleTillSave' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, HideInOtherMap) == 0x00001D, "Member 'FMinimapIconTableRow::HideInOtherMap' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, ShowFar) == 0x00001E, "Member 'FMinimapIconTableRow::ShowFar' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, MainRoute) == 0x000020, "Member 'FMinimapIconTableRow::MainRoute' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, Not2D) == 0x000024, "Member 'FMinimapIconTableRow::Not2D' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, OnFlag) == 0x000028, "Member 'FMinimapIconTableRow::OnFlag' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, OffFlag) == 0x000030, "Member 'FMinimapIconTableRow::OffFlag' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, InactiveFlag) == 0x000038, "Member 'FMinimapIconTableRow::InactiveFlag' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, WorldLocation) == 0x000040, "Member 'FMinimapIconTableRow::WorldLocation' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, RotateZ) == 0x00004C, "Member 'FMinimapIconTableRow::RotateZ' has a wrong offset!");
static_assert(offsetof(FMinimapIconTableRow, DrawOffset) == 0x000050, "Member 'FMinimapIconTableRow::DrawOffset' has a wrong offset!");

// ScriptStruct Project.MinimapPOIOneMapData
// 0x0020 (0x0020 - 0x0000)
struct FMinimapPOIOneMapData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TableIndex;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMinimapPOIEntry>               M_POIEntries;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapPOIOneMapData) == 0x000008, "Wrong alignment on FMinimapPOIOneMapData");
static_assert(sizeof(FMinimapPOIOneMapData) == 0x000020, "Wrong size on FMinimapPOIOneMapData");
static_assert(offsetof(FMinimapPOIOneMapData, M_MapID) == 0x000000, "Member 'FMinimapPOIOneMapData::M_MapID' has a wrong offset!");
static_assert(offsetof(FMinimapPOIOneMapData, M_AreaId) == 0x000004, "Member 'FMinimapPOIOneMapData::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMinimapPOIOneMapData, M_TableIndex) == 0x000008, "Member 'FMinimapPOIOneMapData::M_TableIndex' has a wrong offset!");
static_assert(offsetof(FMinimapPOIOneMapData, M_POIEntries) == 0x000010, "Member 'FMinimapPOIOneMapData::M_POIEntries' has a wrong offset!");

// ScriptStruct Project.MinimapRadarEntry
// 0x001C (0x001C - 0x0000)
struct FMinimapRadarEntry final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_TargetSaveUniqueId;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_VISIBILITY                          M_Visibility;                                      // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_ScreenLocation;                                  // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimapRadarEntry) == 0x000004, "Wrong alignment on FMinimapRadarEntry");
static_assert(sizeof(FMinimapRadarEntry) == 0x00001C, "Wrong size on FMinimapRadarEntry");
static_assert(offsetof(FMinimapRadarEntry, M_MapID) == 0x000000, "Member 'FMinimapRadarEntry::M_MapID' has a wrong offset!");
static_assert(offsetof(FMinimapRadarEntry, M_AreaId) == 0x000004, "Member 'FMinimapRadarEntry::M_AreaId' has a wrong offset!");
static_assert(offsetof(FMinimapRadarEntry, M_TargetSaveUniqueId) == 0x000008, "Member 'FMinimapRadarEntry::M_TargetSaveUniqueId' has a wrong offset!");
static_assert(offsetof(FMinimapRadarEntry, M_Visibility) == 0x00000C, "Member 'FMinimapRadarEntry::M_Visibility' has a wrong offset!");
static_assert(offsetof(FMinimapRadarEntry, M_ScreenLocation) == 0x000010, "Member 'FMinimapRadarEntry::M_ScreenLocation' has a wrong offset!");

// ScriptStruct Project.MissionUpdateInfo
// 0x001C (0x001C - 0x0000)
struct FMissionUpdateInfo final
{
public:
	int32                                         MissionId;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CondIndex;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentValue;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMissionCondData                       CondData;                                          // 0x000C(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionUpdateInfo) == 0x000004, "Wrong alignment on FMissionUpdateInfo");
static_assert(sizeof(FMissionUpdateInfo) == 0x00001C, "Wrong size on FMissionUpdateInfo");
static_assert(offsetof(FMissionUpdateInfo, MissionId) == 0x000000, "Member 'FMissionUpdateInfo::MissionId' has a wrong offset!");
static_assert(offsetof(FMissionUpdateInfo, CondIndex) == 0x000004, "Member 'FMissionUpdateInfo::CondIndex' has a wrong offset!");
static_assert(offsetof(FMissionUpdateInfo, CurrentValue) == 0x000008, "Member 'FMissionUpdateInfo::CurrentValue' has a wrong offset!");
static_assert(offsetof(FMissionUpdateInfo, CondData) == 0x00000C, "Member 'FMissionUpdateInfo::CondData' has a wrong offset!");

// ScriptStruct Project.MissionRewardData
// 0x0008 (0x0008 - 0x0000)
struct FMissionRewardData final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionRewardData) == 0x000004, "Wrong alignment on FMissionRewardData");
static_assert(sizeof(FMissionRewardData) == 0x000008, "Wrong size on FMissionRewardData");
static_assert(offsetof(FMissionRewardData, ID) == 0x000000, "Member 'FMissionRewardData::ID' has a wrong offset!");
static_assert(offsetof(FMissionRewardData, Num) == 0x000004, "Member 'FMissionRewardData::Num' has a wrong offset!");

// ScriptStruct Project.MissionTimeAttackData
// 0x0008 (0x0008 - 0x0000)
struct FMissionTimeAttackData final
{
public:
	int32                                         MoonAgeNum;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnFlag;                                            // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionTimeAttackData) == 0x000004, "Wrong alignment on FMissionTimeAttackData");
static_assert(sizeof(FMissionTimeAttackData) == 0x000008, "Wrong size on FMissionTimeAttackData");
static_assert(offsetof(FMissionTimeAttackData, MoonAgeNum) == 0x000000, "Member 'FMissionTimeAttackData::MoonAgeNum' has a wrong offset!");
static_assert(offsetof(FMissionTimeAttackData, OnFlag) == 0x000004, "Member 'FMissionTimeAttackData::OnFlag' has a wrong offset!");

// ScriptStruct Project.MissionData
// 0x00B8 (0x00B8 - 0x0000)
struct FMissionData final
{
public:
	int32                                         MissionId;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortID;                                            // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHideReward;                                      // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHideCond;                                        // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTimeAttack;                                      // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCondUnlimited;                                   // 0x000B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MISSION_MAJOR_TYPE                          MajorType;                                         // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MISSION_TYPE                                Type;                                              // 0x000D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MISSION_REPEAT_TYPE                         RepeatType;                                        // 0x000E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMissionRewardData>             Rewards;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RewardMoney;                                       // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardExp;                                         // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMissionCondData>               CompleteConds;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CompleteOnFlags;                                   // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CompleteOffFlags;                                  // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AllCompleteOnFlag;                                 // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntryOnFlag;                                       // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMissionEntryCond                      EntryCond;                                         // 0x0060(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMissionTimeAttackData                 TimeAttack;                                        // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 PlaceMessageID;                                    // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMissionTargetIcon>             TargetIcons;                                       // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReportMapId;                                       // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReportAreaId;                                      // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedLevel;                                     // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionData) == 0x000008, "Wrong alignment on FMissionData");
static_assert(sizeof(FMissionData) == 0x0000B8, "Wrong size on FMissionData");
static_assert(offsetof(FMissionData, MissionId) == 0x000000, "Member 'FMissionData::MissionId' has a wrong offset!");
static_assert(offsetof(FMissionData, SortID) == 0x000004, "Member 'FMissionData::SortID' has a wrong offset!");
static_assert(offsetof(FMissionData, IsHideReward) == 0x000008, "Member 'FMissionData::IsHideReward' has a wrong offset!");
static_assert(offsetof(FMissionData, IsHideCond) == 0x000009, "Member 'FMissionData::IsHideCond' has a wrong offset!");
static_assert(offsetof(FMissionData, IsTimeAttack) == 0x00000A, "Member 'FMissionData::IsTimeAttack' has a wrong offset!");
static_assert(offsetof(FMissionData, IsCondUnlimited) == 0x00000B, "Member 'FMissionData::IsCondUnlimited' has a wrong offset!");
static_assert(offsetof(FMissionData, MajorType) == 0x00000C, "Member 'FMissionData::MajorType' has a wrong offset!");
static_assert(offsetof(FMissionData, Type) == 0x00000D, "Member 'FMissionData::Type' has a wrong offset!");
static_assert(offsetof(FMissionData, RepeatType) == 0x00000E, "Member 'FMissionData::RepeatType' has a wrong offset!");
static_assert(offsetof(FMissionData, Rewards) == 0x000010, "Member 'FMissionData::Rewards' has a wrong offset!");
static_assert(offsetof(FMissionData, RewardMoney) == 0x000020, "Member 'FMissionData::RewardMoney' has a wrong offset!");
static_assert(offsetof(FMissionData, RewardExp) == 0x000024, "Member 'FMissionData::RewardExp' has a wrong offset!");
static_assert(offsetof(FMissionData, CompleteConds) == 0x000028, "Member 'FMissionData::CompleteConds' has a wrong offset!");
static_assert(offsetof(FMissionData, CompleteOnFlags) == 0x000038, "Member 'FMissionData::CompleteOnFlags' has a wrong offset!");
static_assert(offsetof(FMissionData, CompleteOffFlags) == 0x000048, "Member 'FMissionData::CompleteOffFlags' has a wrong offset!");
static_assert(offsetof(FMissionData, AllCompleteOnFlag) == 0x000058, "Member 'FMissionData::AllCompleteOnFlag' has a wrong offset!");
static_assert(offsetof(FMissionData, EntryOnFlag) == 0x00005C, "Member 'FMissionData::EntryOnFlag' has a wrong offset!");
static_assert(offsetof(FMissionData, EntryCond) == 0x000060, "Member 'FMissionData::EntryCond' has a wrong offset!");
static_assert(offsetof(FMissionData, TimeAttack) == 0x000080, "Member 'FMissionData::TimeAttack' has a wrong offset!");
static_assert(offsetof(FMissionData, PlaceMessageID) == 0x000088, "Member 'FMissionData::PlaceMessageID' has a wrong offset!");
static_assert(offsetof(FMissionData, TargetIcons) == 0x000098, "Member 'FMissionData::TargetIcons' has a wrong offset!");
static_assert(offsetof(FMissionData, ReportMapId) == 0x0000A8, "Member 'FMissionData::ReportMapId' has a wrong offset!");
static_assert(offsetof(FMissionData, ReportAreaId) == 0x0000AC, "Member 'FMissionData::ReportAreaId' has a wrong offset!");
static_assert(offsetof(FMissionData, ExpectedLevel) == 0x0000B0, "Member 'FMissionData::ExpectedLevel' has a wrong offset!");

// ScriptStruct Project.MovieSceneAllMaterialSectionTemplate
// 0x0030 (0x0050 - 0x0020)
struct FMovieSceneAllMaterialSectionTemplate final : public FMovieSceneEvalTemplate
{
public:
	TArray<struct FScalarParameterNameAndCurve>   Scalars;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVectorParameterNameAndCurves>  Vectors;                                           // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FColorParameterNameAndCurves>   Colors;                                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMovieSceneAllMaterialSectionTemplate) == 0x000008, "Wrong alignment on FMovieSceneAllMaterialSectionTemplate");
static_assert(sizeof(FMovieSceneAllMaterialSectionTemplate) == 0x000050, "Wrong size on FMovieSceneAllMaterialSectionTemplate");
static_assert(offsetof(FMovieSceneAllMaterialSectionTemplate, Scalars) == 0x000020, "Member 'FMovieSceneAllMaterialSectionTemplate::Scalars' has a wrong offset!");
static_assert(offsetof(FMovieSceneAllMaterialSectionTemplate, Vectors) == 0x000030, "Member 'FMovieSceneAllMaterialSectionTemplate::Vectors' has a wrong offset!");
static_assert(offsetof(FMovieSceneAllMaterialSectionTemplate, Colors) == 0x000040, "Member 'FMovieSceneAllMaterialSectionTemplate::Colors' has a wrong offset!");

// ScriptStruct Project.NaviDevilGimmickActors
// 0x0020 (0x0020 - 0x0000)
struct FNaviDevilGimmickActors final
{
public:
	int32                                         M_Category;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_Actors;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_ExistNum;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNaviDevilGimmickActors) == 0x000008, "Wrong alignment on FNaviDevilGimmickActors");
static_assert(sizeof(FNaviDevilGimmickActors) == 0x000020, "Wrong size on FNaviDevilGimmickActors");
static_assert(offsetof(FNaviDevilGimmickActors, M_Category) == 0x000000, "Member 'FNaviDevilGimmickActors::M_Category' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickActors, M_Actors) == 0x000008, "Member 'FNaviDevilGimmickActors::M_Actors' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickActors, M_ExistNum) == 0x000018, "Member 'FNaviDevilGimmickActors::M_ExistNum' has a wrong offset!");

// ScriptStruct Project.NaviDevilGimmickData
// 0x0050 (0x0050 - 0x0000)
struct FNaviDevilGimmickData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Index;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ExcavateType;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StartFlag;                                       // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndFlag;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_NaviDevilCond;                                   // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_ItemRate;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EncountPackIndex;                                // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EncountOnFlag;                                   // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ChainEncountRate;                                // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_NoChainEncount;                                  // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_PlayerFirst;                                     // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ChainEncountPackIndex;                           // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNaviDevilGimmickItemData>      M_ItemInfo;                                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNaviDevilGimmickData) == 0x000008, "Wrong alignment on FNaviDevilGimmickData");
static_assert(sizeof(FNaviDevilGimmickData) == 0x000050, "Wrong size on FNaviDevilGimmickData");
static_assert(offsetof(FNaviDevilGimmickData, M_MapID) == 0x000000, "Member 'FNaviDevilGimmickData::M_MapID' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_Index) == 0x000004, "Member 'FNaviDevilGimmickData::M_Index' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_ExcavateType) == 0x000008, "Member 'FNaviDevilGimmickData::M_ExcavateType' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_StartFlag) == 0x00000C, "Member 'FNaviDevilGimmickData::M_StartFlag' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_EndFlag) == 0x000010, "Member 'FNaviDevilGimmickData::M_EndFlag' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_NaviDevilCond) == 0x000018, "Member 'FNaviDevilGimmickData::M_NaviDevilCond' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_ItemRate) == 0x000028, "Member 'FNaviDevilGimmickData::M_ItemRate' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_EncountPackIndex) == 0x00002C, "Member 'FNaviDevilGimmickData::M_EncountPackIndex' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_EncountOnFlag) == 0x000030, "Member 'FNaviDevilGimmickData::M_EncountOnFlag' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_ChainEncountRate) == 0x000034, "Member 'FNaviDevilGimmickData::M_ChainEncountRate' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_NoChainEncount) == 0x000038, "Member 'FNaviDevilGimmickData::M_NoChainEncount' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_PlayerFirst) == 0x000039, "Member 'FNaviDevilGimmickData::M_PlayerFirst' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_ChainEncountPackIndex) == 0x00003C, "Member 'FNaviDevilGimmickData::M_ChainEncountPackIndex' has a wrong offset!");
static_assert(offsetof(FNaviDevilGimmickData, M_ItemInfo) == 0x000040, "Member 'FNaviDevilGimmickData::M_ItemInfo' has a wrong offset!");

// ScriptStruct Project.OptionSaveBuffer
// 0x0013 (0x0013 - 0x0000)
struct FOptionSaveBuffer final
{
public:
	uint8                                         Pad_0[0x13];                                       // 0x0000(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOptionSaveBuffer) == 0x000001, "Wrong alignment on FOptionSaveBuffer");
static_assert(sizeof(FOptionSaveBuffer) == 0x000013, "Wrong size on FOptionSaveBuffer");

// ScriptStruct Project.ActionMappingInfoRow
// 0x0028 (0x0030 - 0x0008)
struct FActionMappingInfoRow final : public FTableRowBase
{
public:
	E_ACTION_MAPPING_TYPE                         ActionMapping;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0010(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MainKey;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionMappingInfoRow) == 0x000008, "Wrong alignment on FActionMappingInfoRow");
static_assert(sizeof(FActionMappingInfoRow) == 0x000030, "Wrong size on FActionMappingInfoRow");
static_assert(offsetof(FActionMappingInfoRow, ActionMapping) == 0x000008, "Member 'FActionMappingInfoRow::ActionMapping' has a wrong offset!");
static_assert(offsetof(FActionMappingInfoRow, Key) == 0x000010, "Member 'FActionMappingInfoRow::Key' has a wrong offset!");
static_assert(offsetof(FActionMappingInfoRow, MainKey) == 0x000028, "Member 'FActionMappingInfoRow::MainKey' has a wrong offset!");

// ScriptStruct Project.UniteDataTable
// 0x0010 (0x0010 - 0x0000)
struct FUniteDataTable final
{
public:
	int32                                         UnitePlus;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccidentMissDevil;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccidentUpperLv;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccidentLowerLv;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteDataTable) == 0x000004, "Wrong alignment on FUniteDataTable");
static_assert(sizeof(FUniteDataTable) == 0x000010, "Wrong size on FUniteDataTable");
static_assert(offsetof(FUniteDataTable, UnitePlus) == 0x000000, "Member 'FUniteDataTable::UnitePlus' has a wrong offset!");
static_assert(offsetof(FUniteDataTable, AccidentMissDevil) == 0x000004, "Member 'FUniteDataTable::AccidentMissDevil' has a wrong offset!");
static_assert(offsetof(FUniteDataTable, AccidentUpperLv) == 0x000008, "Member 'FUniteDataTable::AccidentUpperLv' has a wrong offset!");
static_assert(offsetof(FUniteDataTable, AccidentLowerLv) == 0x00000C, "Member 'FUniteDataTable::AccidentLowerLv' has a wrong offset!");

// ScriptStruct Project.AxisMappingNameRow
// 0x0010 (0x0018 - 0x0008)
struct FAxisMappingNameRow final : public FTableRowBase
{
public:
	class FName                                   MappingName;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AXIS_MAPPING_TYPE                           EnumValue;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAxisMappingNameRow) == 0x000008, "Wrong alignment on FAxisMappingNameRow");
static_assert(sizeof(FAxisMappingNameRow) == 0x000018, "Wrong size on FAxisMappingNameRow");
static_assert(offsetof(FAxisMappingNameRow, MappingName) == 0x000008, "Member 'FAxisMappingNameRow::MappingName' has a wrong offset!");
static_assert(offsetof(FAxisMappingNameRow, EnumValue) == 0x000010, "Member 'FAxisMappingNameRow::EnumValue' has a wrong offset!");

// ScriptStruct Project.BlueprintActionPadDelegateBinding
// 0x0014 (0x0018 - 0x0004)
struct FBlueprintActionPadDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	class FName                                   InputActionName;                                   // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_INPUT_TYPE                                  InputType;                                         // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FunctionNameToBind;                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintActionPadDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintActionPadDelegateBinding");
static_assert(sizeof(FBlueprintActionPadDelegateBinding) == 0x000018, "Wrong size on FBlueprintActionPadDelegateBinding");
static_assert(offsetof(FBlueprintActionPadDelegateBinding, InputActionName) == 0x000004, "Member 'FBlueprintActionPadDelegateBinding::InputActionName' has a wrong offset!");
static_assert(offsetof(FBlueprintActionPadDelegateBinding, InputType) == 0x00000C, "Member 'FBlueprintActionPadDelegateBinding::InputType' has a wrong offset!");
static_assert(offsetof(FBlueprintActionPadDelegateBinding, FunctionNameToBind) == 0x000010, "Member 'FBlueprintActionPadDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Project.PathPoint
// 0x0070 (0x0070 - 0x0000)
struct FPathPoint final
{
public:
	float                                         InputKey;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArriveTangent;                                     // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeaveTangent;                                      // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0030(0x0010)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Param1;                                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param2;                                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param3;                                            // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param4;                                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param5;                                            // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param6;                                            // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param7;                                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param8;                                            // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplinePointType                              Type;                                              // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathPoint) == 0x000010, "Wrong alignment on FPathPoint");
static_assert(sizeof(FPathPoint) == 0x000070, "Wrong size on FPathPoint");
static_assert(offsetof(FPathPoint, InputKey) == 0x000000, "Member 'FPathPoint::InputKey' has a wrong offset!");
static_assert(offsetof(FPathPoint, Position) == 0x000004, "Member 'FPathPoint::Position' has a wrong offset!");
static_assert(offsetof(FPathPoint, ArriveTangent) == 0x000010, "Member 'FPathPoint::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FPathPoint, LeaveTangent) == 0x00001C, "Member 'FPathPoint::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FPathPoint, Rotation) == 0x000030, "Member 'FPathPoint::Rotation' has a wrong offset!");
static_assert(offsetof(FPathPoint, Param1) == 0x000040, "Member 'FPathPoint::Param1' has a wrong offset!");
static_assert(offsetof(FPathPoint, Param2) == 0x000044, "Member 'FPathPoint::Param2' has a wrong offset!");
static_assert(offsetof(FPathPoint, Param3) == 0x000048, "Member 'FPathPoint::Param3' has a wrong offset!");
static_assert(offsetof(FPathPoint, Param4) == 0x00004C, "Member 'FPathPoint::Param4' has a wrong offset!");
static_assert(offsetof(FPathPoint, Param5) == 0x000050, "Member 'FPathPoint::Param5' has a wrong offset!");
static_assert(offsetof(FPathPoint, Param6) == 0x000054, "Member 'FPathPoint::Param6' has a wrong offset!");
static_assert(offsetof(FPathPoint, Param7) == 0x000058, "Member 'FPathPoint::Param7' has a wrong offset!");
static_assert(offsetof(FPathPoint, Param8) == 0x00005C, "Member 'FPathPoint::Param8' has a wrong offset!");
static_assert(offsetof(FPathPoint, Type) == 0x000060, "Member 'FPathPoint::Type' has a wrong offset!");

// ScriptStruct Project.UniteSeireiBornTable
// 0x000C (0x000C - 0x0000)
struct FUniteSeireiBornTable final
{
public:
	int32                                         Group1;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Group2;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Soul;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteSeireiBornTable) == 0x000004, "Wrong alignment on FUniteSeireiBornTable");
static_assert(sizeof(FUniteSeireiBornTable) == 0x00000C, "Wrong size on FUniteSeireiBornTable");
static_assert(offsetof(FUniteSeireiBornTable, Group1) == 0x000000, "Member 'FUniteSeireiBornTable::Group1' has a wrong offset!");
static_assert(offsetof(FUniteSeireiBornTable, Group2) == 0x000004, "Member 'FUniteSeireiBornTable::Group2' has a wrong offset!");
static_assert(offsetof(FUniteSeireiBornTable, Soul) == 0x000008, "Member 'FUniteSeireiBornTable::Soul' has a wrong offset!");

// ScriptStruct Project.PieceData
// 0x000C (0x000C - 0x0000)
struct FPieceData final
{
public:
	E_PIECE_TYPE                                  M_Type;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Param;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Num;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPieceData) == 0x000004, "Wrong alignment on FPieceData");
static_assert(sizeof(FPieceData) == 0x00000C, "Wrong size on FPieceData");
static_assert(offsetof(FPieceData, M_Type) == 0x000000, "Member 'FPieceData::M_Type' has a wrong offset!");
static_assert(offsetof(FPieceData, M_Param) == 0x000004, "Member 'FPieceData::M_Param' has a wrong offset!");
static_assert(offsetof(FPieceData, M_Num) == 0x000008, "Member 'FPieceData::M_Num' has a wrong offset!");

// ScriptStruct Project.PopUpIconEntry
// 0x0030 (0x0030 - 0x0000)
struct FPopUpIconEntry final
{
public:
	bool                                          M_IsExist;                                         // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_WorldLocation;                                   // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_ScreenLocation;                                  // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ImageScale;                                      // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_POP_UP_ICON_TYPE                            M_IconType;                                        // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ACustomPawn>             M_Owner;                                           // 0x0024(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MINIMAP_VISIBILITY                          M_Visibility;                                      // 0x002C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPopUpIconEntry) == 0x000004, "Wrong alignment on FPopUpIconEntry");
static_assert(sizeof(FPopUpIconEntry) == 0x000030, "Wrong size on FPopUpIconEntry");
static_assert(offsetof(FPopUpIconEntry, M_IsExist) == 0x000000, "Member 'FPopUpIconEntry::M_IsExist' has a wrong offset!");
static_assert(offsetof(FPopUpIconEntry, M_WorldLocation) == 0x000004, "Member 'FPopUpIconEntry::M_WorldLocation' has a wrong offset!");
static_assert(offsetof(FPopUpIconEntry, M_ScreenLocation) == 0x000010, "Member 'FPopUpIconEntry::M_ScreenLocation' has a wrong offset!");
static_assert(offsetof(FPopUpIconEntry, M_ImageScale) == 0x00001C, "Member 'FPopUpIconEntry::M_ImageScale' has a wrong offset!");
static_assert(offsetof(FPopUpIconEntry, M_IconType) == 0x000020, "Member 'FPopUpIconEntry::M_IconType' has a wrong offset!");
static_assert(offsetof(FPopUpIconEntry, M_Owner) == 0x000024, "Member 'FPopUpIconEntry::M_Owner' has a wrong offset!");
static_assert(offsetof(FPopUpIconEntry, M_Visibility) == 0x00002C, "Member 'FPopUpIconEntry::M_Visibility' has a wrong offset!");

// ScriptStruct Project.ProjectSubLevelStatus
// 0x0038 (0x0038 - 0x0000)
struct FProjectSubLevelStatus final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BaseName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectStreamingStatus                       StreamingStatus;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODIndex;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerInside;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBeVisible;                                  // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightScenario;                                    // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightVolumeAdded;                                 // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVolumetricLightmapDataExist;                      // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0xB];                                       // 0x0025(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bVolumetricLightmapAdded;                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectSubLevelStatus) == 0x000008, "Wrong alignment on FProjectSubLevelStatus");
static_assert(sizeof(FProjectSubLevelStatus) == 0x000038, "Wrong size on FProjectSubLevelStatus");
static_assert(offsetof(FProjectSubLevelStatus, PackageName) == 0x000000, "Member 'FProjectSubLevelStatus::PackageName' has a wrong offset!");
static_assert(offsetof(FProjectSubLevelStatus, BaseName) == 0x000008, "Member 'FProjectSubLevelStatus::BaseName' has a wrong offset!");
static_assert(offsetof(FProjectSubLevelStatus, StreamingStatus) == 0x000018, "Member 'FProjectSubLevelStatus::StreamingStatus' has a wrong offset!");
static_assert(offsetof(FProjectSubLevelStatus, LODIndex) == 0x00001C, "Member 'FProjectSubLevelStatus::LODIndex' has a wrong offset!");
static_assert(offsetof(FProjectSubLevelStatus, bPlayerInside) == 0x000020, "Member 'FProjectSubLevelStatus::bPlayerInside' has a wrong offset!");
static_assert(offsetof(FProjectSubLevelStatus, bShouldBeVisible) == 0x000021, "Member 'FProjectSubLevelStatus::bShouldBeVisible' has a wrong offset!");
static_assert(offsetof(FProjectSubLevelStatus, bLightScenario) == 0x000022, "Member 'FProjectSubLevelStatus::bLightScenario' has a wrong offset!");
static_assert(offsetof(FProjectSubLevelStatus, bLightVolumeAdded) == 0x000023, "Member 'FProjectSubLevelStatus::bLightVolumeAdded' has a wrong offset!");
static_assert(offsetof(FProjectSubLevelStatus, bVolumetricLightmapDataExist) == 0x000024, "Member 'FProjectSubLevelStatus::bVolumetricLightmapDataExist' has a wrong offset!");
static_assert(offsetof(FProjectSubLevelStatus, bVolumetricLightmapAdded) == 0x000030, "Member 'FProjectSubLevelStatus::bVolumetricLightmapAdded' has a wrong offset!");

// ScriptStruct Project.ProjectWindowState
// 0x001C (0x001C - 0x0000)
struct FProjectWindowState final
{
public:
	EWindowsWindowMode                            WindowMode;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              Resolution;                                        // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MonitorIndex;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              Position;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMaximized;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectWindowState) == 0x000004, "Wrong alignment on FProjectWindowState");
static_assert(sizeof(FProjectWindowState) == 0x00001C, "Wrong size on FProjectWindowState");
static_assert(offsetof(FProjectWindowState, WindowMode) == 0x000000, "Member 'FProjectWindowState::WindowMode' has a wrong offset!");
static_assert(offsetof(FProjectWindowState, Resolution) == 0x000004, "Member 'FProjectWindowState::Resolution' has a wrong offset!");
static_assert(offsetof(FProjectWindowState, MonitorIndex) == 0x00000C, "Member 'FProjectWindowState::MonitorIndex' has a wrong offset!");
static_assert(offsetof(FProjectWindowState, Position) == 0x000010, "Member 'FProjectWindowState::Position' has a wrong offset!");
static_assert(offsetof(FProjectWindowState, bMaximized) == 0x000018, "Member 'FProjectWindowState::bMaximized' has a wrong offset!");

// ScriptStruct Project.UniteBibleEntryData
// 0x000C (0x000C - 0x0000)
struct FUniteBibleEntryData final
{
public:
	int32                                         DevilID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NkmIndex;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteBibleEntryData) == 0x000004, "Wrong alignment on FUniteBibleEntryData");
static_assert(sizeof(FUniteBibleEntryData) == 0x00000C, "Wrong size on FUniteBibleEntryData");
static_assert(offsetof(FUniteBibleEntryData, DevilID) == 0x000000, "Member 'FUniteBibleEntryData::DevilID' has a wrong offset!");
static_assert(offsetof(FUniteBibleEntryData, NkmIndex) == 0x000004, "Member 'FUniteBibleEntryData::NkmIndex' has a wrong offset!");
static_assert(offsetof(FUniteBibleEntryData, Level) == 0x000008, "Member 'FUniteBibleEntryData::Level' has a wrong offset!");

// ScriptStruct Project.BGMRequest
// 0x0020 (0x0020 - 0x0000)
struct FBGMRequest final
{
public:
	bool                                          bPlayRequest;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopRequest;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          Cue;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFadeType                                     FadeType;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPosition;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceReplay;                                      // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBGMRequest) == 0x000008, "Wrong alignment on FBGMRequest");
static_assert(sizeof(FBGMRequest) == 0x000020, "Wrong size on FBGMRequest");
static_assert(offsetof(FBGMRequest, bPlayRequest) == 0x000000, "Member 'FBGMRequest::bPlayRequest' has a wrong offset!");
static_assert(offsetof(FBGMRequest, bStopRequest) == 0x000001, "Member 'FBGMRequest::bStopRequest' has a wrong offset!");
static_assert(offsetof(FBGMRequest, Cue) == 0x000008, "Member 'FBGMRequest::Cue' has a wrong offset!");
static_assert(offsetof(FBGMRequest, FadeType) == 0x000010, "Member 'FBGMRequest::FadeType' has a wrong offset!");
static_assert(offsetof(FBGMRequest, FadeTime) == 0x000014, "Member 'FBGMRequest::FadeTime' has a wrong offset!");
static_assert(offsetof(FBGMRequest, StartPosition) == 0x000018, "Member 'FBGMRequest::StartPosition' has a wrong offset!");
static_assert(offsetof(FBGMRequest, bForceReplay) == 0x00001C, "Member 'FBGMRequest::bForceReplay' has a wrong offset!");

// ScriptStruct Project.PurposeData
// 0x0028 (0x0028 - 0x0000)
struct FPurposeData final
{
public:
	int32                                         M_PurposeId;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_OldNewRoute                                 M_OldNewRoute;                                     // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_StartFlagValues;                                 // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_EndFlagValue;                                    // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_MessageLabel;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPurposeData) == 0x000008, "Wrong alignment on FPurposeData");
static_assert(sizeof(FPurposeData) == 0x000028, "Wrong size on FPurposeData");
static_assert(offsetof(FPurposeData, M_PurposeId) == 0x000000, "Member 'FPurposeData::M_PurposeId' has a wrong offset!");
static_assert(offsetof(FPurposeData, M_OldNewRoute) == 0x000004, "Member 'FPurposeData::M_OldNewRoute' has a wrong offset!");
static_assert(offsetof(FPurposeData, M_StartFlagValues) == 0x000008, "Member 'FPurposeData::M_StartFlagValues' has a wrong offset!");
static_assert(offsetof(FPurposeData, M_EndFlagValue) == 0x000018, "Member 'FPurposeData::M_EndFlagValue' has a wrong offset!");
static_assert(offsetof(FPurposeData, M_MessageLabel) == 0x00001C, "Member 'FPurposeData::M_MessageLabel' has a wrong offset!");

// ScriptStruct Project.RecordData
// 0x0008 (0x0008 - 0x0000)
struct FRecordData final
{
public:
	int32                                         M_SortId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_RECORD_DISP_TYPE                            M_DispType;                                        // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsDisp;                                          // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecordData) == 0x000004, "Wrong alignment on FRecordData");
static_assert(sizeof(FRecordData) == 0x000008, "Wrong size on FRecordData");
static_assert(offsetof(FRecordData, M_SortId) == 0x000000, "Member 'FRecordData::M_SortId' has a wrong offset!");
static_assert(offsetof(FRecordData, M_DispType) == 0x000004, "Member 'FRecordData::M_DispType' has a wrong offset!");
static_assert(offsetof(FRecordData, M_IsDisp) == 0x000005, "Member 'FRecordData::M_IsDisp' has a wrong offset!");

// ScriptStruct Project.RecordSaveData
// 0x0010 (0x0010 - 0x0000)
struct FRecordSaveData final
{
public:
	TArray<int32>                                 M_Counter;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecordSaveData) == 0x000008, "Wrong alignment on FRecordSaveData");
static_assert(sizeof(FRecordSaveData) == 0x000010, "Wrong size on FRecordSaveData");
static_assert(offsetof(FRecordSaveData, M_Counter) == 0x000000, "Member 'FRecordSaveData::M_Counter' has a wrong offset!");

// ScriptStruct Project.RelicSaveBuffer
// 0x000C (0x000C - 0x0000)
struct FRelicSaveBuffer final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Buffer;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRelicSaveBuffer) == 0x000004, "Wrong alignment on FRelicSaveBuffer");
static_assert(sizeof(FRelicSaveBuffer) == 0x00000C, "Wrong size on FRelicSaveBuffer");
static_assert(offsetof(FRelicSaveBuffer, M_MapID) == 0x000000, "Member 'FRelicSaveBuffer::M_MapID' has a wrong offset!");
static_assert(offsetof(FRelicSaveBuffer, M_AreaId) == 0x000004, "Member 'FRelicSaveBuffer::M_AreaId' has a wrong offset!");
static_assert(offsetof(FRelicSaveBuffer, M_Buffer) == 0x000008, "Member 'FRelicSaveBuffer::M_Buffer' has a wrong offset!");

// ScriptStruct Project.RelicGroupData
// 0x000C (0x000C - 0x0000)
struct FRelicGroupData final
{
public:
	int32                                         M_ItemID;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Num;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Rate;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRelicGroupData) == 0x000004, "Wrong alignment on FRelicGroupData");
static_assert(sizeof(FRelicGroupData) == 0x00000C, "Wrong size on FRelicGroupData");
static_assert(offsetof(FRelicGroupData, M_ItemID) == 0x000000, "Member 'FRelicGroupData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FRelicGroupData, M_Num) == 0x000004, "Member 'FRelicGroupData::M_Num' has a wrong offset!");
static_assert(offsetof(FRelicGroupData, M_Rate) == 0x000008, "Member 'FRelicGroupData::M_Rate' has a wrong offset!");

// ScriptStruct Project.RelicData
// 0x0028 (0x0028 - 0x0000)
struct FRelicData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Index;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RebornTime;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RebornRate;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRelicGroupData>                M_RelicGroup;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_OnFlag;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRelicData) == 0x000008, "Wrong alignment on FRelicData");
static_assert(sizeof(FRelicData) == 0x000028, "Wrong size on FRelicData");
static_assert(offsetof(FRelicData, M_MapID) == 0x000000, "Member 'FRelicData::M_MapID' has a wrong offset!");
static_assert(offsetof(FRelicData, M_Index) == 0x000004, "Member 'FRelicData::M_Index' has a wrong offset!");
static_assert(offsetof(FRelicData, M_RebornTime) == 0x000008, "Member 'FRelicData::M_RebornTime' has a wrong offset!");
static_assert(offsetof(FRelicData, M_RebornRate) == 0x00000C, "Member 'FRelicData::M_RebornRate' has a wrong offset!");
static_assert(offsetof(FRelicData, M_RelicGroup) == 0x000010, "Member 'FRelicData::M_RelicGroup' has a wrong offset!");
static_assert(offsetof(FRelicData, M_OnFlag) == 0x000020, "Member 'FRelicData::M_OnFlag' has a wrong offset!");

// ScriptStruct Project.ResultTopCharaData
// 0x0034 (0x0034 - 0x0000)
struct FResultTopCharaData final
{
public:
	bool                                          M_IsEmpty;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_BeforeLv;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DstLv;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP_Max;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP_Max;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_BefPercent;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DstPercent;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsMaxEnd;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_DevilID;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResultTopCharaData) == 0x000004, "Wrong alignment on FResultTopCharaData");
static_assert(sizeof(FResultTopCharaData) == 0x000034, "Wrong size on FResultTopCharaData");
static_assert(offsetof(FResultTopCharaData, M_IsEmpty) == 0x000000, "Member 'FResultTopCharaData::M_IsEmpty' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_BeforeLv) == 0x000004, "Member 'FResultTopCharaData::M_BeforeLv' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_DstLv) == 0x000008, "Member 'FResultTopCharaData::M_DstLv' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_HP) == 0x00000C, "Member 'FResultTopCharaData::M_HP' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_HP_Max) == 0x000010, "Member 'FResultTopCharaData::M_HP_Max' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_MP) == 0x000014, "Member 'FResultTopCharaData::M_MP' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_MP_Max) == 0x000018, "Member 'FResultTopCharaData::M_MP_Max' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_Exp) == 0x00001C, "Member 'FResultTopCharaData::M_Exp' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_BefPercent) == 0x000020, "Member 'FResultTopCharaData::M_BefPercent' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_DstPercent) == 0x000024, "Member 'FResultTopCharaData::M_DstPercent' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_IsMaxEnd) == 0x000028, "Member 'FResultTopCharaData::M_IsMaxEnd' has a wrong offset!");
static_assert(offsetof(FResultTopCharaData, M_DevilID) == 0x00002C, "Member 'FResultTopCharaData::M_DevilID' has a wrong offset!");

// ScriptStruct Project.UniteAccidentDevilTable
// 0x0004 (0x0004 - 0x0000)
struct FUniteAccidentDevilTable final
{
public:
	int32                                         DevilID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteAccidentDevilTable) == 0x000004, "Wrong alignment on FUniteAccidentDevilTable");
static_assert(sizeof(FUniteAccidentDevilTable) == 0x000004, "Wrong size on FUniteAccidentDevilTable");
static_assert(offsetof(FUniteAccidentDevilTable, DevilID) == 0x000000, "Member 'FUniteAccidentDevilTable::DevilID' has a wrong offset!");

// ScriptStruct Project.ResultTopItem
// 0x000C (0x000C - 0x0000)
struct FResultTopItem final
{
public:
	int32                                         M_IconID;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Num;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResultTopItem) == 0x000004, "Wrong alignment on FResultTopItem");
static_assert(sizeof(FResultTopItem) == 0x00000C, "Wrong size on FResultTopItem");
static_assert(offsetof(FResultTopItem, M_IconID) == 0x000000, "Member 'FResultTopItem::M_IconID' has a wrong offset!");
static_assert(offsetof(FResultTopItem, M_ItemID) == 0x000004, "Member 'FResultTopItem::M_ItemID' has a wrong offset!");
static_assert(offsetof(FResultTopItem, M_Num) == 0x000008, "Member 'FResultTopItem::M_Num' has a wrong offset!");

// ScriptStruct Project.GardenTekiseiUpEventData
// 0x0010 (0x0010 - 0x0000)
struct FGardenTekiseiUpEventData final
{
public:
	E_SKILL_TEKISEI_CATEGORY                      M_Type;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AddValue;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OldValue;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NewValue;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenTekiseiUpEventData) == 0x000004, "Wrong alignment on FGardenTekiseiUpEventData");
static_assert(sizeof(FGardenTekiseiUpEventData) == 0x000010, "Wrong size on FGardenTekiseiUpEventData");
static_assert(offsetof(FGardenTekiseiUpEventData, M_Type) == 0x000000, "Member 'FGardenTekiseiUpEventData::M_Type' has a wrong offset!");
static_assert(offsetof(FGardenTekiseiUpEventData, M_AddValue) == 0x000004, "Member 'FGardenTekiseiUpEventData::M_AddValue' has a wrong offset!");
static_assert(offsetof(FGardenTekiseiUpEventData, M_OldValue) == 0x000008, "Member 'FGardenTekiseiUpEventData::M_OldValue' has a wrong offset!");
static_assert(offsetof(FGardenTekiseiUpEventData, M_NewValue) == 0x00000C, "Member 'FGardenTekiseiUpEventData::M_NewValue' has a wrong offset!");

// ScriptStruct Project.GardenParamUpEventData
// 0x0010 (0x0010 - 0x0000)
struct FGardenParamUpEventData final
{
public:
	E_ABILITYNAME_TYPE                            M_Type;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AddValue;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OldValue;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NewValue;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenParamUpEventData) == 0x000004, "Wrong alignment on FGardenParamUpEventData");
static_assert(sizeof(FGardenParamUpEventData) == 0x000010, "Wrong size on FGardenParamUpEventData");
static_assert(offsetof(FGardenParamUpEventData, M_Type) == 0x000000, "Member 'FGardenParamUpEventData::M_Type' has a wrong offset!");
static_assert(offsetof(FGardenParamUpEventData, M_AddValue) == 0x000004, "Member 'FGardenParamUpEventData::M_AddValue' has a wrong offset!");
static_assert(offsetof(FGardenParamUpEventData, M_OldValue) == 0x000008, "Member 'FGardenParamUpEventData::M_OldValue' has a wrong offset!");
static_assert(offsetof(FGardenParamUpEventData, M_NewValue) == 0x00000C, "Member 'FGardenParamUpEventData::M_NewValue' has a wrong offset!");

// ScriptStruct Project.UIStatusDataUpParam
// 0x0048 (0x0048 - 0x0000)
struct FUIStatusDataUpParam final
{
public:
	int32                                         M_Lv;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAbilData                              M_AbiData;                                         // 0x0008(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_DefenceAishou;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_SkillTekisei;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIStatusDataUpParam) == 0x000008, "Wrong alignment on FUIStatusDataUpParam");
static_assert(sizeof(FUIStatusDataUpParam) == 0x000048, "Wrong size on FUIStatusDataUpParam");
static_assert(offsetof(FUIStatusDataUpParam, M_Lv) == 0x000000, "Member 'FUIStatusDataUpParam::M_Lv' has a wrong offset!");
static_assert(offsetof(FUIStatusDataUpParam, M_Exp) == 0x000004, "Member 'FUIStatusDataUpParam::M_Exp' has a wrong offset!");
static_assert(offsetof(FUIStatusDataUpParam, M_AbiData) == 0x000008, "Member 'FUIStatusDataUpParam::M_AbiData' has a wrong offset!");
static_assert(offsetof(FUIStatusDataUpParam, M_DefenceAishou) == 0x000028, "Member 'FUIStatusDataUpParam::M_DefenceAishou' has a wrong offset!");
static_assert(offsetof(FUIStatusDataUpParam, M_SkillTekisei) == 0x000038, "Member 'FUIStatusDataUpParam::M_SkillTekisei' has a wrong offset!");

// ScriptStruct Project.GardenResultData
// 0x0080 (0x0080 - 0x0000)
struct FGardenResultData final
{
public:
	int32                                         M_NkmIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGardenTekiseiUpEventData>      M_TekiseiUpData;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGardenParamUpEventData>        M_ParamUpData;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_GetNewSkill;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIStatusDataUpParam                   M_StatusTotalUpData;                               // 0x0030(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         M_AddSkillRank;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HeroBonusPoint;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGardenResultData) == 0x000008, "Wrong alignment on FGardenResultData");
static_assert(sizeof(FGardenResultData) == 0x000080, "Wrong size on FGardenResultData");
static_assert(offsetof(FGardenResultData, M_NkmIndex) == 0x000000, "Member 'FGardenResultData::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FGardenResultData, M_TekiseiUpData) == 0x000008, "Member 'FGardenResultData::M_TekiseiUpData' has a wrong offset!");
static_assert(offsetof(FGardenResultData, M_ParamUpData) == 0x000018, "Member 'FGardenResultData::M_ParamUpData' has a wrong offset!");
static_assert(offsetof(FGardenResultData, M_GetNewSkill) == 0x000028, "Member 'FGardenResultData::M_GetNewSkill' has a wrong offset!");
static_assert(offsetof(FGardenResultData, M_StatusTotalUpData) == 0x000030, "Member 'FGardenResultData::M_StatusTotalUpData' has a wrong offset!");
static_assert(offsetof(FGardenResultData, M_AddSkillRank) == 0x000078, "Member 'FGardenResultData::M_AddSkillRank' has a wrong offset!");
static_assert(offsetof(FGardenResultData, M_HeroBonusPoint) == 0x00007C, "Member 'FGardenResultData::M_HeroBonusPoint' has a wrong offset!");

// ScriptStruct Project.RyuketsuChangeName
// 0x0018 (0x0018 - 0x0000)
struct FRyuketsuChangeName final
{
public:
	class FName                                   M_BeforeLabel;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_AfterLabel;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StartFlag;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndFlag;                                         // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRyuketsuChangeName) == 0x000004, "Wrong alignment on FRyuketsuChangeName");
static_assert(sizeof(FRyuketsuChangeName) == 0x000018, "Wrong size on FRyuketsuChangeName");
static_assert(offsetof(FRyuketsuChangeName, M_BeforeLabel) == 0x000000, "Member 'FRyuketsuChangeName::M_BeforeLabel' has a wrong offset!");
static_assert(offsetof(FRyuketsuChangeName, M_AfterLabel) == 0x000008, "Member 'FRyuketsuChangeName::M_AfterLabel' has a wrong offset!");
static_assert(offsetof(FRyuketsuChangeName, M_StartFlag) == 0x000010, "Member 'FRyuketsuChangeName::M_StartFlag' has a wrong offset!");
static_assert(offsetof(FRyuketsuChangeName, M_EndFlag) == 0x000014, "Member 'FRyuketsuChangeName::M_EndFlag' has a wrong offset!");

// ScriptStruct Project.RyuketsuData
// 0x003C (0x003C - 0x0000)
struct FRyuketsuData final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Index;                                           // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_WarpID;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortId;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_HideLabelL;                                      // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_LabelL;                                          // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_LabelM;                                          // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OnFlag;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AutoOpenFlag;                                    // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AutoCloseFlag;                                   // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_RYUKETSU_GARDEN_TYPE                        M_GardenLevelType;                                 // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ExpectedDevilLevel;                              // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRyuketsuData) == 0x000004, "Wrong alignment on FRyuketsuData");
static_assert(sizeof(FRyuketsuData) == 0x00003C, "Wrong size on FRyuketsuData");
static_assert(offsetof(FRyuketsuData, M_MapID) == 0x000000, "Member 'FRyuketsuData::M_MapID' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_AreaId) == 0x000004, "Member 'FRyuketsuData::M_AreaId' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_Index) == 0x000008, "Member 'FRyuketsuData::M_Index' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_WarpID) == 0x00000C, "Member 'FRyuketsuData::M_WarpID' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_SortId) == 0x000010, "Member 'FRyuketsuData::M_SortId' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_HideLabelL) == 0x000014, "Member 'FRyuketsuData::M_HideLabelL' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_LabelL) == 0x000018, "Member 'FRyuketsuData::M_LabelL' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_LabelM) == 0x000020, "Member 'FRyuketsuData::M_LabelM' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_OnFlag) == 0x000028, "Member 'FRyuketsuData::M_OnFlag' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_AutoOpenFlag) == 0x00002C, "Member 'FRyuketsuData::M_AutoOpenFlag' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_AutoCloseFlag) == 0x000030, "Member 'FRyuketsuData::M_AutoCloseFlag' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_GardenLevelType) == 0x000034, "Member 'FRyuketsuData::M_GardenLevelType' has a wrong offset!");
static_assert(offsetof(FRyuketsuData, M_ExpectedDevilLevel) == 0x000038, "Member 'FRyuketsuData::M_ExpectedDevilLevel' has a wrong offset!");

// ScriptStruct Project.BattlePartyData
// 0x0008 (0x0008 - 0x0000)
struct FBattlePartyData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Level;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattlePartyData) == 0x000004, "Wrong alignment on FBattlePartyData");
static_assert(sizeof(FBattlePartyData) == 0x000008, "Wrong size on FBattlePartyData");
static_assert(offsetof(FBattlePartyData, M_Id) == 0x000000, "Member 'FBattlePartyData::M_Id' has a wrong offset!");
static_assert(offsetof(FBattlePartyData, M_Level) == 0x000004, "Member 'FBattlePartyData::M_Level' has a wrong offset!");

// ScriptStruct Project.SaveLoadHeaderData
// 0x0070 (0x0070 - 0x0000)
struct FSaveLoadHeaderData final
{
public:
	int32                                         M_State;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SlotIndex;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Version;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SaveType;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_Name;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DebugRandValue;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              M_Date;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Difficulty;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_TotalPlayTimeSec;                                // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBattlePartyData>               M_BattlePartyData;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         M_LastRyuketsuTableIndex;                          // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ClearRound;                                      // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ClearAlignment;                                  // 0x004A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_LoacationMessageId;                              // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_CanInherit;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_joinDlcFlag;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         M_LanguageType;                                    // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_PlayNewOldRoute;                                 // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_EnablePlayGoLoad;                                // 0x006A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveLoadHeaderData) == 0x000008, "Wrong alignment on FSaveLoadHeaderData");
static_assert(sizeof(FSaveLoadHeaderData) == 0x000070, "Wrong size on FSaveLoadHeaderData");
static_assert(offsetof(FSaveLoadHeaderData, M_State) == 0x000000, "Member 'FSaveLoadHeaderData::M_State' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_SlotIndex) == 0x000004, "Member 'FSaveLoadHeaderData::M_SlotIndex' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_Version) == 0x000008, "Member 'FSaveLoadHeaderData::M_Version' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_SaveType) == 0x00000C, "Member 'FSaveLoadHeaderData::M_SaveType' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_Name) == 0x000010, "Member 'FSaveLoadHeaderData::M_Name' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_DebugRandValue) == 0x000020, "Member 'FSaveLoadHeaderData::M_DebugRandValue' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_Date) == 0x000028, "Member 'FSaveLoadHeaderData::M_Date' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_Difficulty) == 0x000030, "Member 'FSaveLoadHeaderData::M_Difficulty' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_TotalPlayTimeSec) == 0x000034, "Member 'FSaveLoadHeaderData::M_TotalPlayTimeSec' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_BattlePartyData) == 0x000038, "Member 'FSaveLoadHeaderData::M_BattlePartyData' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_LastRyuketsuTableIndex) == 0x000048, "Member 'FSaveLoadHeaderData::M_LastRyuketsuTableIndex' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_ClearRound) == 0x000049, "Member 'FSaveLoadHeaderData::M_ClearRound' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_ClearAlignment) == 0x00004A, "Member 'FSaveLoadHeaderData::M_ClearAlignment' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_LoacationMessageId) == 0x00004C, "Member 'FSaveLoadHeaderData::M_LoacationMessageId' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_CanInherit) == 0x000050, "Member 'FSaveLoadHeaderData::M_CanInherit' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_joinDlcFlag) == 0x000058, "Member 'FSaveLoadHeaderData::M_joinDlcFlag' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_LanguageType) == 0x000068, "Member 'FSaveLoadHeaderData::M_LanguageType' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_PlayNewOldRoute) == 0x000069, "Member 'FSaveLoadHeaderData::M_PlayNewOldRoute' has a wrong offset!");
static_assert(offsetof(FSaveLoadHeaderData, M_EnablePlayGoLoad) == 0x00006A, "Member 'FSaveLoadHeaderData::M_EnablePlayGoLoad' has a wrong offset!");

// ScriptStruct Project.WaveConvTable
// 0x0008 (0x0010 - 0x0008)
struct FWaveConvTable final : public FTableRowBase
{
public:
	class UDataTable*                             M_DataTable;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaveConvTable) == 0x000008, "Wrong alignment on FWaveConvTable");
static_assert(sizeof(FWaveConvTable) == 0x000010, "Wrong size on FWaveConvTable");
static_assert(offsetof(FWaveConvTable, M_DataTable) == 0x000008, "Member 'FWaveConvTable::M_DataTable' has a wrong offset!");

// ScriptStruct Project.ScriptMessagePageData
// 0x0070 (0x0070 - 0x0000)
struct FScriptMessagePageData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Voice;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAtomCue>           Cue;                                               // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCharaLipSync>           LipSync;                                           // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScriptMessagePageData) == 0x000008, "Wrong alignment on FScriptMessagePageData");
static_assert(sizeof(FScriptMessagePageData) == 0x000070, "Wrong size on FScriptMessagePageData");
static_assert(offsetof(FScriptMessagePageData, Name) == 0x000000, "Member 'FScriptMessagePageData::Name' has a wrong offset!");
static_assert(offsetof(FScriptMessagePageData, Voice) == 0x000010, "Member 'FScriptMessagePageData::Voice' has a wrong offset!");
static_assert(offsetof(FScriptMessagePageData, Cue) == 0x000020, "Member 'FScriptMessagePageData::Cue' has a wrong offset!");
static_assert(offsetof(FScriptMessagePageData, LipSync) == 0x000048, "Member 'FScriptMessagePageData::LipSync' has a wrong offset!");

// ScriptStruct Project.ScriptMessageIconData
// 0x0014 (0x0014 - 0x0000)
struct FScriptMessageIconData final
{
public:
	struct FVector2D                              M_Pos;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_Scale;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Type;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScriptMessageIconData) == 0x000004, "Wrong alignment on FScriptMessageIconData");
static_assert(sizeof(FScriptMessageIconData) == 0x000014, "Wrong size on FScriptMessageIconData");
static_assert(offsetof(FScriptMessageIconData, M_Pos) == 0x000000, "Member 'FScriptMessageIconData::M_Pos' has a wrong offset!");
static_assert(offsetof(FScriptMessageIconData, M_Scale) == 0x000008, "Member 'FScriptMessageIconData::M_Scale' has a wrong offset!");
static_assert(offsetof(FScriptMessageIconData, M_Type) == 0x000010, "Member 'FScriptMessageIconData::M_Type' has a wrong offset!");

// ScriptStruct Project.ScriptMessage
// 0x0040 (0x0040 - 0x0000)
struct FScriptMessage final
{
public:
	int32                                         MessageID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageLabel;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           MessageTextPages;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FScriptMessagePageData>         MessagePageData;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FScriptMessageIconData>         MessageIconData;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScriptMessage) == 0x000008, "Wrong alignment on FScriptMessage");
static_assert(sizeof(FScriptMessage) == 0x000040, "Wrong size on FScriptMessage");
static_assert(offsetof(FScriptMessage, MessageID) == 0x000000, "Member 'FScriptMessage::MessageID' has a wrong offset!");
static_assert(offsetof(FScriptMessage, MessageLabel) == 0x000004, "Member 'FScriptMessage::MessageLabel' has a wrong offset!");
static_assert(offsetof(FScriptMessage, MessageTextPages) == 0x000010, "Member 'FScriptMessage::MessageTextPages' has a wrong offset!");
static_assert(offsetof(FScriptMessage, MessagePageData) == 0x000020, "Member 'FScriptMessage::MessagePageData' has a wrong offset!");
static_assert(offsetof(FScriptMessage, MessageIconData) == 0x000030, "Member 'FScriptMessage::MessageIconData' has a wrong offset!");

// ScriptStruct Project.ShinseiSaveBuffer
// 0x000C (0x000C - 0x0000)
struct FShinseiSaveBuffer final
{
public:
	int32                                         M_MapID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Buffer;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShinseiSaveBuffer) == 0x000004, "Wrong alignment on FShinseiSaveBuffer");
static_assert(sizeof(FShinseiSaveBuffer) == 0x00000C, "Wrong size on FShinseiSaveBuffer");
static_assert(offsetof(FShinseiSaveBuffer, M_MapID) == 0x000000, "Member 'FShinseiSaveBuffer::M_MapID' has a wrong offset!");
static_assert(offsetof(FShinseiSaveBuffer, M_AreaId) == 0x000004, "Member 'FShinseiSaveBuffer::M_AreaId' has a wrong offset!");
static_assert(offsetof(FShinseiSaveBuffer, M_Buffer) == 0x000008, "Member 'FShinseiSaveBuffer::M_Buffer' has a wrong offset!");

// ScriptStruct Project.ShinseiData
// 0x0004 (0x0004 - 0x0000)
struct FShinseiData final
{
public:
	int32                                         M_Num;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShinseiData) == 0x000004, "Wrong alignment on FShinseiData");
static_assert(sizeof(FShinseiData) == 0x000004, "Wrong size on FShinseiData");
static_assert(offsetof(FShinseiData, M_Num) == 0x000000, "Member 'FShinseiData::M_Num' has a wrong offset!");

// ScriptStruct Project.ShopItemData
// 0x0008 (0x0008 - 0x0000)
struct FShopItemData final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewItem;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShopItemData) == 0x000004, "Wrong alignment on FShopItemData");
static_assert(sizeof(FShopItemData) == 0x000008, "Wrong size on FShopItemData");
static_assert(offsetof(FShopItemData, ItemId) == 0x000000, "Member 'FShopItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FShopItemData, bNewItem) == 0x000004, "Member 'FShopItemData::bNewItem' has a wrong offset!");

// ScriptStruct Project.MouseCursorState
// 0x0018 (0x0018 - 0x0000)
struct FMouseCursorState final
{
public:
	class FString                                 SceneName;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShow;                                             // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceShow;                                        // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMouseCursorState) == 0x000008, "Wrong alignment on FMouseCursorState");
static_assert(sizeof(FMouseCursorState) == 0x000018, "Wrong size on FMouseCursorState");
static_assert(offsetof(FMouseCursorState, SceneName) == 0x000000, "Member 'FMouseCursorState::SceneName' has a wrong offset!");
static_assert(offsetof(FMouseCursorState, bShow) == 0x000010, "Member 'FMouseCursorState::bShow' has a wrong offset!");
static_assert(offsetof(FMouseCursorState, bForceShow) == 0x000011, "Member 'FMouseCursorState::bForceShow' has a wrong offset!");

// ScriptStruct Project.SkillMasterTableData
// 0x000C (0x000C - 0x0000)
struct FSkillMasterTableData final
{
public:
	uint8                                         M_Id;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_SKILL_MASTER_COND                           M_Cond;                                            // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_SKILL_MASTER_TARGET                         M_Tgt;                                             // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_SKILL_MASTER_EFT                            M_Eft;                                             // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Value;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HitEffect;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillMasterTableData) == 0x000004, "Wrong alignment on FSkillMasterTableData");
static_assert(sizeof(FSkillMasterTableData) == 0x00000C, "Wrong size on FSkillMasterTableData");
static_assert(offsetof(FSkillMasterTableData, M_Id) == 0x000000, "Member 'FSkillMasterTableData::M_Id' has a wrong offset!");
static_assert(offsetof(FSkillMasterTableData, M_Cond) == 0x000001, "Member 'FSkillMasterTableData::M_Cond' has a wrong offset!");
static_assert(offsetof(FSkillMasterTableData, M_Tgt) == 0x000002, "Member 'FSkillMasterTableData::M_Tgt' has a wrong offset!");
static_assert(offsetof(FSkillMasterTableData, M_Eft) == 0x000003, "Member 'FSkillMasterTableData::M_Eft' has a wrong offset!");
static_assert(offsetof(FSkillMasterTableData, M_Value) == 0x000004, "Member 'FSkillMasterTableData::M_Value' has a wrong offset!");
static_assert(offsetof(FSkillMasterTableData, M_HitEffect) == 0x000008, "Member 'FSkillMasterTableData::M_HitEffect' has a wrong offset!");

// ScriptStruct Project.SkillInfoMess
// 0x001C (0x001C - 0x0000)
struct FSkillInfoMess final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UseMesID;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UseMasterMesID;                                  // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_MsgTime;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MsgTiming;                                       // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ActorNameOn;                                     // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TargetNameOn;                                    // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_OverwriteCondition;                              // 0x0013(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_OverwriteMesID;                                  // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SE_Type;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_pad0;                                            // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_pad1;                                            // 0x001A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_pad2;                                            // 0x001B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillInfoMess) == 0x000004, "Wrong alignment on FSkillInfoMess");
static_assert(sizeof(FSkillInfoMess) == 0x00001C, "Wrong size on FSkillInfoMess");
static_assert(offsetof(FSkillInfoMess, M_Id) == 0x000000, "Member 'FSkillInfoMess::M_Id' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_UseMesID) == 0x000004, "Member 'FSkillInfoMess::M_UseMesID' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_UseMasterMesID) == 0x000008, "Member 'FSkillInfoMess::M_UseMasterMesID' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_MsgTime) == 0x00000C, "Member 'FSkillInfoMess::M_MsgTime' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_MsgTiming) == 0x000010, "Member 'FSkillInfoMess::M_MsgTiming' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_ActorNameOn) == 0x000011, "Member 'FSkillInfoMess::M_ActorNameOn' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_TargetNameOn) == 0x000012, "Member 'FSkillInfoMess::M_TargetNameOn' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_OverwriteCondition) == 0x000013, "Member 'FSkillInfoMess::M_OverwriteCondition' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_OverwriteMesID) == 0x000014, "Member 'FSkillInfoMess::M_OverwriteMesID' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_SE_Type) == 0x000018, "Member 'FSkillInfoMess::M_SE_Type' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_pad0) == 0x000019, "Member 'FSkillInfoMess::M_pad0' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_pad1) == 0x00001A, "Member 'FSkillInfoMess::M_pad1' has a wrong offset!");
static_assert(offsetof(FSkillInfoMess, M_pad2) == 0x00001B, "Member 'FSkillInfoMess::M_pad2' has a wrong offset!");

// ScriptStruct Project.SkillTekisei
// 0x0008 (0x0008 - 0x0000)
struct FSkillTekisei final
{
public:
	int32                                         M_KoukaType;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_KoukaValue;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillTekisei) == 0x000004, "Wrong alignment on FSkillTekisei");
static_assert(sizeof(FSkillTekisei) == 0x000008, "Wrong size on FSkillTekisei");
static_assert(offsetof(FSkillTekisei, M_KoukaType) == 0x000000, "Member 'FSkillTekisei::M_KoukaType' has a wrong offset!");
static_assert(offsetof(FSkillTekisei, M_KoukaValue) == 0x000004, "Member 'FSkillTekisei::M_KoukaValue' has a wrong offset!");

// ScriptStruct Project.SkillTekiseiArray
// 0x0010 (0x0010 - 0x0000)
struct FSkillTekiseiArray final
{
public:
	TArray<struct FSkillTekisei>                  M_Data;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillTekiseiArray) == 0x000008, "Wrong alignment on FSkillTekiseiArray");
static_assert(sizeof(FSkillTekiseiArray) == 0x000010, "Wrong size on FSkillTekiseiArray");
static_assert(offsetof(FSkillTekiseiArray, M_Data) == 0x000000, "Member 'FSkillTekiseiArray::M_Data' has a wrong offset!");

// ScriptStruct Project.AutoSkillExtraEffectData
// 0x0008 (0x0008 - 0x0000)
struct FAutoSkillExtraEffectData final
{
public:
	E_AUTO_SKILL_EXTRA_EFFECT                     M_Condition;                                       // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Value;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutoSkillExtraEffectData) == 0x000004, "Wrong alignment on FAutoSkillExtraEffectData");
static_assert(sizeof(FAutoSkillExtraEffectData) == 0x000008, "Wrong size on FAutoSkillExtraEffectData");
static_assert(offsetof(FAutoSkillExtraEffectData, M_Condition) == 0x000000, "Member 'FAutoSkillExtraEffectData::M_Condition' has a wrong offset!");
static_assert(offsetof(FAutoSkillExtraEffectData, M_Value) == 0x000004, "Member 'FAutoSkillExtraEffectData::M_Value' has a wrong offset!");

// ScriptStruct Project.SkillAutoErupt
// 0x0058 (0x0058 - 0x0000)
struct FSkillAutoErupt final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NameSortId;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ListSortId;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UniqueType;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MaxHPValue;                                      // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MaxMPValue;                                      // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Counter;                                         // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_FriendCounter;                                   // 0x0013(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Str;                                             // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Vit;                                             // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Mgi;                                             // 0x0016(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Agi;                                             // 0x0017(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Luc;                                             // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_CounterRate;                                     // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BstRate;                                         // 0x001A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_EXPRate;                                         // 0x001B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_CriticalRate;                                    // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Kantuu;                                          // 0x001D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_WinRec;                                          // 0x001E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ClenchingType;                                   // 0x001F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Kind;                                            // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Attr;                                            // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_EruptType;                                       // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Dead;                                            // 0x0023(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Poison;                                          // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Vertigo;                                         // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Confuse;                                         // 0x0026(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Charm;                                           // 0x0027(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Sleep;                                           // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Close;                                           // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Stray;                                           // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Stone;                                           // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Dazzle;                                          // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Burn;                                            // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Freeze;                                          // 0x002E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Shock;                                           // 0x002F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Laceration;                                      // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Mud;                                             // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Phisics;                                         // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Fire;                                            // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Ice;                                             // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Thunder;                                         // 0x0035(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Wind;                                            // 0x0036(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Dark;                                            // 0x0037(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Light;                                           // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Rank;                                            // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Keishou;                                         // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_LibEntry;                                        // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GetSkillSource;                                  // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_IsUniqueSkill;                                   // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAutoSkillExtraEffectData>      M_AutoExtraEffect;                                 // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillAutoErupt) == 0x000008, "Wrong alignment on FSkillAutoErupt");
static_assert(sizeof(FSkillAutoErupt) == 0x000058, "Wrong size on FSkillAutoErupt");
static_assert(offsetof(FSkillAutoErupt, M_Id) == 0x000000, "Member 'FSkillAutoErupt::M_Id' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_NameSortId) == 0x000004, "Member 'FSkillAutoErupt::M_NameSortId' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_ListSortId) == 0x000008, "Member 'FSkillAutoErupt::M_ListSortId' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_UniqueType) == 0x00000C, "Member 'FSkillAutoErupt::M_UniqueType' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_MaxHPValue) == 0x000010, "Member 'FSkillAutoErupt::M_MaxHPValue' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_MaxMPValue) == 0x000011, "Member 'FSkillAutoErupt::M_MaxMPValue' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Counter) == 0x000012, "Member 'FSkillAutoErupt::M_Counter' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_FriendCounter) == 0x000013, "Member 'FSkillAutoErupt::M_FriendCounter' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Str) == 0x000014, "Member 'FSkillAutoErupt::M_Str' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Vit) == 0x000015, "Member 'FSkillAutoErupt::M_Vit' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Mgi) == 0x000016, "Member 'FSkillAutoErupt::M_Mgi' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Agi) == 0x000017, "Member 'FSkillAutoErupt::M_Agi' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Luc) == 0x000018, "Member 'FSkillAutoErupt::M_Luc' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_CounterRate) == 0x000019, "Member 'FSkillAutoErupt::M_CounterRate' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_BstRate) == 0x00001A, "Member 'FSkillAutoErupt::M_BstRate' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_EXPRate) == 0x00001B, "Member 'FSkillAutoErupt::M_EXPRate' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_CriticalRate) == 0x00001C, "Member 'FSkillAutoErupt::M_CriticalRate' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Kantuu) == 0x00001D, "Member 'FSkillAutoErupt::M_Kantuu' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_WinRec) == 0x00001E, "Member 'FSkillAutoErupt::M_WinRec' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_ClenchingType) == 0x00001F, "Member 'FSkillAutoErupt::M_ClenchingType' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Kind) == 0x000020, "Member 'FSkillAutoErupt::M_Kind' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Attr) == 0x000021, "Member 'FSkillAutoErupt::M_Attr' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_EruptType) == 0x000022, "Member 'FSkillAutoErupt::M_EruptType' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Dead) == 0x000023, "Member 'FSkillAutoErupt::M_Dead' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Poison) == 0x000024, "Member 'FSkillAutoErupt::M_Poison' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Vertigo) == 0x000025, "Member 'FSkillAutoErupt::M_Vertigo' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Confuse) == 0x000026, "Member 'FSkillAutoErupt::M_Confuse' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Charm) == 0x000027, "Member 'FSkillAutoErupt::M_Charm' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Sleep) == 0x000028, "Member 'FSkillAutoErupt::M_Sleep' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Close) == 0x000029, "Member 'FSkillAutoErupt::M_Close' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Stray) == 0x00002A, "Member 'FSkillAutoErupt::M_Stray' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Stone) == 0x00002B, "Member 'FSkillAutoErupt::M_Stone' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Dazzle) == 0x00002C, "Member 'FSkillAutoErupt::M_Dazzle' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Burn) == 0x00002D, "Member 'FSkillAutoErupt::M_Burn' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Freeze) == 0x00002E, "Member 'FSkillAutoErupt::M_Freeze' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Shock) == 0x00002F, "Member 'FSkillAutoErupt::M_Shock' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Laceration) == 0x000030, "Member 'FSkillAutoErupt::M_Laceration' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Mud) == 0x000031, "Member 'FSkillAutoErupt::M_Mud' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Phisics) == 0x000032, "Member 'FSkillAutoErupt::M_Phisics' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Fire) == 0x000033, "Member 'FSkillAutoErupt::M_Fire' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Ice) == 0x000034, "Member 'FSkillAutoErupt::M_Ice' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Thunder) == 0x000035, "Member 'FSkillAutoErupt::M_Thunder' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Wind) == 0x000036, "Member 'FSkillAutoErupt::M_Wind' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Dark) == 0x000037, "Member 'FSkillAutoErupt::M_Dark' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Light) == 0x000038, "Member 'FSkillAutoErupt::M_Light' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Rank) == 0x000039, "Member 'FSkillAutoErupt::M_Rank' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_Keishou) == 0x00003A, "Member 'FSkillAutoErupt::M_Keishou' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_LibEntry) == 0x00003B, "Member 'FSkillAutoErupt::M_LibEntry' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_GetSkillSource) == 0x00003C, "Member 'FSkillAutoErupt::M_GetSkillSource' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_IsUniqueSkill) == 0x000040, "Member 'FSkillAutoErupt::M_IsUniqueSkill' has a wrong offset!");
static_assert(offsetof(FSkillAutoErupt, M_AutoExtraEffect) == 0x000048, "Member 'FSkillAutoErupt::M_AutoExtraEffect' has a wrong offset!");

// ScriptStruct Project.SkillOverwriteInfo
// 0x0008 (0x0008 - 0x0000)
struct FSkillOverwriteInfo final
{
public:
	E_OVERWRITE_CONDITION                         M_OverwriteCondition;                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_OverwriteSubCondition;                           // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_OVERWRITE_FORMULA                           M_OverwriteFormula;                                // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_OverwriteValue;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillOverwriteInfo) == 0x000004, "Wrong alignment on FSkillOverwriteInfo");
static_assert(sizeof(FSkillOverwriteInfo) == 0x000008, "Wrong size on FSkillOverwriteInfo");
static_assert(offsetof(FSkillOverwriteInfo, M_OverwriteCondition) == 0x000000, "Member 'FSkillOverwriteInfo::M_OverwriteCondition' has a wrong offset!");
static_assert(offsetof(FSkillOverwriteInfo, M_OverwriteSubCondition) == 0x000001, "Member 'FSkillOverwriteInfo::M_OverwriteSubCondition' has a wrong offset!");
static_assert(offsetof(FSkillOverwriteInfo, M_OverwriteFormula) == 0x000002, "Member 'FSkillOverwriteInfo::M_OverwriteFormula' has a wrong offset!");
static_assert(offsetof(FSkillOverwriteInfo, M_OverwriteValue) == 0x000004, "Member 'FSkillOverwriteInfo::M_OverwriteValue' has a wrong offset!");

// ScriptStruct Project.SkillBaseData
// 0x0100 (0x0100 - 0x0000)
struct FSkillBaseData final
{
public:
	int32                                         M_Id;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         M_MP;                                              // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Limited;                                         // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_SkillType;                                       // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_HitStamp;                                        // 0x000B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NameSortId;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ListSortId;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_UniqueType;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Icon;                                            // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_TekiseiType;                                     // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         M_Target;                                          // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UseScene;                                        // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkNum;                                          // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AtkNumMax;                                       // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_CriticalRate;                                    // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NahobinoMotion;                                  // 0x0035(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_AtkVal;                                          // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ActVal;                                          // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StanVal;                                         // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_HitRate;                                         // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Bst;                                             // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HPUpRate;                                        // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Kantuu;                                          // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_MoonAgeTurn;                                     // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_BstRate;                                         // 0x0052(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_RecBst;                                          // 0x0053(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ComboBst;                                        // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AidTime;                                         // 0x0055(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Maka;                                            // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Taru;                                            // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Raku;                                            // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Suku;                                            // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Tetorajya;                                       // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_TetMakTurn;                                      // 0x006C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Phisics;                                         // 0x006D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Fire;                                            // 0x006E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Ice;                                             // 0x006F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Thunder;                                         // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Wind;                                            // 0x0071(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Dark;                                            // 0x0072(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Light;                                           // 0x0073(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_RecVal;                                          // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_RecRate;                                         // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AbsorbHPRate;                                    // 0x0079(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_AbsorbMPRate;                                    // 0x007A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_DeadEffect;                                      // 0x007B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Rank;                                            // 0x007C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Keishou;                                         // 0x007D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_LibEntry;                                        // 0x007E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Pad;                                             // 0x007F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GetSkillSource;                                  // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_IsMagatsuhiSkill;                                // 0x0084(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_UseGroupMagatsuhiSkill;                          // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_LibCost;                                         // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MasterCost;                                      // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HitCallSkillID;                                  // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_MasterEftID;                                     // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<E_SKILL_EXTRA_EFFECT>                  M_ExtraEffect;                                     // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_AtkAttr;                                         // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 M_TekiseiCategory;                                 // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkillOverwriteInfo>            M_OverwriteInfo;                                   // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_EnableSkip;                                      // 0x00F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_EnableShowSkillName;                             // 0x00F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UnaffectedClose;                                 // 0x00FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_UnaffectedConfuseAndCharm;                       // 0x00FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ConvertItemEffect;                               // 0x00FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillBaseData) == 0x000008, "Wrong alignment on FSkillBaseData");
static_assert(sizeof(FSkillBaseData) == 0x000100, "Wrong size on FSkillBaseData");
static_assert(offsetof(FSkillBaseData, M_Id) == 0x000000, "Member 'FSkillBaseData::M_Id' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_MP) == 0x000008, "Member 'FSkillBaseData::M_MP' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Limited) == 0x000009, "Member 'FSkillBaseData::M_Limited' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_SkillType) == 0x00000A, "Member 'FSkillBaseData::M_SkillType' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_HitStamp) == 0x00000B, "Member 'FSkillBaseData::M_HitStamp' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_NameSortId) == 0x00000C, "Member 'FSkillBaseData::M_NameSortId' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_ListSortId) == 0x000010, "Member 'FSkillBaseData::M_ListSortId' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_UniqueType) == 0x000014, "Member 'FSkillBaseData::M_UniqueType' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Icon) == 0x000018, "Member 'FSkillBaseData::M_Icon' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_TekiseiType) == 0x000020, "Member 'FSkillBaseData::M_TekiseiType' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Target) == 0x000030, "Member 'FSkillBaseData::M_Target' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_UseScene) == 0x000031, "Member 'FSkillBaseData::M_UseScene' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_AtkNum) == 0x000032, "Member 'FSkillBaseData::M_AtkNum' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_AtkNumMax) == 0x000033, "Member 'FSkillBaseData::M_AtkNumMax' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_CriticalRate) == 0x000034, "Member 'FSkillBaseData::M_CriticalRate' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_NahobinoMotion) == 0x000035, "Member 'FSkillBaseData::M_NahobinoMotion' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_AtkVal) == 0x000038, "Member 'FSkillBaseData::M_AtkVal' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_ActVal) == 0x00003C, "Member 'FSkillBaseData::M_ActVal' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_StanVal) == 0x000040, "Member 'FSkillBaseData::M_StanVal' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_HitRate) == 0x000044, "Member 'FSkillBaseData::M_HitRate' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Bst) == 0x000048, "Member 'FSkillBaseData::M_Bst' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_HPUpRate) == 0x00004C, "Member 'FSkillBaseData::M_HPUpRate' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Kantuu) == 0x000050, "Member 'FSkillBaseData::M_Kantuu' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_MoonAgeTurn) == 0x000051, "Member 'FSkillBaseData::M_MoonAgeTurn' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_BstRate) == 0x000052, "Member 'FSkillBaseData::M_BstRate' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_RecBst) == 0x000053, "Member 'FSkillBaseData::M_RecBst' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_ComboBst) == 0x000054, "Member 'FSkillBaseData::M_ComboBst' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_AidTime) == 0x000055, "Member 'FSkillBaseData::M_AidTime' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Maka) == 0x000058, "Member 'FSkillBaseData::M_Maka' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Taru) == 0x00005C, "Member 'FSkillBaseData::M_Taru' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Raku) == 0x000060, "Member 'FSkillBaseData::M_Raku' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Suku) == 0x000064, "Member 'FSkillBaseData::M_Suku' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Tetorajya) == 0x000068, "Member 'FSkillBaseData::M_Tetorajya' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_TetMakTurn) == 0x00006C, "Member 'FSkillBaseData::M_TetMakTurn' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Phisics) == 0x00006D, "Member 'FSkillBaseData::M_Phisics' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Fire) == 0x00006E, "Member 'FSkillBaseData::M_Fire' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Ice) == 0x00006F, "Member 'FSkillBaseData::M_Ice' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Thunder) == 0x000070, "Member 'FSkillBaseData::M_Thunder' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Wind) == 0x000071, "Member 'FSkillBaseData::M_Wind' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Dark) == 0x000072, "Member 'FSkillBaseData::M_Dark' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Light) == 0x000073, "Member 'FSkillBaseData::M_Light' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_RecVal) == 0x000074, "Member 'FSkillBaseData::M_RecVal' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_RecRate) == 0x000078, "Member 'FSkillBaseData::M_RecRate' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_AbsorbHPRate) == 0x000079, "Member 'FSkillBaseData::M_AbsorbHPRate' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_AbsorbMPRate) == 0x00007A, "Member 'FSkillBaseData::M_AbsorbMPRate' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_DeadEffect) == 0x00007B, "Member 'FSkillBaseData::M_DeadEffect' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Rank) == 0x00007C, "Member 'FSkillBaseData::M_Rank' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Keishou) == 0x00007D, "Member 'FSkillBaseData::M_Keishou' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_LibEntry) == 0x00007E, "Member 'FSkillBaseData::M_LibEntry' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_Pad) == 0x00007F, "Member 'FSkillBaseData::M_Pad' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_GetSkillSource) == 0x000080, "Member 'FSkillBaseData::M_GetSkillSource' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_IsMagatsuhiSkill) == 0x000084, "Member 'FSkillBaseData::M_IsMagatsuhiSkill' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_UseGroupMagatsuhiSkill) == 0x000088, "Member 'FSkillBaseData::M_UseGroupMagatsuhiSkill' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_LibCost) == 0x000098, "Member 'FSkillBaseData::M_LibCost' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_MasterCost) == 0x00009C, "Member 'FSkillBaseData::M_MasterCost' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_HitCallSkillID) == 0x0000A0, "Member 'FSkillBaseData::M_HitCallSkillID' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_MasterEftID) == 0x0000A8, "Member 'FSkillBaseData::M_MasterEftID' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_ExtraEffect) == 0x0000B8, "Member 'FSkillBaseData::M_ExtraEffect' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_AtkAttr) == 0x0000C8, "Member 'FSkillBaseData::M_AtkAttr' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_TekiseiCategory) == 0x0000D8, "Member 'FSkillBaseData::M_TekiseiCategory' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_OverwriteInfo) == 0x0000E8, "Member 'FSkillBaseData::M_OverwriteInfo' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_EnableSkip) == 0x0000F8, "Member 'FSkillBaseData::M_EnableSkip' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_EnableShowSkillName) == 0x0000F9, "Member 'FSkillBaseData::M_EnableShowSkillName' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_UnaffectedClose) == 0x0000FA, "Member 'FSkillBaseData::M_UnaffectedClose' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_UnaffectedConfuseAndCharm) == 0x0000FB, "Member 'FSkillBaseData::M_UnaffectedConfuseAndCharm' has a wrong offset!");
static_assert(offsetof(FSkillBaseData, M_ConvertItemEffect) == 0x0000FC, "Member 'FSkillBaseData::M_ConvertItemEffect' has a wrong offset!");

// ScriptStruct Project.DevilAttrType
// 0x0002 (0x0002 - 0x0000)
struct FDevilAttrType final
{
public:
	uint8                                         M_Attr1;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Attr2;                                           // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevilAttrType) == 0x000001, "Wrong alignment on FDevilAttrType");
static_assert(sizeof(FDevilAttrType) == 0x000002, "Wrong size on FDevilAttrType");
static_assert(offsetof(FDevilAttrType, M_Attr1) == 0x000000, "Member 'FDevilAttrType::M_Attr1' has a wrong offset!");
static_assert(offsetof(FDevilAttrType, M_Attr2) == 0x000001, "Member 'FDevilAttrType::M_Attr2' has a wrong offset!");

// ScriptStruct Project.MultiDevilMagatsuhiSkillData
// 0x0028 (0x0028 - 0x0000)
struct FMultiDevilMagatsuhiSkillData final
{
public:
	int32                                         M_SkillId;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ItemID;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_DevilID;                                         // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDevilAttrType>                 M_DevilAttr;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiDevilMagatsuhiSkillData) == 0x000008, "Wrong alignment on FMultiDevilMagatsuhiSkillData");
static_assert(sizeof(FMultiDevilMagatsuhiSkillData) == 0x000028, "Wrong size on FMultiDevilMagatsuhiSkillData");
static_assert(offsetof(FMultiDevilMagatsuhiSkillData, M_SkillId) == 0x000000, "Member 'FMultiDevilMagatsuhiSkillData::M_SkillId' has a wrong offset!");
static_assert(offsetof(FMultiDevilMagatsuhiSkillData, M_ItemID) == 0x000004, "Member 'FMultiDevilMagatsuhiSkillData::M_ItemID' has a wrong offset!");
static_assert(offsetof(FMultiDevilMagatsuhiSkillData, M_DevilID) == 0x000008, "Member 'FMultiDevilMagatsuhiSkillData::M_DevilID' has a wrong offset!");
static_assert(offsetof(FMultiDevilMagatsuhiSkillData, M_DevilAttr) == 0x000018, "Member 'FMultiDevilMagatsuhiSkillData::M_DevilAttr' has a wrong offset!");

// ScriptStruct Project.UniteCtrlData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FUniteCtrlData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniteCtrlData) == 0x000008, "Wrong alignment on FUniteCtrlData");
static_assert(sizeof(FUniteCtrlData) == 0x000010, "Wrong size on FUniteCtrlData");

// ScriptStruct Project.MagatsuhiSkillData
// 0x0010 (0x0010 - 0x0000)
struct FMagatsuhiSkillData final
{
public:
	TArray<int32>                                 M_SkillId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMagatsuhiSkillData) == 0x000008, "Wrong alignment on FMagatsuhiSkillData");
static_assert(sizeof(FMagatsuhiSkillData) == 0x000010, "Wrong size on FMagatsuhiSkillData");
static_assert(offsetof(FMagatsuhiSkillData, M_SkillId) == 0x000000, "Member 'FMagatsuhiSkillData::M_SkillId' has a wrong offset!");

// ScriptStruct Project.SkillExtraEffect
// 0x0008 (0x0008 - 0x0000)
struct FSkillExtraEffect final
{
public:
	int32                                         M_Type;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Value;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillExtraEffect) == 0x000004, "Wrong alignment on FSkillExtraEffect");
static_assert(sizeof(FSkillExtraEffect) == 0x000008, "Wrong size on FSkillExtraEffect");
static_assert(offsetof(FSkillExtraEffect, M_Type) == 0x000000, "Member 'FSkillExtraEffect::M_Type' has a wrong offset!");
static_assert(offsetof(FSkillExtraEffect, M_Value) == 0x000004, "Member 'FSkillExtraEffect::M_Value' has a wrong offset!");

// ScriptStruct Project.UniteInheritSkill
// 0x0018 (0x0018 - 0x0000)
struct FUniteInheritSkill final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInherit;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsResultSkill;                                     // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Score;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TekiseiValue;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Makka;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSet;                                             // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniteInheritSkill) == 0x000004, "Wrong alignment on FUniteInheritSkill");
static_assert(sizeof(FUniteInheritSkill) == 0x000018, "Wrong size on FUniteInheritSkill");
static_assert(offsetof(FUniteInheritSkill, SkillId) == 0x000000, "Member 'FUniteInheritSkill::SkillId' has a wrong offset!");
static_assert(offsetof(FUniteInheritSkill, IsInherit) == 0x000004, "Member 'FUniteInheritSkill::IsInherit' has a wrong offset!");
static_assert(offsetof(FUniteInheritSkill, IsResultSkill) == 0x000005, "Member 'FUniteInheritSkill::IsResultSkill' has a wrong offset!");
static_assert(offsetof(FUniteInheritSkill, Score) == 0x000008, "Member 'FUniteInheritSkill::Score' has a wrong offset!");
static_assert(offsetof(FUniteInheritSkill, TekiseiValue) == 0x00000C, "Member 'FUniteInheritSkill::TekiseiValue' has a wrong offset!");
static_assert(offsetof(FUniteInheritSkill, Makka) == 0x000010, "Member 'FUniteInheritSkill::Makka' has a wrong offset!");
static_assert(offsetof(FUniteInheritSkill, IsSet) == 0x000014, "Member 'FUniteInheritSkill::IsSet' has a wrong offset!");

// ScriptStruct Project.SingleKeyboardTextSet
// 0x00A8 (0x00A8 - 0x0000)
struct FSingleKeyboardTextSet final
{
public:
	class FText                                   M_DefaultText;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_HeaderText;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_OkText;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_NgDialogNgWordText;                              // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_NgDialogSpaceText;                               // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_NgDialogUnsupportedText;                         // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   M_OkConfirmDialogText;                             // 0x0090(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleKeyboardTextSet) == 0x000008, "Wrong alignment on FSingleKeyboardTextSet");
static_assert(sizeof(FSingleKeyboardTextSet) == 0x0000A8, "Wrong size on FSingleKeyboardTextSet");
static_assert(offsetof(FSingleKeyboardTextSet, M_DefaultText) == 0x000000, "Member 'FSingleKeyboardTextSet::M_DefaultText' has a wrong offset!");
static_assert(offsetof(FSingleKeyboardTextSet, M_HeaderText) == 0x000018, "Member 'FSingleKeyboardTextSet::M_HeaderText' has a wrong offset!");
static_assert(offsetof(FSingleKeyboardTextSet, M_OkText) == 0x000030, "Member 'FSingleKeyboardTextSet::M_OkText' has a wrong offset!");
static_assert(offsetof(FSingleKeyboardTextSet, M_NgDialogNgWordText) == 0x000048, "Member 'FSingleKeyboardTextSet::M_NgDialogNgWordText' has a wrong offset!");
static_assert(offsetof(FSingleKeyboardTextSet, M_NgDialogSpaceText) == 0x000060, "Member 'FSingleKeyboardTextSet::M_NgDialogSpaceText' has a wrong offset!");
static_assert(offsetof(FSingleKeyboardTextSet, M_NgDialogUnsupportedText) == 0x000078, "Member 'FSingleKeyboardTextSet::M_NgDialogUnsupportedText' has a wrong offset!");
static_assert(offsetof(FSingleKeyboardTextSet, M_OkConfirmDialogText) == 0x000090, "Member 'FSingleKeyboardTextSet::M_OkConfirmDialogText' has a wrong offset!");

// ScriptStruct Project.EnableCheckFontData
// 0x0028 (0x0028 - 0x0000)
struct FEnableCheckFontData final
{
public:
	class UObject*                                FontObject_1;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                FontObject_2;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                FontObject_3;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                FontObject_4;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                FontObject_5;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnableCheckFontData) == 0x000008, "Wrong alignment on FEnableCheckFontData");
static_assert(sizeof(FEnableCheckFontData) == 0x000028, "Wrong size on FEnableCheckFontData");
static_assert(offsetof(FEnableCheckFontData, FontObject_1) == 0x000000, "Member 'FEnableCheckFontData::FontObject_1' has a wrong offset!");
static_assert(offsetof(FEnableCheckFontData, FontObject_2) == 0x000008, "Member 'FEnableCheckFontData::FontObject_2' has a wrong offset!");
static_assert(offsetof(FEnableCheckFontData, FontObject_3) == 0x000010, "Member 'FEnableCheckFontData::FontObject_3' has a wrong offset!");
static_assert(offsetof(FEnableCheckFontData, FontObject_4) == 0x000018, "Member 'FEnableCheckFontData::FontObject_4' has a wrong offset!");
static_assert(offsetof(FEnableCheckFontData, FontObject_5) == 0x000020, "Member 'FEnableCheckFontData::FontObject_5' has a wrong offset!");

// ScriptStruct Project.HelpSaveBuffer
// 0x0010 (0x0010 - 0x0000)
struct FHelpSaveBuffer final
{
public:
	TArray<int32>                                 M_helpType;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHelpSaveBuffer) == 0x000008, "Wrong alignment on FHelpSaveBuffer");
static_assert(sizeof(FHelpSaveBuffer) == 0x000010, "Wrong size on FHelpSaveBuffer");
static_assert(offsetof(FHelpSaveBuffer, M_helpType) == 0x000000, "Member 'FHelpSaveBuffer::M_helpType' has a wrong offset!");

// ScriptStruct Project.SortSaveBuffer
// 0x0010 (0x0010 - 0x0000)
struct FSortSaveBuffer final
{
public:
	TArray<int32>                                 M_sortType;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSortSaveBuffer) == 0x000008, "Wrong alignment on FSortSaveBuffer");
static_assert(sizeof(FSortSaveBuffer) == 0x000010, "Wrong size on FSortSaveBuffer");
static_assert(offsetof(FSortSaveBuffer, M_sortType) == 0x000000, "Member 'FSortSaveBuffer::M_sortType' has a wrong offset!");

// ScriptStruct Project.InheritSkillTekiseiTable
// 0x0008 (0x0008 - 0x0000)
struct FInheritSkillTekiseiTable final
{
public:
	int32                                         ClassValue;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rate;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInheritSkillTekiseiTable) == 0x000004, "Wrong alignment on FInheritSkillTekiseiTable");
static_assert(sizeof(FInheritSkillTekiseiTable) == 0x000008, "Wrong size on FInheritSkillTekiseiTable");
static_assert(offsetof(FInheritSkillTekiseiTable, ClassValue) == 0x000000, "Member 'FInheritSkillTekiseiTable::ClassValue' has a wrong offset!");
static_assert(offsetof(FInheritSkillTekiseiTable, Rate) == 0x000004, "Member 'FInheritSkillTekiseiTable::Rate' has a wrong offset!");

// ScriptStruct Project.StaffRollData
// 0x0058 (0x0058 - 0x0000)
struct FStaffRollData final
{
public:
	class FString                                 OrganizationName;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleName;                                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LeftName;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RightName;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextureRef;                                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineSpace;                                         // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStaffRollData) == 0x000008, "Wrong alignment on FStaffRollData");
static_assert(sizeof(FStaffRollData) == 0x000058, "Wrong size on FStaffRollData");
static_assert(offsetof(FStaffRollData, OrganizationName) == 0x000000, "Member 'FStaffRollData::OrganizationName' has a wrong offset!");
static_assert(offsetof(FStaffRollData, TitleName) == 0x000010, "Member 'FStaffRollData::TitleName' has a wrong offset!");
static_assert(offsetof(FStaffRollData, LeftName) == 0x000020, "Member 'FStaffRollData::LeftName' has a wrong offset!");
static_assert(offsetof(FStaffRollData, RightName) == 0x000030, "Member 'FStaffRollData::RightName' has a wrong offset!");
static_assert(offsetof(FStaffRollData, TextureRef) == 0x000040, "Member 'FStaffRollData::TextureRef' has a wrong offset!");
static_assert(offsetof(FStaffRollData, LineSpace) == 0x000050, "Member 'FStaffRollData::LineSpace' has a wrong offset!");

// ScriptStruct Project.StaticMeshTableRow
// 0x0068 (0x0070 - 0x0008)
struct FStaticMeshTableRow final : public FTableRowBase
{
public:
	int32                                         Disable;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AssetReference;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODNum;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CastShadowLODNum;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionNum;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Percent0;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Percent1;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Percent2;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Percent3;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bAutoComputeLODScreenSize;                         // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSize1;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSize2;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSize3;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LOD_GenerateLM;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LOD_SrcLM;                                         // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LOD_DstLM;                                         // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildAdjacencyBuffer;                              // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildReversedIndexBuffer;                          // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gen_LightmapResolution;                            // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStaticMeshTableRow) == 0x000008, "Wrong alignment on FStaticMeshTableRow");
static_assert(sizeof(FStaticMeshTableRow) == 0x000070, "Wrong size on FStaticMeshTableRow");
static_assert(offsetof(FStaticMeshTableRow, Disable) == 0x000008, "Member 'FStaticMeshTableRow::Disable' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, AssetReference) == 0x000010, "Member 'FStaticMeshTableRow::AssetReference' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, LODNum) == 0x000028, "Member 'FStaticMeshTableRow::LODNum' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, CastShadowLODNum) == 0x00002C, "Member 'FStaticMeshTableRow::CastShadowLODNum' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, SectionNum) == 0x000030, "Member 'FStaticMeshTableRow::SectionNum' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, Percent0) == 0x000034, "Member 'FStaticMeshTableRow::Percent0' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, Percent1) == 0x000038, "Member 'FStaticMeshTableRow::Percent1' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, Percent2) == 0x00003C, "Member 'FStaticMeshTableRow::Percent2' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, Percent3) == 0x000040, "Member 'FStaticMeshTableRow::Percent3' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, bAutoComputeLODScreenSize) == 0x000044, "Member 'FStaticMeshTableRow::bAutoComputeLODScreenSize' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, ScreenSize1) == 0x000048, "Member 'FStaticMeshTableRow::ScreenSize1' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, ScreenSize2) == 0x00004C, "Member 'FStaticMeshTableRow::ScreenSize2' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, ScreenSize3) == 0x000050, "Member 'FStaticMeshTableRow::ScreenSize3' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, LOD_GenerateLM) == 0x000054, "Member 'FStaticMeshTableRow::LOD_GenerateLM' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, LOD_SrcLM) == 0x000058, "Member 'FStaticMeshTableRow::LOD_SrcLM' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, LOD_DstLM) == 0x00005C, "Member 'FStaticMeshTableRow::LOD_DstLM' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, BuildAdjacencyBuffer) == 0x000060, "Member 'FStaticMeshTableRow::BuildAdjacencyBuffer' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, BuildReversedIndexBuffer) == 0x000064, "Member 'FStaticMeshTableRow::BuildReversedIndexBuffer' has a wrong offset!");
static_assert(offsetof(FStaticMeshTableRow, Gen_LightmapResolution) == 0x000068, "Member 'FStaticMeshTableRow::Gen_LightmapResolution' has a wrong offset!");

// ScriptStruct Project.MaskedErrorTableRow
// 0x0048 (0x0050 - 0x0008)
struct FMaskedErrorTableRow final : public FTableRowBase
{
public:
	int32                                         HasErrors;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AssetReference;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetType;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeMasked;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CollisionName;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaskedErrorTableRow) == 0x000008, "Wrong alignment on FMaskedErrorTableRow");
static_assert(sizeof(FMaskedErrorTableRow) == 0x000050, "Wrong size on FMaskedErrorTableRow");
static_assert(offsetof(FMaskedErrorTableRow, HasErrors) == 0x000008, "Member 'FMaskedErrorTableRow::HasErrors' has a wrong offset!");
static_assert(offsetof(FMaskedErrorTableRow, AssetReference) == 0x000010, "Member 'FMaskedErrorTableRow::AssetReference' has a wrong offset!");
static_assert(offsetof(FMaskedErrorTableRow, AssetType) == 0x000028, "Member 'FMaskedErrorTableRow::AssetType' has a wrong offset!");
static_assert(offsetof(FMaskedErrorTableRow, CanBeMasked) == 0x000038, "Member 'FMaskedErrorTableRow::CanBeMasked' has a wrong offset!");
static_assert(offsetof(FMaskedErrorTableRow, CollisionName) == 0x000040, "Member 'FMaskedErrorTableRow::CollisionName' has a wrong offset!");

// ScriptStruct Project.UniteSpTable
// 0x0020 (0x0020 - 0x0000)
struct FUniteSpTable final
{
public:
	int32                                         SortID;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NkmId;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ResultId;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniteSpTable) == 0x000008, "Wrong alignment on FUniteSpTable");
static_assert(sizeof(FUniteSpTable) == 0x000020, "Wrong size on FUniteSpTable");
static_assert(offsetof(FUniteSpTable, SortID) == 0x000000, "Member 'FUniteSpTable::SortID' has a wrong offset!");
static_assert(offsetof(FUniteSpTable, NkmId) == 0x000008, "Member 'FUniteSpTable::NkmId' has a wrong offset!");
static_assert(offsetof(FUniteSpTable, ResultId) == 0x000018, "Member 'FUniteSpTable::ResultId' has a wrong offset!");

// ScriptStruct Project.StatusSkillListData
// 0x000C (0x000C - 0x0000)
struct FStatusSkillListData final
{
public:
	int32                                         M_SkillId;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Use;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_NkmIndex;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_Type;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusSkillListData) == 0x000004, "Wrong alignment on FStatusSkillListData");
static_assert(sizeof(FStatusSkillListData) == 0x00000C, "Wrong size on FStatusSkillListData");
static_assert(offsetof(FStatusSkillListData, M_SkillId) == 0x000000, "Member 'FStatusSkillListData::M_SkillId' has a wrong offset!");
static_assert(offsetof(FStatusSkillListData, M_Use) == 0x000004, "Member 'FStatusSkillListData::M_Use' has a wrong offset!");
static_assert(offsetof(FStatusSkillListData, M_NkmIndex) == 0x000008, "Member 'FStatusSkillListData::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FStatusSkillListData, M_Type) == 0x000009, "Member 'FStatusSkillListData::M_Type' has a wrong offset!");

// ScriptStruct Project.LevelInfo
// 0x0010 (0x0010 - 0x0000)
struct FLevelInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreaming*                        LevelStreamingObject;                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelInfo) == 0x000008, "Wrong alignment on FLevelInfo");
static_assert(sizeof(FLevelInfo) == 0x000010, "Wrong size on FLevelInfo");
static_assert(offsetof(FLevelInfo, LevelStreamingObject) == 0x000008, "Member 'FLevelInfo::LevelStreamingObject' has a wrong offset!");

// ScriptStruct Project.TalkUniqueSkillCameraTableRow
// 0x0020 (0x0028 - 0x0008)
struct FTalkUniqueSkillCameraTableRow final : public FTableRowBase
{
public:
	int32                                         DevilID;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHeight;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocX;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocY;                                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocZ;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotX;                                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotY;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotZ;                                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkUniqueSkillCameraTableRow) == 0x000008, "Wrong alignment on FTalkUniqueSkillCameraTableRow");
static_assert(sizeof(FTalkUniqueSkillCameraTableRow) == 0x000028, "Wrong size on FTalkUniqueSkillCameraTableRow");
static_assert(offsetof(FTalkUniqueSkillCameraTableRow, DevilID) == 0x000008, "Member 'FTalkUniqueSkillCameraTableRow::DevilID' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillCameraTableRow, TargetHeight) == 0x00000C, "Member 'FTalkUniqueSkillCameraTableRow::TargetHeight' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillCameraTableRow, LocX) == 0x000010, "Member 'FTalkUniqueSkillCameraTableRow::LocX' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillCameraTableRow, LocY) == 0x000014, "Member 'FTalkUniqueSkillCameraTableRow::LocY' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillCameraTableRow, LocZ) == 0x000018, "Member 'FTalkUniqueSkillCameraTableRow::LocZ' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillCameraTableRow, RotX) == 0x00001C, "Member 'FTalkUniqueSkillCameraTableRow::RotX' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillCameraTableRow, RotY) == 0x000020, "Member 'FTalkUniqueSkillCameraTableRow::RotY' has a wrong offset!");
static_assert(offsetof(FTalkUniqueSkillCameraTableRow, RotZ) == 0x000024, "Member 'FTalkUniqueSkillCameraTableRow::RotZ' has a wrong offset!");

// ScriptStruct Project.TalkBattleInfo
// 0x0010 (0x0010 - 0x0000)
struct FTalkBattleInfo final
{
public:
	TArray<int32>                                 M_ApologyDevilIdArray;                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkBattleInfo) == 0x000008, "Wrong alignment on FTalkBattleInfo");
static_assert(sizeof(FTalkBattleInfo) == 0x000010, "Wrong size on FTalkBattleInfo");
static_assert(offsetof(FTalkBattleInfo, M_ApologyDevilIdArray) == 0x000000, "Member 'FTalkBattleInfo::M_ApologyDevilIdArray' has a wrong offset!");

// ScriptStruct Project.TalkResultInfo
// 0x0002 (0x0002 - 0x0000)
struct FTalkResultInfo final
{
public:
	E_TALK_END_TYPE                               M_TalkEndType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_TALK_RESULT_TARGET_STATUS                   M_TargetStatus;                                    // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkResultInfo) == 0x000001, "Wrong alignment on FTalkResultInfo");
static_assert(sizeof(FTalkResultInfo) == 0x000002, "Wrong size on FTalkResultInfo");
static_assert(offsetof(FTalkResultInfo, M_TalkEndType) == 0x000000, "Member 'FTalkResultInfo::M_TalkEndType' has a wrong offset!");
static_assert(offsetof(FTalkResultInfo, M_TargetStatus) == 0x000001, "Member 'FTalkResultInfo::M_TargetStatus' has a wrong offset!");

// ScriptStruct Project.TalkDebug
// 0x0034 (0x0034 - 0x0000)
struct alignas(0x04) FTalkDebug final
{
public:
	uint8                                         Pad_0[0x34];                                       // 0x0000(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkDebug) == 0x000004, "Wrong alignment on FTalkDebug");
static_assert(sizeof(FTalkDebug) == 0x000034, "Wrong size on FTalkDebug");

// ScriptStruct Project.TransportLocationSlotInfo
// 0x0020 (0x0020 - 0x0000)
struct FTransportLocationSlotInfo final
{
public:
	class FText                                   LocationName;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsActiveSlot;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransportLocationSlotInfo) == 0x000008, "Wrong alignment on FTransportLocationSlotInfo");
static_assert(sizeof(FTransportLocationSlotInfo) == 0x000020, "Wrong size on FTransportLocationSlotInfo");
static_assert(offsetof(FTransportLocationSlotInfo, LocationName) == 0x000000, "Member 'FTransportLocationSlotInfo::LocationName' has a wrong offset!");
static_assert(offsetof(FTransportLocationSlotInfo, IsActiveSlot) == 0x000018, "Member 'FTransportLocationSlotInfo::IsActiveSlot' has a wrong offset!");

// ScriptStruct Project.TutorialWindowBuffer
// 0x0014 (0x0014 - 0x0000)
struct FTutorialWindowBuffer final
{
public:
	int32                                         M_titleTextId;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_messageTextId;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_categoryId;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_conditionId;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SortId;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialWindowBuffer) == 0x000004, "Wrong alignment on FTutorialWindowBuffer");
static_assert(sizeof(FTutorialWindowBuffer) == 0x000014, "Wrong size on FTutorialWindowBuffer");
static_assert(offsetof(FTutorialWindowBuffer, M_titleTextId) == 0x000000, "Member 'FTutorialWindowBuffer::M_titleTextId' has a wrong offset!");
static_assert(offsetof(FTutorialWindowBuffer, M_messageTextId) == 0x000004, "Member 'FTutorialWindowBuffer::M_messageTextId' has a wrong offset!");
static_assert(offsetof(FTutorialWindowBuffer, M_categoryId) == 0x000008, "Member 'FTutorialWindowBuffer::M_categoryId' has a wrong offset!");
static_assert(offsetof(FTutorialWindowBuffer, M_conditionId) == 0x00000C, "Member 'FTutorialWindowBuffer::M_conditionId' has a wrong offset!");
static_assert(offsetof(FTutorialWindowBuffer, M_SortId) == 0x000010, "Member 'FTutorialWindowBuffer::M_SortId' has a wrong offset!");

// ScriptStruct Project.UIAnimationTableData
// 0x0024 (0x0024 - 0x0000)
struct FUIAnimationTableData final
{
public:
	int32                                         M_Index;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_StartPos;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_StartAlpha;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_EndPos;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EndAlpha;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Time;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsLoop;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIAnimationTableData) == 0x000004, "Wrong alignment on FUIAnimationTableData");
static_assert(sizeof(FUIAnimationTableData) == 0x000024, "Wrong size on FUIAnimationTableData");
static_assert(offsetof(FUIAnimationTableData, M_Index) == 0x000000, "Member 'FUIAnimationTableData::M_Index' has a wrong offset!");
static_assert(offsetof(FUIAnimationTableData, M_StartPos) == 0x000004, "Member 'FUIAnimationTableData::M_StartPos' has a wrong offset!");
static_assert(offsetof(FUIAnimationTableData, M_StartAlpha) == 0x00000C, "Member 'FUIAnimationTableData::M_StartAlpha' has a wrong offset!");
static_assert(offsetof(FUIAnimationTableData, M_EndPos) == 0x000010, "Member 'FUIAnimationTableData::M_EndPos' has a wrong offset!");
static_assert(offsetof(FUIAnimationTableData, M_EndAlpha) == 0x000018, "Member 'FUIAnimationTableData::M_EndAlpha' has a wrong offset!");
static_assert(offsetof(FUIAnimationTableData, M_Time) == 0x00001C, "Member 'FUIAnimationTableData::M_Time' has a wrong offset!");
static_assert(offsetof(FUIAnimationTableData, M_IsLoop) == 0x000020, "Member 'FUIAnimationTableData::M_IsLoop' has a wrong offset!");

// ScriptStruct Project.UIAnimationPlayData
// 0x0038 (0x0038 - 0x0000)
struct FUIAnimationPlayData final
{
public:
	struct FUIAnimationTableData                  M_AnimData;                                        // 0x0000(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              M_Pos;                                             // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Alpha;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Time;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsReverse;                                       // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIAnimationPlayData) == 0x000004, "Wrong alignment on FUIAnimationPlayData");
static_assert(sizeof(FUIAnimationPlayData) == 0x000038, "Wrong size on FUIAnimationPlayData");
static_assert(offsetof(FUIAnimationPlayData, M_AnimData) == 0x000000, "Member 'FUIAnimationPlayData::M_AnimData' has a wrong offset!");
static_assert(offsetof(FUIAnimationPlayData, M_Pos) == 0x000024, "Member 'FUIAnimationPlayData::M_Pos' has a wrong offset!");
static_assert(offsetof(FUIAnimationPlayData, M_Alpha) == 0x00002C, "Member 'FUIAnimationPlayData::M_Alpha' has a wrong offset!");
static_assert(offsetof(FUIAnimationPlayData, M_Time) == 0x000030, "Member 'FUIAnimationPlayData::M_Time' has a wrong offset!");
static_assert(offsetof(FUIAnimationPlayData, M_IsReverse) == 0x000034, "Member 'FUIAnimationPlayData::M_IsReverse' has a wrong offset!");

// ScriptStruct Project.UIAnimationTaskData
// 0x0030 (0x0030 - 0x0000)
struct FUIAnimationTaskData final
{
public:
	int32                                         M_TaskIndex;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIAnimationPlayData>           M_PlayData;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_PlayDataIndex;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsReverse;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsLoop;                                          // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              M_Pos;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Alpha;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsEnd;                                           // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIAnimationTaskData) == 0x000008, "Wrong alignment on FUIAnimationTaskData");
static_assert(sizeof(FUIAnimationTaskData) == 0x000030, "Wrong size on FUIAnimationTaskData");
static_assert(offsetof(FUIAnimationTaskData, M_TaskIndex) == 0x000000, "Member 'FUIAnimationTaskData::M_TaskIndex' has a wrong offset!");
static_assert(offsetof(FUIAnimationTaskData, M_PlayData) == 0x000008, "Member 'FUIAnimationTaskData::M_PlayData' has a wrong offset!");
static_assert(offsetof(FUIAnimationTaskData, M_PlayDataIndex) == 0x000018, "Member 'FUIAnimationTaskData::M_PlayDataIndex' has a wrong offset!");
static_assert(offsetof(FUIAnimationTaskData, M_IsReverse) == 0x00001C, "Member 'FUIAnimationTaskData::M_IsReverse' has a wrong offset!");
static_assert(offsetof(FUIAnimationTaskData, M_IsLoop) == 0x00001D, "Member 'FUIAnimationTaskData::M_IsLoop' has a wrong offset!");
static_assert(offsetof(FUIAnimationTaskData, M_Pos) == 0x000020, "Member 'FUIAnimationTaskData::M_Pos' has a wrong offset!");
static_assert(offsetof(FUIAnimationTaskData, M_Alpha) == 0x000028, "Member 'FUIAnimationTaskData::M_Alpha' has a wrong offset!");
static_assert(offsetof(FUIAnimationTaskData, M_IsEnd) == 0x00002C, "Member 'FUIAnimationTaskData::M_IsEnd' has a wrong offset!");

// ScriptStruct Project.UIAnimationAlphaTableData
// 0x0010 (0x0010 - 0x0000)
struct FUIAnimationAlphaTableData final
{
public:
	float                                         M_Start;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_End;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Time;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsLoop;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIAnimationAlphaTableData) == 0x000004, "Wrong alignment on FUIAnimationAlphaTableData");
static_assert(sizeof(FUIAnimationAlphaTableData) == 0x000010, "Wrong size on FUIAnimationAlphaTableData");
static_assert(offsetof(FUIAnimationAlphaTableData, M_Start) == 0x000000, "Member 'FUIAnimationAlphaTableData::M_Start' has a wrong offset!");
static_assert(offsetof(FUIAnimationAlphaTableData, M_End) == 0x000004, "Member 'FUIAnimationAlphaTableData::M_End' has a wrong offset!");
static_assert(offsetof(FUIAnimationAlphaTableData, M_Time) == 0x000008, "Member 'FUIAnimationAlphaTableData::M_Time' has a wrong offset!");
static_assert(offsetof(FUIAnimationAlphaTableData, M_IsLoop) == 0x00000C, "Member 'FUIAnimationAlphaTableData::M_IsLoop' has a wrong offset!");

// ScriptStruct Project.UIAnimationMoveTableData
// 0x0018 (0x0018 - 0x0000)
struct FUIAnimationMoveTableData final
{
public:
	struct FVector2D                              M_Start;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_End;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_Time;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsLoop;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIAnimationMoveTableData) == 0x000004, "Wrong alignment on FUIAnimationMoveTableData");
static_assert(sizeof(FUIAnimationMoveTableData) == 0x000018, "Wrong size on FUIAnimationMoveTableData");
static_assert(offsetof(FUIAnimationMoveTableData, M_Start) == 0x000000, "Member 'FUIAnimationMoveTableData::M_Start' has a wrong offset!");
static_assert(offsetof(FUIAnimationMoveTableData, M_End) == 0x000008, "Member 'FUIAnimationMoveTableData::M_End' has a wrong offset!");
static_assert(offsetof(FUIAnimationMoveTableData, M_Time) == 0x000010, "Member 'FUIAnimationMoveTableData::M_Time' has a wrong offset!");
static_assert(offsetof(FUIAnimationMoveTableData, M_IsLoop) == 0x000014, "Member 'FUIAnimationMoveTableData::M_IsLoop' has a wrong offset!");

// ScriptStruct Project.BtlUICommandData
// 0x0007 (0x0007 - 0x0000)
struct FBtlUICommandData final
{
public:
	E_BTL_UI_COMMAND                              M_CommId;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_ACTION_MAPPING_TYPE                         M_ActMappingType;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsLButton;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsUse;                                           // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_INPUT_TYPE                                  M_InputType;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsHiddenTexture;                                 // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsLockKey;                                       // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlUICommandData) == 0x000001, "Wrong alignment on FBtlUICommandData");
static_assert(sizeof(FBtlUICommandData) == 0x000007, "Wrong size on FBtlUICommandData");
static_assert(offsetof(FBtlUICommandData, M_CommId) == 0x000000, "Member 'FBtlUICommandData::M_CommId' has a wrong offset!");
static_assert(offsetof(FBtlUICommandData, M_ActMappingType) == 0x000001, "Member 'FBtlUICommandData::M_ActMappingType' has a wrong offset!");
static_assert(offsetof(FBtlUICommandData, M_IsLButton) == 0x000002, "Member 'FBtlUICommandData::M_IsLButton' has a wrong offset!");
static_assert(offsetof(FBtlUICommandData, M_IsUse) == 0x000003, "Member 'FBtlUICommandData::M_IsUse' has a wrong offset!");
static_assert(offsetof(FBtlUICommandData, M_InputType) == 0x000004, "Member 'FBtlUICommandData::M_InputType' has a wrong offset!");
static_assert(offsetof(FBtlUICommandData, M_IsHiddenTexture) == 0x000005, "Member 'FBtlUICommandData::M_IsHiddenTexture' has a wrong offset!");
static_assert(offsetof(FBtlUICommandData, M_IsLockKey) == 0x000006, "Member 'FBtlUICommandData::M_IsLockKey' has a wrong offset!");

// ScriptStruct Project.UIStatusDataLeft
// 0x0070 (0x0070 - 0x0000)
struct FUIStatusDataLeft final
{
public:
	int32                                         M_DevilID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Level;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_HP;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MP;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Exp;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MaxExp;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAbilData                              M_AbilData;                                        // 0x0018(0x001C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_DefenceAishou;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	E_UI_STATUS_BOOK                              M_DevilBook;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_UI_STATUS_ESSENCE_ICON                      M_EssenceIcon;                                     // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_SkillTekisei;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_OpenFlag;                                        // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_DefenceAishouOpenFlag;                           // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_SkillTekiseiOpenFlag;                            // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIStatusDataLeft) == 0x000008, "Wrong alignment on FUIStatusDataLeft");
static_assert(sizeof(FUIStatusDataLeft) == 0x000070, "Wrong size on FUIStatusDataLeft");
static_assert(offsetof(FUIStatusDataLeft, M_DevilID) == 0x000000, "Member 'FUIStatusDataLeft::M_DevilID' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_Level) == 0x000004, "Member 'FUIStatusDataLeft::M_Level' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_HP) == 0x000008, "Member 'FUIStatusDataLeft::M_HP' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_MP) == 0x00000C, "Member 'FUIStatusDataLeft::M_MP' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_Exp) == 0x000010, "Member 'FUIStatusDataLeft::M_Exp' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_MaxExp) == 0x000014, "Member 'FUIStatusDataLeft::M_MaxExp' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_AbilData) == 0x000018, "Member 'FUIStatusDataLeft::M_AbilData' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_DefenceAishou) == 0x000038, "Member 'FUIStatusDataLeft::M_DefenceAishou' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_DevilBook) == 0x000048, "Member 'FUIStatusDataLeft::M_DevilBook' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_EssenceIcon) == 0x000049, "Member 'FUIStatusDataLeft::M_EssenceIcon' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_SkillTekisei) == 0x000050, "Member 'FUIStatusDataLeft::M_SkillTekisei' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_OpenFlag) == 0x000060, "Member 'FUIStatusDataLeft::M_OpenFlag' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_DefenceAishouOpenFlag) == 0x000064, "Member 'FUIStatusDataLeft::M_DefenceAishouOpenFlag' has a wrong offset!");
static_assert(offsetof(FUIStatusDataLeft, M_SkillTekiseiOpenFlag) == 0x000068, "Member 'FUIStatusDataLeft::M_SkillTekiseiOpenFlag' has a wrong offset!");

// ScriptStruct Project.UILevelBootCategoryData
// 0x0028 (0x0028 - 0x0000)
struct FUILevelBootCategoryData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDirectData;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUILevelBootItemData>           ItemData;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUILevelBootCategoryData) == 0x000008, "Wrong alignment on FUILevelBootCategoryData");
static_assert(sizeof(FUILevelBootCategoryData) == 0x000028, "Wrong size on FUILevelBootCategoryData");
static_assert(offsetof(FUILevelBootCategoryData, Name) == 0x000000, "Member 'FUILevelBootCategoryData::Name' has a wrong offset!");
static_assert(offsetof(FUILevelBootCategoryData, IsDirectData) == 0x000010, "Member 'FUILevelBootCategoryData::IsDirectData' has a wrong offset!");
static_assert(offsetof(FUILevelBootCategoryData, ItemData) == 0x000018, "Member 'FUILevelBootCategoryData::ItemData' has a wrong offset!");

// ScriptStruct Project.UIListCursorData
// 0x0014 (0x0014 - 0x0000)
struct FUIListCursorData final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TopIndex;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BottomIndex;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewMax;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIListCursorData) == 0x000004, "Wrong alignment on FUIListCursorData");
static_assert(sizeof(FUIListCursorData) == 0x000014, "Wrong size on FUIListCursorData");
static_assert(offsetof(FUIListCursorData, Index) == 0x000000, "Member 'FUIListCursorData::Index' has a wrong offset!");
static_assert(offsetof(FUIListCursorData, TopIndex) == 0x000004, "Member 'FUIListCursorData::TopIndex' has a wrong offset!");
static_assert(offsetof(FUIListCursorData, BottomIndex) == 0x000008, "Member 'FUIListCursorData::BottomIndex' has a wrong offset!");
static_assert(offsetof(FUIListCursorData, ViewMax) == 0x00000C, "Member 'FUIListCursorData::ViewMax' has a wrong offset!");
static_assert(offsetof(FUIListCursorData, ItemNum) == 0x000010, "Member 'FUIListCursorData::ItemNum' has a wrong offset!");

// ScriptStruct Project.UniteCharaPanelStockListData
// 0x0008 (0x0008 - 0x0000)
struct FUniteCharaPanelStockListData final
{
public:
	uint8                                         M_NkmIndex;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_GlobalEntryId;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteCharaPanelStockListData) == 0x000004, "Wrong alignment on FUniteCharaPanelStockListData");
static_assert(sizeof(FUniteCharaPanelStockListData) == 0x000008, "Wrong size on FUniteCharaPanelStockListData");
static_assert(offsetof(FUniteCharaPanelStockListData, M_NkmIndex) == 0x000000, "Member 'FUniteCharaPanelStockListData::M_NkmIndex' has a wrong offset!");
static_assert(offsetof(FUniteCharaPanelStockListData, M_GlobalEntryId) == 0x000004, "Member 'FUniteCharaPanelStockListData::M_GlobalEntryId' has a wrong offset!");

// ScriptStruct Project.SpecialFusionSourceDevil
// 0x000C (0x000C - 0x0000)
struct FSpecialFusionSourceDevil final
{
public:
	int32                                         DevilID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_UNITECHARAPANEL_DEVILDATATYPE               Type;                                              // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialFusionSourceDevil) == 0x000004, "Wrong alignment on FSpecialFusionSourceDevil");
static_assert(sizeof(FSpecialFusionSourceDevil) == 0x00000C, "Wrong size on FSpecialFusionSourceDevil");
static_assert(offsetof(FSpecialFusionSourceDevil, DevilID) == 0x000000, "Member 'FSpecialFusionSourceDevil::DevilID' has a wrong offset!");
static_assert(offsetof(FSpecialFusionSourceDevil, Type) == 0x000004, "Member 'FSpecialFusionSourceDevil::Type' has a wrong offset!");
static_assert(offsetof(FSpecialFusionSourceDevil, Cost) == 0x000008, "Member 'FSpecialFusionSourceDevil::Cost' has a wrong offset!");

// ScriptStruct Project.SpecialFusionResult
// 0x0030 (0x0030 - 0x0000)
struct FSpecialFusionResult final
{
public:
	TArray<struct FSpecialFusionSourceDevil>      SourceDevilList;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSpecialFusionResultDevil              ResultDevil;                                       // 0x0010(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialFusionResult) == 0x000008, "Wrong alignment on FSpecialFusionResult");
static_assert(sizeof(FSpecialFusionResult) == 0x000030, "Wrong size on FSpecialFusionResult");
static_assert(offsetof(FSpecialFusionResult, SourceDevilList) == 0x000000, "Member 'FSpecialFusionResult::SourceDevilList' has a wrong offset!");
static_assert(offsetof(FSpecialFusionResult, ResultDevil) == 0x000010, "Member 'FSpecialFusionResult::ResultDevil' has a wrong offset!");

// ScriptStruct Project.UniteUtsusemiSetupData
// 0x0030 (0x0030 - 0x0000)
struct FUniteUtsusemiSetupData final
{
public:
	int32                                         ResultNkmIndex;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceDevilId;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUniteSkillData>                PossibleSkillList;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SelectedSkillList;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDefenceAishouMode;                                // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniteUtsusemiSetupData) == 0x000008, "Wrong alignment on FUniteUtsusemiSetupData");
static_assert(sizeof(FUniteUtsusemiSetupData) == 0x000030, "Wrong size on FUniteUtsusemiSetupData");
static_assert(offsetof(FUniteUtsusemiSetupData, ResultNkmIndex) == 0x000000, "Member 'FUniteUtsusemiSetupData::ResultNkmIndex' has a wrong offset!");
static_assert(offsetof(FUniteUtsusemiSetupData, SourceDevilId) == 0x000004, "Member 'FUniteUtsusemiSetupData::SourceDevilId' has a wrong offset!");
static_assert(offsetof(FUniteUtsusemiSetupData, PossibleSkillList) == 0x000008, "Member 'FUniteUtsusemiSetupData::PossibleSkillList' has a wrong offset!");
static_assert(offsetof(FUniteUtsusemiSetupData, SelectedSkillList) == 0x000018, "Member 'FUniteUtsusemiSetupData::SelectedSkillList' has a wrong offset!");
static_assert(offsetof(FUniteUtsusemiSetupData, bDefenceAishouMode) == 0x000028, "Member 'FUniteUtsusemiSetupData::bDefenceAishouMode' has a wrong offset!");

// ScriptStruct Project.UniteSetupData
// 0x0060 (0x0060 - 0x0000)
struct FUniteSetupData final
{
public:
	int32                                         ResultDevilId;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccidentDevilId;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SourceDevilList;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniteSkillData>                PossibleSkillList;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SelectedSkillList;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAbilData                              BonusParam;                                        // 0x0040(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniteSetupData) == 0x000008, "Wrong alignment on FUniteSetupData");
static_assert(sizeof(FUniteSetupData) == 0x000060, "Wrong size on FUniteSetupData");
static_assert(offsetof(FUniteSetupData, ResultDevilId) == 0x000000, "Member 'FUniteSetupData::ResultDevilId' has a wrong offset!");
static_assert(offsetof(FUniteSetupData, AccidentDevilId) == 0x000004, "Member 'FUniteSetupData::AccidentDevilId' has a wrong offset!");
static_assert(offsetof(FUniteSetupData, SourceDevilList) == 0x000008, "Member 'FUniteSetupData::SourceDevilList' has a wrong offset!");
static_assert(offsetof(FUniteSetupData, PossibleSkillList) == 0x000018, "Member 'FUniteSetupData::PossibleSkillList' has a wrong offset!");
static_assert(offsetof(FUniteSetupData, SelectedSkillList) == 0x000028, "Member 'FUniteSetupData::SelectedSkillList' has a wrong offset!");
static_assert(offsetof(FUniteSetupData, Cost) == 0x000038, "Member 'FUniteSetupData::Cost' has a wrong offset!");
static_assert(offsetof(FUniteSetupData, Exp) == 0x00003C, "Member 'FUniteSetupData::Exp' has a wrong offset!");
static_assert(offsetof(FUniteSetupData, BonusParam) == 0x000040, "Member 'FUniteSetupData::BonusParam' has a wrong offset!");

// ScriptStruct Project.UniteBibleViewData
// 0x0010 (0x0010 - 0x0000)
struct FUniteBibleViewData final
{
public:
	int32                                         DevilID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEntry;                                           // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniteBibleViewData) == 0x000004, "Wrong alignment on FUniteBibleViewData");
static_assert(sizeof(FUniteBibleViewData) == 0x000010, "Wrong size on FUniteBibleViewData");
static_assert(offsetof(FUniteBibleViewData, DevilID) == 0x000000, "Member 'FUniteBibleViewData::DevilID' has a wrong offset!");
static_assert(offsetof(FUniteBibleViewData, Level) == 0x000004, "Member 'FUniteBibleViewData::Level' has a wrong offset!");
static_assert(offsetof(FUniteBibleViewData, Cost) == 0x000008, "Member 'FUniteBibleViewData::Cost' has a wrong offset!");
static_assert(offsetof(FUniteBibleViewData, IsEntry) == 0x00000C, "Member 'FUniteBibleViewData::IsEntry' has a wrong offset!");

// ScriptStruct Project.UniteLearnSkill
// 0x0010 (0x0010 - 0x0000)
struct FUniteLearnSkill final
{
public:
	int32                                         SkillId;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsResultSkill;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TekiseiValue;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Makka;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteLearnSkill) == 0x000004, "Wrong alignment on FUniteLearnSkill");
static_assert(sizeof(FUniteLearnSkill) == 0x000010, "Wrong size on FUniteLearnSkill");
static_assert(offsetof(FUniteLearnSkill, SkillId) == 0x000000, "Member 'FUniteLearnSkill::SkillId' has a wrong offset!");
static_assert(offsetof(FUniteLearnSkill, IsResultSkill) == 0x000004, "Member 'FUniteLearnSkill::IsResultSkill' has a wrong offset!");
static_assert(offsetof(FUniteLearnSkill, TekiseiValue) == 0x000008, "Member 'FUniteLearnSkill::TekiseiValue' has a wrong offset!");
static_assert(offsetof(FUniteLearnSkill, Makka) == 0x00000C, "Member 'FUniteLearnSkill::Makka' has a wrong offset!");

// ScriptStruct Project.UniteDlcDevilTable
// 0x0004 (0x0004 - 0x0000)
struct FUniteDlcDevilTable final
{
public:
	int32                                         DevilID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteDlcDevilTable) == 0x000004, "Wrong alignment on FUniteDlcDevilTable");
static_assert(sizeof(FUniteDlcDevilTable) == 0x000004, "Wrong size on FUniteDlcDevilTable");
static_assert(offsetof(FUniteDlcDevilTable, DevilID) == 0x000000, "Member 'FUniteDlcDevilTable::DevilID' has a wrong offset!");

// ScriptStruct Project.UniteCombineData
// 0x0010 (0x0010 - 0x0000)
struct FUniteCombineData final
{
public:
	int32                                         Id2;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Id1;                                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Key;                                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResultId;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteCombineData) == 0x000004, "Wrong alignment on FUniteCombineData");
static_assert(sizeof(FUniteCombineData) == 0x000010, "Wrong size on FUniteCombineData");
static_assert(offsetof(FUniteCombineData, Id2) == 0x000000, "Member 'FUniteCombineData::Id2' has a wrong offset!");
static_assert(offsetof(FUniteCombineData, Id1) == 0x000004, "Member 'FUniteCombineData::Id1' has a wrong offset!");
static_assert(offsetof(FUniteCombineData, Key) == 0x000008, "Member 'FUniteCombineData::Key' has a wrong offset!");
static_assert(offsetof(FUniteCombineData, ResultId) == 0x00000C, "Member 'FUniteCombineData::ResultId' has a wrong offset!");

// ScriptStruct Project.UniteCombineHead
// 0x0004 (0x0004 - 0x0000)
struct FUniteCombineHead final
{
public:
	int32                                         TableMax;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteCombineHead) == 0x000004, "Wrong alignment on FUniteCombineHead");
static_assert(sizeof(FUniteCombineHead) == 0x000004, "Wrong size on FUniteCombineHead");
static_assert(offsetof(FUniteCombineHead, TableMax) == 0x000000, "Member 'FUniteCombineHead::TableMax' has a wrong offset!");

// ScriptStruct Project.UniteAccidentTable
// 0x0008 (0x0008 - 0x0000)
struct FUniteAccidentTable final
{
public:
	int32                                         AddLevel;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rate;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteAccidentTable) == 0x000004, "Wrong alignment on FUniteAccidentTable");
static_assert(sizeof(FUniteAccidentTable) == 0x000008, "Wrong size on FUniteAccidentTable");
static_assert(offsetof(FUniteAccidentTable, AddLevel) == 0x000000, "Member 'FUniteAccidentTable::AddLevel' has a wrong offset!");
static_assert(offsetof(FUniteAccidentTable, Rate) == 0x000004, "Member 'FUniteAccidentTable::Rate' has a wrong offset!");

// ScriptStruct Project.UniteAccidentProbTable
// 0x001C (0x001C - 0x0000)
struct FUniteAccidentProbTable final
{
public:
	int32                                         ProbNormalMoon;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbFullMoon;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbNewMoon0;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbNewMoon1;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbNewMoon2;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbMissDevil;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbAccidentDevil;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteAccidentProbTable) == 0x000004, "Wrong alignment on FUniteAccidentProbTable");
static_assert(sizeof(FUniteAccidentProbTable) == 0x00001C, "Wrong size on FUniteAccidentProbTable");
static_assert(offsetof(FUniteAccidentProbTable, ProbNormalMoon) == 0x000000, "Member 'FUniteAccidentProbTable::ProbNormalMoon' has a wrong offset!");
static_assert(offsetof(FUniteAccidentProbTable, ProbFullMoon) == 0x000004, "Member 'FUniteAccidentProbTable::ProbFullMoon' has a wrong offset!");
static_assert(offsetof(FUniteAccidentProbTable, ProbNewMoon0) == 0x000008, "Member 'FUniteAccidentProbTable::ProbNewMoon0' has a wrong offset!");
static_assert(offsetof(FUniteAccidentProbTable, ProbNewMoon1) == 0x00000C, "Member 'FUniteAccidentProbTable::ProbNewMoon1' has a wrong offset!");
static_assert(offsetof(FUniteAccidentProbTable, ProbNewMoon2) == 0x000010, "Member 'FUniteAccidentProbTable::ProbNewMoon2' has a wrong offset!");
static_assert(offsetof(FUniteAccidentProbTable, ProbMissDevil) == 0x000014, "Member 'FUniteAccidentProbTable::ProbMissDevil' has a wrong offset!");
static_assert(offsetof(FUniteAccidentProbTable, ProbAccidentDevil) == 0x000018, "Member 'FUniteAccidentProbTable::ProbAccidentDevil' has a wrong offset!");

// ScriptStruct Project.UniteSeireiTable
// 0x000C (0x000C - 0x0000)
struct FUniteSeireiTable final
{
public:
	int32                                         Group1;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Soul;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteSeireiTable) == 0x000004, "Wrong alignment on FUniteSeireiTable");
static_assert(sizeof(FUniteSeireiTable) == 0x00000C, "Wrong size on FUniteSeireiTable");
static_assert(offsetof(FUniteSeireiTable, Group1) == 0x000000, "Member 'FUniteSeireiTable::Group1' has a wrong offset!");
static_assert(offsetof(FUniteSeireiTable, Soul) == 0x000004, "Member 'FUniteSeireiTable::Soul' has a wrong offset!");
static_assert(offsetof(FUniteSeireiTable, Rank) == 0x000008, "Member 'FUniteSeireiTable::Rank' has a wrong offset!");

// ScriptStruct Project.UniteNormalTable
// 0x000C (0x000C - 0x0000)
struct FUniteNormalTable final
{
public:
	int32                                         Group1;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Group2;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupMake;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniteNormalTable) == 0x000004, "Wrong alignment on FUniteNormalTable");
static_assert(sizeof(FUniteNormalTable) == 0x00000C, "Wrong size on FUniteNormalTable");
static_assert(offsetof(FUniteNormalTable, Group1) == 0x000000, "Member 'FUniteNormalTable::Group1' has a wrong offset!");
static_assert(offsetof(FUniteNormalTable, Group2) == 0x000004, "Member 'FUniteNormalTable::Group2' has a wrong offset!");
static_assert(offsetof(FUniteNormalTable, GroupMake) == 0x000008, "Member 'FUniteNormalTable::GroupMake' has a wrong offset!");

// ScriptStruct Project.WaveMaterialConv
// 0x0050 (0x0058 - 0x0008)
struct FWaveMaterialConv final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UMaterialInterface>      M_SrcMaterial;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      M_WaveMaterial;                                    // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaveMaterialConv) == 0x000008, "Wrong alignment on FWaveMaterialConv");
static_assert(sizeof(FWaveMaterialConv) == 0x000058, "Wrong size on FWaveMaterialConv");
static_assert(offsetof(FWaveMaterialConv, M_SrcMaterial) == 0x000008, "Member 'FWaveMaterialConv::M_SrcMaterial' has a wrong offset!");
static_assert(offsetof(FWaveMaterialConv, M_WaveMaterial) == 0x000030, "Member 'FWaveMaterialConv::M_WaveMaterial' has a wrong offset!");

}

