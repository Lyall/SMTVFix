#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_EncountArea_Magatsuka

#include "Basic.hpp"

#include "BP_EncountArea_Magatsuka_classes.hpp"
#include "BP_EncountArea_Magatsuka_parameters.hpp"


namespace SDK
{

// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.ExecuteUbergraph_BP_EncountArea_Magatsuka
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EncountArea_Magatsuka_C::ExecuteUbergraph_BP_EncountArea_Magatsuka(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "ExecuteUbergraph_BP_EncountArea_Magatsuka");

	Params::BP_EncountArea_Magatsuka_C_ExecuteUbergraph_BP_EncountArea_Magatsuka Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.AllReborn
// (BlueprintCallable, BlueprintEvent)

void ABP_EncountArea_Magatsuka_C::AllReborn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "AllReborn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.MagatsukaSpawnOneSymbol
// (BlueprintCallable, BlueprintEvent)

void ABP_EncountArea_Magatsuka_C::MagatsukaSpawnOneSymbol()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "MagatsukaSpawnOneSymbol");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.AllDead
// (BlueprintCallable, BlueprintEvent)

void ABP_EncountArea_Magatsuka_C::AllDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "AllDead");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.InitMagatsukaArea
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FMagatsukaSymbolPoint>    EncountPackIndex                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Param_NoEncount                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Param_RouteNodeSpace                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Param_RouteNode_LimitHeight                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Param_RouteNode_LimitSlope                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_MagatsukaCenter                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<struct FVector2D>                Param_DevilLocationList                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Param_SafeZoneID                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_ManualSafeZone                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Param_AttackAlongWall                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<struct FSymbolActPattern>        Param_SecondActPatterns                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ABP_EncountArea_Magatsuka_C::InitMagatsukaArea(const TArray<struct FMagatsukaSymbolPoint>& EncountPackIndex, bool Param_NoEncount, float Param_RouteNodeSpace, float Param_RouteNode_LimitHeight, float Param_RouteNode_LimitSlope, bool Param_MagatsukaCenter, const TArray<struct FVector2D>& Param_DevilLocationList, int32 Param_SafeZoneID, bool Param_ManualSafeZone, bool Param_AttackAlongWall, TArray<struct FSymbolActPattern>& Param_SecondActPatterns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "InitMagatsukaArea");

	Params::BP_EncountArea_Magatsuka_C_InitMagatsukaArea Parms{};

	Parms.EncountPackIndex = std::move(EncountPackIndex);
	Parms.Param_NoEncount = Param_NoEncount;
	Parms.Param_RouteNodeSpace = Param_RouteNodeSpace;
	Parms.Param_RouteNode_LimitHeight = Param_RouteNode_LimitHeight;
	Parms.Param_RouteNode_LimitSlope = Param_RouteNode_LimitSlope;
	Parms.Param_MagatsukaCenter = Param_MagatsukaCenter;
	Parms.Param_DevilLocationList = std::move(Param_DevilLocationList);
	Parms.Param_SafeZoneID = Param_SafeZoneID;
	Parms.Param_ManualSafeZone = Param_ManualSafeZone;
	Parms.Param_AttackAlongWall = Param_AttackAlongWall;
	Parms.Param_SecondActPatterns = std::move(Param_SecondActPatterns);

	UObject::ProcessEvent(Func, &Parms);

	Param_SecondActPatterns = std::move(Parms.Param_SecondActPatterns);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.MagatsukaDiscovery
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Discovery                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_EncountArea_Magatsuka_C::MagatsukaDiscovery(bool Param_Discovery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "MagatsukaDiscovery");

	Params::BP_EncountArea_Magatsuka_C_MagatsukaDiscovery Parms{};

	Parms.Param_Discovery = Param_Discovery;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.InitMagatsukaParamTable
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_EncountArea_Magatsuka_C::InitMagatsukaParamTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "InitMagatsukaParamTable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.CalcSpawnPointList_Magatsuka
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Param_SpawnNum                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FTransform>               SpawnPoint                                             (Parm, OutParm)

void ABP_EncountArea_Magatsuka_C::CalcSpawnPointList_Magatsuka(int32 Param_SpawnNum, TArray<struct FTransform>* SpawnPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "CalcSpawnPointList_Magatsuka");

	Params::BP_EncountArea_Magatsuka_C_CalcSpawnPointList_Magatsuka Parms{};

	Parms.Param_SpawnNum = Param_SpawnNum;

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnPoint != nullptr)
		*SpawnPoint = std::move(Parms.SpawnPoint);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.GetUnfixSpawnNum
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Num                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EncountArea_Magatsuka_C::GetUnfixSpawnNum(int32* Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "GetUnfixSpawnNum");

	Params::BP_EncountArea_Magatsuka_C_GetUnfixSpawnNum Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Num != nullptr)
		*Num = Parms.Num;
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.InitRouteNode
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_EncountArea_Magatsuka_C::InitRouteNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "InitRouteNode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_EncountArea_Magatsuka_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.CalcSpawnPointList
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LineTrace                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<struct FTransform>               Param_SpawnPointList                                   (Parm, OutParm)

void ABP_EncountArea_Magatsuka_C::CalcSpawnPointList(bool LineTrace, TArray<struct FTransform>* Param_SpawnPointList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "CalcSpawnPointList");

	Params::BP_EncountArea_Magatsuka_C_CalcSpawnPointList Parms{};

	Parms.LineTrace = LineTrace;

	UObject::ProcessEvent(Func, &Parms);

	if (Param_SpawnPointList != nullptr)
		*Param_SpawnPointList = std::move(Parms.Param_SpawnPointList);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.CheckRouteNodeRange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OK                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_EncountArea_Magatsuka_C::CheckRouteNodeRange(const struct FVector& Location, bool* OK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "CheckRouteNodeRange");

	Params::BP_EncountArea_Magatsuka_C_CheckRouteNodeRange Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	if (OK != nullptr)
		*OK = Parms.OK;
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.GetRandomEncountId
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ArrayIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_MITAMA_ENCOUNT                        MitamaType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_EncountID                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EncountArea_Magatsuka_C::GetRandomEncountId(int32 ArrayIndex, E_MITAMA_ENCOUNT MitamaType, int32* Param_EncountID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "GetRandomEncountId");

	Params::BP_EncountArea_Magatsuka_C_GetRandomEncountId Parms{};

	Parms.ArrayIndex = ArrayIndex;
	Parms.MitamaType = MitamaType;

	UObject::ProcessEvent(Func, &Parms);

	if (Param_EncountID != nullptr)
		*Param_EncountID = Parms.Param_EncountID;
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.GetEncountPack
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ArrayIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_MITAMA_ENCOUNT                        MitamaType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FPackEncount                     Pack                                                   (Parm, OutParm)
// int32                                   Param_PackId                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_EncountArea_Magatsuka_C::GetEncountPack(int32 ArrayIndex, E_MITAMA_ENCOUNT MitamaType, struct FPackEncount* Pack, int32* Param_PackId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "GetEncountPack");

	Params::BP_EncountArea_Magatsuka_C_GetEncountPack Parms{};

	Parms.ArrayIndex = ArrayIndex;
	Parms.MitamaType = MitamaType;

	UObject::ProcessEvent(Func, &Parms);

	if (Pack != nullptr)
		*Pack = std::move(Parms.Pack);

	if (Param_PackId != nullptr)
		*Param_PackId = Parms.Param_PackId;
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.CheckFly
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsFly                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_EncountArea_Magatsuka_C::CheckFly(bool* IsFly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "CheckFly");

	Params::BP_EncountArea_Magatsuka_C_CheckFly Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsFly != nullptr)
		*IsFly = Parms.IsFly;
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.GetMoverData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Pos                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Respawn                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FSymbolMoverData                 Param_MoverData                                        (Parm, OutParm, HasGetValueTypeHash)

void ABP_EncountArea_Magatsuka_C::GetMoverData(const struct FVector& Pos, bool Respawn, struct FSymbolMoverData* Param_MoverData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "GetMoverData");

	Params::BP_EncountArea_Magatsuka_C_GetMoverData Parms{};

	Parms.Pos = std::move(Pos);
	Parms.Respawn = Respawn;

	UObject::ProcessEvent(Func, &Parms);

	if (Param_MoverData != nullptr)
		*Param_MoverData = std::move(Parms.Param_MoverData);
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.CheckFloatingIK_OFF
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SpawnListIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_FloatingIK_OFF                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_EncountArea_Magatsuka_C::CheckFloatingIK_OFF(int32 SpawnListIndex, bool* Param_FloatingIK_OFF)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "CheckFloatingIK_OFF");

	Params::BP_EncountArea_Magatsuka_C_CheckFloatingIK_OFF Parms{};

	Parms.SpawnListIndex = SpawnListIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Param_FloatingIK_OFF != nullptr)
		*Param_FloatingIK_OFF = Parms.Param_FloatingIK_OFF;
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.CheckImmediateUpdateFloatingIK_WhenCameraIn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SpawnListIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ImmediateUpdateFloatingIK                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_EncountArea_Magatsuka_C::CheckImmediateUpdateFloatingIK_WhenCameraIn(int32 SpawnListIndex, bool* ImmediateUpdateFloatingIK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "CheckImmediateUpdateFloatingIK_WhenCameraIn");

	Params::BP_EncountArea_Magatsuka_C_CheckImmediateUpdateFloatingIK_WhenCameraIn Parms{};

	Parms.SpawnListIndex = SpawnListIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (ImmediateUpdateFloatingIK != nullptr)
		*ImmediateUpdateFloatingIK = Parms.ImmediateUpdateFloatingIK;
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.BPI_CheckEncountAreaOverlap
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Overlap                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_EncountArea_Magatsuka_C::BPI_CheckEncountAreaOverlap(bool* Param_Overlap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "BPI_CheckEncountAreaOverlap");

	Params::BP_EncountArea_Magatsuka_C_BPI_CheckEncountAreaOverlap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Overlap != nullptr)
		*Param_Overlap = Parms.Param_Overlap;
}


// Function BP_EncountArea_Magatsuka.BP_EncountArea_Magatsuka_C.BPI_CheckMagatsukaEncountArea
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Magatsuka                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_EncountArea_Magatsuka_C::BPI_CheckMagatsukaEncountArea(bool* Magatsuka)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_EncountArea_Magatsuka_C", "BPI_CheckMagatsukaEncountArea");

	Params::BP_EncountArea_Magatsuka_C_BPI_CheckMagatsukaEncountArea Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Magatsuka != nullptr)
		*Magatsuka = Parms.Magatsuka;
}

}

