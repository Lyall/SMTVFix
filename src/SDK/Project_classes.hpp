#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Project

#include "Basic.hpp"

#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AtRichTextWidget_classes.hpp"
#include "Project_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_classes.hpp"
#include "MovieSceneTracks_classes.hpp"
#include "Foliage_classes.hpp"


namespace SDK
{

// Class Project.CustomPoseWeightTable
// 0x0050 (0x0078 - 0x0028)
class UCustomPoseWeightTable final : public UObject
{
public:
	TMap<class FName, float>                      Map;                                               // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPoseWeightTable">();
	}
	static class UCustomPoseWeightTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomPoseWeightTable>();
	}
};
static_assert(alignof(UCustomPoseWeightTable) == 0x000008, "Wrong alignment on UCustomPoseWeightTable");
static_assert(sizeof(UCustomPoseWeightTable) == 0x000078, "Wrong size on UCustomPoseWeightTable");
static_assert(offsetof(UCustomPoseWeightTable, Map) == 0x000028, "Member 'UCustomPoseWeightTable::Map' has a wrong offset!");

// Class Project.BPL_Asset
// 0x0000 (0x0028 - 0x0028)
class UBPL_Asset final : public UBlueprintFunctionLibrary
{
public:
	static TSubclassOf<class AActor> GetBlueprintGeneratedActorClass(class UObject* BPAsset);
	static class UObject* LoadObjectBlocking(TSoftObjectPtr<class UObject> SoftObjectReference);
	static TSoftObjectPtr<class UCharaLipSync> SearchEventLipSync(const class FName Filename);
	static TSoftObjectPtr<class UCharaLipSync> SearchEventLipSyncEx(const class FName Filename, const class FName Path, const bool UsePath);
	static TSoftObjectPtr<class USoundAtomCue> SearchEventVoice(const class FName VoiceName);
	static TSoftObjectPtr<class USoundAtomCue> SearchEventVoiceEx(const class FName VoiceName, const class FName Path, const bool UsePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Asset">();
	}
	static class UBPL_Asset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Asset>();
	}
};
static_assert(alignof(UBPL_Asset) == 0x000008, "Wrong alignment on UBPL_Asset");
static_assert(sizeof(UBPL_Asset) == 0x000028, "Wrong size on UBPL_Asset");

// Class Project.AchievementManager
// 0x0068 (0x0090 - 0x0028)
class UAchievementManager final : public UObject
{
public:
	uint8                                         Pad_1468[0x68];                                    // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAchievementManager* Get(const class UObject* WorldContextObject);

	void CallCached();
	void CallCheck(float _interval);
	void CallUnlock(const EAchievementFlag _flag, bool _priority, float _interval);
	void LockAchievements();
	void UpdateLatestUnlockList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementManager">();
	}
	static class UAchievementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementManager>();
	}
};
static_assert(alignof(UAchievementManager) == 0x000008, "Wrong alignment on UAchievementManager");
static_assert(sizeof(UAchievementManager) == 0x000090, "Wrong size on UAchievementManager");

// Class Project.BPL_DebugPad
// 0x0000 (0x0028 - 0x0028)
class UBPL_DebugPad final : public UBlueprintFunctionLibrary
{
public:
	static void RegisterSimultaneouslyInputEvent(class UObject* WorldContextObject, const struct FKey& Input1, const struct FKey& Input2, const TDelegate<void()>& Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_DebugPad">();
	}
	static class UBPL_DebugPad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_DebugPad>();
	}
};
static_assert(alignof(UBPL_DebugPad) == 0x000008, "Wrong alignment on UBPL_DebugPad");
static_assert(sizeof(UBPL_DebugPad) == 0x000028, "Wrong size on UBPL_DebugPad");

// Class Project.BPL_TalkUtils
// 0x0000 (0x0028 - 0x0028)
class UBPL_TalkUtils final : public UBlueprintFunctionLibrary
{
public:
	static EDevilTalkVoice GetStringToDevilTalkVoice(const class FString& String);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_TalkUtils">();
	}
	static class UBPL_TalkUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_TalkUtils>();
	}
};
static_assert(alignof(UBPL_TalkUtils) == 0x000008, "Wrong alignment on UBPL_TalkUtils");
static_assert(sizeof(UBPL_TalkUtils) == 0x000028, "Wrong size on UBPL_TalkUtils");

// Class Project.BPL_Achievement
// 0x0000 (0x0028 - 0x0028)
class UBPL_Achievement final : public UBlueprintFunctionLibrary
{
public:
	static void AchievementIntervalChange_Normal(const class UObject* WorldContextObject, float _interval);
	static void AchievementIntervalChange_Priority(const class UObject* WorldContextObject, float _interval);
	static void InstallAchievement(const class UObject* WorldContextObject);
	static void LockAllAchievements(const class UObject* WorldContextObject);
	static void OutputLogConvertTrophyData();
	static void OutputLogSaveTrophyData();
	static void UnlockAchievement(const class UObject* WorldContextObject, const EAchievementFlag _flag, bool _priority);
	static void UnlockAchievement_Delay(const class UObject* WorldContextObject, const EAchievementFlag _flag, bool _priority, float _delay);
	static void UpdateLatestConvertTrophyData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Achievement">();
	}
	static class UBPL_Achievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Achievement>();
	}
};
static_assert(alignof(UBPL_Achievement) == 0x000008, "Wrong alignment on UBPL_Achievement");
static_assert(sizeof(UBPL_Achievement) == 0x000028, "Wrong size on UBPL_Achievement");

// Class Project.MinimapFootprintManager
// 0x0068 (0x0090 - 0x0028)
class alignas(0x10) UMinimapFootprintManager final : public UObject
{
public:
	uint8                                         Pad_146F[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMinimapFootprintEntry>         M_Entries;                                         // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1470[0x50];                                    // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Reset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapFootprintManager">();
	}
	static class UMinimapFootprintManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapFootprintManager>();
	}
};
static_assert(alignof(UMinimapFootprintManager) == 0x000010, "Wrong alignment on UMinimapFootprintManager");
static_assert(sizeof(UMinimapFootprintManager) == 0x000090, "Wrong size on UMinimapFootprintManager");
static_assert(offsetof(UMinimapFootprintManager, M_Entries) == 0x000030, "Member 'UMinimapFootprintManager::M_Entries' has a wrong offset!");

// Class Project.BPL_DebugUtils
// 0x0000 (0x0028 - 0x0028)
class UBPL_DebugUtils final : public UBlueprintFunctionLibrary
{
public:
	static void ClipboardCopy(const class FString& Str);
	static void ClipboardPaste(class FString* Dest);
	static bool DebugFirstInit();
	static void DisableProjectDebugCamera();
	static EDebugFlag EDebugFlag_FromString(const class FString& EnumString);
	static void EnableProjectDebugCamera(const struct FVector& Location, const struct FRotator& Rotation, const struct FTransform& Transform);
	static void GetCollisionProfileNames(TArray<class FString>* CollisionProfileNames);
	static void ProjectConsoleCommand(const class FString& ConsoleCommand);
	static class AProjectDebugCameraController* ProjectDebugCameraGet();
	static struct FTransform ProjectDebugCameraGetTransform();
	static bool ProjectDebugCameraIsEnabled();
	static void ProjectDebugCameraSetDisplay(bool bEnabled);
	static bool ProjectDebugFlagGet(EDebugFlag DebugFlag);
	static bool ProjectDebugFlagSet(EDebugFlag DebugFlag, bool Value);
	static bool ProjectDebugFlagToggle(EDebugFlag DebugFlag);
	static struct FProjectSubLevelStatus ProjectDebugGetLevelStatus(class UObject* WorldContextObject, const class FName& DebugMenuPath);
	static struct FProjectSubLevelStatus ProjectDebugToggleLevelLoad(class UObject* WorldContextObject, const class FName& DebugMenuPath);
	static struct FProjectSubLevelStatus ProjectDebugToggleVolumetricLightmap(class UObject* WorldContextObject, const class FName& DebugMenuPath);
	static void SaveStatsInfo(const class FString& DirectoryPath, const class FString& StatsGroupName);
	static bool ScreenCapture(int32 ScreenWidth, int32 ScreenHeight, const class FString& Filename, bool bAddDateTime, bool bNotFileCompress);
	static void Screenshot(const class FString& DirectoryPath, const class FString& Filename, bool bAddDateTimeToFileName, bool bShowUI);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_DebugUtils">();
	}
	static class UBPL_DebugUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_DebugUtils>();
	}
};
static_assert(alignof(UBPL_DebugUtils) == 0x000008, "Wrong alignment on UBPL_DebugUtils");
static_assert(sizeof(UBPL_DebugUtils) == 0x000028, "Wrong size on UBPL_DebugUtils");

// Class Project.BPL_AchievementCounter
// 0x0000 (0x0028 - 0x0028)
class UBPL_AchievementCounter final : public UBlueprintFunctionLibrary
{
public:
	static void AddUtsusemiUnionCounter(int32* _utsusemiCounter);
	static void CountUpUtsusemiUnionCount();
	static void GetCurrentBattleCounter(uint8* _bunreiKill, uint8* _weak, uint8* _missBlockRefAbs, uint8* _useMagatsuhi);
	static void GetCurrentTalkCounter(int32* _ScoutSuccess, int32* _PaidMoney);
	static int32 GetDevilStatueFlagCount();
	static int32 GetLearningGodParameterCounter();
	static int32 GetSubQuestClearCounter();
	static int32 GetUtsusemiUnionCounter();
	static void SetBunreiKillCounter(uint8 _killCount);
	static void SetMissEtcCounter(uint8 _missEtcCount);
	static void SetPaidMoneyCounter(int32 _paidMoneyCount);
	static void SetScoutSuccessCounter(int32 _scoutSuccessCount);
	static void SetUseMagatsuhiCounter(uint8 _useMagatsuhiCount);
	static void SetWeakCounter(uint8 _weakCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_AchievementCounter">();
	}
	static class UBPL_AchievementCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_AchievementCounter>();
	}
};
static_assert(alignof(UBPL_AchievementCounter) == 0x000008, "Wrong alignment on UBPL_AchievementCounter");
static_assert(sizeof(UBPL_AchievementCounter) == 0x000028, "Wrong size on UBPL_AchievementCounter");

// Class Project.BPL_DownloadContent
// 0x0000 (0x0028 - 0x0028)
class UBPL_DownloadContent final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_DownloadContent">();
	}
	static class UBPL_DownloadContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_DownloadContent>();
	}
};
static_assert(alignof(UBPL_DownloadContent) == 0x000008, "Wrong alignment on UBPL_DownloadContent");
static_assert(sizeof(UBPL_DownloadContent) == 0x000028, "Wrong size on UBPL_DownloadContent");

// Class Project.StatusDevilModelTblData
// 0x0058 (0x0080 - 0x0028)
class UStatusDevilModelTblData final : public UObject
{
public:
	uint8                                         Pad_1475[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_InTableData;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             M_OutTableData;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScriptMessageAsset*                    M_DevilNameMess;                                   // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_DevilNameArray;                                  // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_StartDevilId;                                    // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EndDevilId;                                      // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsCallCreate;                                    // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1476[0x17];                                    // 0x0069(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusDevilModelTblData">();
	}
	static class UStatusDevilModelTblData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusDevilModelTblData>();
	}
};
static_assert(alignof(UStatusDevilModelTblData) == 0x000008, "Wrong alignment on UStatusDevilModelTblData");
static_assert(sizeof(UStatusDevilModelTblData) == 0x000080, "Wrong size on UStatusDevilModelTblData");
static_assert(offsetof(UStatusDevilModelTblData, M_InTableData) == 0x000038, "Member 'UStatusDevilModelTblData::M_InTableData' has a wrong offset!");
static_assert(offsetof(UStatusDevilModelTblData, M_OutTableData) == 0x000040, "Member 'UStatusDevilModelTblData::M_OutTableData' has a wrong offset!");
static_assert(offsetof(UStatusDevilModelTblData, M_DevilNameMess) == 0x000048, "Member 'UStatusDevilModelTblData::M_DevilNameMess' has a wrong offset!");
static_assert(offsetof(UStatusDevilModelTblData, M_DevilNameArray) == 0x000050, "Member 'UStatusDevilModelTblData::M_DevilNameArray' has a wrong offset!");
static_assert(offsetof(UStatusDevilModelTblData, M_StartDevilId) == 0x000060, "Member 'UStatusDevilModelTblData::M_StartDevilId' has a wrong offset!");
static_assert(offsetof(UStatusDevilModelTblData, M_EndDevilId) == 0x000064, "Member 'UStatusDevilModelTblData::M_EndDevilId' has a wrong offset!");
static_assert(offsetof(UStatusDevilModelTblData, M_IsCallCreate) == 0x000068, "Member 'UStatusDevilModelTblData::M_IsCallCreate' has a wrong offset!");

// Class Project.ActivityManager
// 0x0070 (0x0098 - 0x0028)
class UActivityManager final : public UObject
{
public:
	uint8                                         Pad_1477[0x70];                                    // 0x0028(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UActivityManager* Get(const class UObject* WorldContextObject);

	EActivityType GetCardType();
	void ResetCardType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityManager">();
	}
	static class UActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityManager>();
	}
};
static_assert(alignof(UActivityManager) == 0x000008, "Wrong alignment on UActivityManager");
static_assert(sizeof(UActivityManager) == 0x000098, "Wrong size on UActivityManager");

// Class Project.BPL_DrawDebugPause
// 0x0000 (0x0028 - 0x0028)
class UBPL_DrawDebugPause final : public UBlueprintFunctionLibrary
{
public:
	static void DrawDebugArrowWhenPaused(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FLinearColor& LineColor, float Thickness);
	static void DrawDebugBoxWhenPaused(class UObject* WorldContextObject, const struct FVector& Center, const struct FVector& Extent, const struct FLinearColor& LineColor, const struct FRotator& Rotation, float Thickness);
	static void DrawDebugCapsuleWhenPaused(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Thickness);
	static void DrawDebugCircleWhenPaused(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 NumSegments, const struct FLinearColor& LineColor, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis);
	static void DrawDebugConeInDegreesWhenPaused(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FLinearColor& LineColor, float Thickness);
	static void DrawDebugConeWhenPaused(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FLinearColor& LineColor, float Thickness);
	static void DrawDebugCoordinateSystemWhenPaused(class UObject* WorldContextObject, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, float Thickness);
	static void DrawDebugCylinderWhenPaused(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, int32 Segments, const struct FLinearColor& LineColor, float Thickness);
	static void DrawDebugLineWhenPaused(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& LineColor, float Thickness);
	static void DrawDebugPointWhenPaused(class UObject* WorldContextObject, const struct FVector& Position, float Size, const struct FLinearColor& PointColor);
	static void DrawDebugSphereWhenPaused(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 Segments, const struct FLinearColor& LineColor, float Thickness);
	static void DrawDebugStringWhenPaused(class UObject* WorldContextObject, const struct FVector& TextLocation, const class FString& Text, const struct FLinearColor& TextColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_DrawDebugPause">();
	}
	static class UBPL_DrawDebugPause* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_DrawDebugPause>();
	}
};
static_assert(alignof(UBPL_DrawDebugPause) == 0x000008, "Wrong alignment on UBPL_DrawDebugPause");
static_assert(sizeof(UBPL_DrawDebugPause) == 0x000028, "Wrong size on UBPL_DrawDebugPause");

// Class Project.BPL_Activity
// 0x0000 (0x0028 - 0x0028)
class UBPL_Activity final : public UBlueprintFunctionLibrary
{
public:
	static void ActivityAvailabilityChange(const class FString& ActivityId, bool Enable);
	static void ActivityEnd(const class FString& ActivityId);
	static void ActivityResume(const class FString& ActivityId, const class FString& InProgressTask, const TArray<class FString>& InCompletedTasks);
	static void ActivityStart(const class FString& ActivityId);
	static void ActivityTerminate();
	static class FString ConvertActivityId(const EActivityType _actType, const EActivityTaskID _actTask);
	static void FinishActivity(const EActivityType _activityType, const class UObject* WorldContextObject);
	static EActivityType GetActivityCardType(const class UObject* WorldContextObject);
	static EActivityTaskID GetProgressActivityID(const class UObject* WorldContextObject);
	static void InstallActivity(class UDataTable* _table, const class UObject* WorldContextObject);
	static bool IsActivityRequest(const class UObject* WorldContextObject);
	static void LoadActivity(const EActivityType _actType, const EActivityTaskID _actTask, const class UObject* WorldContextObject);
	static TArray<class FString> MakeCompletedTasksList(const EActivityType _actType, const EActivityTaskID _actTask);
	static void ResetActivities(const class UObject* WorldContextObject);
	static void ResetActivityAvailability(EActivityType _activityType);
	static void ResetActivityRequest(const class UObject* WorldContextObject);
	static void SetActivityFromId(EActivityType _activity, EActivityTaskID _task, const class UObject* WorldContextObject);
	static void SetActivityFromMapEvent(int32 _mapEventID, const class UObject* WorldContextObject);
	static void StartActivity(const EActivityType _activityType, const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Activity">();
	}
	static class UBPL_Activity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Activity>();
	}
};
static_assert(alignof(UBPL_Activity) == 0x000008, "Wrong alignment on UBPL_Activity");
static_assert(sizeof(UBPL_Activity) == 0x000028, "Wrong size on UBPL_Activity");

// Class Project.BPL_EventFlag
// 0x0000 (0x0028 - 0x0028)
class UBPL_EventFlag final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckEventFlag(class FName Param_Name);
	static bool CheckEventFlagValue(int32 Flag);
	static void ClearAllEventFlag();
	static int32 NameToValue(const class FName& FlagName);
	static void SetEventFlag(class FName Param_Name, bool Sw);
	static void SetEventFlagValue(int32 Flag, bool Sw);
	static class FName ValueToName(int32 FlagValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_EventFlag">();
	}
	static class UBPL_EventFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_EventFlag>();
	}
};
static_assert(alignof(UBPL_EventFlag) == 0x000008, "Wrong alignment on UBPL_EventFlag");
static_assert(sizeof(UBPL_EventFlag) == 0x000028, "Wrong size on UBPL_EventFlag");

// Class Project.BPL_Analyze
// 0x0000 (0x0028 - 0x0028)
class UBPL_Analyze final : public UBlueprintFunctionLibrary
{
public:
	static void Analyze_AllClearByReincarnation();
	static void Analyze_AllClearByRenewal();
	static bool Analyze_CheckIsOpenAnalyze(const int32 DevilID);
	static bool Analyze_CheckIsOpenAnalyzeArg(const int32 DevilID, struct FAnalyzeData* Data);
	static bool Analyze_CheckIsOpenDefenceAisyou(const int32 DevilID, const E_ATTRIBUTE_TYPE Type);
	static bool Analyze_CheckIsOpenDefenceAisyouArg(const int32 DevilID, const E_ATTRIBUTE_TYPE Type, struct FAnalyzeData* Data);
	static bool Analyze_CheckIsOpenSkill(const int32 DevilID, const int32 SkillId);
	static bool Analyze_CheckIsOpenSkillArg(const int32 DevilID, const int32 SkillId, struct FAnalyzeData* Data);
	static bool Analyze_CheckIsOpenSkillTekisei(const int32 DevilID, const E_SKILL_TEKISEI_CATEGORY Category);
	static bool Analyze_CheckIsOpenSkillTekiseiArg(const int32 DevilID, const E_SKILL_TEKISEI_CATEGORY Category, struct FAnalyzeData* Data);
	static bool Analyze_CheckIsOpenUniqueSkill(const int32 DevilID);
	static bool Analyze_CheckIsOpenUniqueSkillArg(const int32 DevilID, struct FAnalyzeData* Data);
	static void Analyze_Clear(const int32 DevilID);
	static struct FAnalyzeData Analyze_GetAnalyzeData(const int32 DevilID);
	static bool Analyze_IsNewIconFlagOn(const int32 DevilID);
	static void Analyze_OpenAutoSkill(const int32 DevilID, const int32 UseAutoSkillId);
	static void Analyze_OpenAutoSkillArg(const int32 DevilID, const int32 UseAutoSkillId, struct FAnalyzeData* Data, const int32& SwapSkillID);
	static void Analyze_OpenDefenceAishou(const int32 DevilID, const int32 HitSkillId);
	static void Analyze_OpenDefenceAishouArg(const int32 DevilID, const int32 HitSkillId, struct FAnalyzeData* Data);
	static void Analyze_OpenDefenceAishouAttr(const int32 DevilID, const E_ATTRIBUTE_TYPE Attr);
	static void Analyze_OpenDefenceAishouAttrArg(const int32 DevilID, const E_ATTRIBUTE_TYPE Attr, struct FAnalyzeData* Data);
	static void Analyze_OpenSkill(const int32 DevilID, const int32 UseSkillId);
	static void Analyze_OpenSkillArg(const int32 DevilID, const int32 UseSkillId, struct FAnalyzeData* Data, const int32& SwapSkillID);
	static void Analyze_OpenSkillTekisei(const int32 DevilID, const E_SKILL_TEKISEI_CATEGORY Category);
	static void Analyze_OpenSkillTekiseiArg(const int32 DevilID, const E_SKILL_TEKISEI_CATEGORY Category, struct FAnalyzeData* Data);
	static void Analyze_OpenUniqueSkill(const int32 DevilID);
	static void Analyze_OpenUniqueSkillArg(const int32 DevilID, struct FAnalyzeData* Data);
	static void Analyze_ResetNewIconFlag(const int32 DevilID);
	static void Analyze_SetNewIconFlag(const int32 DevilID);
	static void Analyze_SetOpenFlag(const int32 DevilID, bool IsOpen);
	static void Analyze_SetOpenFlagArg(const int32 DevilID, bool IsOpen, struct FAnalyzeData* Data);
	static void Analyze_TakeOverDefenceAishou(const int32 RootDevilId, const int32 TargetDevilId);
	static void Analyze_TakeOverDefenceAishouArg(const int32 RootDevilId, const int32 TargetDevilId, struct FAnalyzeData* RootData, struct FAnalyzeData* TargetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Analyze">();
	}
	static class UBPL_Analyze* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Analyze>();
	}
};
static_assert(alignof(UBPL_Analyze) == 0x000008, "Wrong alignment on UBPL_Analyze");
static_assert(sizeof(UBPL_Analyze) == 0x000028, "Wrong size on UBPL_Analyze");

// Class Project.SysFlagEditor
// 0x0000 (0x0220 - 0x0220)
class ASysFlagEditor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SysFlagEditor">();
	}
	static class ASysFlagEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASysFlagEditor>();
	}
};
static_assert(alignof(ASysFlagEditor) == 0x000008, "Wrong alignment on ASysFlagEditor");
static_assert(sizeof(ASysFlagEditor) == 0x000220, "Wrong size on ASysFlagEditor");

// Class Project.AnimationCameraComponent
// 0x0040 (0x0810 - 0x07D0)
class UAnimationCameraComponent final : public UCameraComponent
{
public:
	float                                         FovAdjuster;                                       // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A7[0x4];                                     // 0x07D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraAnimationAsset*                  Animation;                                         // 0x07D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14A8[0x30];                                    // 0x07E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayAnimation(class UCameraAnimationAsset* InAnimation, class UCameraAnimationAsset* InAnimation2nd, TDelegate<void(float OverrunSec)> OnEndPlay, ECameraAnimationSpace InPlaySpace, float InPlayRate, float InLerpAlpha, bool bInLoop, float InPlayStartPosition);
	void SetPlayRate(float InPlayRate);
	void StopAnimation();
	void UpdateAnimation(float DeltaTime);

	float GetCurrentTime() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationCameraComponent">();
	}
	static class UAnimationCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationCameraComponent>();
	}
};
static_assert(alignof(UAnimationCameraComponent) == 0x000010, "Wrong alignment on UAnimationCameraComponent");
static_assert(sizeof(UAnimationCameraComponent) == 0x000810, "Wrong size on UAnimationCameraComponent");
static_assert(offsetof(UAnimationCameraComponent, FovAdjuster) == 0x0007D0, "Member 'UAnimationCameraComponent::FovAdjuster' has a wrong offset!");
static_assert(offsetof(UAnimationCameraComponent, Animation) == 0x0007D8, "Member 'UAnimationCameraComponent::Animation' has a wrong offset!");

// Class Project.AnimNotify_MotionHead
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_MotionHead final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_MotionHead">();
	}
	static class UAnimNotify_MotionHead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_MotionHead>();
	}
};
static_assert(alignof(UAnimNotify_MotionHead) == 0x000008, "Wrong alignment on UAnimNotify_MotionHead");
static_assert(sizeof(UAnimNotify_MotionHead) == 0x000038, "Wrong size on UAnimNotify_MotionHead");

// Class Project.BPL_AogamiDebrisData
// 0x0000 (0x0028 - 0x0028)
class UBPL_AogamiDebrisData final : public UBlueprintFunctionLibrary
{
public:
	static const struct FAogamiDebrisData GetAogamiDebrisData(int32 MapId, int32 Param_Index);
	static const struct FAogamiDebrisData GetAogamiDebrisData_FromTableIndex(int32 TableIndex);
	static int32 GetAogamiDebrisTableIndex(int32 MapId, int32 Param_Index);
	static int32 GetAogamiDebrisTableMax();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_AogamiDebrisData">();
	}
	static class UBPL_AogamiDebrisData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_AogamiDebrisData>();
	}
};
static_assert(alignof(UBPL_AogamiDebrisData) == 0x000008, "Wrong alignment on UBPL_AogamiDebrisData");
static_assert(sizeof(UBPL_AogamiDebrisData) == 0x000028, "Wrong size on UBPL_AogamiDebrisData");

// Class Project.AtomExpand
// 0x0000 (0x0028 - 0x0028)
class UAtomExpand final : public UBlueprintFunctionLibrary
{
public:
	static bool IsInCategory(class USoundAtomCue* Cue, const class FString& CategoryName);
	static bool IsPreparedStreamSound(class UAtomComponent* Comp);
	static class UAtomComponent* PlaySound2DRooted(const class UObject* WorldContextObject, class USoundAtomCue* Cue, bool bAutoDestroy);
	static void PrepareStreamSound(class UAtomComponent* Comp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomExpand">();
	}
	static class UAtomExpand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomExpand>();
	}
};
static_assert(alignof(UAtomExpand) == 0x000008, "Wrong alignment on UAtomExpand");
static_assert(sizeof(UAtomExpand) == 0x000028, "Wrong size on UAtomExpand");

// Class Project.UIListCursor
// 0x0018 (0x0040 - 0x0028)
class UUIListCursor final : public UObject
{
public:
	uint8                                         Pad_14AF[0x14];                                    // 0x0028(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_IsLimitLock;                                     // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14B0[0x3];                                     // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItemNum(int32 Add);
	struct FUIListCursorData GetCursorData();
	int32 GetNowIndex();
	void Init(int32 Param_Index, int32 TopIndex, int32 ViewMax, int32 ItemNum);
	bool IsLimitLock();
	bool MoveCursor(int32 Add, int32 Set, bool IsLimitStop);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIListCursor">();
	}
	static class UUIListCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIListCursor>();
	}
};
static_assert(alignof(UUIListCursor) == 0x000008, "Wrong alignment on UUIListCursor");
static_assert(sizeof(UUIListCursor) == 0x000040, "Wrong size on UUIListCursor");
static_assert(offsetof(UUIListCursor, M_IsLimitLock) == 0x00003C, "Member 'UUIListCursor::M_IsLimitLock' has a wrong offset!");

// Class Project.BattleActorComponentBase
// 0x0000 (0x00B0 - 0x00B0)
class UBattleActorComponentBase : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleActorComponentBase">();
	}
	static class UBattleActorComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleActorComponentBase>();
	}
};
static_assert(alignof(UBattleActorComponentBase) == 0x000008, "Wrong alignment on UBattleActorComponentBase");
static_assert(sizeof(UBattleActorComponentBase) == 0x0000B0, "Wrong size on UBattleActorComponentBase");

// Class Project.BattleActionTaskFactoryBase
// 0x0000 (0x00B0 - 0x00B0)
class UBattleActionTaskFactoryBase : public UBattleActorComponentBase
{
public:
	void AddPoolTaskListInner(TMap<int32, struct FBattleTaskArray>& InTaskListValue, int32 InKey, class ABattleActorBase*& InTask);
	int32 FindPoolTaskListKeyInner(TMap<int32, struct FBattleIntegerArray>& InTaskListKey, TArray<int32>& InWaitTaskList, int32* OutKeyLength);
	int32 FindReadyPoolTaskListInner(TMap<int32, struct FBattleIntegerArray>& InTaskListKey, TArray<int32>& InPopedTaskList, const TArray<uint8>& InValidArray);
	bool IsTerminalTaskInner(const TMap<int32, struct FBattleIntegerArray>& InTaskListKey, int32 InPecID);
	bool OutputDebugInfo(class FString& Data, TArray<struct FDebugBattleTaskInfo>& TaskInfo, const class FString& Path, const class FString& Filename);
	void RemoveTaskFromPoolInner(TMap<int32, struct FBattleTaskArray>& InTaskListValue, class ABattleActorBase*& InTask);
	void TaskSort(TArray<class ABattleActorBase*>& Tasks, bool IsOldSystem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleActionTaskFactoryBase">();
	}
	static class UBattleActionTaskFactoryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleActionTaskFactoryBase>();
	}
};
static_assert(alignof(UBattleActionTaskFactoryBase) == 0x000008, "Wrong alignment on UBattleActionTaskFactoryBase");
static_assert(sizeof(UBattleActionTaskFactoryBase) == 0x0000B0, "Wrong size on UBattleActionTaskFactoryBase");

// Class Project.PopUpIconManager
// 0x0020 (0x0048 - 0x0028)
class UPopUpIconManager final : public UObject
{
public:
	uint8                                         Pad_14B7[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPopUpIconEntry>                M_RenderEntries;                                   // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UPopUpIconManager* GetPopUpIconManager(const class UObject* WorldContextObject);

	TArray<struct FPopUpIconEntry> GetRenderEntries();
	bool Register(class ACustomPawn* Owner, E_POP_UP_ICON_TYPE IconType);
	bool UnregisterByIndex(int32 Param_Index);
	bool UnregisterByOwner(const class ACustomPawn* Owner);
	void UpdateRender(const struct FVector& PlayerLocation, const class UObject* WorldContextObject);

	int32 CountShowingEntriesMax() const;
	int32 GetRenderEntriesMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopUpIconManager">();
	}
	static class UPopUpIconManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopUpIconManager>();
	}
};
static_assert(alignof(UPopUpIconManager) == 0x000008, "Wrong alignment on UPopUpIconManager");
static_assert(sizeof(UPopUpIconManager) == 0x000048, "Wrong size on UPopUpIconManager");
static_assert(offsetof(UPopUpIconManager, M_RenderEntries) == 0x000038, "Member 'UPopUpIconManager::M_RenderEntries' has a wrong offset!");

// Class Project.BattleActorBase
// 0x0010 (0x0230 - 0x0220)
class ABattleActorBase : public AActor
{
public:
	int32                                         SortWeight;                                        // 0x0220(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SortWeight_WaitSec;                                // 0x0224(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_ElapsedSec;                                      // 0x0228(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14BC[0x4];                                     // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString DebugWriteTaskInfo(int32 PecID, int32 Step, int32 UpdateTimes, float ElapsedTime, bool IsTerminal, TArray<int32>& WaitTaskList, struct FBtlTaskDesc& Desc, struct FDebugBattleTaskInfo* TaskInfo, bool IsOutputLog);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleActorBase">();
	}
	static class ABattleActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleActorBase>();
	}
};
static_assert(alignof(ABattleActorBase) == 0x000008, "Wrong alignment on ABattleActorBase");
static_assert(sizeof(ABattleActorBase) == 0x000230, "Wrong size on ABattleActorBase");
static_assert(offsetof(ABattleActorBase, SortWeight) == 0x000220, "Member 'ABattleActorBase::SortWeight' has a wrong offset!");
static_assert(offsetof(ABattleActorBase, SortWeight_WaitSec) == 0x000224, "Member 'ABattleActorBase::SortWeight_WaitSec' has a wrong offset!");
static_assert(offsetof(ABattleActorBase, M_ElapsedSec) == 0x000228, "Member 'ABattleActorBase::M_ElapsedSec' has a wrong offset!");

// Class Project.BattleAICommandBase
// 0x0000 (0x00B0 - 0x00B0)
class UBattleAICommandBase : public UActorComponent
{
public:
	bool AIBaseChk_ENMakraID(int32 DevilID);
	bool AIBaseChk_ENTetraID(int32 DevilID);
	bool AIBaseChk_ENUsedSkillIDTurn(int32 SkillId, int32 Turn);
	bool AIBaseChk_MyAtcAbsorptionBefTurn(int32 MyPartyIndex, E_ATTRIBUTE_TYPE Attr);
	bool AIBaseChk_MyAtcBlockBefTurn(int32 MyPartyIndex, E_ATTRIBUTE_TYPE Attr);
	bool AIBaseChk_MyAtcReflectionBefTurn(int32 MyPartyIndex, E_ATTRIBUTE_TYPE Attr);
	bool AIBaseChk_MyDmgAishouBefTurn(int32 MyPartyIndex, E_ATTRIBUTE_TYPE Attr);
	bool AIBaseChk_MyUsedSkillIDTurn(int32 MyPartyIndex, int32 SkillId, int32 Turn);
	bool AIBaseChk_PLAishouAbsorption(int32 N);
	bool AIBaseChk_PLAishouBlock(int32 N);
	bool AIBaseChk_PLAishouReflection(int32 N);
	bool AIBaseChk_PLChohatsu();
	bool AIBaseChk_PLGuard();
	bool AIBaseChk_PLMakra();
	bool AIBaseChk_PLNotGuard();
	bool AIBaseChk_PLNotMakra();
	bool AIBaseChk_PLNotTetra();
	bool AIBaseChk_PLTetra();
	bool AIBaseChk_PLValidAttr(int32 DevilID, E_ATTRIBUTE_TYPE Attr);
	bool AIBaseChk_PLValidSkillID(int32 DevilID, int32 SkillId);
	bool AIBaseChk_VailAttrDevilID_ENAnalyze(int32 DevilID, E_ATTRIBUTE_TYPE Attr);
	bool AIBaseChk_VailAttrDevilID_ENAnalyze2(int32 DevilID, E_ATTRIBUTE_TYPE Attr);
	bool AIBaseChk_VailSkillDevilID_ENAnalyze(int32 DevilID, int32 SkillId);
	bool AIBaseChk_VailSkillDevilID_ENAnalyze2(int32 DevilID, int32 SkillId);
	TArray<E_ATTRIBUTE_TYPE> AIBaseGet_AishouChangeAll(const int32& MyPartyIndex);
	TArray<E_ATTRIBUTE_TYPE> AIBaseGet_AishouChangeThisTurn(const int32& MyPartyIndex);
	int32 AIBaseGet_AttackSkillID(int32 MyPartyIndex, bool IsAll);
	int32 AIBaseGet_ChargeSkillID(int32 MyPartyIndex);
	int32 AIBaseGet_HojoSkillIDNotCharge(int32 MyPartyIndex);
	int32 AIBaseGet_HojoSkillValidTarget(int32 MyPartyIndex, int32 SkillId);
	int32 AIBaseGet_HPHealSkillID(int32 MyPartyIndex);
	int32 AIBaseGet_MagatsuhiDevilNum();
	int32 AIBaseGet_MagicChargeEffectiveSkillID(int32 MyPartyIndex);
	int32 AIBaseGet_MyDmgAishouMinusBefTurn(int32 MyPartyIndex);
	int32 AIBaseGet_PhysicalChargeEffectiveSkillID(int32 MyPartyIndex);
	int32 AIBaseGet_PLAishouAbsorption(E_ATTRIBUTE_TYPE N);
	int32 AIBaseGet_PLAishouBlock(E_ATTRIBUTE_TYPE N);
	int32 AIBaseGet_PLAishouFlat(E_ATTRIBUTE_TYPE N);
	int32 AIBaseGet_PLAishouMinus(E_ATTRIBUTE_TYPE N);
	int32 AIBaseGet_PLAishouPlus(E_ATTRIBUTE_TYPE N);
	int32 AIBaseGet_PLAishouReflection(E_ATTRIBUTE_TYPE N);
	int32 AIBaseGet_PLNumValidAttrENAnalyze(E_ATTRIBUTE_TYPE Attr);
	int32 AIBaseGet_PLNumValidAttrENAnalyze2(E_ATTRIBUTE_TYPE Attr);
	int32 AIBaseGet_PLNumValidSkillENAnalyze(int32 SkillId);
	int32 AIBaseGet_PLNumValidSkillENAnalyze2(int32 SkillId);
	int32 AIBaseGet_PLPrvoke();
	int32 AIBaseGet_PLShieldNum(E_ATTRIBUTE_TYPE Attr);
	int32 AIBaseGet_PLValidAttrNum(E_ATTRIBUTE_TYPE Attr);
	int32 AIBaseGet_PLValidSkillNum(int32 SkillId);
	int32 AIBaseGet_SkillIDBySkillType(int32 MyPartyIndex, E_SKILL_TYPE SkillType);
	int32 AIBaseGet_TarPLChohatsu_ENAnalyze();
	int32 AIBaseGet_UpliftRate(bool IsEnemySurpriseTurn);
	E_BTL_CNT AIBaseGetBadStatusToBtlCnt(E_BAD_STATUS bst);
	E_BTL_CNT AIBaseGetEfficacyToBtlCnt(E_EFFICACY_BD Efficacy);
	TArray<uint8> AIBaseTar_Common(int32 ActorIndex, E_BTL_AI_TAR Type, int32 Value, int32 Value2);
	void AIBaseTar_GetTargetSideArea(E_BTL_SIDE ActorSide, E_SKILL_TARGET SkillTarget, E_BTL_SIDE* TargetSide, E_BTL_AI_AREA* Area);
	int32 AIBaseTar_Provoke(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetProvoke(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetRenzokuSkill(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 PartyIndex);
	TArray<uint8> AIBaseTar_SetTarAishouAbsorption(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTarAishouBlock(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTarAishouNotAbsorption(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTarAishouNotBlock(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTarAllEnemy();
	TArray<uint8> AIBaseTar_SetTarAutoBattle(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetAI(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetAishouFlat(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 Aishou);
	TArray<uint8> AIBaseTar_SetTargetAishouMinus(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 Aishou);
	TArray<uint8> AIBaseTar_SetTargetAishouNotFlat(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 Aishou);
	TArray<uint8> AIBaseTar_SetTargetAishouNotMinus(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 Aishou);
	TArray<uint8> AIBaseTar_SetTargetAishouNotPlus(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 Aishou);
	TArray<uint8> AIBaseTar_SetTargetAishouNotReflection(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTargetAishouPlus(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 Aishou);
	TArray<uint8> AIBaseTar_SetTargetAishouReflection(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTargetBadStatus(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 bst);
	TArray<uint8> AIBaseTar_SetTargetHojoAI(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 SkillId);
	TArray<uint8> AIBaseTar_SetTargetHojoMAX(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 Efficacy);
	TArray<uint8> AIBaseTar_SetTargetHojoMIN(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 Efficacy);
	TArray<uint8> AIBaseTar_SetTargetHPMAX(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetHPMAXn(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTargetHPMIN(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetHPPerc(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTargetHPRatioMAX(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetHPRatioMIN(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetID(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 ID);
	TArray<uint8> AIBaseTar_SetTargetNotBadStatus(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 bst);
	TArray<uint8> AIBaseTar_SetTargetNotBadStatus2(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 bst, int32 Num);
	TArray<uint8> AIBaseTar_SetTargetNotCritical(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetNotID(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 ID);
	TArray<uint8> AIBaseTar_SetTargetNotPartyIndex(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 PartyIndex);
	TArray<uint8> AIBaseTar_SetTargetPartyIndex(const TArray<struct FBtlParty>& PartyArray, int32 PartyIndex);
	TArray<uint8> AIBaseTar_SetTargetRandom(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetRecCounter(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetRecCritical(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetSelf(const struct FBtlParty& Actor);
	TArray<uint8> AIBaseTar_SetTargetSelfSideOther(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 SelfIndex);
	TArray<uint8> AIBaseTar_SetTargetSmart(int32 ActorIndex, const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTargetWeak(int32 ActorIndex, const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide);
	TArray<uint8> AIBaseTar_SetTarGuard(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTarMaka(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTarNotGuard(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTarNotMaka(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTarNotTetra(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetTarTetra(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 N);
	TArray<uint8> AIBaseTar_SetValidSkill(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 SkillId);
	bool CheckAishouFlat(int32 TargetAishou);
	bool CheckAishouMinus(int32 TargetAishou);
	bool CheckAishouNotFlat(int32 TargetAishou);
	bool CheckAishouNotMinus(int32 TargetAishou);
	bool CheckAishouNotPlus(int32 TargetAishou);
	bool CheckAishouPlus(int32 TargetAishou);
	bool CheckEnemySidePartyData(const struct FBtlParty& Party, const E_BTL_SIDE& TargetSide);
	bool CheckExistPartyData(const struct FBtlParty& Party);
	bool CheckPlayerSidePartyData(const struct FBtlParty& Party, const E_BTL_SIDE& TargetSide);
	bool Chk_BattleEventFlag();
	bool Chk_BattleEventFlag2();
	bool Chk_SummonPositionDevilID(int32 SummonIndex, int32 DevilID);
	int32 GetElectrificationNum();
	TArray<int32> GetEmptyPosSummonDevilId(int32 DevilID_0, int32 DevilID_1, int32 DevilID_2, int32 DevilID_3, bool IsExclusionLeader);
	bool OptUpLifting_TurnEnd(int32 DevilID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleAICommandBase">();
	}
	static class UBattleAICommandBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleAICommandBase>();
	}
};
static_assert(alignof(UBattleAICommandBase) == 0x000008, "Wrong alignment on UBattleAICommandBase");
static_assert(sizeof(UBattleAICommandBase) == 0x0000B0, "Wrong size on UBattleAICommandBase");

// Class Project.UICalc
// 0x0000 (0x0028 - 0x0028)
class UUICalc final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FUICalcRectCheck> CalcRect_SlideSide(const TArray<struct FUICalcRectCheck>& Rect);
	static TArray<struct FUICalcRectCheck> CalcRect_Sort_MinPostionX(const TArray<struct FUICalcRectCheck>& Rect);
	static TArray<struct FUICalcRectCheck> CalcRectNoOverlaid(const TArray<struct FUICalcRectCheck>& Rect, const struct FVector2D& ScreenSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICalc">();
	}
	static class UUICalc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICalc>();
	}
};
static_assert(alignof(UUICalc) == 0x000008, "Wrong alignment on UUICalc");
static_assert(sizeof(UUICalc) == 0x000028, "Wrong size on UUICalc");

// Class Project.BPL_AsyncLib
// 0x0000 (0x0028 - 0x0028)
class UBPL_AsyncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckAddGaugeSkill(const struct FSkillBaseData& Skill);
	static bool CheckAidClearSkill(const struct FSkillBaseData& Skill);
	static bool CheckAnalyzeSkill(const struct FSkillBaseData& Skill);
	static bool CheckBstCureSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Player);
	static bool CheckBstSkill(const struct FSkillBaseData& Skill);
	static bool CheckChargeSkill(const struct FSkillBaseData& Skill);
	static bool CheckDamageCutSkill(const struct FSkillBaseData& Skill);
	static bool CheckHPCureItem(const struct FUseItemData& Item);
	static bool CheckHPCureSkill(const struct FSkillBaseData& Skill);
	static bool CheckKajyandaSkill(const struct FSkillBaseData& Skill);
	static bool CheckKarnSkill(const struct FSkillBaseData& Skill);
	static bool CheckMPCureItem(const struct FUseItemData& Item);
	static bool CheckMPCureSkill(const struct FSkillBaseData& Skill);
	static bool CheckPass(const struct FSkillBaseData& Skill);
	static bool CheckPressIcon(const struct FSkillBaseData& Skill);
	static bool CheckPrevTurnAvoid(const struct FSkillBaseData& Skill);
	static bool CheckProvokeSkill(const struct FSkillBaseData& Skill);
	static bool CheckRecomeSkill(const struct FSkillBaseData& Skill);
	static TArray<int32> GetAddMagatsuhiSkillId(const struct FBtlParty& Player, const TArray<struct FBtlParty>& PartyAll);
	static E_BTL_CNT GetBarrierType(const uint8 barrier, const E_ATTRIBUTE_TYPE Attr);
	static int32 GetRecoveryHPUpRate(const struct FSkillBaseData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static int32 GetSkillBarrierCount(const struct FSkillBaseData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUsedAddGaugeSkill(class UObject* MainWork, const struct FSkillBaseData& Skill, const int32& PlayerUpliftingGauge);
	static bool IsUsedAidClearSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUsedAnalyzeSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Party);
	static bool IsUsedBstCureSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Party);
	static bool IsUsedBstSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Party);
	static bool IsUsedChargeSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Party);
	static bool IsUsedDamageCutSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Party);
	static bool IsUsedHPCureItem(const struct FUseItemData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUsedHPCureSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUsedItem(const struct FUseItemData& Item, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUsedKajyandaSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUsedKajyandaSkillCommon(const struct FBtlParty& Player, const struct FBtlParty& Party, const int32 KajyanndaValue, const int32 KajyanndaTurn, const E_BTL_CNT KajyandaType, const E_BTL_CNT KajyandaTurnType);
	static bool IsUsedKarnSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUsedMPCureItem(const struct FUseItemData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUsedMPCureSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Party);
	static bool IsUsedPass(class UObject* MainWork, const struct FSkillBaseData& Skill, const struct FBtlParty& Player);
	static bool IsUsedPressIcon(class UObject* MainWork, const struct FSkillBaseData& Skill, const struct FBtlParty& Player);
	static bool IsUsedPrevTurnAvoid(const struct FSkillBaseData& Skill, const struct FBtlParty& Player);
	static bool IsUsedProvokeSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Party);
	static bool IsUsedRecomeSkill(const struct FSkillBaseData& Skill, const struct FBtlParty& Party);
	static bool IsUsedSkill(class UObject* MainWork, const struct FSkillBaseData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUsedSkillStock(const struct FSkillBaseData& Skill, const struct FBtlParty& Player, const struct FBtlParty& Party);
	static bool IsUseItemCommand(class UObject* MainWork, const struct FUseItemData& Item, const struct FBtlParty& Player, const TArray<struct FBtlParty>& PartyAll, bool IsEscape, bool IsUse);
	static bool IsUseItemCommandMainWork(class UObject* MainWork, const struct FUseItemData& Item, const struct FBtlParty& Player, bool IsEscape, bool IsUse);
	static bool IsUseItemTargetSelect(class UObject* MainWork, const struct FUseItemData& Item, const struct FBtlParty& User, const struct FBtlParty& Target, bool IsUse);
	static bool IsUseSkillCommand(class UObject* MainWork, const struct FSkillBaseData& Skill, const struct FBtlParty& Player, const TArray<struct FBtlParty>& PartyAll, bool IsEscape);
	static bool IsUseSkillTargetSelect(class UObject* MainWork, const struct FSkillBaseData& Skill, const struct FBtlParty& User, const struct FBtlParty& Target, bool IsUse);
	static void SettleCriticalFunc(class ABattleMainWorkBase* BattleMain, const struct FBtlParty& Player, const TArray<struct FBtlParty>& Enemy, const TArray<struct FBtlParty>& PartyAll, TArray<struct FSkillCriticalValueOne>* Result, bool* bFinished);
	static bool SettleCriticalSkill(const struct FBtlParty& Player, const struct FBtlParty& Enemy, int32 SkillId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_AsyncLib">();
	}
	static class UBPL_AsyncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_AsyncLib>();
	}
};
static_assert(alignof(UBPL_AsyncLib) == 0x000008, "Wrong alignment on UBPL_AsyncLib");
static_assert(sizeof(UBPL_AsyncLib) == 0x000028, "Wrong size on UBPL_AsyncLib");

// Class Project.BattleAsyncTaskWorkComponent
// 0x0018 (0x00C8 - 0x00B0)
class UBattleAsyncTaskWorkComponent : public UBattleActorComponentBase
{
public:
	bool                                          M_IsFinished;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155D[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkillCriticalValueOne>         M_Result;                                          // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void MakeSettleCriticalWork(class ABattleMainWorkBase* BattleMain, const struct FBtlParty& Player, const TArray<struct FBtlParty>& Enemy, const TArray<struct FBtlParty>& PartyAll);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleAsyncTaskWorkComponent">();
	}
	static class UBattleAsyncTaskWorkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleAsyncTaskWorkComponent>();
	}
};
static_assert(alignof(UBattleAsyncTaskWorkComponent) == 0x000008, "Wrong alignment on UBattleAsyncTaskWorkComponent");
static_assert(sizeof(UBattleAsyncTaskWorkComponent) == 0x0000C8, "Wrong size on UBattleAsyncTaskWorkComponent");
static_assert(offsetof(UBattleAsyncTaskWorkComponent, M_IsFinished) == 0x0000B0, "Member 'UBattleAsyncTaskWorkComponent::M_IsFinished' has a wrong offset!");
static_assert(offsetof(UBattleAsyncTaskWorkComponent, M_Result) == 0x0000B8, "Member 'UBattleAsyncTaskWorkComponent::M_Result' has a wrong offset!");

// Class Project.BPL_BattleAttack
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleAttack final : public UBlueprintFunctionLibrary
{
public:
	static bool BtlAttackCheckAttr(const struct FBtlAttack& PData, E_ATTRIBUTE_TYPE CheckAttr);
	static void BtlAttackGetTekiseiValue(const struct FBtlParty& Player, const struct FBtlAttack& PData, E_SKILL_TEKISEI_EFT_TYPE CheckType, int32* RetValue, E_SKILL_TEKISEI_CATEGORY* RetCateg);
	static bool BtlAttackIsHaveAtrAttr(const struct FBtlAttack& PData, E_ATTRIBUTE_TYPE InAttr);
	static bool BtlAttackIsMasicalAttack(const struct FBtlAttack& PData);
	static bool BtlAttackIsPhysicalAttack(const struct FBtlAttack& PData);
	static bool BtlAttackIsRecome(const struct FBtlAttack& PData);
	static bool BtlAttackIsRecoverySkill(const struct FBtlAttack& PData);
	static bool BtlAttackIsSummon(const struct FBtlAttack& PData);
	static struct FBtlAttack MakeUpBattleAttackData(const struct FBtlParty& Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleAttack">();
	}
	static class UBPL_BattleAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleAttack>();
	}
};
static_assert(alignof(UBPL_BattleAttack) == 0x000008, "Wrong alignment on UBPL_BattleAttack");
static_assert(sizeof(UBPL_BattleAttack) == 0x000028, "Wrong size on UBPL_BattleAttack");

// Class Project.BPL_BattleBossFlag
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleBossFlag final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleBossFlag">();
	}
	static class UBPL_BattleBossFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleBossFlag>();
	}
};
static_assert(alignof(UBPL_BattleBossFlag) == 0x000008, "Wrong alignment on UBPL_BattleBossFlag");
static_assert(sizeof(UBPL_BattleBossFlag) == 0x000028, "Wrong size on UBPL_BattleBossFlag");

// Class Project.UniteCharaPanelCtrlBase
// 0x02D0 (0x04F0 - 0x0220)
class AUniteCharaPanelCtrlBase final : public AActor
{
public:
	uint8                                         Pad_1568[0x2D0];                                   // 0x0220(0x02D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddPartyListFlag(int32 InIndex, E_UNITECHARAPANELFLAG InType, int32 InCursorOffset);
	bool ApplyCharaPanelCursorCtrl(E_UNITECHARAPANEL_MENUTYPE InType);
	bool BackUpForSortPartyData(int32 InIndex, int32 InOffset);
	void BIESetFadeOutPanelAnimation(int32 InIndex);
	void BIESetInitializePanelAnimation(int32 InIndex);
	void BIESetUniteCharaPanelUnselectablePanelOff(int32 InIndex);
	void BIESetUniteCharaPanelUnselectablePanelOn(int32 InIndex);
	int32 CalcDevilBookCost(int32 InIndex, int32 InMode, int32 InType);
	void CalcDevilBookCursorPositionByDataIndex(int32 InDataIndex, int32* OutCursorOffset, int32* OutCursorPosition);
	struct FUniteCharaPanelParamData CalcDevilBookPanelParam(int32 InIndex, int32 InMode, int32 InType);
	struct FUniteCharaPanelParamData CalcDevilBookPanelParamByDevilId(int32 InDevilId);
	int32 CalcFResultDevilExpByCursorOffset(int32 InCursorOffset, int32 InIndex, int32 InType);
	struct FVector2D CalcFusionCombineAnimationPos(const struct FVector2D& InStartPos, const struct FVector2D& InEndPos, float InRate);
	int32 CalcScrollBarClickedByDevilBook(float InRate, int32 InOffsetType);
	int32 CalcScrollBarClickedByParty(float InRate, int32 InType);
	int32 CalcScrollBarClickedBySearchFusion(float InRate, int32 InOffsetType);
	int32 CalcScrollBarClickedBySpecialFusion(float InRate, int32 InOffsetType);
	int32 CalcScrollBarClickedByUtsusemi(float InRate, int32 InOffsetType);
	void CalcSearchFusionCursorPositionByDataIndex(int32 InDataIndex, int32* OutCursorOffset, int32* OutCursorPosition);
	void CalcSpecialFusionCursorPositionByDataIndex(int32 InDataIndex, int32* OutCursorOffset, int32* OutCursorPosition);
	int32 CalcSpecialFusionResultExpByIndex(int32 InIndex);
	int32 CalcSpecialFusionSecondResultExp();
	void CalcUtsusemiFusionCursorPositionByDataIndex(int32 InDataIndex, int32* OutCursorOffset, int32* OutCursorPosition);
	int32 CanBeDeletedAsSrc(int32 InSrcIndex);
	int32 CanBeSelectedAsDst(int32 InSrcIndex, int32 InSrcType, int32 InDstIndex, int32 InSrcCursorOffset, int32 InDstCursorOffset);
	int32 CanBeSelectedAsFusionFirst(int32 InSrcIndex, bool bInUseDevilBook);
	int32 CanBeSelectedAsFusionSecond();
	int32 CanBeSelectedAsSearchFusion(int32 InSrcIndex);
	E_UNITECHARAPANEL_ERRORTYPE CanBeSelectedAsSpecialFusionSecond();
	int32 CanBeSelectedAsSrc(int32 InSrcIndex);
	bool CanBeSelectedAsStatusTarget(int32 InSrcIndex, int32 InOffsetCursor);
	bool CanBeSelectedAsUtsusemi(int32 InIndex);
	bool CanBeSelectedAsUtsusemiDevil(int32 InDevilId);
	bool CanBeSelectedAsUtsusemiNkmIndex(int32 InSrcIndex);
	bool ChangeSelectedPanel(int32 InSrcIndex, int32 InSrcType, int32 InDstIndex, int32 InDstType);
	int32 CheckCombineNumFromSearchFusionList(int32 InDevilId);
	E_UNITECHARAPANEL_ERRORTYPE CheckDevilBookSummonError(int32 InDevilId, int32 InCost);
	bool CreateDevilBookEntryList();
	bool CreateDevilBookRewriteList();
	bool CreateFusionResultEntryList();
	bool CreateSearchExFusionList(bool bInReSearch);
	bool CreateSearchExFusionListAsync(bool bInReSearch);
	bool CreateSearchFusionCombinationList();
	bool CreateSearchFusionList();
	bool CreateSpecialFusionList();
	bool CreateStockSortList();
	bool CreateUtsusemiEntryList();
	bool CreateUtsusemiSkillBuffer();
	bool DeleteCharaPanel(int32 InSrcIndex);
	bool DeletePanelList();
	int32 DelPartyListFlag(int32 InIndex, E_UNITECHARAPANELFLAG InType, int32 InCursorOffset);
	bool EntryDevilBook(int32 InDevilId);
	bool EntryDevilBookAll();
	bool EntryNkmList(int32 InIndex, int32 InNkmIndex, int32 InCursorOffset);
	int32 EntryPartyList(int32 InIndex, E_UNITECHARAPANELFLAG InType, int32 InCursorOffset);
	int32 GetBattleIndexByStockIndex(int32 InIndex);
	int32 GetDevilBookCost(int32 InIndex);
	int32 GetDevilBookCostFontColor(int32 InCost, int32 InPartyMakka);
	int32 GetDevilBookCount();
	int32 GetDevilBookCursorPosition();
	int32 GetDevilBookDevilIdByIndex(int32 InIndex);
	int32 GetDevilBookMaxDisplayCount();
	int32 GetDevilBookMoveCategoryCursorPositionIndex(int32 InDevilId);
	int32 GetDevilBookMoveCursorOffsetPositionIndex(int32 InIndex, int32 InMoveIndex, bool InScrollLock);
	int32 GetDevilBookMoveCursorOffsetPositionIndexByScroll(int32 InIndex, int32 InMoveIndex, int32 InScrollLock);
	int32 GetDevilBookMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex);
	int32 GetDevilBookOffsetCursorPosition();
	int32 GetDevilBookType();
	int32 GetDevilIdByIndex(int32 InIndex);
	int32 GetDevilIdOfFusionFirst();
	int32 GetDevilIdOfFusionResult();
	int32 GetDevilIdOfFusionResultCost();
	int32 GetDevilIdOfFusionSecond();
	int32 GetFFirstDevilIdByCursorOffset(int32 InCursorOffset, int32 InIndex, int32 InType);
	void GetFFirstDevilInfoByCursorOffset(int32 InCursorOffset, int32 InIndex, int32 InType, int32* OutDevilId, int32* OutNkmIndex, int32* OutCost, E_UNITECHARAPANEL_DEVILDATATYPE* OutType);
	int32 GetFFirstNkmIndexByCursorOffset(int32 InCursorOffset, int32 InIndex, int32 InType);
	int32 GetFResultDevilIdByCursorOffset(int32 InCursorOffset, int32 InIndex, int32 InType);
	void GetFResultDevilInfoByCursorOffset(int32 InCursorOffset, int32 InIndex, int32 InType, bool bInCheckCanSelect, int32* OutDevilId, int32* OutCost, int32* OutExp, int32* OutLv, int32* OutHp, int32* OutMp, int32* OutCanSelect);
	int32 GetFSecondDevilIdByCursorOffset(int32 InCursorOffset, int32 InIndex, int32 InType);
	void GetFSecondDevilInfoByCursorOffset(int32 InCursorOffset, int32 InIndex, int32 InType, int32* OutDevilId, int32* OutNkmIndex, int32* OutCost, E_UNITECHARAPANEL_DEVILDATATYPE* OutType);
	int32 GetFSecondDisplayCursorPosition();
	int32 GetFSecondMoveCharaCursor(int32 InMove, bool bInCursorLoop);
	int32 GetFSecondMoveOffsetCursor(int32 InMove);
	int32 GetFSecondNkmIndexByCursorOffset(int32 InCursorOffset, int32 InIndex, int32 InType);
	int32 GetFusionCombineAnimationMoveDistance();
	int32 GetFusionCombineAnimationMoveType();
	float GetFusionCombineAnimationRate();
	float GetFusionCombineAnimationTimeMax();
	TArray<struct FFusionCombineDispID> GetFusionCombineDispIDList();
	int32 GetFusionCount();
	int32 GetFusionCursorOffset();
	int32 GetFusionCursorPosition();
	int32 GetFusionMaxDisplayCount();
	struct FVector2D GetFusionPanelPositionByIndex(int32 InIndex, const struct FVector2D& InVec2D, int32 InCheckType);
	int32 GetMaxStockNumber();
	int32 GetMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex, int32 InOffsetType);
	int32 GetMoveOffsetCursorPositionIndex(int32 InIndex, int32 InMoveIndex, int32 InOffsetType, bool InScrollLock);
	int32 GetMoveOffsetCursorPositionIndexByScrollBar(int32 InIndex, int32 InOffsetIndex, int32 InMoveIndex, int32 InOffsetType);
	struct FVector2D GetMovePanelAnimation(int32 InCategory);
	struct FVector2D GetMovePanelPosition(int32 InCategory);
	int32 GetNkmIndexOfFusionFirst();
	int32 GetNkmIndexOfUseTargetList(int32 InIndex);
	int32 GetNkmIndexOfUseTargetListInOffset(int32 InIndex, int32 InCursorOffset);
	struct FUniteCharaPanelParamData GetNkmParamForResultPanel(int32 InDevilId);
	struct FVector2D GetPanelPositionByIndex(int32 InIndex, const struct FVector2D& InVec2D, int32 InCheckType);
	int32 GetPartyCursorWithInDrawRange(int32 InIndex, int32 InCursorOffset);
	int32 GetPartyListDstOffsetIndex();
	int32 GetPartyListOffsetIndex();
	int32 GetPartyMaxDisplayCount();
	int32 GetResultDevilCostFontColor(int32 InCost);
	void GetResultDevilHpMpFontColor(int32 InDevilId, int32 InLv, int32 InHp, int32 InMp, int32* OutHpColorType, int32* OutMpColorType);
	int32 GetResultDevilLevelFontColor(int32 InDevilId, int32 InLv);
	void GetReturnDataFromStatusUI(class UUIStatusCtrlDataObjUnite* StatusUIDataObj, int32* RetCursorPos, int32* RetOffset, const int32 beforeCursorPos, const int32 beforeOffset);
	int32 GetRewriteType();
	int32 GetSearchFusionDevilCount();
	int32 GetSearchFusionDevilCursorPosition();
	int32 GetSearchFusionDevilIdByIndex(int32 InIndex);
	int32 GetSearchFusionDevilMaxDisplayCount();
	int32 GetSearchFusionDevilMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex);
	int32 GetSearchFusionDevilOffsetCursorPosition();
	int32 GetSearchFusionMoveCursorOffsetPositionIndex(int32 InIndex, int32 InMoveIndex, bool InScrollLock);
	int32 GetSearchFusionMoveCursorOffsetPositionIndexByScroll(int32 InIndex, int32 InMoveIndex, int32 InScrollLock);
	struct FSpecialFusionResultDevil GetSpecialFusionDevilByIndex(int32 InIndex);
	int32 GetSpecialFusionDevilCount();
	int32 GetSpecialFusionDevilCursorPosition();
	int32 GetSpecialFusionDevilIdByIndex(int32 InIndex);
	int32 GetSpecialFusionDevilMaxDisplayCount();
	int32 GetSpecialFusionDevilMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex);
	int32 GetSpecialFusionDevilOffsetCursorPosition();
	int32 GetSpecialFusionDevilSecondCursorPosition();
	int32 GetSpecialFusionMoveCursorOffsetPositionIndex(int32 InIndex, int32 InMoveIndex, bool InScrollLock);
	int32 GetSpecialFusionMoveCursorOffsetPositionIndexByScroll(int32 InIndex, int32 InMoveIndex, int32 InScrollLock);
	struct FSpecialFusionResultDevil GetSpecialFusionResultDevil();
	void GetSpecialFusionSecondDevilByIndex(int32 InIndex, int32* OutDevilId, int32* OutNkmIndex, E_UNITECHARAPANEL_DEVILDATATYPE* OutDevilType);
	int32 GetSpecialFusionSecondMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex, bool bInCursorLoop);
	struct FSpecialFusionSourceDevil GetSpecialFusionSourceDevil(int32 InSourceIndex);
	int32 GetSpecialFusionSourceNum();
	int32 GetStockDispNumber();
	int32 GetStockIndexByAddOffset(int32 InIndex, int32 InCursorOffset);
	int32 GetStockIndexByBattleIndex(int32 InIndex);
	int32 GetStockNumber();
	int32 GetTutorialMessageId(E_TUTORIAL_WINDOW_MESSAGE_TYPE InMessageNo, int32 InType);
	int32 GetUtsusemiCount();
	int32 GetUtsusemiCursorPosition();
	int32 GetUtsusemiDevilIdByIndex(int32 InIndex);
	int32 GetUtsusemiMaxDisplayCount();
	int32 GetUtsusemiMoveCursorOffsetPositionIndex(int32 InIndex, int32 InMoveIndex, bool InScrollLock);
	int32 GetUtsusemiMoveCursorOffsetPositionIndexByScroll(int32 InIndex, int32 InMoveIndex, int32 InScrollLock);
	int32 GetUtsusemiMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex);
	bool GetUtsusemiNewIconByIndex(int32 InIndex);
	int32 GetUtsusemiOffsetCursorPosition();
	bool InitializeCharaPanelCursor(E_UNITECHARAPANEL_MENUTYPE InType);
	bool InitializeEntryPartyList();
	bool InitializeUtsusemiSkillBuffer();
	bool IsCharaPanelAnimation();
	bool IsDead(int32 InIndex);
	bool IsDevilBookExistIndexInDevilBook(int32 InIndex);
	bool IsExistUtsusemiInShop(int32 InIndex);
	bool IsFusionCombineAnimation();
	bool IsFusionExistDevilIdInDevilBook(int32 InDevilId);
	bool IsFusionExistDevilIdInParty(int32 InDevilId);
	bool IsGuestParty(int32 InIndex, int32 InOffsetCursor);
	bool IsIndexPanelSummoned(int32 InIndex);
	bool IsMovePanelAnimation(int32 InCategory);
	bool IsPartyCursorWithInDrawRange(int32 InIndex, int32 InCursorOffset);
	bool IsSearchExFusionCompleteSearch();
	bool IsSearchExFusionNowSearching();
	bool IsSearchFusionCombinationListCompleteSearch();
	bool IsSearchFusionCombinationListNowSearching();
	bool IsSummonAnimation();
	bool IsValidDevilBookPartyMakkaDiffColor();
	bool IsValidInputCtrl(E_UNITECHARAPANELCTRL_GSTATUS InGStatus);
	int32 MoveDevilBookType(int32 InMoveIndex, bool bInCursorLoop);
	int32 MoveRewriteType(int32 InMoveIndex, bool bInCursorLoop);
	void RebuildStatusCharaList_Browse(class UUIStatusCtrlDataObjUnite* StatusUIDataObj);
	void RebuildStatusCharaList_FusionSecond(class UUIStatusCtrlDataObjUnite* StatusUIDataObj, E_UI_STATUS_CTRL_TYPE Type);
	void RebuildStatusCharaList_Party(class UUIStatusCtrlDataObjUnite* StatusUIDataObj, E_UI_STATUS_CTRL_TYPE Type, bool UseParty, bool UseStock, int32 CursorPos);
	void RebuildStatusCharaList_Rewrite(class UUIStatusCtrlDataObjUnite* StatusUIDataObj);
	void RebuildStatusCharaList_SearchFirst(class UUIStatusCtrlDataObjUnite* StatusUIDataObj);
	void RebuildStatusCharaList_SpecialFirst(class UUIStatusCtrlDataObjUnite* StatusUIDataObj);
	void RebuildStatusCharaList_SpecialFusionSecond(class UUIStatusCtrlDataObjUnite* StatusUIDataObj);
	void RebuildStatusCharaList_Utsusemi(class UUIStatusCtrlDataObjUnite* StatusUIDataObj);
	bool ResetCharaMovingCursor(E_UNITECHARAPANEL_MENUTYPE InType);
	void ResetCursorParam();
	bool ResetUnselectablePanelByUtsusemi(int32 InIndex);
	bool SetCharaMovingCursor(E_UNITECHARAPANEL_MENUTYPE InType);
	bool SetDevilBookCost(int32 InIndex, int32 InCost);
	void SetDevilBookCursorPosition(int32 InIndex);
	int32 SetDevilBookCursorPositionIndex(int32 InCursorPosition, int32 InCursorOffset);
	void SetDevilBookOffsetCursorPosition(int32 InIndex);
	bool SetDevilBookType(int32 InType);
	bool SetFusionCursorOffset(int32 InIndex);
	bool SetFusionCursorPosition(int32 InIndex);
	bool SetFusionFirst(int32 InIndex);
	bool SetFusionSecond();
	bool SetMovePanelPosition(const struct FVector2D& InPos, int32 InCategory, int32 InType);
	bool SetMovePanelSpeed(int32 InCategory, float InMoveSpeed);
	void SetOffsetAndIndex(const E_UI_STATUS_CTRL_TYPE Mode, const int32 InCursorPos, const int32 InOffset, const bool SwapDstMode);
	bool SetPartyCursorParameter(int32 InCursor, int32 InOffset);
	int32 SetPartyInitializeCursorPositionIndex(int32 InIndex);
	bool SetPartyListDstOffsetIndex(int32 InOffsetIndex);
	bool SetPartyListOffsetIndex(int32 InOffsetIndex);
	int32 SetPartyPanelPositionBySelectNkmId(int32 InType);
	bool SetRewriteType(int32 InType);
	int32 SetSearchFusionCursorPositionIndex(int32 InCursorPosition, int32 InCursorOffset);
	void SetSearchFusionDevilCursorPosition(int32 InIndex);
	bool SetSearchFusionDevilId(int32 InIndex);
	void SetSearchFusionDevilOffsetCursorPosition(int32 InIndex);
	int32 SetSpecialFusionCursorPositionIndex(int32 InCursorPosition, int32 InCursorOffset);
	void SetSpecialFusionDevilCursorPosition(int32 InIndex);
	bool SetSpecialFusionDevilId(int32 InIndex);
	void SetSpecialFusionDevilOffsetCursorPosition(int32 InIndex);
	void SetSpecialFusionDevilSecondCursorPosition(int32 InIndex);
	int32 SetStockInitializeCursorPositionIndex(int32 InIndex, int32 InType);
	bool SetStockSortToParty();
	void SetUniteCtrlPtr(class AUniteCtrl* PUniteCtrl);
	bool SetUnselectablePanelByUtsusemi(int32 InIndex);
	void SetUseSearchType(E_UNITECHARAPANEL_SEARCH InSearchType);
	void SetUtsusemiCursorPosition(int32 InIndex);
	int32 SetUtsusemiCursorPositionIndex(int32 InCursorPosition, int32 InCursorOffset);
	bool SetUtsusemiNewIconByIndex(int32 InIndex);
	bool SetUtsusemiNewIconByOffsetIndex(int32 InOffsetIndex, int32 InIndex);
	void SetUtsusemiOffsetCursorPosition(int32 InIndex);
	int32 SortDevilBook(int32 InSortMenuPos, bool bInAscending, int32 InSelectPos);
	int32 SortFusionFirstDevil(int32 InSortMenuPos, bool bInAscending, int32 InSelectPos);
	int32 SortFusionSearchDevil(int32 InSortMenuPos, bool bInAscending, int32 InSelectPos);
	int32 SortFusionSearchSecondDevil(int32 InSortMenuPos, bool bInAscending, int32 InSelectPos);
	int32 SortFusionSecondDevil(int32 InSortMenuPos, bool bInAscending, int32 InSelectPos);
	int32 SortFusionSpDevil(int32 InSortMenuPos, bool bInAscending, int32 InSelectPos);
	int32 SortFusionUtsusemi(int32 InSortMenuPos, bool bInAscending, int32 InSelectPos, int32 InSkillId);
	bool SortUtsusemiSkillBuffer();
	bool StartCharaPanelAnimation(int32 InMovePanelNum);
	bool StartCharaPanelFadeOutAnimation();
	bool StartFusionCombineAnimation(float InWaitTime, bool bCursorUp, int32 InStartCursorOffset, int32 InEndCursorOffset);
	bool StartMovePanelAnimation(int32 InCategory);
	bool StartSummonAnimation(float InWaitTime);
	bool StopCharaPanelAnimation();
	bool StopFusionCombineAnimation();
	bool StopMovePanelAnimation(int32 InCategory);
	bool StopSummonAnimation();
	bool UpDateDevilBookEntry();
	bool UpdateDevilBookEntryList();

	E_UNITECHARAPANEL_SEARCH GetUseSearchType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniteCharaPanelCtrlBase">();
	}
	static class AUniteCharaPanelCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUniteCharaPanelCtrlBase>();
	}
};
static_assert(alignof(AUniteCharaPanelCtrlBase) == 0x000008, "Wrong alignment on AUniteCharaPanelCtrlBase");
static_assert(sizeof(AUniteCharaPanelCtrlBase) == 0x0004F0, "Wrong size on AUniteCharaPanelCtrlBase");

// Class Project.BattleCalcBase
// 0x0AF0 (0x0BA0 - 0x00B0)
class UBattleCalcBase : public UBattleActorComponentBase
{
public:
	uint8                                         Pad_15B1[0xAF0];                                   // 0x00B0(0x0AF0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 BattleRand(int32 Max);
	int32 BattleRand2(int32 Min, int32 Max);
	float BattleRandF(float Max);
	float BattleRandF2(float Min, float Max);
	struct FBtlResultData GetExpMakkaItem(const struct FBtlResultData& PResult, const struct FBtlParty& PParty, bool IsRenzoku);
	struct FBtlResultData GetExpMakkaItemForTalk(const struct FBtlResultData& PResult, const struct FBtlParty& PParty);
	void GetMagatsuhiDevilFirstDropItemIDandNum(const struct FBtlParty& Party, const struct FEnemyData& EnemyData, bool Log, int32* OutItemID, int32* OutItemNum);
	int32 GetResultItemKindNum(const struct FBtlResultData& PResult);
	struct FBtlResultData ResultItemGabage(const struct FBtlResultData& PResult, int32 GetItem);
	int32 StanDamageCalc(int32 SkillId, int32 SrcLv, int32 DstLv);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCalcBase">();
	}
	static class UBattleCalcBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleCalcBase>();
	}
};
static_assert(alignof(UBattleCalcBase) == 0x000008, "Wrong alignment on UBattleCalcBase");
static_assert(sizeof(UBattleCalcBase) == 0x000BA0, "Wrong size on UBattleCalcBase");

// Class Project.BPL_BattleCalcStatics
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleCalcStatics final : public UBlueprintFunctionLibrary
{
public:
	static float ActSpeedCalc(float baseSpd, float baseLv);
	static uint8 AddCount(const uint8& OriginValue, const uint8& AddValue);
	static struct FPressIcon ApplyPressIcon(const struct FPressIcon& Current_press_icon, const struct FPressIcon& Add_press_icon);
	static struct FPressIcon CalcDrawPressIconNum(const struct FPressIcon& Current_press_icon);
	static struct FPressIcon CalcPressIcon(E_BTL_PRESS_TYPE Press_type, const struct FPressIcon& Current_press_icon);
	static void CancelBst(int32* bst_bit);
	static bool CheckAishouMinus(int32 TargetAishou);
	static E_BST_TYPE CheckBstType(E_BAD_STATUS bst);
	static bool CheckDamageAttackKind(E_SKILL_TYPE Kind);
	static bool CheckDamageAttackKindPhysical(E_SKILL_TYPE Kind);
	static bool CheckHighAisyo(int32 Aisyo);
	static float GetDamageEnemyRate(E_GAME_DIFFICULTY Diff);
	static float GetDamageTakeEnemyRate(E_GAME_DIFFICULTY Diff);
	static float GetDeathEnemyRate(E_GAME_DIFFICULTY Diff);
	static float GetDeathPlayerRate(E_GAME_DIFFICULTY Diff);
	static float GetDiffRate(E_BTL_DIFF Diff);
	static float GetEnemyBstRate(E_GAME_DIFFICULTY Diff);
	static float GetEscapeSuccessRate(E_GAME_DIFFICULTY Diff);
	static float GetHitEnemyAttack(E_GAME_DIFFICULTY Diff);
	static float GetHitPlayerAttackRate(E_GAME_DIFFICULTY Diff);
	static float GetHitPlayerBstRate(E_GAME_DIFFICULTY Diff);
	static float GetPlayerCriticalRate(E_GAME_DIFFICULTY Diff);
	static float GetPlayerFirstRate(E_GAME_DIFFICULTY Diff);
	static E_BTL_CNT GetRandSkillAidCounter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleCalcStatics">();
	}
	static class UBPL_BattleCalcStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleCalcStatics>();
	}
};
static_assert(alignof(UBPL_BattleCalcStatics) == 0x000008, "Wrong alignment on UBPL_BattleCalcStatics");
static_assert(sizeof(UBPL_BattleCalcStatics) == 0x000028, "Wrong size on UBPL_BattleCalcStatics");

// Class Project.BPL_BattleCalcTable
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleCalcTable final : public UBlueprintFunctionLibrary
{
public:
	static const class FText BattleGetCommonMess(int32 Param_Index);
	static int32 GetRandUpliftingType(E_BTL_UPLIFTING_TYPE Type);
	static int32 GetRateUpliftingType(E_BTL_UPLIFTING_TYPE Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleCalcTable">();
	}
	static class UBPL_BattleCalcTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleCalcTable>();
	}
};
static_assert(alignof(UBPL_BattleCalcTable) == 0x000008, "Wrong alignment on UBPL_BattleCalcTable");
static_assert(sizeof(UBPL_BattleCalcTable) == 0x000028, "Wrong size on UBPL_BattleCalcTable");

// Class Project.BattleCamActorFactoryBase
// 0x0000 (0x00B0 - 0x00B0)
class UBattleCamActorFactoryBase : public UBattleActorComponentBase
{
public:
	void CalcUnitSocketLocation_Native(struct FTransform& PartyTrans, struct FVector& LocalSocketLoc, float RelativeLocZ, struct FVector* OutRoot, struct FVector* OutSocketLoc);
	bool IsRangeSkillCamera_Native(class FString& CameraName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCamActorFactoryBase">();
	}
	static class UBattleCamActorFactoryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleCamActorFactoryBase>();
	}
};
static_assert(alignof(UBattleCamActorFactoryBase) == 0x000008, "Wrong alignment on UBattleCamActorFactoryBase");
static_assert(sizeof(UBattleCamActorFactoryBase) == 0x0000B0, "Wrong size on UBattleCamActorFactoryBase");

// Class Project.UICommon
// 0x0000 (0x0028 - 0x0028)
class UUICommon final : public UBlueprintFunctionLibrary
{
public:
	static bool AddToWidgetPrio(class UUserWidget* Widget, E_WIDGET_PRIO Prio);
	static struct FLinearColor CalcScreenToWidgetUV(const class UCanvasPanel* Canvas, const struct FGeometry& Geometry);
	static struct FLinearColor CalcScreenToWidgetUVEx(const class UCanvasPanel* Canvas, const struct FGeometry& Geometry, float* OutScale);
	static bool GeometryEquals(const struct FGeometry& A, const struct FGeometry& B);
	static class AActor* SpawnUIActor(class UClass* PClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommon">();
	}
	static class UUICommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommon>();
	}
};
static_assert(alignof(UUICommon) == 0x000008, "Wrong alignment on UUICommon");
static_assert(sizeof(UUICommon) == 0x000028, "Wrong size on UUICommon");

// Class Project.BattleCharaActionBase
// 0x0428 (0x0648 - 0x0220)
class ABattleCharaActionBase : public AActor
{
public:
	struct FBtlActionStack                        M_Desc;                                            // 0x0220(0x0014)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                         Pad_15CF[0x4];                                     // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillActionDesc                       M_SkillActionDesc;                                 // 0x0238(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 M_UniqueName;                                      // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ActorIndex;                                      // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AddMPCost;                                       // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BAD_STATUS                                  M_MissByBadStatus;                                 // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D0[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_SelectList;                                      // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	E_BTL_PRESS_TYPE                              M_NewPressType;                                    // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D1[0x7];                                     // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<E_BTL_UPLIFTING_TYPE>                  M_NewUpliftingTypeArray;                           // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_CounterIndex;                                    // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D2[0x4];                                     // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_CounterIndexArray;                               // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_PlayerDeadNum;                                   // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_EnemyDeadNum;                                    // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsContinueUpdate;                                // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D3[0x317];                                   // 0x0331(0x0317)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddHPRefList(int32 PartyIndex, int32 Value);
	void AddRenzokuSkillCount(const int32& SrcIndex);
	void AddStatus(E_BTL_ACT_STAT InValue);
	void ApplySummonAfterPos(const TMap<int32, struct FTransform>& AfterList, const TArray<int32>& SummonList, const TArray<int32>& ReturnList);
	void BeginSelectorLabelCtrl(int32 BattleTempo);
	void BP_SetSummonTask(int32 TargetIndex);
	bool CheckHPRefListDead(int32 PartyIndex);
	bool CheckNoRenzokuEncountByTalkEnd(const struct FTalkResultInfo& TalkResultInfo);
	bool CheckStatus(E_BTL_ACT_STAT InValue);
	void ClearCounter(const int32& PartyIndex);
	void DelStatus(E_BTL_ACT_STAT InValue);
	void EndSelectorLabelCtrl();
	int32 GetCounterIndex();
	int32 GetHPRefListHP(int32 PartyIndex);
	const TArray<int32> GetReflectCharaList();
	bool IsEscapeSkill();
	void MakeSkillReflectList();
	TArray<int32> MakeSummonAfterDevilList(const TArray<int32>& NowList, const TArray<int32>& SummonList, const TArray<int32>& ReturnList);
	void RemoveCounterIndex();
	void SelectPressAndGauge(E_BTL_REFLECT_RES_TYPE ResType, E_BTL_DAMAGE_HIT_TYPE DamageType, int32 SrcIndex, int32 DstIndex);
	void SeqReadytFunc();
	void SeqSkillFunc();
	void SetAutoBattleCommandAndTargetSelect();
	void SetAutoBattleSkillCommandAndTargetSelect(int32 SkillId);
	bool SetCounterCommand(int32 PartyIndex);
	void SetCounterTargetList();
	bool SetFlagCharmOrConfuse(int32 PartyIndex);
	void SetHPRefList();
	void SetNewPress(E_BTL_PRESS_TYPE Press_type);
	void SetNewUpliftingType(int32 PartyIndex, E_BTL_UPLIFTING_TYPE Type);
	void SetReadyFunc();
	void SetRenzokuSkillCommand(int32 PartyIndex);
	void SetSkillFunc();
	void SetUpliftingOffFlag(const int32 SrcPartyIndex, const int32 DstPartyIndex);
	void SetWeakAutoBattleCommandAndTargetSelect();
	void SupportTsukuyomiSummon();
	bool UniqueSkill_CheckChargeDead(const int32& PartyIndex);
	TArray<int32> UpdateDelElectrification();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCharaActionBase">();
	}
	static class ABattleCharaActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleCharaActionBase>();
	}
};
static_assert(alignof(ABattleCharaActionBase) == 0x000008, "Wrong alignment on ABattleCharaActionBase");
static_assert(sizeof(ABattleCharaActionBase) == 0x000648, "Wrong size on ABattleCharaActionBase");
static_assert(offsetof(ABattleCharaActionBase, M_Desc) == 0x000220, "Member 'ABattleCharaActionBase::M_Desc' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_SkillActionDesc) == 0x000238, "Member 'ABattleCharaActionBase::M_SkillActionDesc' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_UniqueName) == 0x0002C8, "Member 'ABattleCharaActionBase::M_UniqueName' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_ActorIndex) == 0x0002D8, "Member 'ABattleCharaActionBase::M_ActorIndex' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_AddMPCost) == 0x0002DC, "Member 'ABattleCharaActionBase::M_AddMPCost' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_MissByBadStatus) == 0x0002E0, "Member 'ABattleCharaActionBase::M_MissByBadStatus' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_SelectList) == 0x0002E8, "Member 'ABattleCharaActionBase::M_SelectList' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_NewPressType) == 0x0002F8, "Member 'ABattleCharaActionBase::M_NewPressType' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_NewUpliftingTypeArray) == 0x000300, "Member 'ABattleCharaActionBase::M_NewUpliftingTypeArray' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_CounterIndex) == 0x000310, "Member 'ABattleCharaActionBase::M_CounterIndex' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_CounterIndexArray) == 0x000318, "Member 'ABattleCharaActionBase::M_CounterIndexArray' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_PlayerDeadNum) == 0x000328, "Member 'ABattleCharaActionBase::M_PlayerDeadNum' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_EnemyDeadNum) == 0x00032C, "Member 'ABattleCharaActionBase::M_EnemyDeadNum' has a wrong offset!");
static_assert(offsetof(ABattleCharaActionBase, M_IsContinueUpdate) == 0x000330, "Member 'ABattleCharaActionBase::M_IsContinueUpdate' has a wrong offset!");

// Class Project.BattleCharaPanelCtrlBase
// 0x01C8 (0x03E8 - 0x0220)
class ABattleCharaPanelCtrlBase : public AActor
{
public:
	uint8                                         Pad_15DA[0x1C8];                                   // 0x0220(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddPartyListFlag(int32 InIndex, E_BATTLECHARAPANELFLAG InType, int32 InCursorOffset);
	void BIEResetSupportIcon(int32 InSupportIndex, E_BTL_CNT InCount);
	void BIESetBattleCharaPanelFadeOutPanelAnimation(int32 InIndex);
	void BIESetBattleCharaPanelUnselectablePanelOff(int32 InIndex);
	void BIESetBattleCharaPanelUnselectablePanelOn(int32 InIndex);
	void BIESetBattleStatusOffsetCursorAnimation(int32 InOffsetType, int32 InAnimationType, bool InInstanceAnimationFrameOn);
	void BIESetBattleStatusOffsetCursorInstanceFrameRate(int32 InOffsetType);
	void BIESetInitializeBattleCharaPanelAnimation(int32 InIndex);
	void BIESetInitializeBattleStatusPanelAnimation(int32 InIndex);
	void BIESetInitializeBattleSummonPanelAnimation(int32 InIndex);
	void BIESetSupportIcon(int32 InSupportIndex, E_BTL_CNT InCount, int32 InValue, bool InLoopCheck, int32 InTurn, bool InMagatsuhi);
	int32 CalcBattleStatusPosition(int32 InPartyIndex, const struct FBtlParty& InPartyData);
	bool CalcDeadBadstatus(int32 InNkmIndex, int32 InHp, int32 InBadStatus);
	bool CalcMoveCursorStatusPositionIndex(int32 InIndex);
	int32 CalcScrollBarClickedByParty(float InRate, int32 InType);
	int32 CalcScrollBarClickedByStatus(float InRate);
	bool CalcSupportSkill(int32 InIndex, const struct FBtlParty& InPartyData);
	int32 CanBeSelectedAsCharaSelect(int32 InSrcIndex, int32 InType);
	int32 CanBeSelectedAsDst(int32 InSrcIndex, int32 InSrcType, int32 InDstIndex, int32 InSrcCursorOffset, int32 InDstCursorOffset);
	int32 CanBeSelectedAsSrc(int32 InSrcIndex);
	int32 CanBeSelectedAsStatus(int32 InSrcIndex, bool WithEnemy);
	bool CanBeSelectedAsStatusTarget(int32 InSrcIndex, int32 InOffsetCursor);
	bool ChangeSelectedPanel(int32 InSrcIndex, int32 InSrcType, int32 InDstIndex, int32 InDstType);
	TArray<E_BAD_STATUS> CreateBadstatusArray(int32 InBadstatusIndex);
	int32 CreateBattleInPartyList();
	bool CreateBattleNkmIndexList();
	bool DeletePanelList();
	int32 DelPartyListFlag(int32 InIndex, E_BATTLECHARAPANELFLAG InType, int32 InCursorOffset);
	bool EntryBadStatusList(int32 InIndex, int32 InBadStatus, int32 InCursorOffset);
	bool EntryNkmList(int32 InIndex, int32 InNkmIndex, int32 InCursorOffset);
	int32 EntryPartyList(int32 InIndex, E_BATTLECHARAPANELFLAG InType, int32 InCursorOffset);
	int32 GetBadstatusNumber();
	int32 GetBattleEnemyIndexByIndexList(int32 InType, int32 InIndex);
	int32 GetBattleInPartyIndex(int32 InType, int32 InIndex);
	int32 GetBattleNkmIndexByNkmIndexList(int32 InType, int32 InIndex);
	int32 GetBattlePartyIndexType(int32 InNkmIndex);
	int32 GetBattleSStatusNkmIndex(int32 InIndex);
	int32 GetBattleStatusEnemyPanelData(int32 InIndex);
	int32 GetBattleStatusOffsetCursorPosition();
	int32 GetBattleStatusPanelNumber(int32 InType);
	uint8 GetBattleSummonNkmIndex(int32 InIndex);
	uint8 GetBattleSummonNkmIndexByOffset(int32 InIndex, int32 InCursorOffset);
	int32 GetDeadTargetInStock(int32 InIndex);
	int32 GetMaxStockNumber();
	int32 GetMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex, int32 InOffsetType);
	int32 GetMoveCursorStatusPositionIndex(int32 InIndex, int32 InMoveIndex);
	int32 GetMoveOffsetCursorPositionIndex(int32 InIndex, int32 InMoveIndex, int32 InOffsetType, bool InScrollLock);
	int32 GetMoveOffsetCursorPositionIndexByScrollBar(int32 InIndex, int32 InOffsetIndex, int32 InMoveIndex, int32 InOffsetType);
	int32 GetMoveOffsetStatusPositionIndex(int32 InIndex, int32 InMoveIndex, bool InScrollLock);
	int32 GetMoveOffsetStatusPositionIndexByScrollBar(int32 InIndex, int32 InMoveIndex);
	struct FVector2D GetMovePanelAnimation(int32 InCategory);
	struct FVector2D GetMovePanelPosition(int32 InCategory);
	struct FVector2D GetPanelPositionByIndex(int32 InIndex, const struct FVector2D& InVec2D, int32 InCheckType);
	int32 GetPartyCursorWithInDrawRange(int32 InIndex, int32 InCursorOffset);
	int32 GetPartyDispNumber();
	int32 GetPartyIndexFromPanelID(int32 InIndex, bool WithEnemy);
	int32 GetPartyListDstOffsetIndex();
	int32 GetPartyListOffsetIndex();
	int32 GetPartyMaxDisplayCount();
	int32 GetStockDispNumber();
	int32 GetStockIndexByAddOffset(int32 InIndex, int32 InCursorOffset);
	int32 GetStockIndexByBattleIndex(int32 InIndex);
	int32 GetStockNumber();
	int32 GetSummonTargetInBattle(int32 InIndex);
	int32 GetSummonTargetInStock(int32 InIndex, bool IsDeadSummon);
	bool InitializeBattleStatusWork();
	bool InitializeCharaPanelCursor();
	bool InitializeEntryPartyList();
	bool IsBattleCharaPanelAnimation();
	bool IsBattleInByNkmIndex(int32 InNkmIndex);
	bool IsBattleStatusPanelAnimation();
	bool IsBattleSummonPanelAnimation();
	bool IsEmptyPanel(int32 InIndex, int32 InCursorOffset);
	bool IsMovePanelAnimation(int32 InCategory);
	bool IsOnBadStatusByIndex(int32 InIndex, E_BAD_STATUS InBadStatus);
	bool IsPartyCursorWithInDrawRange(int32 InIndex, int32 InCursorOffset);
	bool IsSummonAnimation();
	void RebuildStatusCharaList(class UUIStatusCtrlDataObjBtlBase* StatusUIDataObj, bool WithEnemy);
	bool ResetCharaMovingCursor(int32 InType);
	bool SetBattleEnemyIndexList(int32 InType, int32 InIndex, int32 InPartyIndex, int32 InDevilId);
	bool SetBattleNkmIndexList(int32 InType, int32 InIndex, int32 InNkmIndex);
	bool SetBattleStatusOffsetCursorPositionByIndex(int32 InIndex);
	bool SetCharaMovingCursor(int32 InType);
	bool SetDeadSummonFlag(bool InDeadSummonOn);
	int32 SetEnemyStatusInitializeCursorPositionIndex(int32 InIndex);
	bool SetMovePanelPosition(const struct FVector2D& InPos, int32 InCategory, int32 InType);
	int32 SetPartyCharaSelectInitializeCursorPositionIndex(int32 InIndex, int32 InType);
	bool SetPartyCursorParameter(int32 InCursor, int32 InOffset);
	bool SetPartyListDstOffsetIndex(int32 InOffsetIndex);
	bool SetPartyListOffsetIndex(int32 InOffsetIndex);
	int32 SetPartyStatusInitializeCursorPositionIndex(int32 InIndex);
	int32 SetStockCharaSelectInitializeCursorPositionIndex(int32 InIndex, int32 InType);
	int32 SetStockStatusInitializeCursorPositionIndex(int32 InIndex);
	bool SetSummonSelectedPanel();
	bool StartBattleCharaPanelAnimation();
	bool StartBattleCharaPanelFadeOutAnimation();
	bool StartBattleStatusPanelAnimation();
	bool StartBattleSummonPanelAnimation();
	bool StartMovePanelAnimation(int32 InCategory);
	bool StartStatusCharaPanelFadeOutAnimation();
	bool StartSummonAnimation(float InWaitTime);
	bool StartSummonCharaPanelFadeOutAnimation();
	bool StopBattleCharaPanelAnimation();
	bool StopBattleStatusPanelAnimation();
	bool StopBattleSummonPanelAnimation();
	bool StopMovePanelAnimation(int32 InCategory);
	bool StopSummonAnimation();
	int32 UpdateBattleInPartyList();
	bool UpdateEnemyPanelData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCharaPanelCtrlBase">();
	}
	static class ABattleCharaPanelCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleCharaPanelCtrlBase>();
	}
};
static_assert(alignof(ABattleCharaPanelCtrlBase) == 0x000008, "Wrong alignment on ABattleCharaPanelCtrlBase");
static_assert(sizeof(ABattleCharaPanelCtrlBase) == 0x0003E8, "Wrong size on ABattleCharaPanelCtrlBase");

// Class Project.UIWidgetBase
// 0x0018 (0x0278 - 0x0260)
class UUIWidgetBase : public UUserWidget
{
public:
	bool                                          IsTickCallOn;                                      // 0x0260(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1607[0x7];                                     // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<E_WIDGET_TICK_TASK_TYPE>               M_TickTaskArray;                                   // 0x0268(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void AddTickCallTask(E_WIDGET_TICK_TASK_TYPE TaskType);
	void ChangeTickCall(bool IsOn);
	void DelTickCallTask(E_WIDGET_TICK_TASK_TYPE TaskType);
	void TickCallTaskAllClear();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWidgetBase">();
	}
	static class UUIWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWidgetBase>();
	}
};
static_assert(alignof(UUIWidgetBase) == 0x000008, "Wrong alignment on UUIWidgetBase");
static_assert(sizeof(UUIWidgetBase) == 0x000278, "Wrong size on UUIWidgetBase");
static_assert(offsetof(UUIWidgetBase, IsTickCallOn) == 0x000260, "Member 'UUIWidgetBase::IsTickCallOn' has a wrong offset!");
static_assert(offsetof(UUIWidgetBase, M_TickTaskArray) == 0x000268, "Member 'UUIWidgetBase::M_TickTaskArray' has a wrong offset!");

// Class Project.BtlCommandWidgetBase
// 0x0368 (0x05E0 - 0x0278)
#pragma pack(push, 0x1)
class alignas(0x10) UBtlCommandWidgetBase : public UUIWidgetBase
{
public:
	uint8                                         Pad_1608[0x8];                                     // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlParty                              M_PartyData;                                       // 0x0280(0x0320)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         Const_HoldOnTime;                                  // 0x05A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsHold;                                          // 0x05A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1609[0x3];                                     // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_HoldTime;                                        // 0x05A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	E_ACTION_MAPPING_TYPE                         M_HoldActionType;                                  // 0x05AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	E_BTL_UI_COMMAND                              M_HoldCommandType;                                 // 0x05AD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160A[0x2];                                     // 0x05AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIAnimationTaskData>           M_AnimTaskArray;                                   // 0x05B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FUIAnimationTableData>          M_AnimTableDataArray;                              // 0x05C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UUIAnimtionCtrl*                        M_pAnimCtrl;                                       // 0x05D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddAnimationTask(E_BTL_COMM_ANIM_TYPE AnimType, bool IsReverse);
	void AddAnimTable(const struct FUIAnimationTableData& AnimTableData);
	void AddHoldTime(float AddTime);
	struct FVector2D CalcHoldBarSize(const struct FVector2D& barSize, float Time, float MaxTime);
	void ClearAnimTable(const struct FUIAnimationTableData& AnimTableData);
	void ClearHold();
	void CreateAnimCtrl();
	void DeleteAnimCtrl();
	void EndAnimation(E_BTL_COMM_ANIM_TYPE AnimType);
	struct FUIAnimationTaskData GetAnimationTask(E_BTL_COMM_ANIM_TYPE AnimType);
	struct FUIAnimationTableData GetAnimTableData(E_BTL_COMM_ANIM_TABLE TableType);
	bool GetIsHold();
	int32 GetPartyData_NkmIndex();
	int32 GetPartyData_PartyIndex();
	void GetSetAnimDataTableTypes(E_BTL_COMM_ANIM_TYPE Type, TArray<E_BTL_COMM_ANIM_TABLE>* TblTypes, bool* IsLoop);
	void Init_BP();
	bool Input(bool* IsInput, E_BTL_UI_COMMAND* InputCommand);
	bool InputCheckOne(const struct FBtlCommandUIData& CommandData, bool* IsInput, E_BTL_UI_COMMAND* InputCommand);
	bool IsPlayUIAnimation(E_BTL_COMM_ANIM_TYPE AnimType);
	void PlayAnimation_Clear();
	void PlayAnimation_UnitFormBlinking();
	bool PlayUIAnimation(float DeltaTime, bool* IsPlayEnd);
	bool StartAnimation(E_BTL_COMM_ANIM_TYPE AnimType, bool IsReverse, bool IsCheckPlaySame);
	bool UpDataHoldBarUI(E_BTL_UI_COMMAND CommandType, float Time, float MaxTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlCommandWidgetBase">();
	}
	static class UBtlCommandWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlCommandWidgetBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBtlCommandWidgetBase) == 0x000010, "Wrong alignment on UBtlCommandWidgetBase");
static_assert(sizeof(UBtlCommandWidgetBase) == 0x0005E0, "Wrong size on UBtlCommandWidgetBase");
static_assert(offsetof(UBtlCommandWidgetBase, M_PartyData) == 0x000280, "Member 'UBtlCommandWidgetBase::M_PartyData' has a wrong offset!");
static_assert(offsetof(UBtlCommandWidgetBase, Const_HoldOnTime) == 0x0005A0, "Member 'UBtlCommandWidgetBase::Const_HoldOnTime' has a wrong offset!");
static_assert(offsetof(UBtlCommandWidgetBase, M_IsHold) == 0x0005A4, "Member 'UBtlCommandWidgetBase::M_IsHold' has a wrong offset!");
static_assert(offsetof(UBtlCommandWidgetBase, M_HoldTime) == 0x0005A8, "Member 'UBtlCommandWidgetBase::M_HoldTime' has a wrong offset!");
static_assert(offsetof(UBtlCommandWidgetBase, M_HoldActionType) == 0x0005AC, "Member 'UBtlCommandWidgetBase::M_HoldActionType' has a wrong offset!");
static_assert(offsetof(UBtlCommandWidgetBase, M_HoldCommandType) == 0x0005AD, "Member 'UBtlCommandWidgetBase::M_HoldCommandType' has a wrong offset!");
static_assert(offsetof(UBtlCommandWidgetBase, M_AnimTaskArray) == 0x0005B0, "Member 'UBtlCommandWidgetBase::M_AnimTaskArray' has a wrong offset!");
static_assert(offsetof(UBtlCommandWidgetBase, M_AnimTableDataArray) == 0x0005C0, "Member 'UBtlCommandWidgetBase::M_AnimTableDataArray' has a wrong offset!");
static_assert(offsetof(UBtlCommandWidgetBase, M_pAnimCtrl) == 0x0005D0, "Member 'UBtlCommandWidgetBase::M_pAnimCtrl' has a wrong offset!");

// Class Project.BtlSubCommandWidgetBase
// 0x0010 (0x05F0 - 0x05E0)
class UBtlSubCommandWidgetBase final : public UBtlCommandWidgetBase
{
public:
	TArray<struct FBtlSubCommandUIData>           M_CommandUIDataArray;                              // 0x05D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1612[0x8];                                     // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCommandUIData(const struct FBtlSubCommandUIData& Data);
	void CreateCommandData(bool IsList, bool IsPlayer, bool IsCounter, bool IsChangeCharaUse);
	TArray<struct FBtlSubCommandUIData> GetCommandUIDataArray();
	void MakeCounterListCommand(bool IsChangeCharaUse);
	void MakeNkmCommand(bool IsChangeCharaUse);
	void MakeNkmListCommand(bool IsChangeCharaUse);
	void MakePlayerCommand(bool IsChangeCharaUse);
	void MakePlayerListCommand(bool IsChangeCharaUse);
	bool Setting(const struct FBtlParty& PartyData, bool IsUseCharaChange, bool IsCounter, bool IsList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSubCommandWidgetBase">();
	}
	static class UBtlSubCommandWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSubCommandWidgetBase>();
	}
};
static_assert(alignof(UBtlSubCommandWidgetBase) == 0x000010, "Wrong alignment on UBtlSubCommandWidgetBase");
static_assert(sizeof(UBtlSubCommandWidgetBase) == 0x0005F0, "Wrong size on UBtlSubCommandWidgetBase");
static_assert(offsetof(UBtlSubCommandWidgetBase, M_CommandUIDataArray) == 0x0005D8, "Member 'UBtlSubCommandWidgetBase::M_CommandUIDataArray' has a wrong offset!");

// Class Project.BPL_BattleCommon
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleCommon final : public UBlueprintFunctionLibrary
{
public:
	static void BattleCommonClearInochigoiCnt();
	static void BattleCommonDelInochigoiCnt(int32 Value);
	static uint8 BattleCommonGetCurrentHeroType();
	static int32 BattleCommonGetInochigoiCnt();
	static void BattleCommonGetPreFirstActor(int32 EncountID, bool IsEvent, E_BTL_CHAR_TYPE* Type, int32* DevilID);
	static void BattleCommonSetCurrentHeroType(uint8 Type);
	static void BattleUIDrawWidgetToTarget(class UTextureRenderTarget2D* Target, class UUserWidget* WidgetToRender, const struct FVector2D& DrawSize, bool UseGamma, ETextureFilter Filter, float DeltaTime);
	static int32 GetUpliftingGaugeConsumptionValue();
	static int32 GetUpliftingGaugeMax();
	static TArray<class FString> RetrieveCameraNameInner(const class UDataTable* CameraTable, const class FString& CoreName, int32 FB, int32 LR, bool IsNoWildCard);
	static void TalkQuizNotCountAdd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleCommon">();
	}
	static class UBPL_BattleCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleCommon>();
	}
};
static_assert(alignof(UBPL_BattleCommon) == 0x000008, "Wrong alignment on UBPL_BattleCommon");
static_assert(sizeof(UBPL_BattleCommon) == 0x000028, "Wrong size on UBPL_BattleCommon");

// Class Project.BPL_BattleEventTable
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleEventTable final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FBattleEventData> BattleEventTableGetDataList(int32 battleNo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleEventTable">();
	}
	static class UBPL_BattleEventTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleEventTable>();
	}
};
static_assert(alignof(UBPL_BattleEventTable) == 0x000008, "Wrong alignment on UBPL_BattleEventTable");
static_assert(sizeof(UBPL_BattleEventTable) == 0x000028, "Wrong size on UBPL_BattleEventTable");

// Class Project.BattleMainWorkBase
// 0x04A0 (0x06C0 - 0x0220)
class ABattleMainWorkBase : public AActor
{
public:
	uint8                                         Pad_1618[0x38];                                    // 0x0220(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          M_RandStream;                                      // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	E_BTL_STEP                                    M_Step;                                            // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_BTL_STEP                                    M_PrevStep;                                        // 0x0261(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_BTL_STEP                                    M_NextStep;                                        // 0x0262(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1619[0x1];                                     // 0x0263(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_LocalStep;                                       // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBtlActionStack>                M_ActionStack;                                     // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         M_ActionStackCnt;                                  // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_BTL_END                                     M_EndType;                                         // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161A[0x3];                                     // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_BtlFlag;                                         // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_BtlFlag2;                                        // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_DbgState;                                        // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_DbgState2;                                       // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBtlKillData>                   M_EnemyKillList;                                   // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<E_EVTBTL_WIN_COND, struct FEvtBtlWinCond> M_WinCondition;                                    // 0x02A0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         M_AIFlag;                                          // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161B[0x4];                                     // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_AIValue;                                         // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         M_SaveTargetIndex;                                 // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_BTL_SEQ                                     M_SeqState;                                        // 0x030C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161C[0x3];                                     // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_StepCnt;                                         // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161D[0xC];                                     // 0x0314(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_OriginTransform;                                 // 0x0320(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBtlEncData                            M_EncountData;                                     // 0x0350(0x0058)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         M_EncCnt;                                          // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_EscCnt;                                          // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBtlDescData                           M_DescData;                                        // 0x03B0(0x0090)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBtlDescData                           M_DescDataBackup;                                  // 0x0440(0x0090)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class ABattleFieldWorkBase*                   M_pBattleField;                                    // 0x04D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pMapCameraActor;                                 // 0x04D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_RealTurn;                                        // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPressIcon                             M_PressIcon;                                       // 0x04E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPressIcon                             M_InitialPressIcon;                                // 0x04F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	E_BTL_PRESS_TYPE                              M_PressType;                                       // 0x04FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161E[0x3];                                     // 0x04FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPressIcon                             M_AddEnemyKilledPressIcon;                         // 0x0500(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPressIcon                             M_BackupPressIcon;                                 // 0x050C(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPressIcon                             M_BackupPressIconAdded;                            // 0x0518(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	E_BTL_PRESS_TYPE                              M_BackupPressType;                                 // 0x0524(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161F[0x3];                                     // 0x0525(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPressIcon                             M_ActionPrevPressIcon;                             // 0x0528(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBtlMoonAge                            M_MoonAge;                                         // 0x0534(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         M_Kantuu;                                          // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUpliftingGauge                        M_UpliftingGauge;                                  // 0x0540(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1620[0x4];                                     // 0x0550(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_UpliftingPartyIndex;                             // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_PressIconAddNum;                                 // 0x0558(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<bool>                                  M_IsPressIconDel;                                  // 0x0568(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_PressIconIncDec;                                 // 0x0578(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1621[0x20];                                    // 0x0588(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBtlKuishibariData>             M_KuiUserList;                                     // 0x05A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBtlGardenPointData                    M_GardenPointData;                                 // 0x05B8(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_IsContinueUpdate;                                // 0x05C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1622[0x3];                                     // 0x05C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChainEncountEnemyInfo                 M_ChainEncountEnemyInfo;                           // 0x05C8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1623[0x88];                                    // 0x05E0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_DebugSkillList;                                  // 0x0668(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_DebugRenzokuEncountlList;                        // 0x0678(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<bool>                                  M_DebugSkillSelectIconList;                        // 0x0688(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1624[0x28];                                    // 0x0698(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBattleDebugFlag(E_BTL_STATE_DEBUG Value);
	void AddBattleDebugFlag2(E_BTL_STATE_DEBUG_2 Value);
	void AddBattleFlag(E_BTL_STAT Value);
	void AddBattleFlag2(E_BTL_STAT_2 Value);
	void AddEscapeCnt();
	E_BTL_PRESS_TYPE AddPressIconTypeGodParam();
	void BattleSeqStart(const struct FBtlDescData& Desc);
	void BattleUpdate(float DeltaTime);
	E_BTL_STEP BI_GetStep();
	void BossRush_Reset();
	void BP_ActionPreActCheckBattleEnd();
	void BP_ActionPreActEndByBadStatusTask();
	void BP_ActionPreBadStatusCureTask();
	void BP_ActionPreCamChangeTask();
	void BP_ActionPreTaskWait();
	void BP_BattleSeqStart();
	void BP_DebugBattleOnlySetting();
	void BP_SeqStepFuncEnemyTurnStartReturn();
	void BP_SetStepFuncEnemyTurnStartReturn();
	void BP_StepFuncSeqAction();
	void BP_StepFuncSeqActionAfter();
	void BP_StepFuncSeqActionEvent();
	void BP_StepFuncSeqActionPre();
	void BP_StepFuncSeqCheckEnd();
	void BP_StepFuncSeqCheckTurn();
	void BP_StepFuncSeqEndEvent();
	void BP_StepFuncSeqEnemyTurnEndReturn();
	void BP_StepFuncSeqEnemyUplifting();
	void BP_StepFuncSeqEscape();
	void BP_StepFuncSeqGameOver();
	void BP_StepFuncSeqInochigoi();
	void BP_StepFuncSeqMercyTalk();
	void BP_StepFuncSeqPre();
	void BP_StepFuncSeqPressPre();
	void BP_StepFuncSeqReady();
	void BP_StepFuncSeqRenzokuEncount();
	void BP_StepFuncSeqResult();
	void BP_StepFuncSeqStartEvent();
	void BP_StepFuncSeqTalkEndFriend();
	void BP_StepFuncSeqTurnChange();
	void BP_StepFuncSeqTurnEnd();
	void BP_StepFuncSeqTurnEndEvent();
	void BP_StepFuncSeqTurnStartEvent();
	void BP_StepFuncSeqUpliftingTurn();
	void BP_StepFuncSetAction();
	void BP_StepFuncSetActionAfter();
	void BP_StepFuncSetActionEvent();
	void BP_StepFuncSetActionPre();
	void BP_StepFuncSetCheckEnd();
	void BP_StepFuncSetCheckTurn();
	void BP_StepFuncSetEndEvent();
	void BP_StepFuncSetEnemyTurnEndReturn();
	void BP_StepFuncSetEnemyUplifting();
	void BP_StepFuncSetEscape();
	void BP_StepFuncSetGameOver();
	void BP_StepFuncSetInochigoi();
	void BP_StepFuncSetMercyTalk();
	void BP_StepFuncSetPre();
	void BP_StepFuncSetPressPre();
	void BP_StepFuncSetReady();
	void BP_StepFuncSetRenzokuEncount();
	void BP_StepFuncSetResult();
	void BP_StepFuncSetStartEvent();
	void BP_StepFuncSetTalkEndFriend();
	void BP_StepFuncSetTurnChange();
	void BP_StepFuncSetTurnEnd();
	void BP_StepFuncSetTurnEndEvent();
	void BP_StepFuncSetTurnStartEvent();
	void BP_StepFuncSetUpliftingTurn();
	void BP_TickCheckDebugMenu();
	void BP_TickMainCalcAfter(float DeltaTime);
	bool CheckBattleDebugFlag(E_BTL_STATE_DEBUG Value);
	bool CheckBattleDebugFlag2(E_BTL_STATE_DEBUG_2 Value);
	bool CheckBattleEndEnemyHPRate();
	bool CheckBattleEndLeaderDead();
	bool CheckBattleFlag(E_BTL_STAT Value);
	bool CheckBattleFlag2(E_BTL_STAT_2 Value);
	void CheckEnemyAttackType();
	bool CheckInochigoi();
	bool CheckKuiUserList(int32 PartyIndex, E_KUISHIBARI_LEVEL Level);
	void CheckMercyTalk(bool* OutIsMercyTalk, struct FTalkStartInfo* OutStartInfo);
	int32 CheckRenzokuEncount(class UDataTable* DataTable);
	bool CheckRenzokuEncountMagatsuhiDevil(const int32& EncountID);
	bool CheckThisBattleEntryNkm(const int32 PartyIndex);
	bool CheckTimeAttackBattle(struct FBtlDescData& DescData);
	bool CheckTutorial(const E_BTL_TUTORIAL Tutorial);
	bool CheckUniqueSkillEfficacy_forInfo(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT UniqueSkillType);
	void CleanupTutorialData();
	void CleanupTutorialDataAll();
	void ClearActionPreParam(bool Is_counter);
	void ClearAddEnemyKilledPressIcon();
	void ClearAllUniqueSkillEfficacy_forInfo(int32 PartyIndex);
	void ClearBackupPressIconAdded();
	void ClearSavedTsukuyomiHP();
	void ClearUniqueSkillEfficacy_forInfo(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT UniqueSkillType);
	void ClearUpliftingPartyIndex();
	void DelBattleDebugFlag(E_BTL_STATE_DEBUG Value);
	void DelBattleDebugFlag2(E_BTL_STATE_DEBUG_2 Value);
	void DelBattleFlag(E_BTL_STAT Value);
	void DelBattleFlag2(E_BTL_STAT_2 Value);
	void DeleteKuiUserList(bool IsPlayer);
	void DelPressIcon(struct FPressIcon* PressIcon);
	int32 EncountIsEvent();
	bool EncountIsNotEscape();
	bool EncountIsRoomBoss();
	E_BTL_END GetBtlEnd();
	int32 GetCurrentBGMID();
	int32 GetEscapeCnt();
	const struct FBtlGardenPointData GetGardenPointData();
	struct FPressIcon GetInitialPressIcon();
	int32 GetKantuu();
	int32 GetOverwriteSkillInfoID(const int32 SkillId);
	struct FPressIcon GetPressIcon();
	E_BTL_PRESS_TYPE GetPressType();
	float GetRenzokuEncountResultBonus();
	int32 GetUpliftingPartyIndex();
	void IncRealTurn();
	void InitializeUniqueSkillEfficacy_forInfo();
	bool IsBossRushChallengeMode();
	bool IsMagatsuhiTalkFailedBlock();
	bool IsPressIcon();
	void MakeUpEncountData();
	void MakeupTutorialData(const E_BTL_TUTORIAL_TYPE Type);
	void OnWindowActivationChanged(bool bActive);
	void ResetMoonAge();
	void SaveTsukuyomiHP();
	void SetAchievements_Damage(const int32& SrcPartyIndex, const int32& Damage, TArray<EAchievementFlag>& OutAchievements);
	void SetAchievements_Kill(const int32& SrcPartyIndex, const int32& DstPartyIndex, const bool& IsDead, TArray<EAchievementFlag>& OutAchievements);
	void SetAchievements_MissBlockRefAbsCount(const int32& DstPartyIndex, const E_BTL_REFLECT_RES_TYPE& ResType, TArray<EAchievementFlag>& OutAchievements);
	void SetAchievements_UseMagatsuhiSkillCount(const int32& SrcPartyIndex, const struct FSkillBaseData& UseSkillData, TArray<EAchievementFlag>& OutAchievements);
	void SetAchievements_WeakCount(const int32& SrcPartyIndex, const bool& IsWeak, TArray<EAchievementFlag>& OutAchievements);
	void SetAchievements_WinRenzoku(TArray<EAchievementFlag>& OutAchievements);
	void SetAddEnemyKilledPressIcon(const int32 EnemyKilledNum);
	void SetCurrentBGMID(int32 ID);
	void SetDebugSkillSelectIcon(E_SKILL_ICON Icon, bool Sw);
	void SetKantuu(int32 Value);
	void SetKuiUserList(int32 PartyIndex, E_KUISHIBARI_LEVEL Level);
	void SetNextStep(E_BTL_STEP NextStep);
	void SetPressIcon(const struct FPressIcon& Press_icon);
	void SetPressType(E_BTL_PRESS_TYPE PressType);
	void SetRenzouEncountReader(struct FBtlDescData& DescData);
	void SetTutorialDoneFlag(const E_BTL_TUTORIAL_TYPE Type);
	void SetUniqueSkillEfficacy_forInfo(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT UniqueSkillType);
	void SetUpliftingPartyIndex(int32 Party_index);
	const TArray<struct FBtlSummonData> ShuffleSummonData(TArray<struct FBtlSummonData>* SummonData);
	void UpdateMagatsuhiTalkFailedBlock();
	bool UpdateMoonAgeCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleMainWorkBase">();
	}
	static class ABattleMainWorkBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleMainWorkBase>();
	}
};
static_assert(alignof(ABattleMainWorkBase) == 0x000010, "Wrong alignment on ABattleMainWorkBase");
static_assert(sizeof(ABattleMainWorkBase) == 0x0006C0, "Wrong size on ABattleMainWorkBase");
static_assert(offsetof(ABattleMainWorkBase, M_RandStream) == 0x000258, "Member 'ABattleMainWorkBase::M_RandStream' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_Step) == 0x000260, "Member 'ABattleMainWorkBase::M_Step' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_PrevStep) == 0x000261, "Member 'ABattleMainWorkBase::M_PrevStep' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_NextStep) == 0x000262, "Member 'ABattleMainWorkBase::M_NextStep' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_LocalStep) == 0x000264, "Member 'ABattleMainWorkBase::M_LocalStep' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_ActionStack) == 0x000268, "Member 'ABattleMainWorkBase::M_ActionStack' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_ActionStackCnt) == 0x000278, "Member 'ABattleMainWorkBase::M_ActionStackCnt' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_EndType) == 0x00027C, "Member 'ABattleMainWorkBase::M_EndType' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_BtlFlag) == 0x000280, "Member 'ABattleMainWorkBase::M_BtlFlag' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_BtlFlag2) == 0x000284, "Member 'ABattleMainWorkBase::M_BtlFlag2' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_DbgState) == 0x000288, "Member 'ABattleMainWorkBase::M_DbgState' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_DbgState2) == 0x00028C, "Member 'ABattleMainWorkBase::M_DbgState2' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_EnemyKillList) == 0x000290, "Member 'ABattleMainWorkBase::M_EnemyKillList' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_WinCondition) == 0x0002A0, "Member 'ABattleMainWorkBase::M_WinCondition' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_AIFlag) == 0x0002F0, "Member 'ABattleMainWorkBase::M_AIFlag' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_AIValue) == 0x0002F8, "Member 'ABattleMainWorkBase::M_AIValue' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_SaveTargetIndex) == 0x000308, "Member 'ABattleMainWorkBase::M_SaveTargetIndex' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_SeqState) == 0x00030C, "Member 'ABattleMainWorkBase::M_SeqState' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_StepCnt) == 0x000310, "Member 'ABattleMainWorkBase::M_StepCnt' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_OriginTransform) == 0x000320, "Member 'ABattleMainWorkBase::M_OriginTransform' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_EncountData) == 0x000350, "Member 'ABattleMainWorkBase::M_EncountData' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_EncCnt) == 0x0003A8, "Member 'ABattleMainWorkBase::M_EncCnt' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_EscCnt) == 0x0003AC, "Member 'ABattleMainWorkBase::M_EscCnt' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_DescData) == 0x0003B0, "Member 'ABattleMainWorkBase::M_DescData' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_DescDataBackup) == 0x000440, "Member 'ABattleMainWorkBase::M_DescDataBackup' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_pBattleField) == 0x0004D0, "Member 'ABattleMainWorkBase::M_pBattleField' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_pMapCameraActor) == 0x0004D8, "Member 'ABattleMainWorkBase::M_pMapCameraActor' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_RealTurn) == 0x0004E0, "Member 'ABattleMainWorkBase::M_RealTurn' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_PressIcon) == 0x0004E4, "Member 'ABattleMainWorkBase::M_PressIcon' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_InitialPressIcon) == 0x0004F0, "Member 'ABattleMainWorkBase::M_InitialPressIcon' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_PressType) == 0x0004FC, "Member 'ABattleMainWorkBase::M_PressType' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_AddEnemyKilledPressIcon) == 0x000500, "Member 'ABattleMainWorkBase::M_AddEnemyKilledPressIcon' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_BackupPressIcon) == 0x00050C, "Member 'ABattleMainWorkBase::M_BackupPressIcon' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_BackupPressIconAdded) == 0x000518, "Member 'ABattleMainWorkBase::M_BackupPressIconAdded' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_BackupPressType) == 0x000524, "Member 'ABattleMainWorkBase::M_BackupPressType' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_ActionPrevPressIcon) == 0x000528, "Member 'ABattleMainWorkBase::M_ActionPrevPressIcon' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_MoonAge) == 0x000534, "Member 'ABattleMainWorkBase::M_MoonAge' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_Kantuu) == 0x00053C, "Member 'ABattleMainWorkBase::M_Kantuu' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_UpliftingGauge) == 0x000540, "Member 'ABattleMainWorkBase::M_UpliftingGauge' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_UpliftingPartyIndex) == 0x000554, "Member 'ABattleMainWorkBase::M_UpliftingPartyIndex' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_PressIconAddNum) == 0x000558, "Member 'ABattleMainWorkBase::M_PressIconAddNum' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_IsPressIconDel) == 0x000568, "Member 'ABattleMainWorkBase::M_IsPressIconDel' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_PressIconIncDec) == 0x000578, "Member 'ABattleMainWorkBase::M_PressIconIncDec' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_KuiUserList) == 0x0005A8, "Member 'ABattleMainWorkBase::M_KuiUserList' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_GardenPointData) == 0x0005B8, "Member 'ABattleMainWorkBase::M_GardenPointData' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_IsContinueUpdate) == 0x0005C4, "Member 'ABattleMainWorkBase::M_IsContinueUpdate' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_ChainEncountEnemyInfo) == 0x0005C8, "Member 'ABattleMainWorkBase::M_ChainEncountEnemyInfo' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_DebugSkillList) == 0x000668, "Member 'ABattleMainWorkBase::M_DebugSkillList' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_DebugRenzokuEncountlList) == 0x000678, "Member 'ABattleMainWorkBase::M_DebugRenzokuEncountlList' has a wrong offset!");
static_assert(offsetof(ABattleMainWorkBase, M_DebugSkillSelectIconList) == 0x000688, "Member 'ABattleMainWorkBase::M_DebugSkillSelectIconList' has a wrong offset!");

// Class Project.BPL_BattleMain
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleMain final : public UBlueprintFunctionLibrary
{
public:
	static bool BattleMainCheckKuishibariUsedList(const TArray<struct FBtlKuishibariData>& List, const struct FBtlParty& Src, E_KUISHIBARI_LEVEL Level);
	static TArray<struct FBtlKuishibariData> BattleMainDeleteKuishibariUsedList(const TArray<struct FBtlKuishibariData>& List, bool IsPlayer);
	static TArray<struct FBtlKillData> BattleMainSetKillEnemy(const TArray<struct FBtlKillData>& List, int32 EnemyID);
	static TArray<struct FBtlKuishibariData> BattleMainSetKuishibariUsedList(const TArray<struct FBtlKuishibariData>& List, const struct FBtlParty& Src, E_KUISHIBARI_LEVEL Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleMain">();
	}
	static class UBPL_BattleMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleMain>();
	}
};
static_assert(alignof(UBPL_BattleMain) == 0x000008, "Wrong alignment on UBPL_BattleMain");
static_assert(sizeof(UBPL_BattleMain) == 0x000028, "Wrong size on UBPL_BattleMain");

// Class Project.UIStatusCtrlDataObjBase
// 0x0180 (0x01A8 - 0x0028)
class UUIStatusCtrlDataObjBase : public UObject
{
public:
	int32                                         M_Current;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1638[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_CharaRefList;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1639[0x168];                                   // 0x0040(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCurrent();
	bool ChangeNewOld();
	void ClearParentSkill();
	void ClearParentSkillCursorData();
	struct FUIStatusSlotItemData GetUISlotDataParent(int32 Offset, int32 IndexOnUI);
	void JumpBeforePage();
	void JumpFirstPage();
	void JumpNextPage();
	void PrepareBibleData(int32 DevilID);
	void PrepareDevilBaseData(int32 DevilID);
	void PrepareEnemyData(int32 DevilID);
	void PrepareNkmData(int32 NkmIndex, int32 UpLv);
	void PreparePlayerData();
	void ResetSkipList(const E_UI_STATUS_PAGE_TYPE PageType);
	void SetCurrent(int32 NewCurrent);
	void SetEmptyStatusData();
	void SubCurrent();
	void SwapSkillData(int32 TargetIndex_1, int32 TargetIndex_2);
	void SwitchKamui_ForCtrl(int32 TargetIndex);
	void UpdateCurrent(int32 Param_Index);
	bool UpdateDropAndCondCursor(int32 NewTotalIndex);
	void UpdateSkillCursor(bool* IsChanged, int32 Index_New, int32 Index_Hold);

	int32 CalcNearlyIndex_Right(const int32 IdealIndex, const int32 Offset, const E_UI_STATUS_PAGE_TYPE PageType) const;
	int32 CalcNextIndex(const int32 OldDataIndex, const int32 MoveValue, const bool EnableLoop, const E_UI_STATUS_PAGE_TYPE PageType) const;
	int32 CalcNextOffset(const int32 OldOffset, const int32 NextDataIndex, const E_UI_STATUS_PAGE_TYPE PageType) const;
	bool ExistLearningNextSkill() const;
	int32 GetAdditionalCost() const;
	class AActor* GetCharaReference(const int32 RelativePosition) const;
	int32 GetConditionTurnCount(const int32 TextNum) const;
	int32 GetCostDifference() const;
	int32 GetCurrent() const;
	void GetCurrentTextID(E_UI_STATUS_LIST_ITEM_TYPE* TextType, int32* TextID, bool* IsOpen) const;
	int32 GetDevilID(const int32 RelativePosition) const;
	int32 GetDevilIDFromIndex(const int32 Param_Index) const;
	int32 GetFaceIconID(const int32 RelativePosition) const;
	E_UI_STATUS_FUSION_ORDER GetFaceIconOrder() const;
	int32 GetFirstForcusableIndex() const;
	const struct FUIStatusDataLeft GetLeftData() const;
	int32 GetListMax() const;
	const struct FTransform GetModelSpawnTransform() const;
	int32 GetNextSkillLv() const;
	E_UI_STATUS_PAGE_TYPE GetPageType() const;
	const struct FUIStatusSlotItemData GetParentSkill(int32 Param_Index) const;
	int32 GetParentSkillMax() const;
	int32 GetRightSlotMax(E_UI_STATUS_PAGE_TYPE PageType) const;
	int32 GetShowFlag() const;
	struct FUIStatusSlotItemData GetUISlotDataRight(int32 TotalIndex, E_UI_STATUS_PAGE_TYPE PageType) const;
	const struct FUIStatusDataUpParam GetUpParam() const;
	bool IsAlreadySpawnedMode() const;
	bool IsCursorIndex(E_UI_STATUS_PAGE_TYPE PageType, int32 Offset, int32 Param_Index) const;
	bool IsDevilUnknown(const int32 RelativePosition) const;
	bool IsDyingMotion() const;
	bool IsEmptyStatusData() const;
	bool IsExistFocusanbeSlot_Right(const int32 betA, const int32 betB, const E_UI_STATUS_PAGE_TYPE PageType) const;
	bool IsFocusableSlot_Right(int32 TotalIndex, E_UI_STATUS_PAGE_TYPE PageType) const;
	bool IsParentCursorIndex(int32 Offset, int32 Param_Index) const;
	bool IsSelectableSrc_ForCtrl(int32 TotalIndex) const;
	bool IsSwitchableKamui_ForCtrl(int32 TotalIndex) const;
	bool IsUtsusemiStatusData() const;
	void MakeSatanMagatsuhiSkillList(const int32 StealSkillId, TArray<int32>* MagaSkills) const;
	float ScrollBarRate_Condition(int32 Offset) const;
	float ScrollBarRate_Parent(int32 Offset) const;
	float ScrollBarRate_Skill(int32 Offset) const;
	bool UseCharaChangeUI() const;
	bool UseFluctuation() const;
	bool UseLevelUpParts() const;
	bool UseLvUpGimmerParts() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusCtrlDataObjBase">();
	}
	static class UUIStatusCtrlDataObjBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatusCtrlDataObjBase>();
	}
};
static_assert(alignof(UUIStatusCtrlDataObjBase) == 0x000008, "Wrong alignment on UUIStatusCtrlDataObjBase");
static_assert(sizeof(UUIStatusCtrlDataObjBase) == 0x0001A8, "Wrong size on UUIStatusCtrlDataObjBase");
static_assert(offsetof(UUIStatusCtrlDataObjBase, M_Current) == 0x000028, "Member 'UUIStatusCtrlDataObjBase::M_Current' has a wrong offset!");
static_assert(offsetof(UUIStatusCtrlDataObjBase, M_CharaRefList) == 0x000030, "Member 'UUIStatusCtrlDataObjBase::M_CharaRefList' has a wrong offset!");

// Class Project.UIStatusCtrlDataObjCampParty
// 0x0060 (0x0208 - 0x01A8)
class UUIStatusCtrlDataObjCampParty final : public UUIStatusCtrlDataObjBase
{
public:
	uint8                                         Pad_164D[0x60];                                    // 0x01A8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentAnalyze(int32 InAnalyzeCursorOffset, int32 InIndex);
	void SetCurrentFromNkmIndex(int32 NkmIndex, bool IsInParty);
	void SetCurrentUtsusemi(int32 InUtsusemiCursorOffset, int32 InIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusCtrlDataObjCampParty">();
	}
	static class UUIStatusCtrlDataObjCampParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatusCtrlDataObjCampParty>();
	}
};
static_assert(alignof(UUIStatusCtrlDataObjCampParty) == 0x000008, "Wrong alignment on UUIStatusCtrlDataObjCampParty");
static_assert(sizeof(UUIStatusCtrlDataObjCampParty) == 0x000208, "Wrong size on UUIStatusCtrlDataObjCampParty");

// Class Project.BPL_BattleUtilLib
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleUtilLib final : public UBlueprintFunctionLibrary
{
public:
	static void ClearBstCountAll();
	static E_BAD_STATUS GetBadStatus(int32 InBst);
	static int32 GetMagatsuhiGauge();
	static bool IsBossRushChallengeMode();
	static TArray<E_BAD_STATUS> MakeBstArray(int32 InBst);
	static void SetMagatsuhiDevils(struct FBtlDescData& DescData, const int32 UseData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleUtilLib">();
	}
	static class UBPL_BattleUtilLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleUtilLib>();
	}
};
static_assert(alignof(UBPL_BattleUtilLib) == 0x000008, "Wrong alignment on UBPL_BattleUtilLib");
static_assert(sizeof(UBPL_BattleUtilLib) == 0x000028, "Wrong size on UBPL_BattleUtilLib");

// Class Project.BattleMessageTable
// 0x0010 (0x0038 - 0x0028)
class UBattleMessageTable final : public UObject
{
public:
	TArray<class FText>                           M_BstMessage;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	class FText GetBstMessage(E_BAD_STATUS Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleMessageTable">();
	}
	static class UBattleMessageTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleMessageTable>();
	}
};
static_assert(alignof(UBattleMessageTable) == 0x000008, "Wrong alignment on UBattleMessageTable");
static_assert(sizeof(UBattleMessageTable) == 0x000038, "Wrong size on UBattleMessageTable");
static_assert(offsetof(UBattleMessageTable, M_BstMessage) == 0x000028, "Member 'UBattleMessageTable::M_BstMessage' has a wrong offset!");

// Class Project.UISystemInfoBase
// 0x0078 (0x0180 - 0x0108)
class UUISystemInfoBase final : public UWidget
{
public:
	FMulticastInlineDelegateProperty_             OnEventDispather_EndView;                          // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FString                                 M_InfoName;                                        // 0x0118(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FUIAnimationTaskData>           M_AnimTaskArray;                                   // 0x0128(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FUIAnimationTaskData                   M_AnimViewTask;                                    // 0x0138(0x0030)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FUIAnimationTableData>          M_AnimTableDataArray;                              // 0x0168(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UUIAnimtionCtrl*                        M_pAnimCtrl;                                       // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChangeView();
	class FString GetInfoName();
	void StartAnim(E_SYS_INFO_ANIM AnimType);
	void StartViewAnim(E_SYS_INFO_ANIM AnimType, float WaitTime);
	void StopAnim(E_SYS_INFO_ANIM AnimType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISystemInfoBase">();
	}
	static class UUISystemInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISystemInfoBase>();
	}
};
static_assert(alignof(UUISystemInfoBase) == 0x000008, "Wrong alignment on UUISystemInfoBase");
static_assert(sizeof(UUISystemInfoBase) == 0x000180, "Wrong size on UUISystemInfoBase");
static_assert(offsetof(UUISystemInfoBase, OnEventDispather_EndView) == 0x000108, "Member 'UUISystemInfoBase::OnEventDispather_EndView' has a wrong offset!");
static_assert(offsetof(UUISystemInfoBase, M_InfoName) == 0x000118, "Member 'UUISystemInfoBase::M_InfoName' has a wrong offset!");
static_assert(offsetof(UUISystemInfoBase, M_AnimTaskArray) == 0x000128, "Member 'UUISystemInfoBase::M_AnimTaskArray' has a wrong offset!");
static_assert(offsetof(UUISystemInfoBase, M_AnimViewTask) == 0x000138, "Member 'UUISystemInfoBase::M_AnimViewTask' has a wrong offset!");
static_assert(offsetof(UUISystemInfoBase, M_AnimTableDataArray) == 0x000168, "Member 'UUISystemInfoBase::M_AnimTableDataArray' has a wrong offset!");
static_assert(offsetof(UUISystemInfoBase, M_pAnimCtrl) == 0x000178, "Member 'UUISystemInfoBase::M_pAnimCtrl' has a wrong offset!");

// Class Project.BPL_BattleMessageTable
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleMessageTable final : public UBlueprintFunctionLibrary
{
public:
	static void BattleMessageTableClearInst();
	static class UBattleMessageTable* BattleMessageTableCreateInst(class UScriptMessageAsset* PMessage);
	static class UBattleMessageTable* BattleMessageTableGetInst();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleMessageTable">();
	}
	static class UBPL_BattleMessageTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleMessageTable>();
	}
};
static_assert(alignof(UBPL_BattleMessageTable) == 0x000008, "Wrong alignment on UBPL_BattleMessageTable");
static_assert(sizeof(UBPL_BattleMessageTable) == 0x000028, "Wrong size on UBPL_BattleMessageTable");

// Class Project.BPL_BattleParty
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleParty final : public UBlueprintFunctionLibrary
{
public:
	static struct FBtlCommand BattleCommandSetAttack(const struct FBtlParty& Src, int32 TargetIndex);
	static struct FBtlCommand BattleCommandSetSkill(const struct FBtlParty& Src, int32 SkillId, int32 TargetIndex);
	static void BattlePartyAttributeHit(const struct FBtlParty& Src, E_ATTRIBUTE_TYPE Attr, E_BTL_REFLECT_RES_TYPE* Ret, bool* IsBarrierHit);
	static bool BattlePartyCanCounter(const struct FBtlParty& Src, const struct FBtlParty& Dst);
	static int32 BattlePartyGetAidCounter(const struct FBtlParty& Src, int32 Type);
	static int32 BattlePartyGetAidCounterMaxValue(int32 Type);
	static int32 BattlePartyGetAidCounterMinValue(int32 Type);
	static int32 BattlePartyGetSkillCost(const struct FBtlParty& Src, int32 SkillId);
	static TArray<int32> BattlePartyGetSkillList(const struct FBtlParty& Src);
	static int32 BattlePartyGetTekiseiValue(const struct FBtlParty& Src, E_SKILL_TEKISEI_CATEGORY Categ);
	static bool BattlePartyIsHero(struct FBtlParty& Actor);
	static bool BattlePartyIsItemUseableItemList(const struct FBtlParty& Actor, int32 ItemId);
	static struct FBtlParty BattlePartyNkmParamSwitch(const struct FBtlParty& PNkmData, bool IsNahobino);
	static struct FBtlParty BattlePartySetAutoEruptAidCounter(const struct FBtlParty& Src);
	static struct FBtlParty BattlePartySetNowCommand(const struct FBtlParty& Src, const struct FBtlCommand& Cmd);
	static bool BattlePartyStockIsExistDeadAny(const TArray<struct FBtlParty>& PartyArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleParty">();
	}
	static class UBPL_BattleParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleParty>();
	}
};
static_assert(alignof(UBPL_BattleParty) == 0x000008, "Wrong alignment on UBPL_BattleParty");
static_assert(sizeof(UBPL_BattleParty) == 0x000028, "Wrong size on UBPL_BattleParty");

// Class Project.UIStatusCtrlDataObjSimple
// 0x0000 (0x01A8 - 0x01A8)
class UUIStatusCtrlDataObjSimple final : public UUIStatusCtrlDataObjBase
{
public:
	void PrepareStatusData(E_UI_STATUS_SIMPLE_SOURCE Type, int32 DataIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusCtrlDataObjSimple">();
	}
	static class UUIStatusCtrlDataObjSimple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatusCtrlDataObjSimple>();
	}
};
static_assert(alignof(UUIStatusCtrlDataObjSimple) == 0x000008, "Wrong alignment on UUIStatusCtrlDataObjSimple");
static_assert(sizeof(UUIStatusCtrlDataObjSimple) == 0x0001A8, "Wrong size on UUIStatusCtrlDataObjSimple");

// Class Project.BattlePartySystemComponentBase
// 0x0640 (0x06F0 - 0x00B0)
class alignas(0x10) UBattlePartySystemComponentBase : public UBattleActorComponentBase
{
public:
	TArray<struct FBtlParty>                      M_PartyDataArray;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_InFieldPlayerList;                               // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_InFieldEnemyList;                                // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_InFieldPartnerList;                              // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_NowActorPartyIndex;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NowActorPartyIndexCopy;                          // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NowActorID;                                      // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1661[0x4];                                     // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_OrderList;                                       // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_OrderIndex;                                      // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1662[0x4];                                     // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FVector>             M_PlayerSideAveArray;                              // 0x0118(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             M_EnemySideAveArray;                               // 0x0168(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        M_PlayerSideHomeLocationArray;                     // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        M_EnemySideHomeLocationArray;                      // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                M_PlayerSideHomeAveLocation;                       // 0x01D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_EnemySideHomeAveLocation;                        // 0x01E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_GlobalActNum;                                    // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1663[0x4];                                     // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBtlCycle>                      M_CycleArray;                                      // 0x01F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_AveLocationSocketName;                           // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                M_CommandAveLocation;                              // 0x0218(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1664[0x4];                                     // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  M_ChkENTargetAllArray;                             // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrevSkillArray>                M_ChkENPrevSkillArray;                             // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_SaveHP;                                          // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_CNT                                     M_GodSkillUpAidType;                               // 0x024C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BTL_CNT                                     M_GodSkillDownAidType;                             // 0x024D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1665[0x2];                                     // 0x024E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_TalkEntryDevilID;                                // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1666[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMitamaAnalyzeData>             M_MitamaAnalyzeDataList;                           // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAnalyzeData                           M_DummyAnalyzeData;                                // 0x0268(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMagatsuhiDevilParamRate               M_MagatsuhiDevilParamRate;                         // 0x02B8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1667[0x4];                                     // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_MagatsuhiDevilSkillTable;                        // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStealSkillRateTable>           M_StealSkillRateTable;                             // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Const_PartyMax;                                    // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_PlayerStart;                                 // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_PlayerNum;                                   // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_PlayerLoopMax;                               // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_EnemyStart;                                  // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_EnemyNum;                                    // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_EnemyLoopMax;                                // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_PartnerStart;                                // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_PartnerNum;                                  // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_PartnerLoopMax;                              // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_StockStart;                                  // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_StockNum;                                    // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_StockLoopMax;                                // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Const_CycleNum;                                    // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1668[0x3C8];                                   // 0x0328(0x03C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAidCounter(int32 PartyIndex, E_BTL_CNT Type, int32 Point);
	void AddBadStatusRecCounter(int32 PartyIndex, int32 Status);
	void AddBadStatusTurnCounter(int32 PartyIndex);
	void AddBossFlag(int32 PartyIndex, E_BTL_BOSS_FLAG InFlag);
	void AddCureHPValue(int32 PartyIndex, int32 AddValue);
	void AddCureMPValue(int32 PartyIndex, int32 AddValue);
	void AddFlag(int32 PartyIndex, E_BTL_PARTY_STAT InFlag);
	void AddFlag2(int32 PartyIndex, E_BTL_PARTY_STAT2 InFlag);
	void AddFlag2All(E_BTL_PARTY_STAT2 InFlag);
	void AddFlag2SideAll(E_BTL_SIDE Side, E_BTL_PARTY_STAT2 InFlag);
	void AddFlagAll(E_BTL_PARTY_STAT InFlag);
	void AddFlagSideAll(E_BTL_SIDE Side, E_BTL_PARTY_STAT InFlag);
	void AddHPMP(int32 PartyIndex, int32 InValue, bool IsHP, bool IsIgnoreDebugFlag);
	void AddIsInFieldList(E_BTL_SIDE Side, int32 PartyIndex);
	void AddMagatsuhiDevilSkillTable(const struct FMagatsuhiDevilSkillRow& MagatsuhiDevilSkillTableRow);
	void AddOrder(int32 PartyIndex);
	void AddOrderArray(const TArray<int32>& PartyIndexArray);
	void AddPrevTurnInfoMinusDamageNum(const int32& PartyIndex);
	void ApplyBarrierSkillIncludedDefenceAishou(const int32& PartyIndex);
	void ApplyBossFlag(int32 PartyIndex);
	void ApplyCure(int32 PartyIndex, int32 HpCure, int32 MpCure, int32 bst);
	void ApplyDamage(int32 PartyIndex, int32 HpDamage, int32 MpDamage, int32 bst);
	void ApplyRenzokuBattle();
	void ApplySkillAidCounter(int32 PartyIndex, int32 SkillId, int32 SrcPartyIndex);
	void ApplySkillAidCounterCore(int32 PartyIndex, const struct FSkillBaseData& Data, int32 SrcPartyIndex);
	E_KUISHIBARI_LEVEL BstDamageKuishibari(int32 PartyIndex);
	E_ATTRIBUTE_TYPE CalcAishouSuitableTargetSelect(const int32 SrcPartyIndex, const int32 DstPartyIndex, const TArray<E_ATTRIBUTE_TYPE>& AishouArray);
	void CalcMoonAgeTurn();
	bool CheckBadStatus(int32 PartyIndex, E_BAD_STATUS Status);
	E_BAD_STATUS CheckBadStatusActEnd(int32 PartyIndex);
	bool CheckBadStatusAny(int32 PartyIndex);
	int32 CheckBadStatusNaturalyCure(int32 PartyIndex);
	bool CheckBossFlag(int32 PartyIndex, E_BTL_BOSS_FLAG InFlag);
	bool CheckBossFlagMember(E_BTL_SIDE Side, E_BTL_BOSS_FLAG Flag);
	bool CheckEnemyLoseBattleEnd();
	bool CheckFlag(int32 PartyIndex, E_BTL_PARTY_STAT InFlag);
	bool CheckFlag2(int32 PartyIndex, E_BTL_PARTY_STAT2 InFlag);
	void CheckHiddenTarget();
	bool CheckMagatsuhiDevil(const int32& PartyIndex);
	bool CheckMitama(const int32& PartyIndex);
	bool CheckNowMagatsuhiSkill(const int32& PartyIndex);
	bool CheckReqCureBadStatus(int32 PartyIndex, E_BAD_STATUS Status);
	bool CheckUniqueSkillKantuu(const int32& SrcIndex, const int32& DstIndex, bool IsKantuu, bool IsForceNormalAttack);
	E_KUISHIBARI_LEVEL CheckUseKuiSkill(int32 PartyIndex);
	bool CheckUseMagatsuhiSkill(const int32& PartyIndex, const int32& SkillId);
	bool ChkENTargetAllArray(int32 Turn);
	bool ChkUseSkill(int32 Turn, int32 SkillId);
	void ClampHP(int32 PartyIndex, bool battleAfter);
	void ClearActionParamAll();
	void ClearAid(int32 PartyIndex, bool Is_magatsuhi_skill);
	void ClearAidCounter(int32 PartyIndex, E_BTL_CNT Type);
	void ClearBarrierAidCounter(int32 PartyIndex, const bool IsKarnClear);
	void ClearBstCount(int32 PartyIndex);
	void ClearBstCountAll();
	void ClearCharData(const int32& PartyIndex);
	void ClearCharmSkillID(const int32& PartyIndex);
	void ClearCounter(const int32& PartyIndex);
	void ClearEnemyPartyDataAll();
	void ClearIsInFieldList(E_BTL_SIDE Side);
	void ClearMagatsuhiSkillCounter(const int32& PartyIndex);
	void ClearMitamaAnalyzeData(const int32& PartyIndex);
	void ClearMitamaAnalyzeDataAll();
	void ClearNowCommand(int32 PartyIndex);
	void ClearParty(int32 TargetIndex);
	void ClearPartyData(const int32& PartyIndex);
	void ClearPrevTurnInfo(const int32& PartyIndex);
	void ClearRenzokuSkillParam();
	void ClearReqCureBadStatus(int32 PartyIndex);
	void ClearSavedUserHP();
	void ClearSlipDamage(int32 PartyIndex);
	void ConditionMapUpdate(int32 PartyIndex);
	int32 ConstPartyMax();
	int32 ConstStockNum();
	int32 ConstStockStart();
	void ControlParameterBattleEndByStock();
	void CopyMitamaAnalyzeData(const int32& PartyIndex, const struct FAnalyzeData& AnalyzeData);
	void CureHPMPAutoSkill(int32 PartyIndex);
	void DebugSetAishou(int32 PartyIndex, E_ATTRIBUTE_TYPE Attr, int32 InValue);
	void DebugSetAutoSkill(int32 PartyIndex, int32 Slot, int32 SkillId);
	void DebugSetLevel(int32 PartyIndex, int32 Level);
	void DebugSetParamter(int32 PartyIndex, E_ABILITY_TYPE Type, int32 Value);
	void DebugSetSkill(int32 PartyIndex, int32 Slot, int32 SkillId);
	void DebugSetTekisei(int32 PartyIndex, E_SKILL_TEKISEI_CATEGORY Tekisei, int32 InValue);
	void DebugSetUniqueLevel(int32 PartyIndex, int32 SkillId);
	void DelBadStatusTurnCounter(int32 PartyIndex);
	void DelBossFlag(int32 PartyIndex, E_BTL_BOSS_FLAG InFlag);
	void DelBossFlagPartyList(const TArray<E_BTL_BOSS_FLAG>& FlagArray);
	void DelFlag(int32 PartyIndex, E_BTL_PARTY_STAT InFlag);
	void DelFlag2(int32 PartyIndex, E_BTL_PARTY_STAT2 InFlag);
	void DelFlag2All(E_BTL_PARTY_STAT2 InFlag);
	void DelFlag2SideAll(E_BTL_SIDE Side, E_BTL_PARTY_STAT2 InFlag);
	void DelFlagAll(E_BTL_PARTY_STAT InFlag);
	void DelFlagSideAll(E_BTL_SIDE Side, E_BTL_PARTY_STAT InFlag);
	void DelIsInFieldList(E_BTL_SIDE Side, int32 PartyIndex);
	void DownRecovery(const int32& PartyIndex);
	void EscapeFailedForPlayer();
	void ExecuteActEnd(int32 PartyIndex);
	void ExpendActionCycle(int32 PartyIndex);
	void GetActCharmSkill(int32 PartyIndex, int32* Repair, TArray<uint8>* RepairIndex, int32* Aid, TArray<uint8>* AidIndex);
	E_BAD_STATUS GetActEndByBadStatus(int32 PartyIndex);
	TArray<int32> GetActList();
	int32 GetActPassNum(int32 PartyIndex);
	int32 GetAidCounter(int32 PartyIndex, E_BTL_CNT Type);
	TArray<int32> GetAllIsInFieldList();
	TArray<struct FBtlParty> GetAllIsInFieldPartyData(bool IsTargetOnly);
	TArray<int32> GetAllIsLogicList();
	TArray<int32> GetAllIsTargetList();
	TArray<class AActor*> GetAllOfBattleUnitList();
	float GetAutoSkillExtraEffectRate(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT Value, bool Is_large);
	int32 GetAutoSkillExtraEffectValue(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT Value, bool Is_large);
	TArray<int32> GetAutoSkillIncludedDefenceAishou(const int32& PartyIndex);
	int32 GetBadStatus(int32 PartyIndex);
	int32 GetBadStatusCounter(int32 PartyIndex, E_BAD_STATUS Status);
	int32 GetBadStatusDamage(int32 PartyIndex, E_BAD_STATUS Status);
	int32 GetBadStatusMPDamage(int32 PartyIndex, E_BAD_STATUS Status);
	TArray<int32> GetBarrierSkillIncludedDefenceAishou(const int32& PartyIndex);
	int32 GetBattleEnemyNumber();
	int32 GetBattleEnemyPartyIndexByIndex(int32 InIndex);
	int32 GetBattlePartyIndexByNkmIndex(int32 InNkmIndex, int32 InPlayerIndex, int32 InType);
	struct FAnalyzeData GetBossRushChallengeModeAnalyzeData(const int32& PartyIndex);
	struct FBtlCharData GetBtlCharaData(int32 PartyIndex);
	struct FBtlParty GetBtlPartyData(int32 PartyIndex);
	TArray<int32> GetCanActList();
	int32 GetCharaID(int32 PartyIndex);
	E_BTL_CHAR_TYPE GetCharaTypeDetail(int32 PartyIndex);
	const int32 GetCharmSkillID(const int32& PartyIndex);
	TArray<E_BTL_CNT> GetConditonMapList(int32 PartyIndex);
	int32 GetCounterSkill(int32 PartyIndex, bool Param_IsElectrification, bool IsUniqueSkillCounter, bool IsAvoidCounter);
	int32 GetCureHPValue(int32 PartyIndex);
	int32 GetCureMPValue(int32 PartyIndex);
	int32 GetEnableFirstPartyIndex();
	int32 GetEnemyPartyIndexWithDevilID(int32 DevilID);
	int32 GetEnemyPartyIndexWithDevilIDOrRootID(int32 DevilID);
	int32 GetEnemyUpliftingPartyIndex();
	int32 GetGlobalActNum();
	E_BTL_CNT GetGodSkillDownAidType();
	E_BTL_CNT GetGodSkillUpAidType();
	struct FBtlParty GetHeroData();
	int32 GetHeroIndex();
	float GetHitOffset(int32 PartyIndex);
	struct FVector GetHomeTargetLocation(int32 PartyIndex);
	struct FTransform GetHomeTransform(int32 PartyIndex);
	float GetHPRatio(int32 PartyIndex);
	int32 GetHPUpValue(int32 PartyIndex);
	int32 GetHPUpValueUI(int32 PartyIndex);
	E_BTL_SIDE GetIndexSide(int32 PartyIndex);
	E_KUISHIBARI_LEVEL GetKuiLevel(int32 PartyIndex);
	const int32 GetKuishibariCureHP(int32 PartyIndex, E_KUISHIBARI_LEVEL Level);
	int32 GetLevel(int32 PartyIndex);
	struct FAnalyzeData GetMagatsuhiDevilAnalyzeData(const int32& PartyIndex);
	const TArray<int32> GetMagatsuhiDevilDropItemID(const int32& PartyIndex);
	const TArray<int32> GetMagatsuhiDevilMagatsuhiSkill(const int32& PartyIndex);
	TArray<int32> GetMagatsuhiSkill(const int32& PartyIndex, const bool CheckMultiSkill);
	int32 GetMaxHP(int32 PartyIndex);
	int32 GetMaxMP(int32 PartyIndex);
	struct FAnalyzeData GetMitamaAnalyzeData(const int32& PartyIndex);
	float GetMPRatio(int32 PartyIndex);
	int32 GetNowActNum(int32 PartyIndex);
	struct FBtlCommand GetNowCommand(int32 PartyIndex);
	int32 GetNowHP(int32 PartyIndex);
	int32 GetNowMP(int32 PartyIndex);
	TArray<int32> GetOrderList();
	TArray<int32> GetPartnerList();
	int32 GetPartyBlankIndex(E_BTL_CHAR_TYPE Type, bool IsStock, bool IsReader);
	class FText GetPartyName(const int32& PartyIndex);
	int32 GetPlayerOrder(int32 PlayerIndex);
	struct FBtlCommand GetPrevCommand(int32 PartyIndex, int32 CommandIndex);
	TArray<struct FBtlCommand> GetPrevCommandTurn(int32 PartyIndex, int32 Turn);
	float GetPrevHPRatio(const int32& PartyIndex);
	const struct FBtlPrevTurnInfo GetPrevTurnInfo(const int32& PartyIndex, const int32 TurnIndex);
	int32 GetReqCureBadStatus(int32 PartyIndex);
	int32 GetSavedUserHP();
	E_BTL_SIDE GetSide(int32 PartyIndex);
	TArray<int32> GetSideActList_ToDie(E_BTL_SIDE Side);
	E_BTL_SIDE GetSideFromIndex(int32 PartyIndex);
	TArray<int32> GetSideIsBossFlagList(E_BTL_SIDE Side, E_BTL_BOSS_FLAG Flag);
	TArray<int32> GetSideIsInFieldList(E_BTL_SIDE Side);
	TArray<struct FBtlParty> GetSideIsInFieldPartyData(E_BTL_SIDE Side);
	TArray<int32> GetSideIsStat2List(E_BTL_SIDE Side, E_BTL_PARTY_STAT2 Stat);
	TArray<int32> GetSideIsStatList(E_BTL_SIDE Side, E_BTL_PARTY_STAT Stat);
	TArray<int32> GetSideIsTargetList(E_BTL_SIDE Side);
	TArray<int32> GetSideListCondition(E_BTL_SIDE Side, bool Param_IsInField, bool IsHitTarget, bool IsDmgChara);
	TArray<int32> GetSideListDevilIDList(E_BTL_SIDE Side);
	int32 GetSkillCost(int32 PartyIndex, int32 SkillId);
	int32 GetSkillCostCore(int32 PartyIndex, int32 SkillId);
	const int32 GetSkillTekisei(const int32& PartyIndex, const int32& SkillId);
	TArray<int32> GetSlipDamage(int32 PartyIndex);
	const int32 GetStartPartyIndexWhenPlayerTargetSelect(const int32& ActorPartyIndex, const int32& SkillId, const int32& ItemId);
	const int32 GetStealMagatsuhiSkill(const int32& PartyIndex);
	int32 GetTekiseiValue(int32 PartyIndex, E_SKILL_TEKISEI_CATEGORY Categ);
	class AActor* GetUnit(int32 PartyIndex);
	struct FVector GetUnitAveLocation(E_BTL_SIDE Side, class FName SocketName);
	TArray<int32> GetVirtualActOrder(int32 PartyIndex);
	bool HeroIsNahobino();
	bool IsBossRushChallengeModeEnemy(const int32& PartyIndex);
	bool IsCurrentCommandUseGodSkillSummon();
	bool IsDead(int32 PartyIndex);
	bool IsDown(int32 PartyIndex);
	bool IsElectrification(int32 PartyIndex);
	bool IsExist(int32 PartyIndex);
	bool IsExistInParty(int32 CharaID);
	bool IsGuest(const int32 PartyIndex);
	bool IsHaveAutoSkillExtraEffect(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT Value);
	bool IsHeroIndex(const int32& Party_index);
	bool IsInField(int32 PartyIndex);
	bool IsPhisicsTaisei(const int32& PartyIndex, const E_ATTRIBUTE_TYPE& Attr);
	bool IsUplifting(int32 PartyIndex);
	bool IsValidIndex(int32 PartyIndex);
	void LoopCycle(int32 AddTime);
	void MakeUpBattlePartyEnemy(int32 EnemyID, int32 PartyIndex);
	void MakeUpBattlePartyNkm(int32 DevilID, int32 PartyIndex);
	void MakeUpBattlePartyPlayer(E_PLAYER_TYPE Type, int32 PartyIndex);
	void MakeUpCycle(E_BTL_CYCLE_TYPE CycleType);
	void MakeUpEnemySideBattlePartyData(const struct FBtlEncData& Data);
	void MakeUpPlayerSideBattlePartyData();
	void MaxSkillTekisei(const int32& PartyIndex);
	bool ModeChange(const int32 PartyIndex, const int32 AfterDevilID);
	int32 NkmStockIn(int32 PartyIndex);
	int32 OnBattleNkmNum();
	void OpenAnalyze(const struct FBtlParty& Party);
	void OverwriteBadStatus(int32 PartyIndex, int32 Status);
	bool OverwriteCharge(int32 PartyIndex, E_BTL_CNT Aid_type);
	void Replace(int32 PartyIndexA, int32 PartyIndexB, E_SUMMON_TYPE Type);
	void ReqCureBadStatus(int32 PartyIndex);
	void ReqCureBadStatusSide();
	void ResetSkillTekisei(const int32& PartyIndex);
	void ReturnEnemy();
	void SaveNowHP(const int32& PartyIndex);
	void SaveNowHPAll();
	void SaveUserHP(int32 PartyIndex);
	void SetActEndByBadStatus(int32 PartyIndex, bool IsActEnd, E_BAD_STATUS Status);
	void SetAidCounter(int32 PartyIndex, E_BTL_CNT Type, int32 Point);
	void SetAidCounterByGodParamterAid(int32 PartyIndex, E_BTL_CNT Type, int32 Point);
	void SetAidCounterMin(int32 PartyIndex, E_BTL_CNT Type);
	void SetBadStatus(int32 PartyIndex, int32 Status, bool Sw);
	void SetBadStatusOne(int32 PartyIndex, E_BAD_STATUS Status, bool Sw);
	void SetBAtkExtendValue(int32 PartyIndex, float Value);
	void SetCharmSkillID(const int32& PartyIndex, const int32& SkillId);
	void SetChkENTargetAllArray(bool IsUse);
	void SetCounterAutoSkill(int32 PartyIndex, int32 SkillId);
	void SetCounterSkill(int32 PartyIndex, int32 SkillId);
	void SetCureHPValue(int32 PartyIndex, int32 HPValue);
	void SetCureMPValue(int32 PartyIndex, int32 MPValue);
	void SetDeadParam(int32 PartyIndex);
	void SetDown(int32 PartyIndex, bool Down);
	void SetElectrification(int32 PartyIndex, bool Electrification);
	void SetEnemyBattleIn(int32 TargetIndex, int32 DevilID);
	void SetHitOffset(int32 PartyIndex, float Offset);
	void SetHomeTransform(int32 PartyIndex, const struct FTransform& Transform);
	void SetHPMP(int32 PartyIndex, int32 InValue, bool IsHP);
	void SetHPUpValue(int32 PartyIndex, int32 HpUpValue);
	void SetHPUpValueUI(int32 PartyIndex, int32 HpUpValue);
	void SetKuiLevel(int32 PartyIndex, E_KUISHIBARI_LEVEL Level);
	void SetKuiStop(int32 PartyIndex);
	void SetMagatsuhiDevilParamRate(const struct FMagatsuhiDevilParamRateRow& MagatsuhiDevilParamRateRow);
	void SetMagatsuhiDevilParamRateTable(class UDataTable* DataTable);
	void SetMagatsuhiDevilSkillTable(class UDataTable* DataTable);
	void SetMitamaAnalyzeData(const int32& PartyIndex);
	void SetNewPartyIn(int32 OldPartyIndex, int32* RetValue, int32* DevilID, int32* NewEntryIndex);
	void SetNextOrder();
	void SetNowCommand(int32 PartyIndex, const struct FBtlCommand& Data);
	void SetNowCommandSetAttack(int32 PartyIndex, int32 Target);
	void SetNowCommandSetSkill(int32 PartyIndex, int32 SkillId, int32 Target);
	void SetNowCommandTarget(int32 PartyIndex, int32 Target);
	void SetNowCommandVarious(E_BTL_COMM_TYPE Comm_type, int32 PartyIndex, int32 N1, int32 N2);
	void SetOrder();
	void SetPoisonDamageRate(int32 PartyIndex, float Rate);
	void SetPrevCommand(int32 PartyIndex);
	void SetPrevTurnInfoAbsAttr(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void SetPrevTurnInfoAttrDamaged(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void SetPrevTurnInfoBlockAttr(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void SetPrevTurnInfoRefAttr(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void SetPrevTurnInfoWeakDamaged(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void SetReqCureBadStatus(int32 PartyIndex, int32 Status);
	void SetStealSkillTable(class UDataTable* DataTable);
	void SetUniqueSkillParty(const int32& PartyIndex);
	void SetUnit(int32 PartyIndex, class AActor* PActor);
	void SetUplifting(int32 PartyIndex, bool Uplifting);
	void SetUseSkill(int32 SkillId);
	void SharedBossHPRate();
	void SharedBossHPRatePartyIndex(const int32& PartyIndex);
	void SortOrder(int32 Start);
	void TakeOverDefenceAishou();
	void UniqueSkill_ChangeTest(const int32& SrcIndex, const int32& DstIndex);
	void UniqueSkill_SkillTekisei();
	void UpdateActionAfter(int32 PartyIndex);
	void UpdateAid(int32 PartyIndex);
	void UpdateAidCycle();
	void UpdateBarrier(int32 PartyIndex);
	bool UpdateBossAishou();
	bool UpdateBossAishouTurnStart();
	bool UpdateBossShareOpenAishou();
	void UpdateChkENTargetAllArray();
	void UpdateIsInFieldList(E_BTL_SIDE Side);
	void UpdateOrder();
	void UpdateSlipCycle();
	void UpdateUnitAveLocation();
	void UpdateUseSkillArray();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePartySystemComponentBase">();
	}
	static class UBattlePartySystemComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePartySystemComponentBase>();
	}
};
static_assert(alignof(UBattlePartySystemComponentBase) == 0x000010, "Wrong alignment on UBattlePartySystemComponentBase");
static_assert(sizeof(UBattlePartySystemComponentBase) == 0x0006F0, "Wrong size on UBattlePartySystemComponentBase");
static_assert(offsetof(UBattlePartySystemComponentBase, M_PartyDataArray) == 0x0000B0, "Member 'UBattlePartySystemComponentBase::M_PartyDataArray' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_InFieldPlayerList) == 0x0000C0, "Member 'UBattlePartySystemComponentBase::M_InFieldPlayerList' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_InFieldEnemyList) == 0x0000D0, "Member 'UBattlePartySystemComponentBase::M_InFieldEnemyList' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_InFieldPartnerList) == 0x0000E0, "Member 'UBattlePartySystemComponentBase::M_InFieldPartnerList' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_NowActorPartyIndex) == 0x0000F0, "Member 'UBattlePartySystemComponentBase::M_NowActorPartyIndex' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_NowActorPartyIndexCopy) == 0x0000F4, "Member 'UBattlePartySystemComponentBase::M_NowActorPartyIndexCopy' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_NowActorID) == 0x0000F8, "Member 'UBattlePartySystemComponentBase::M_NowActorID' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_OrderList) == 0x000100, "Member 'UBattlePartySystemComponentBase::M_OrderList' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_OrderIndex) == 0x000110, "Member 'UBattlePartySystemComponentBase::M_OrderIndex' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_PlayerSideAveArray) == 0x000118, "Member 'UBattlePartySystemComponentBase::M_PlayerSideAveArray' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_EnemySideAveArray) == 0x000168, "Member 'UBattlePartySystemComponentBase::M_EnemySideAveArray' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_PlayerSideHomeLocationArray) == 0x0001B8, "Member 'UBattlePartySystemComponentBase::M_PlayerSideHomeLocationArray' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_EnemySideHomeLocationArray) == 0x0001C8, "Member 'UBattlePartySystemComponentBase::M_EnemySideHomeLocationArray' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_PlayerSideHomeAveLocation) == 0x0001D8, "Member 'UBattlePartySystemComponentBase::M_PlayerSideHomeAveLocation' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_EnemySideHomeAveLocation) == 0x0001E4, "Member 'UBattlePartySystemComponentBase::M_EnemySideHomeAveLocation' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_GlobalActNum) == 0x0001F0, "Member 'UBattlePartySystemComponentBase::M_GlobalActNum' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_CycleArray) == 0x0001F8, "Member 'UBattlePartySystemComponentBase::M_CycleArray' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_AveLocationSocketName) == 0x000208, "Member 'UBattlePartySystemComponentBase::M_AveLocationSocketName' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_CommandAveLocation) == 0x000218, "Member 'UBattlePartySystemComponentBase::M_CommandAveLocation' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_ChkENTargetAllArray) == 0x000228, "Member 'UBattlePartySystemComponentBase::M_ChkENTargetAllArray' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_ChkENPrevSkillArray) == 0x000238, "Member 'UBattlePartySystemComponentBase::M_ChkENPrevSkillArray' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_SaveHP) == 0x000248, "Member 'UBattlePartySystemComponentBase::M_SaveHP' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_GodSkillUpAidType) == 0x00024C, "Member 'UBattlePartySystemComponentBase::M_GodSkillUpAidType' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_GodSkillDownAidType) == 0x00024D, "Member 'UBattlePartySystemComponentBase::M_GodSkillDownAidType' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_TalkEntryDevilID) == 0x000250, "Member 'UBattlePartySystemComponentBase::M_TalkEntryDevilID' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_MitamaAnalyzeDataList) == 0x000258, "Member 'UBattlePartySystemComponentBase::M_MitamaAnalyzeDataList' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_DummyAnalyzeData) == 0x000268, "Member 'UBattlePartySystemComponentBase::M_DummyAnalyzeData' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_MagatsuhiDevilParamRate) == 0x0002B8, "Member 'UBattlePartySystemComponentBase::M_MagatsuhiDevilParamRate' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_MagatsuhiDevilSkillTable) == 0x0002D0, "Member 'UBattlePartySystemComponentBase::M_MagatsuhiDevilSkillTable' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, M_StealSkillRateTable) == 0x0002E0, "Member 'UBattlePartySystemComponentBase::M_StealSkillRateTable' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_PartyMax) == 0x0002F0, "Member 'UBattlePartySystemComponentBase::Const_PartyMax' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_PlayerStart) == 0x0002F4, "Member 'UBattlePartySystemComponentBase::Const_PlayerStart' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_PlayerNum) == 0x0002F8, "Member 'UBattlePartySystemComponentBase::Const_PlayerNum' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_PlayerLoopMax) == 0x0002FC, "Member 'UBattlePartySystemComponentBase::Const_PlayerLoopMax' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_EnemyStart) == 0x000300, "Member 'UBattlePartySystemComponentBase::Const_EnemyStart' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_EnemyNum) == 0x000304, "Member 'UBattlePartySystemComponentBase::Const_EnemyNum' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_EnemyLoopMax) == 0x000308, "Member 'UBattlePartySystemComponentBase::Const_EnemyLoopMax' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_PartnerStart) == 0x00030C, "Member 'UBattlePartySystemComponentBase::Const_PartnerStart' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_PartnerNum) == 0x000310, "Member 'UBattlePartySystemComponentBase::Const_PartnerNum' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_PartnerLoopMax) == 0x000314, "Member 'UBattlePartySystemComponentBase::Const_PartnerLoopMax' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_StockStart) == 0x000318, "Member 'UBattlePartySystemComponentBase::Const_StockStart' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_StockNum) == 0x00031C, "Member 'UBattlePartySystemComponentBase::Const_StockNum' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_StockLoopMax) == 0x000320, "Member 'UBattlePartySystemComponentBase::Const_StockLoopMax' has a wrong offset!");
static_assert(offsetof(UBattlePartySystemComponentBase, Const_CycleNum) == 0x000324, "Member 'UBattlePartySystemComponentBase::Const_CycleNum' has a wrong offset!");

// Class Project.BPL_BattlePlaceInFileldLib
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattlePlaceInFileldLib final : public UBlueprintFunctionLibrary
{
public:
	static void BattleNewPlaceInField(E_BTL_FIELD_TYPE Type, const TArray<struct FBattleUnitPlaceOne>& UnitArray, bool* PFinished, bool* PSuccess, TArray<int32>* PResult);
	static void BattleNewPlaceInFieldFree(int32 FieldGrid_X, int32 FieldGrid_Y, const TArray<struct FBattleUnitPlaceOne>& UnitArray, bool* PFinished, bool* PSuccess, TArray<int32>* PResult, bool IsReplace);
	static void BattlePlaceInFieldGetInfo(const struct FBattleUnitPlaceOne& Place, int32* Vertical, int32* Horizontal, int32* Tall);
	static int32 BattlePlaceInFieldGetPostIndex(int32 FieldGrid_X, int32 FieldGrid_Y, const struct FBattleUnitPlaceOne& Place, int32 PostIndex, TArray<int32>* PResult);
	static bool BattlePlaceInFieldSetPost(int32 FieldGrid_X, int32 FieldGrid_Y, const struct FBattleUnitPlaceOne& Place, int32 PostIndex, TArray<int32>* PResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattlePlaceInFileldLib">();
	}
	static class UBPL_BattlePlaceInFileldLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattlePlaceInFileldLib>();
	}
};
static_assert(alignof(UBPL_BattlePlaceInFileldLib) == 0x000008, "Wrong alignment on UBPL_BattlePlaceInFileldLib");
static_assert(sizeof(UBPL_BattlePlaceInFileldLib) == 0x000028, "Wrong size on UBPL_BattlePlaceInFileldLib");

// Class Project.SphereVolumeComponent
// 0x0010 (0x0460 - 0x0450)
class USphereVolumeComponent final : public UPrimitiveComponent
{
public:
	float                                         SphereInnerRadius;                                 // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereOuterRadius;                                 // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E7[0x8];                                     // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetPenetrationRate(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SphereVolumeComponent">();
	}
	static class USphereVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USphereVolumeComponent>();
	}
};
static_assert(alignof(USphereVolumeComponent) == 0x000010, "Wrong alignment on USphereVolumeComponent");
static_assert(sizeof(USphereVolumeComponent) == 0x000460, "Wrong size on USphereVolumeComponent");
static_assert(offsetof(USphereVolumeComponent, SphereInnerRadius) == 0x000450, "Member 'USphereVolumeComponent::SphereInnerRadius' has a wrong offset!");
static_assert(offsetof(USphereVolumeComponent, SphereOuterRadius) == 0x000454, "Member 'USphereVolumeComponent::SphereOuterRadius' has a wrong offset!");

// Class Project.BattlePlaceInFieldComponent
// 0x0040 (0x00F0 - 0x00B0)
class UBattlePlaceInFieldComponent : public UBattleActorComponentBase
{
public:
	FMulticastInlineDelegateProperty_             OnEventDispather;                                  // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReplaceFinished;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_IsSuccess;                                       // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsFinished;                                      // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E8[0x6];                                     // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_Result;                                          // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_IsReplace;                                       // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E9[0x7];                                     // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MakeNewPlaceWork(E_BTL_FIELD_TYPE Type, const TArray<struct FBattleUnitPlaceOne>& UnitArray);
	void MakeNewPlaceWorkFree(int32 RimitX, int32 RimitY, const TArray<struct FBattleUnitPlaceOne>& UnitArray);
	void MakeRePlaceWorkFree(int32 RimitX, int32 RimitY, const TArray<struct FBattleUnitPlaceOne>& UnitArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePlaceInFieldComponent">();
	}
	static class UBattlePlaceInFieldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePlaceInFieldComponent>();
	}
};
static_assert(alignof(UBattlePlaceInFieldComponent) == 0x000008, "Wrong alignment on UBattlePlaceInFieldComponent");
static_assert(sizeof(UBattlePlaceInFieldComponent) == 0x0000F0, "Wrong size on UBattlePlaceInFieldComponent");
static_assert(offsetof(UBattlePlaceInFieldComponent, OnEventDispather) == 0x0000B0, "Member 'UBattlePlaceInFieldComponent::OnEventDispather' has a wrong offset!");
static_assert(offsetof(UBattlePlaceInFieldComponent, OnReplaceFinished) == 0x0000C0, "Member 'UBattlePlaceInFieldComponent::OnReplaceFinished' has a wrong offset!");
static_assert(offsetof(UBattlePlaceInFieldComponent, M_IsSuccess) == 0x0000D0, "Member 'UBattlePlaceInFieldComponent::M_IsSuccess' has a wrong offset!");
static_assert(offsetof(UBattlePlaceInFieldComponent, M_IsFinished) == 0x0000D1, "Member 'UBattlePlaceInFieldComponent::M_IsFinished' has a wrong offset!");
static_assert(offsetof(UBattlePlaceInFieldComponent, M_Result) == 0x0000D8, "Member 'UBattlePlaceInFieldComponent::M_Result' has a wrong offset!");
static_assert(offsetof(UBattlePlaceInFieldComponent, M_IsReplace) == 0x0000E8, "Member 'UBattlePlaceInFieldComponent::M_IsReplace' has a wrong offset!");

// Class Project.BattleFieldWorkBase
// 0x0000 (0x0220 - 0x0220)
class ABattleFieldWorkBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleFieldWorkBase">();
	}
	static class ABattleFieldWorkBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleFieldWorkBase>();
	}
};
static_assert(alignof(ABattleFieldWorkBase) == 0x000008, "Wrong alignment on ABattleFieldWorkBase");
static_assert(sizeof(ABattleFieldWorkBase) == 0x000220, "Wrong size on ABattleFieldWorkBase");

// Class Project.BattlePostProcessVolume
// 0x0000 (0x07D0 - 0x07D0)
class ABattlePostProcessVolume final : public APostProcessVolume
{
public:
	static float GetCurrentActiveExposureCompensation(const TArray<class APostProcessVolume*>& PostProcessVolumes, const struct FVector& ViewLocation);

	void GetExposureCompensation(bool* OutIsOverride, float* OutExposureCompensation);
	void RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject);
	void SetExposureCompensation(bool IsOverride, float ExposureCompensation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePostProcessVolume">();
	}
	static class ABattlePostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattlePostProcessVolume>();
	}
};
static_assert(alignof(ABattlePostProcessVolume) == 0x000010, "Wrong alignment on ABattlePostProcessVolume");
static_assert(sizeof(ABattlePostProcessVolume) == 0x0007D0, "Wrong size on ABattlePostProcessVolume");

// Class Project.BattleResultActorComponentBase
// 0x0078 (0x0128 - 0x00B0)
class UBattleResultActorComponentBase : public UActorComponent
{
public:
	struct FResultData                            M_NewReslutData;                                   // 0x00B0(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         M_EXPRate;                                         // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_MakkaRate;                                       // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16ED[0x8];                                     // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BattleDataApllyPartyData(TArray<struct FBtlParty>& PartyArray);
	void BattleDataApllyPartyOne(struct FBtlParty* Src);
	const struct FBtlResultData ClearResultData(struct FBtlResultData* Src);
	void SetExpRate(int32 Rate);
	void SetMakkaRate(int32 Rate);
	bool SetPlayerPartyIndex(TArray<struct FBtlParty>& PartyArray, TArray<int32>& Panelorder);
	void SetResultData(const struct FBtlResultData& OldResultData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleResultActorComponentBase">();
	}
	static class UBattleResultActorComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleResultActorComponentBase>();
	}
};
static_assert(alignof(UBattleResultActorComponentBase) == 0x000008, "Wrong alignment on UBattleResultActorComponentBase");
static_assert(sizeof(UBattleResultActorComponentBase) == 0x000128, "Wrong size on UBattleResultActorComponentBase");
static_assert(offsetof(UBattleResultActorComponentBase, M_NewReslutData) == 0x0000B0, "Member 'UBattleResultActorComponentBase::M_NewReslutData' has a wrong offset!");
static_assert(offsetof(UBattleResultActorComponentBase, M_EXPRate) == 0x000118, "Member 'UBattleResultActorComponentBase::M_EXPRate' has a wrong offset!");
static_assert(offsetof(UBattleResultActorComponentBase, M_MakkaRate) == 0x00011C, "Member 'UBattleResultActorComponentBase::M_MakkaRate' has a wrong offset!");

// Class Project.BPL_BattleSkillAction
// 0x0000 (0x0028 - 0x0028)
class UBPL_BattleSkillAction final : public UBlueprintFunctionLibrary
{
public:
	static struct FSkillActionDesc BattleSkillActionDescAddDrainHPMP(const struct FSkillActionDesc& Src, int32 DrainHP, int32 DrainMP);
	static struct FSkillActionDesc BattleSkillActionDescAddExtendAction(const struct FSkillActionDesc& Src, const struct FSkillActionExtend& Extend);
	static struct FSkillActionDesc BattleSkillActionDescAddTargetInfo(const struct FSkillActionDesc& Src, const struct FSkillActionTargetInfo& Data, bool IsReflex);
	static struct FSkillActionDesc BattleSkillActionDescSetActorIndex(const struct FSkillActionDesc& Src, int32 PartyIndex);
	static struct FSkillActionDesc BattleSkillActionDescSetCounterOn(const struct FSkillActionDesc& Src);
	static struct FSkillActionDesc BattleSkillActionDescSetExtraAction(const struct FSkillActionDesc& Src, E_BTL_EXTRA_ACTION Action);
	static struct FSkillActionDesc BattleSkillActionDescSetSkillID(const struct FSkillActionDesc& Src, int32 SkillId, int32 ItemId);
	static void BattleSkillActionGetSkillMasterEffectID(const struct FSkillActionDesc& Src, int32* EffectID, E_SKILL_MASTER_TARGET* Target);
	static bool BattleSkillActionIsSkillMasterExec(const struct FSkillActionDesc& Src);
	static bool BattleSkillActionIsTargetDead(const struct FSkillActionDesc& Src, int32 Param_Index);
	static int32 BattleSkillActionIsTargetNum(const struct FSkillActionDesc& Src);
	static bool BattleSkillActionLoadTable(class UDataTable* DataTable, TMap<class FName, struct FBattleSkillAction_Raw>& OutMap);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoComboOn(const struct FSkillActionTargetInfo& Src);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoGuardOn(const struct FSkillActionTargetInfo& Src);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoResistOn(const struct FSkillActionTargetInfo& Src);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetAid(const struct FSkillActionTargetInfo& Src, E_BTL_SKILL_ACTION_AID Aid);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetBst(const struct FSkillActionTargetInfo& Src, int32 bst);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetCounterOn(const struct FSkillActionTargetInfo& Src);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetCriticalLevel(const struct FSkillActionTargetInfo& Src, int32 Value);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetDeadOff(const struct FSkillActionTargetInfo& Src);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetDeadOn(const struct FSkillActionTargetInfo& Src, E_BTL_DEAD_EFFECT DeadType);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetHit(const struct FSkillActionTargetInfo& Src, E_BTL_REFLECT_RES_TYPE Value, E_BTL_DAMAGE_HIT_TYPE DamageHit, int32 Damage, int32 DamageReal);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetHitFull(const struct FSkillActionTargetInfo& Src, E_BTL_REFLECT_RES_TYPE Value, E_BTL_DAMAGE_HIT_TYPE DamageHit, int32 Damage, int32 DamageReal, int32 Rec, int32 DamageMP, int32 RecMP);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetNahobinoBreakOn(const struct FSkillActionTargetInfo& Src);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetRecBst(const struct FSkillActionTargetInfo& Src, int32 bst);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetRecHP(const struct FSkillActionTargetInfo& Src, int32 RecHP, int32 Param_Index);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetRecMP(const struct FSkillActionTargetInfo& Src, int32 RecMP, int32 Param_Index);
	static struct FSkillActionTargetInfo BattleSkillActionTargetInfoSetTargetIndex(const struct FSkillActionTargetInfo& Src, int32 PartyIndex, int32 FromPartyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BattleSkillAction">();
	}
	static class UBPL_BattleSkillAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BattleSkillAction>();
	}
};
static_assert(alignof(UBPL_BattleSkillAction) == 0x000008, "Wrong alignment on UBPL_BattleSkillAction");
static_assert(sizeof(UBPL_BattleSkillAction) == 0x000028, "Wrong size on UBPL_BattleSkillAction");

// Class Project.S5LoadObject
// 0x47B0 (0x47D8 - 0x0028)
class US5LoadObject final : public USaveGame
{
public:
	uint8                                         Pad_16FF[0x47B0];                                  // 0x0028(0x47B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S5LoadObject">();
	}
	static class US5LoadObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<US5LoadObject>();
	}
};
static_assert(alignof(US5LoadObject) == 0x000008, "Wrong alignment on US5LoadObject");
static_assert(sizeof(US5LoadObject) == 0x0047D8, "Wrong size on US5LoadObject");

// Class Project.BenefitDataReader
// 0x0020 (0x0048 - 0x0028)
class UBenefitDataReader final : public UObject
{
public:
	uint8                                         Pad_1700[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ReadComplete;                                      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BenefitDataRead(class UDlcTableData* PDlcTableData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BenefitDataReader">();
	}
	static class UBenefitDataReader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBenefitDataReader>();
	}
};
static_assert(alignof(UBenefitDataReader) == 0x000008, "Wrong alignment on UBenefitDataReader");
static_assert(sizeof(UBenefitDataReader) == 0x000048, "Wrong size on UBenefitDataReader");
static_assert(offsetof(UBenefitDataReader, ReadComplete) == 0x000038, "Member 'UBenefitDataReader::ReadComplete' has a wrong offset!");

// Class Project.BPL_BenefitData
// 0x0000 (0x0028 - 0x0028)
class UBPL_BenefitData final : public UBlueprintFunctionLibrary
{
public:
	static void ExtractBenefitDevilMsgDataList(const struct FBenefitData& BenefitData, struct FBenefitDevilMsgDataList* DevilDataList);
	static void GetBenefitItemData(class UBenefitDataTable* PTableObj, const E_BENEFIT_ROUTE Route, struct FBenefitItemMsgDataList* RetData);
	static void ObtainBenefits(const struct FBenefitData& BenefitData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BenefitData">();
	}
	static class UBPL_BenefitData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BenefitData>();
	}
};
static_assert(alignof(UBPL_BenefitData) == 0x000008, "Wrong alignment on UBPL_BenefitData");
static_assert(sizeof(UBPL_BenefitData) == 0x000028, "Wrong size on UBPL_BenefitData");

// Class Project.BenefitDataTable
// 0x0010 (0x0038 - 0x0028)
class UBenefitDataTable final : public UObject
{
public:
	uint8                                         Pad_1702[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool MakeUp(class UMMIAsset* PAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BenefitDataTable">();
	}
	static class UBenefitDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBenefitDataTable>();
	}
};
static_assert(alignof(UBenefitDataTable) == 0x000008, "Wrong alignment on UBenefitDataTable");
static_assert(sizeof(UBenefitDataTable) == 0x000038, "Wrong size on UBenefitDataTable");

// Class Project.BPC_EncountAreaManager
// 0x0018 (0x00C8 - 0x00B0)
class UBPC_EncountAreaManager final : public UActorComponent
{
public:
	uint8                                         Pad_1704[0x18];                                    // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckAfterLoaded();
	void ClearEncountAreaActor();
	const TArray<class AActor*> GetEncountAreaActors();
	void RegisterEncountAreaActor(class AActor* Actor);
	void RegisterEncountAreaActors(const TArray<class AActor*>& Actors);
	void SetPause(bool Pause);
	void StartAfterLoadedCounter(float StartTime);
	void UnregisterEncountAreaActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPC_EncountAreaManager">();
	}
	static class UBPC_EncountAreaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPC_EncountAreaManager>();
	}
};
static_assert(alignof(UBPC_EncountAreaManager) == 0x000008, "Wrong alignment on UBPC_EncountAreaManager");
static_assert(sizeof(UBPC_EncountAreaManager) == 0x0000C8, "Wrong size on UBPC_EncountAreaManager");

// Class Project.BPFL_MapMisc
// 0x0000 (0x0028 - 0x0028)
class UBPFL_MapMisc final : public UBlueprintFunctionLibrary
{
public:
	static struct FLinearColor ColorHSVInterp(const struct FLinearColor& ColorA, const struct FLinearColor& ColorB, float Alpha);
	static int32 CreateRandomSeedFromString(const class FString& Str);
	static void PrintFogVerbose(const class FString& InString, bool bVeryVerbose);
	static void SetSecondFogData(class UExponentialHeightFogComponent* Target, float FogDensity, float FogHeightFalloff, float FogHeightOffset);
	static void SetShapeComponentColor(class UShapeComponent* ShapeComponent, const struct FColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPFL_MapMisc">();
	}
	static class UBPFL_MapMisc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPFL_MapMisc>();
	}
};
static_assert(alignof(UBPFL_MapMisc) == 0x000008, "Wrong alignment on UBPFL_MapMisc");
static_assert(sizeof(UBPFL_MapMisc) == 0x000028, "Wrong size on UBPFL_MapMisc");

// Class Project.BPI_CalcInterface
// 0x0000 (0x0028 - 0x0028)
class IBPI_CalcInterface final : public IInterface
{
public:
	int32 BI_BattleRand(int32 Max);
	int32 BI_BattleRand2(int32 Min, int32 Max);
	float BI_BattleRandF(float Max);
	float BI_BattleRandF2(float Min, float Max);
	bool BI_CheckOverwriteFormulaValue(const struct FSkillBaseData& SkillData, E_OVERWRITE_FORMULA Formula);
	int32 BI_GetEscapeRate();
	void BI_GetMagatsuhiDevilFirstDropItemIDandNum(const struct FBtlParty& Party, bool Log, int32* OutItemID, int32* OutItemNum);
	int32 BI_GetOverwriteFormulaValue(const struct FSkillBaseData& SkillData, E_OVERWRITE_FORMULA Formula);
	bool BI_UniqueSkill_Kantuu(const struct FBtlParty& SrcParty, const struct FBtlParty& DstParty, bool IsForceNormalAttack);
	bool BI_UniqueSkill_KantuuNormalAttack(const int32& SrcIndex, const int32& SkillId, const bool& IsSkill);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_CalcInterface">();
	}
	static class IBPI_CalcInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_CalcInterface>();
	}
};
static_assert(alignof(IBPI_CalcInterface) == 0x000008, "Wrong alignment on IBPI_CalcInterface");
static_assert(sizeof(IBPI_CalcInterface) == 0x000028, "Wrong size on IBPI_CalcInterface");

// Class Project.BPI_PTFlagInterface
// 0x0000 (0x0028 - 0x0028)
class IBPI_PTFlagInterface final : public IInterface
{
public:
	void BI_AddBossFlag(int32 PartyIndex, E_BTL_BOSS_FLAG InFlag);
	void BI_AddFlag(int32 PartyIndex, E_BTL_PARTY_STAT InFlag);
	void BI_AddFlag2(int32 PartyIndex, E_BTL_PARTY_STAT2 InFlag);
	void BI_AddFlag2All(E_BTL_PARTY_STAT2 InFlag);
	void BI_AddFlag2SideAll(E_BTL_SIDE Side, E_BTL_PARTY_STAT2 InFlag);
	void BI_AddFlagAll(E_BTL_PARTY_STAT InFlag);
	void BI_AddFlagSideAll(E_BTL_SIDE Side, E_BTL_PARTY_STAT InFlag);
	bool BI_CheckBossFlag(int32 PartyIndex, E_BTL_BOSS_FLAG InFlag);
	bool BI_CheckFlag(int32 PartyIndex, E_BTL_PARTY_STAT InFlag);
	bool BI_CheckFlag2(int32 PartyIndex, E_BTL_PARTY_STAT2 InFlag);
	void BI_DelBossFlag(int32 PartyIndex, E_BTL_BOSS_FLAG InFlag);
	void BI_DelFlag(int32 PartyIndex, E_BTL_PARTY_STAT InFlag);
	void BI_DelFlag2(int32 PartyIndex, E_BTL_PARTY_STAT2 InFlag);
	void BI_DelFlag2All(E_BTL_PARTY_STAT2 InFlag);
	void BI_DelFlag2SideAll(E_BTL_SIDE Side, E_BTL_PARTY_STAT2 InFlag);
	void BI_DelFlagAll(E_BTL_PARTY_STAT InFlag);
	void BI_DelFlagSideAll(E_BTL_SIDE Side, E_BTL_PARTY_STAT InFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_PTFlagInterface">();
	}
	static class IBPI_PTFlagInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_PTFlagInterface>();
	}
};
static_assert(alignof(IBPI_PTFlagInterface) == 0x000008, "Wrong alignment on IBPI_PTFlagInterface");
static_assert(sizeof(IBPI_PTFlagInterface) == 0x000028, "Wrong size on IBPI_PTFlagInterface");

// Class Project.BPI_PTActOrderInterface
// 0x0000 (0x0028 - 0x0028)
class IBPI_PTActOrderInterface final : public IInterface
{
public:
	void BI_AddOrder(int32 PartyIndex);
	void BI_AddOrderArray(const TArray<int32>& PartyIndexArray);
	TArray<int32> BI_GetOrderList();
	void BI_SetNextOrder();
	void BI_UpdateOrder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_PTActOrderInterface">();
	}
	static class IBPI_PTActOrderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_PTActOrderInterface>();
	}
};
static_assert(alignof(IBPI_PTActOrderInterface) == 0x000008, "Wrong alignment on IBPI_PTActOrderInterface");
static_assert(sizeof(IBPI_PTActOrderInterface) == 0x000028, "Wrong size on IBPI_PTActOrderInterface");

// Class Project.BPI_PTMemDataInterface
// 0x0000 (0x0028 - 0x0028)
class IBPI_PTMemDataInterface final : public IInterface
{
public:
	void BI_AddAidCounter(int32 PartyIndex, E_BTL_CNT Type, int32 Point);
	void BI_AddCureHPValue(int32 PartyIndex, int32 AddValue);
	void BI_AddCureMPValue(int32 PartyIndex, int32 AddValue);
	void BI_AddDeadCharID(const E_BTL_SIDE& Side, const int32& PartyIndex);
	void BI_AddHPMP(int32 PartyIndex, int32 InValue, bool IsHP, bool IsIgnoreDebugFlag);
	void BI_AddPrevTurnInfoMinusDamageNum(const int32& PartyIndex);
	E_KUISHIBARI_LEVEL BI_BstDamageKuishibari(int32 PartyIndex);
	bool BI_CheckBossFlagDeadEffect(const int32& DstPartyIndex);
	E_KUISHIBARI_LEVEL BI_CheckUseKuiSkill(int32 PartyIndex);
	bool BI_CheckUseMagatsuhiSkill(const int32& PartyIndex, const int32& SkillId);
	void BI_ClampHP(int32 PartyIndex, bool battleAfter);
	void BI_ClearBarrierAidCounter(int32 PartyIndex);
	void BI_ClearCharmSkillID(const int32& PartyIndex);
	void BI_ClearCounter(const int32& PartyIndex);
	void BI_ClearDeadCharaID();
	void BI_ClearDeadNum();
	void BI_ClearNowCommand(int32 PartyIndex);
	void BI_ConditionMapUpdate(int32 PartyIndex);
	void BI_CureHPMPAutoSkill(int32 PartyIndex);
	int32 BI_GetAidCounter(int32 PartyIndex, E_BTL_CNT Type);
	float BI_GetAutoSkillExtraEffectRate(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT Value, bool Is_large);
	int32 BI_GetAutoSkillExtraEffectValue(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT Value, bool Is_large);
	TArray<int32> BI_GetAutoSkillIncludedDefenceAishou(const int32& PartyIndex);
	struct FBtlCharData BI_GetBtlCharaData(int32 PartyIndex);
	int32 BI_GetCharaID(int32 PartyIndex);
	E_BTL_CHAR_TYPE BI_GetCharaTypeDetail(int32 PartyIndex);
	const int32 BI_GetCharmSkillID(const int32& PartyIndex);
	TArray<E_BTL_CNT> BI_GetCondtionMapList(int32 PartyIndex);
	int32 BI_GetCounterSkill(int32 PartyIndex, bool IsElectrification, bool IsUniqueSkillCounter, bool IsAvoidCounter);
	int32 BI_GetCureHPValue(int32 PartyIndex);
	int32 BI_GetCureMPValue(int32 PartyIndex);
	int32 BI_GetEnemyUpliftingPartyIndex();
	struct FBtlParty BI_GetHeroData();
	int32 BI_GetHeroIndex();
	float BI_GetHitOffset(int32 PartyIndex);
	struct FTransform BI_GetHomeTransform(int32 PartyIndex);
	float BI_GetHPRatio(int32 PartyIndex);
	int32 BI_GetHPUpValue(int32 PartyIndex);
	int32 BI_GetHPUpValueUI(int32 PartyIndex);
	int32 BI_GetKuiDeadStockPartyIndex();
	E_KUISHIBARI_LEVEL BI_GetKuiLevel(int32 PartyIndex);
	const int32 BI_GetKuishibariCureHP(int32 PartyIndex, E_KUISHIBARI_LEVEL Level);
	TArray<int32> BI_GetMagatsuhiSkill(const int32& PartyIndex, const bool CheckMultiSkill);
	int32 BI_GetMaxHP(int32 PartyIndex);
	float BI_GetMPRatio(int32 PartyIndex);
	struct FBtlCommand BI_GetNowCommand(int32 PartyIndex);
	int32 BI_GetNowHP(int32 PartyIndex);
	struct FBtlParty BI_GetPartyData(int32 PartyIndex);
	class FText BI_GetPartyName(const int32& PartyIndex);
	struct FBtlCommand BI_GetPrevCommand(int32 PartyIndex, int32 CommandIndex);
	TArray<struct FBtlCommand> BI_GetPrevCommandTurn(int32 PartyIndex, int32 Turn);
	float BI_GetPrevHPRatio(const int32& PartyIndex);
	const struct FBtlPrevTurnInfo BI_GetPrevTurnInfo(const int32& PartyIndex, const int32 TurnIndex);
	E_BTL_SIDE BI_GetSide(int32 PartyIndex);
	int32 BI_GetSkillCost(int32 PartyIndex, int32 SkillId);
	int32 BI_GetSkillCostCore(int32 PartyIndex, int32 SkillId);
	const int32 BI_GetSkillTekisei(const int32& PartyIndex, const int32& SkillId);
	const int32 BI_GetStartPartyIndexWhenPlayerTargetSelect(const int32& ActorPartyIndex, const int32& SkillId, const int32& ItemId);
	void BI_IncDeadNum(const E_BTL_SIDE& Side);
	bool BI_IsCurrentCommandUseGodSkillSummon();
	bool BI_IsDead(int32 PartyIndex);
	bool BI_IsDown(int32 PartyIndex);
	bool BI_IsElectrification(int32 PartyIndex);
	bool BI_IsExist(int32 PartyIndex);
	bool BI_IsGuest(const int32 PartyIndex);
	bool BI_IsHaveAutoSkillExtraEffect(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT Value);
	bool BI_IsHeroIndex(const int32& Party_index);
	bool BI_IsInField(int32 PartyIndex);
	bool BI_IsUplifting(int32 PartyIndex);
	void BI_MaxSkillTekisei(const int32& PartyIndex);
	bool BI_ModeChange(const int32 PartyIndex, const int32 AfterDevilID);
	void BI_ResetSkillTekisei(const int32& PartyIndex);
	void BI_SaveNowHP(const int32& PartyIndex);
	void BI_SaveNowHPAll();
	void BI_SetAidCounter(int32 PartyIndex, E_BTL_CNT Type, int32 Point);
	void BI_SetAidCounterMin(int32 PartyIndex, E_BTL_CNT Type);
	void BI_SetBossFlagDeadEffectOff(const int32& DstPartyIndex);
	void BI_SetCharmSkillID(const int32& PartyIndex, const int32& SkillId);
	void BI_SetCounterAutoSkill(int32 PartyIndex, int32 SkillId);
	void BI_SetCounterSkill(int32 PartyIndex, int32 SkillId);
	void BI_SetCureHPValue(int32 PartyIndex, int32 HPValue);
	void BI_SetCureMPValue(int32 PartyIndex, int32 MPValue);
	void BI_SetDown(int32 PartyIndex, bool Down);
	void BI_SetElectrification(int32 PartyIndex, bool Electrification);
	void BI_SetHitOffset(int32 PartyIndex, float Offset);
	void BI_SetHomeTransform(int32 PartyIndex, const struct FTransform& Transform);
	void BI_SetHPUpValue(int32 PartyIndex, int32 HpUpValue);
	void BI_SetHPUpValueUI(int32 PartyIndex, int32 HpUpValue);
	void BI_SetKuiLevel(int32 PartyIndex, E_KUISHIBARI_LEVEL Level);
	void BI_SetNowCommand(int32 PartyIndex, const struct FBtlCommand& Data);
	void BI_SetNowCommandSetAttack(int32 PartyIndex, int32 Target);
	void BI_SetNowCommandSetSkill(int32 PartyIndex, int32 SkillId, int32 Target);
	void BI_SetNowCommandVarious(E_BTL_COMM_TYPE Comm_type, int32 PartyIndex, int32 N1, int32 N2);
	void BI_SetPoisonDamageRate(int32 PartyIndex, float Rate);
	void BI_SetPrevCommand(int32 PartyIndex);
	void BI_SetPrevTurnInfoAbsAttr(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void BI_SetPrevTurnInfoAttrDamaged(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void BI_SetPrevTurnInfoBlockAttr(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void BI_SetPrevTurnInfoRefAttr(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void BI_SetPrevTurnInfoWeakDamaged(const int32& PartyIndex, E_ATTRIBUTE_TYPE Attr, bool Sw);
	void BI_SetUniqueSkillParty(const int32& PartyIndex);
	void BI_SetUplifting(int32 PartyIndex, bool Uplifting);
	bool BI_UniqueSkill_CheckChaosRuler(const int32& PartyIndex);
	float BI_UniqueSkill_GetCheatingRate(const E_BTL_SIDE& Side);
	void BI_UniqueSkill_GetCureActionEnd(const int32& PartyIndex, int32 ReserveDeadPartyIndex, bool IsAllAction, bool IsDeadOnly, int32* Out_CureHP, int32* OutCureMP, int32* OutCureBst);
	int32 BI_UniqueSkill_GetCureMPMagatsuhiGaugeMax(const int32& PartyIndex);
	void BI_UniqueSkill_GetCureTurnEnd(const int32& PartyIndex, int32* OutCureHP, int32* OutCureMP, int32* OutCureBst);
	void BI_UniqueSkill_GetCureTurnStart(const int32& PartyIndex, int32* OutCureHP, int32* OutCureMP, int32* OutCureBst);
	void BI_UniqueSkill_SetAddInfo(const int32& SrcIndex, const int32& DstIndex, const E_AUTO_SKILL_EXTRA_EFFECT& SkillExtraEffect);
	void BI_UpdateAbsKuishibari(const int32& PartyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_PTMemDataInterface">();
	}
	static class IBPI_PTMemDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_PTMemDataInterface>();
	}
};
static_assert(alignof(IBPI_PTMemDataInterface) == 0x000008, "Wrong alignment on IBPI_PTMemDataInterface");
static_assert(sizeof(IBPI_PTMemDataInterface) == 0x000028, "Wrong size on IBPI_PTMemDataInterface");

// Class Project.BPI_PTUtilInterface
// 0x0000 (0x0028 - 0x0028)
class IBPI_PTUtilInterface final : public IInterface
{
public:
	void BI_AddUpliftingGauge(E_BTL_SIDE Side, int32 Value);
	void BI_CalcAndApplyPressIcon(E_BTL_PRESS_TYPE Press_type);
	void BI_CalcMoonAgeTurn();
	int32 BI_CalcUpliftingGauge(E_BTL_UPLIFTING_TYPE Type);
	bool BI_CheckEnemyLoseBattleEnd();
	bool BI_CheckHaveSkill(const int32& PartyIndex, const int32& SkillId);
	bool BI_CheckMagatsuhiDevil(const int32& PartyIndex);
	bool BI_CheckMaxUpliftingGauge(E_BTL_SIDE Side);
	bool BI_CheckMitama(const int32& PartyIndex);
	bool BI_ChkENTargetAllArray(int32 Turn);
	bool BI_ChkUseSkill(int32 Turn, int32 SkillId);
	void BI_ClearActionParamAll();
	void BI_ClearMitamaAnalyzeData(const int32& PartyIndex);
	void BI_ClearMitamaAnalyzeDataAll();
	int32 BI_ConstEnemyNum();
	int32 BI_ConstEnemyStart();
	int32 BI_ConstPartyMax();
	int32 BI_ConstStockNum();
	int32 BI_ConstStockStart();
	void BI_CopyMitamaAnalyzeData(const int32& PartyIndex, const struct FAnalyzeData& AnalyzeData);
	void BI_DelBossFlagPartyList(const TArray<E_BTL_BOSS_FLAG>& FlagArray);
	void BI_EscapeFailedForPlayer();
	void BI_ExeMitamaAnalyzeData(const int32& PartyIndex, const int32& UseSkillId);
	void BI_GetActCharmSkill(int32 PartyIndex, int32* Repair, TArray<uint8>* RepairIndex, int32* Aid, TArray<uint8>* AidIndex);
	int32 BI_GetActPassNum(int32 PartyIndex);
	TArray<int32> BI_GetAllIsInFieldList();
	TArray<struct FBtlParty> BI_GetAllIsInFieldPartyData(bool IsTargetOnly);
	int32 BI_GetBattlePartyIndexByNkmIndex(int32 InNkmIndex, int32 InPlayerIndex, int32 InType);
	int32 BI_GetBstNum(int32 PartyIndex, E_BAD_STATUS bst);
	int32 BI_GetEnemyPartyIndexWithDevilID(int32 DevilID);
	int32 BI_GetEnemyPartyIndexWithDevilIDOrRootID(int32 DevilID);
	const int32 BI_GetExistNum(const E_BTL_SIDE& Side);
	int32 BI_GetGlobalActNum();
	E_BTL_CNT BI_GetGodSkillDownAidType();
	E_BTL_CNT BI_GetGodSkillUpAidType();
	E_BTL_SIDE BI_GetIndexSide(int32 PartyIndex);
	int32 BI_GetItemlCureHPValueExpected(const int32 ItemId, const int32 UserIndex, const int32 TargetIndex);
	int32 BI_GetItemlCureMPValueExpected(const int32 ItemId, const int32 UserIndex, const int32 TargetIndex);
	const struct FMagatsuhiDevilParamRate BI_GetMagatsuhiDevilParamRate();
	struct FAnalyzeData BI_GetMitamaAnalyzeData(const int32& PartyIndex);
	int32 BI_GetNowActNum(int32 PartyIndex);
	TArray<int32> BI_GetPartnerList();
	const TArray<struct FBtlParty> BI_GetPartyDataAll();
	struct FPressIcon BI_GetPressIcon();
	E_BTL_PRESS_TYPE BI_GetPressType();
	const int32 BI_GetPrevUpliftingGauge();
	TArray<int32> BI_GetSideIsBossFlagList(E_BTL_SIDE Side, E_BTL_BOSS_FLAG Flag);
	TArray<int32> BI_GetSideIsInFieldList(E_BTL_SIDE Side);
	TArray<struct FBtlParty> BI_GetSideIsInFieldPartyData(E_BTL_SIDE Side);
	TArray<int32> BI_GetSideIsStat2List(E_BTL_SIDE Side, E_BTL_PARTY_STAT2 Stat);
	TArray<int32> BI_GetSideIsStatList(E_BTL_SIDE Side, E_BTL_PARTY_STAT Stat);
	TArray<int32> BI_GetSideIsTargetList(E_BTL_SIDE Side);
	TArray<int32> BI_GetSideListCondition(E_BTL_SIDE Side, bool IsInField, bool IsHitTarget, bool IsDmgChara);
	TArray<int32> BI_GetSideListDevilIDList(E_BTL_SIDE Side);
	int32 BI_GetSkillCureHPValueExpected(const int32 SkillId, const int32 UserIndex, const int32 TargetIndex);
	int32 BI_GetSkillCureMPValueExpected(const int32 SkillId, const int32 UserIndex, const int32 TargetIndex);
	struct FVector BI_GetUnitAveLocation(E_BTL_SIDE Side, class FName SocketName);
	const int32 BI_GetUpliftingGauge(E_BTL_SIDE Side);
	TArray<int32> BI_GetVirtualActOrder(int32 PartyIndex);
	bool BI_IsCharge(const int32& PartyIndex);
	bool BI_IsPressIcon();
	bool BI_IsUseUpliftingGauge(E_BTL_SIDE Side);
	void BI_OpenAnalyze(const struct FBtlParty& Party);
	void BI_OpenAnalyze_AutoSkill(const int32& PartyIndex, const int32& SkillId);
	void BI_ReturnEnemy();
	void BI_SetChkENTargetAllArray(bool IsUse);
	void BI_SetDeadParam(int32 PartyIndex);
	void BI_SetEnemyBattleIn(int32 TargetIndex, int32 DevilID);
	void BI_SetMitamaAnalyzeData(const int32& PartyIndex);
	void BI_SetPressType(E_BTL_PRESS_TYPE PressType);
	void BI_SetPrevUpliftingGauge(const int32& Value);
	void BI_SetUpliftingGauge(E_BTL_SIDE Side, int32 Value);
	void BI_SetUseSkill(int32 SkillId);
	void BI_SharedBossHPRate();
	void BI_TakeOverDefenceAishou();
	bool BI_UpdateBossAishou();
	bool BI_UpdateBossAishouTurnStart();
	bool BI_UpdateBossShareOpenAishou();
	void BI_UpdateIsInFieldList(E_BTL_SIDE Side);
	void BI_UpdateUseSkillArray();
	bool BI_UseUpliftingGauge(E_BTL_SIDE Side);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_PTUtilInterface">();
	}
	static class IBPI_PTUtilInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_PTUtilInterface>();
	}
};
static_assert(alignof(IBPI_PTUtilInterface) == 0x000008, "Wrong alignment on IBPI_PTUtilInterface");
static_assert(sizeof(IBPI_PTUtilInterface) == 0x000028, "Wrong size on IBPI_PTUtilInterface");

// Class Project.BPI_PTBadStatusInterface
// 0x0000 (0x0028 - 0x0028)
class IBPI_PTBadStatusInterface final : public IInterface
{
public:
	void BI_AddBadStatusRecCounter(int32 PartyIndex, int32 Status);
	bool BI_CheckBadStatus(int32 PartyIndex, E_BAD_STATUS Status);
	bool BI_CheckBadStatusAny(int32 PartyIndex);
	void BI_ClearBstCountAll();
	int32 BI_GetBadStatus(int32 PartyIndex);
	int32 BI_GetBadStatusDamage(int32 PartyIndex, E_BAD_STATUS Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_PTBadStatusInterface">();
	}
	static class IBPI_PTBadStatusInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_PTBadStatusInterface>();
	}
};
static_assert(alignof(IBPI_PTBadStatusInterface) == 0x000008, "Wrong alignment on IBPI_PTBadStatusInterface");
static_assert(sizeof(IBPI_PTBadStatusInterface) == 0x000028, "Wrong size on IBPI_PTBadStatusInterface");

// Class Project.MiitsuWindowBase
// 0x0000 (0x0220 - 0x0220)
class AMiitsuWindowBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiitsuWindowBase">();
	}
	static class AMiitsuWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMiitsuWindowBase>();
	}
};
static_assert(alignof(AMiitsuWindowBase) == 0x000008, "Wrong alignment on AMiitsuWindowBase");
static_assert(sizeof(AMiitsuWindowBase) == 0x000220, "Wrong size on AMiitsuWindowBase");

// Class Project.BPI_MainInterface
// 0x0000 (0x0028 - 0x0028)
class IBPI_MainInterface final : public IInterface
{
public:
	void BI_AddBattleDebugFlag(E_BTL_STATE_DEBUG Value);
	void BI_AddBattleDebugFlag2(E_BTL_STATE_DEBUG_2 Value);
	void BI_AddBattleFlag(E_BTL_STAT Value);
	void BI_AddBattleFlag2(E_BTL_STAT_2 Value);
	void BI_AddPressIconAddNum(int32 Num, E_BTL_SIDE Side);
	TArray<uint8> BI_AIBaseTar_Common(int32 ActorIndex, E_BTL_AI_TAR Type, int32 Value, int32 Value2);
	TArray<uint8> BI_AIBaseTar_SetTargetSelf(const struct FBtlParty& Actor);
	TArray<uint8> BI_AIBaseTar_SetTargetSelfSideOther(const TArray<struct FBtlParty>& PartyArray, E_BTL_SIDE TargetSide, int32 SelfIndex);
	void BI_BattleSeqStart(const struct FBtlDescData& Desc);
	bool BI_CheckBattleDebugFlag(E_BTL_STATE_DEBUG Value);
	bool BI_CheckBattleDebugFlag2(E_BTL_STATE_DEBUG_2 Value);
	bool BI_CheckBattleFlag(E_BTL_STAT Value);
	bool BI_CheckBattleFlag2(E_BTL_STAT_2 Value);
	bool BI_CheckDebugSkillSelectIcon();
	void BI_CheckEnemyAttackType();
	bool BI_CheckTutorial(const E_BTL_TUTORIAL Tutorial);
	void BI_CleanupTutorialData();
	void BI_ClearActionPreParam(bool Is_counter);
	void BI_ClearPressIconAddNum(E_BTL_SIDE Side);
	void BI_ClearSavedTsukuyomiHP();
	void BI_ClearUniqueSkillEfficacy_forInfo(int32 PartyIndex);
	void BI_DelBattleDebugFlag(E_BTL_STATE_DEBUG Value);
	void BI_DelBattleDebugFlag2(E_BTL_STATE_DEBUG_2 Value);
	void BI_DelBattleFlag(E_BTL_STAT Value);
	void BI_DelBattleFlag2(E_BTL_STAT_2 Value);
	int32 BI_EncountIsEvent();
	bool BI_EncountIsMagatsukaSpawn();
	bool BI_EncountIsNotEscape();
	bool BI_EncountIsRoomBoss();
	int32 BI_GetBossRushEventEncountID();
	const TArray<int32> BI_GetDebugSkillList();
	TArray<E_SKILL_ICON> BI_GetDebugSkillSelectIconArray();
	const struct FBtlGardenPointData BI_GetGardenPointData();
	int32 BI_GetOverwriteSkillInfoID(const int32 SkillId);
	float BI_GetRenzokuEncountResultBonus();
	E_BTL_STEP BI_GetStep();
	bool BI_IsBossRushChallengeMode();
	bool BI_IsMagatsuhiTalkFailedBlock();
	void BI_MakeupTutorialData(const E_BTL_TUTORIAL_TYPE Type);
	void BI_OpenAnalyzeDeadWithBoss(int32 DstIndex);
	bool BI_RetrieveUniqueSkillEfficacy_forInfo(int32 PartyIndex, TArray<E_AUTO_SKILL_EXTRA_EFFECT>& UniqueSkillType);
	void BI_SaveTsukuyomiHP();
	void BI_SetAchievements_Damage(const int32& SrcPartyIndex, const int32& Damage, TArray<EAchievementFlag>& OutAchievements);
	void BI_SetAchievements_Kill(const int32& SrcPartyIndex, const int32& DstPartyIndex, const bool& IsDead, TArray<EAchievementFlag>& OutAchievements);
	void BI_SetAchievements_MissBlockRefAbsCount(const int32& DstPartyIndex, const E_BTL_REFLECT_RES_TYPE& ResType, TArray<EAchievementFlag>& OutAchievements);
	void BI_SetAchievements_UseMagatsuhiSkillCount(const int32& SrcPartyIndex, const struct FSkillBaseData& UseSkillData, TArray<EAchievementFlag>& OutAchievements);
	void BI_SetAchievements_WeakCount(const int32& SrcPartyIndex, const bool& IsWeak, TArray<EAchievementFlag>& OutAchievements);
	void BI_SetAchievements_WinRenzoku(TArray<EAchievementFlag>& OutAchievements);
	void BI_SetPressIconAddNum(int32 Num, E_BTL_SIDE Side);
	void BI_SetPressIconDel(bool IsDel, E_BTL_SIDE Side);
	void BI_SetPressIconIncDec(int32 Num, E_BTL_SIDE Side);
	void BI_SettingEnemyListMaxLevel();
	void BI_SettingEnemyMaxLevel(const int32 Level);
	void BI_SetTutorialDoneFlag(const E_BTL_TUTORIAL_TYPE Type);
	void BI_SetUniqueSkillEfficacy_forInfo(int32 PartyIndex, TArray<E_AUTO_SKILL_EXTRA_EFFECT>& UniqueSkillType);
	const TArray<struct FBtlSummonData> BI_ShuffleSummonData(const TArray<struct FBtlSummonData>& SummonData);
	void BI_UniqueSkill_AddPressIconHalfNextTurn(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT UniqueSkillType);
	void BI_UniqueSkill_AddPressIconNextTurn(int32 PartyIndex, E_AUTO_SKILL_EXTRA_EFFECT UniqueSkillType);
	bool BI_UniqueSkill_EqualCheckTurnEnd(const E_AUTO_SKILL_EXTRA_EFFECT& UniqueSkillEffect);
	int32 BI_UniqueSkill_GetMagatsuhiGauge();
	void BI_UpdateMagatsuhiTalkFailedBlock();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_MainInterface">();
	}
	static class IBPI_MainInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_MainInterface>();
	}
};
static_assert(alignof(IBPI_MainInterface) == 0x000008, "Wrong alignment on IBPI_MainInterface");
static_assert(sizeof(IBPI_MainInterface) == 0x000028, "Wrong size on IBPI_MainInterface");

// Class Project.BPI_EncountAreaCpp
// 0x0000 (0x0028 - 0x0028)
class IBPI_EncountAreaCpp final : public IInterface
{
public:
	bool BPI_AreaIn_cpp();
	bool BPI_AreaOut_cpp();
	void BPI_CalcReturnSymbol_cpp();
	void BPI_CalcSpawnSymbol_cpp();
	bool BPI_CheckAreaIn_cpp();
	bool BPI_CheckDaathSpawnType_cpp();
	bool BPI_CheckGenerator_cpp();
	bool BPI_CheckIgnorePause_cpp();
	bool BPI_CheckRoomGuardian_cpp();
	bool BPI_CheckTimeAttack_cpp();
	int32 BPI_GetNowSymbolNum_cpp();
	bool BPI_ProcGenerator_cpp(float DeltaTime);
	bool BPI_ProcTimeAttack_cpp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_EncountAreaCpp">();
	}
	static class IBPI_EncountAreaCpp* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_EncountAreaCpp>();
	}
};
static_assert(alignof(IBPI_EncountAreaCpp) == 0x000008, "Wrong alignment on IBPI_EncountAreaCpp");
static_assert(sizeof(IBPI_EncountAreaCpp) == 0x000028, "Wrong size on IBPI_EncountAreaCpp");

// Class Project.BPI_MapActorCorePause
// 0x0000 (0x0028 - 0x0028)
class IBPI_MapActorCorePause final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_MapActorCorePause">();
	}
	static class IBPI_MapActorCorePause* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_MapActorCorePause>();
	}
};
static_assert(alignof(IBPI_MapActorCorePause) == 0x000008, "Wrong alignment on IBPI_MapActorCorePause");
static_assert(sizeof(IBPI_MapActorCorePause) == 0x000028, "Wrong size on IBPI_MapActorCorePause");

// Class Project.BPLCharaPanelBase
// 0x0000 (0x0028 - 0x0028)
class UBPLCharaPanelBase final : public UBlueprintFunctionLibrary
{
public:
	static E_CHARAPANEL_SUPPORTICON_TYPE CalcSupportParameter(E_BTL_CNT InBTLCNT, int32 InValue);
	static float GetBezier(float X0, float X1, float X2, float X3, float bt);
	static int32 GetCharaPanelVNumberMoveMode();
	static int32 GetCharaPanelVNumberPosMode();
	static struct FVector2D GetInterporatePosition(const struct FVector2D& InPosStart, const struct FVector2D& InPosEnd, float InRatio);
	static E_CHARAPANEL_SUPPORTICON_TYPE GetSupportParameter(E_BTL_CNT InBTLCNT);
	static int32 GetVNumberMode(int32 InCalcHP, int32 InCalcMP);
	static bool SetCharaPanelVNumberMoveMode(int32 InMoveMode);
	static bool SetCharaPanelVNumberPosMode(int32 InPosMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPLCharaPanelBase">();
	}
	static class UBPLCharaPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPLCharaPanelBase>();
	}
};
static_assert(alignof(UBPLCharaPanelBase) == 0x000008, "Wrong alignment on UBPLCharaPanelBase");
static_assert(sizeof(UBPLCharaPanelBase) == 0x000028, "Wrong size on UBPLCharaPanelBase");

// Class Project.MinimapBGTextureManager
// 0x0010 (0x0038 - 0x0028)
class UMinimapBGTextureManager final : public UObject
{
public:
	TArray<class UMinimapBGTextureEntry*>         M_Entries;                                         // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	class UMinimapBGTextureEntry* GetLoadedEntry(int32 MapId, int32 AreaId);
	class UMinimapBGTextureEntry* LoadBlocking(TSoftObjectPtr<class UObject> SoftObjectReference, int32 MapId, int32 AreaId);
	void RegisterAll(const struct FMinimapAreaTable& AreaTable);
	class UMinimapBGTextureEntry* RegisterLoadedTexture(class UObject* Object, int32 MapId, int32 AreaId);
	void ReleaseResourceAll();
	void ReleaseResourceByMapId(int32 MapId, int32 AreaId);
	void ReleaseResourceOther(int32 KeepMapId, int32 KeepAreaId, int32 PlayerMapId, int32 PlayerAreaId);
	class UMinimapBGTextureEntry* SearchEntry(int32 MapId, int32 AreaId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapBGTextureManager">();
	}
	static class UMinimapBGTextureManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapBGTextureManager>();
	}
};
static_assert(alignof(UMinimapBGTextureManager) == 0x000008, "Wrong alignment on UMinimapBGTextureManager");
static_assert(sizeof(UMinimapBGTextureManager) == 0x000038, "Wrong size on UMinimapBGTextureManager");
static_assert(offsetof(UMinimapBGTextureManager, M_Entries) == 0x000028, "Member 'UMinimapBGTextureManager::M_Entries' has a wrong offset!");

// Class Project.BPLUICommon
// 0x0000 (0x0028 - 0x0028)
class UBPLUICommon final : public UBlueprintFunctionLibrary
{
public:
	static int32 CalcUseSkillListAnimation(struct FListAnimationBaseData& InData, float InDeltaTime);
	static int32 GetCursorIndexAtBothEnds(int32 InType, int32 InIndex, int32 InCompareIndex);
	static bool GetMouseOvered(class UObject* WorldContextObject, class UWidget* Widget);
	static int32 GetMouseWheelParameter(float InParameter);
	static bool GetNumberItemParam(int32 InMax, int32 InDigits, int32 InItemNo, TArray<int32>& InArray);
	static bool GetNumberParam(int32 InNumber, int32 InDigits, TArray<int32>& InArray);
	static int32 GetPlayerId();
	static bool IsInsideRectAngle(float InRectPosX, float InRectPosY, float InRectSizeX, float InRectSizeY, float InPosX, float InPosY);
	static bool IsNumberDisplay(int32 InNumber, int32 InIndex, int32 InEndIndex, bool InZeroSpace, bool InCheckSpace);
	static bool ResetParameterAvailabelFlag(struct FSortMouseBaseData& InData);
	static int32 SortMouseGetParameter(struct FSortMouseBaseData& InData, int32 InType);
	static bool SortMouseIsParameterAvailabel(struct FSortMouseBaseData& InData);
	static bool SortMouseLockSortMouse(struct FSortMouseBaseData& InData);
	static bool SortMouseSetParameter(struct FSortMouseBaseData& InData, int32 InIndex, int32 InDispIndex, int32 InOffsetIndex);
	static bool SortMouseSetParameterAddElement(struct FSortMouseBaseData& InData, int32 InIndex, int32 InDispIndex, int32 InOffsetIndex, int32 InElementIndex);
	static bool SortMouseUnlockSortMouse(struct FSortMouseBaseData& InData);
	static bool StartUseSkillListAnimation(struct FListAnimationBaseData& InData, int32 InDisplayMax);
	static bool StopUseSkillListAnimation(struct FListAnimationBaseData& InData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPLUICommon">();
	}
	static class UBPLUICommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPLUICommon>();
	}
};
static_assert(alignof(UBPLUICommon) == 0x000008, "Wrong alignment on UBPLUICommon");
static_assert(sizeof(UBPLUICommon) == 0x000028, "Wrong size on UBPLUICommon");

// Class Project.BPL_Actor
// 0x0000 (0x0028 - 0x0028)
class UBPL_Actor final : public UBlueprintFunctionLibrary
{
public:
	static bool HasActorBegunPlay(const class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Actor">();
	}
	static class UBPL_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Actor>();
	}
};
static_assert(alignof(UBPL_Actor) == 0x000008, "Wrong alignment on UBPL_Actor");
static_assert(sizeof(UBPL_Actor) == 0x000028, "Wrong size on UBPL_Actor");

// Class Project.MinimapManager
// 0x0140 (0x0168 - 0x0028)
class UMinimapManager final : public UObject
{
public:
	int32                                         M_Map3DIconNum;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178A[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMinimapFogGridManager*                 M_FogGridManager;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178B[0x10];                                    // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMap3DIconEntry>                M_Map3DIconEntries;                                // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UMinimapPOIManager*                     M_POIManager;                                      // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMinimapFootprintManager*               M_FootprintManager;                                // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMinimapBGTextureManager*               M_BGTextureManager;                                // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapSelectManager*                      M_MapSelectManager;                                // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMinimapIconHelpManager*                M_IconHelpManager;                                 // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMinimapRadarManager*                   M_RadarManager;                                    // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPopUpIconManager*                      M_PopUpIconManager;                                // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMinimapCoasterLineManager*             M_CoasterLineManager;                              // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMinimapCoasterLineMinimap*             M_CoasterLineMinimap;                              // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMinimapAreaTable                      M_AreaTable;                                       // 0x00A0(0x0020)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FMap3DIconEntry>                M_TopCameraIconEntries;                            // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FVector                                M_PlayerScreenLocation;                            // 0x00D0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178C[0x8C];                                    // 0x00DC(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static E_MINIMAP_VISIBILITY CalcScreenLocation(struct FVector* OutScreenLocation, const struct FVector& LocationInWorld, const struct FVector2D& DrawOffset, const struct FMinimapRenderParam& RenderParam, bool IsShowFar, bool IsCalcOuter, float* OutDist2);
	static bool GetIconFogGridFlagFromUniqueId(int32 SaveUniqueId);
	static class UMinimapManager* GetMinimapManager(const class UObject* WorldContextObject);
	static bool GetShowFlagFromUniqueId(int32 SaveUniqueId);
	static void SetIconFogGridFlagFromUniqueId(int32 SaveUniqueId, bool ShowFlag);
	static void SetShowFlagFromUniqueId(int32 SaveUniqueId, bool ShowFlag);
	static struct FVector WorldToScreenScale(const struct FVector& Dimensions, const struct FVector& CanvasSize, float Zoom);

	bool Add3DIcon(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId, class AActor* Owner, const struct FVector& WorldLocationOffset);
	struct FMinimapAreaTableItem ApplyOverrideToAreaTable(int32 MapId, int32 AreaId, const struct FMinimapAreaTableItem& AreaTableItem);
	float CalcAllZoomArray(int32 MapId, int32 AreaId, const TArray<struct FVector>& Locations);
	float CalcAllZoomDefault(int32 MapId, int32 AreaId, const struct FMinimapAreaTableItem& AreaTableItem);
	bool ChangeDynamicPOIIconByOwner(E_MINIMAP_POI_TYPE POIType, class AActor* Owner, E_MINIMAP_POI_ICON NewIcon);
	bool ClearControlActorFromStatic(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId);
	bool Delete3DIconByDataId(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId);
	bool Delete3DIconByOwner(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, class AActor* Owner);
	void FinishCoasterLineMinimapMode();
	void FinishCoasterLineMode();
	void FogGridEnable(bool IsEnable);
	void FogGridOpen(const struct FTransform& PlayerTransform, int32 MapId, int32 AreaId, float Radius);
	void FogGridSetOpenAll(int32 MapId, int32 AreaId, bool IsOpen);
	int32 GetAreaInMapNum();
	class UMinimapBGTextureManager* GetBGTextureManager();
	TArray<class UImage*> GetCoasterLineImageArray();
	class UImage* GetCoasterLineMinimapImage();
	bool GetCoasterLineMinimapMode();
	bool GetCoasterLineMode();
	TArray<struct FMinimapCoasterLineRenderEntry> GetCoasterLineRenderEntries();
	class UTexture* GetFogGridTexture();
	TArray<struct FMinimapFootprintEntry> GetFootprintEntries();
	class UMinimapFootprintManager* GetFootprintManager();
	class UMinimapIconHelpManager* GetIconHelpManager();
	TArray<class UImage*> GetIconImageArray();
	void GetIconMaterial(E_MINIMAP_POI_ICON Icon, float* OutU, float* OutV, struct FLinearColor* OutColor);
	void GetIconMaterial3D(E_MINIMAP_POI_ICON Icon, float* OutU, float* OutV, struct FLinearColor* OutColor);
	void GetIconMaterialTopCamera(E_MINIMAP_POI_ICON Icon, float* OutU, float* OutV, struct FLinearColor* OutColor);
	E_MINIMAP_POI_ICON GetIconToRenderMission(int32 MissionId);
	TArray<struct FMap3DIconEntry> GetMap3DIconEntries();
	class FText GetMapName(int32 MapId, int32 AreaId);
	class UMapSelectManager* GetMapSelectManager();
	bool GetMapSelectReachFlag(int32 MapId, int32 AreaId);
	TArray<struct FVector> GetOnOffEffectArray(E_MINIMAP_POI_ICON Icon, int32* OutNum);
	TArray<struct FVector> GetOnOffEffectArrayAll(int32* OutNum);
	TArray<struct FVector> GetOnOffEffectArrayRyuketsu(int32* OutNum);
	void GetPlayerId(int32* OutMapId, int32* OutAreaId);
	struct FVector GetPlayerScreenLocation();
	TArray<struct FMinimapPOIEntry> GetPOIRenderEntries();
	class UPopUpIconManager* GetPopUpIconManager();
	TArray<struct FMinimapRadarEntry> GetRadarEntries();
	int32 GetRadarRegisteredCount();
	void GetShowingId(int32* OutMapId, int32* OutAreaId);
	struct FMinimapPOIEntry GetStaticMinimapEntry(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId, bool* Found);
	struct FMinimapPOIEntry GetStaticMinimapEntryBySaveUniqueId(int32 MapId, int32 AreaId, int32 SaveUniqueId, bool* Found);
	TArray<struct FMap3DIconEntry> GetTopCameraIconEntries();
	void InitAfterResource();
	bool IsIconHideByUI(E_MINIMAP_POI_ICON Icon);
	bool IsPlayerId(int32 MapId, int32 AreaId);
	bool IsShowingPlayerId();
	void MakeUpAreaTable(class UObject* PObject, class UObject* POverrideObject);
	void MakeUpIconHelp(class UObject* PTable, class UScriptMessageAsset* PNameMessage, class UScriptMessageAsset* PHelpMessage);
	void MakeUpMapSelect(class UObject* PObject);
	void PrintLog();
	void RegisterDynamicPOI(const struct FMinimapPOIParam& InParam, class AActor* Owner, bool Show3D, const struct FVector& WorldLocationOffset);
	void RegisterMinimapIconTableAll(class UDataTable* DataTable);
	bool RegisterRadarByDataId(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId);
	bool RegisterRadarBySaveUniqueId(int32 MapId, int32 AreaId, int32 SaveUniqueId);
	bool RemoveRadarAll();
	bool RemoveRadarByDataId(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId);
	bool RemoveRadarBySaveUniqueId(int32 MapId, int32 AreaId, int32 SaveUniqueId);
	void ResetDynamicPOI();
	struct FMinimapAreaTableItem SearchItem(int32 MapId, int32 AreaId);
	void SetCoasterLineMaterial(class UMaterialInterface* MaterialInterface);
	void SetCoasterLineMinimapImageAndMaterial(class UImage* Image, class UMaterialInterface* MaterialInterface);
	bool SetControlActorToStatic(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId, class AActor* ControlActor);
	void SetFootprintDistance(float TargetDistance);
	void SetIconFogGridFlagFromDataId(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId, bool ShowFlag);
	void SetIconHideByUI(E_MINIMAP_POI_ICON Icon, bool IsHide);
	void SetIconHideByUIAll(bool IsHide);
	void SetIconMaterial(class UMaterialInterface* MaterialInterface);
	void SetMapSelectReachFlag(int32 MapId, int32 AreaId);
	void SetMapSelectReachFlagAll(bool Value);
	void SetPlayerId(int32 MapId, int32 AreaId);
	void SetShowFlagAll(bool ShowFlag);
	void SetShowFlagFromMapId(int32 MapId, int32 AreaId, int32 SaveId, bool ShowFlag);
	void SetShowingId(int32 MapId, int32 AreaId);
	void StartCoasterLineMinimapMode(int32 DataId);
	void StartCoasterLineMode();
	void ToggleIconHideByUI(E_MINIMAP_POI_ICON Icon);
	bool UnregisterDynamicPOIByOwner(class AActor* Owner);
	void UpdateByPlayerMovement(const struct FTransform& PlayerTransform, float DeltaTime, int32 MapId, int32 AreaId, float FogGridOpenRadius, const struct FVector& CanvasSize);
	void UpdateFogGridTexture(class UTexture* TargetTexture, int32 MapId, int32 AreaId);
	void UpdateFootprintByPlayerMovement(const struct FTransform& PlayerTransform, float DeltaTime, int32 MapId, int32 AreaId);
	void UpdateIconRenderImages();
	void UpdateMap3DIcon(const struct FVector& PlayerLocation, const class UObject* WorldContextObject);
	void UpdateRender(const struct FMinimapRenderParam& RenderParam);
	void UpdateTopCameraIcon(const struct FVector& CameraLocation, float CameraRotateZ, const struct FVector& HeroLocation, float HeroRotateZ, const class UObject* WorldContextObject);

	bool GetNextAreaInMap(int32 MyMapId, int32 MyAreaId, int32 Direction, bool IsTrigger, int32* OutMapId, int32* OutAreaId) const;
	int32 GetSaveUniqueId(int32 MapId, int32 AreaId, int32 SaveId) const;
	int32 GetSaveUniqueIdFromDataId(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, E_MINIMAP_POI_ICON Icon, int32 DataId) const;
	bool GetShowFlagFromMapId(int32 MapId, int32 AreaId, int32 SaveId) const;
	const struct FMap3DIconEntry GetTopCameraPlayerIcon() const;
	bool IsVisibleByFogGrid(int32 MapId, int32 AreaId, const struct FVector& Location) const;
	bool IsVisibleByFogGridRadius(int32 MapId, int32 AreaId, const struct FVector& Location, float Radius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapManager">();
	}
	static class UMinimapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapManager>();
	}
};
static_assert(alignof(UMinimapManager) == 0x000008, "Wrong alignment on UMinimapManager");
static_assert(sizeof(UMinimapManager) == 0x000168, "Wrong size on UMinimapManager");
static_assert(offsetof(UMinimapManager, M_Map3DIconNum) == 0x000028, "Member 'UMinimapManager::M_Map3DIconNum' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_FogGridManager) == 0x000030, "Member 'UMinimapManager::M_FogGridManager' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_Map3DIconEntries) == 0x000048, "Member 'UMinimapManager::M_Map3DIconEntries' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_POIManager) == 0x000058, "Member 'UMinimapManager::M_POIManager' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_FootprintManager) == 0x000060, "Member 'UMinimapManager::M_FootprintManager' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_BGTextureManager) == 0x000068, "Member 'UMinimapManager::M_BGTextureManager' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_MapSelectManager) == 0x000070, "Member 'UMinimapManager::M_MapSelectManager' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_IconHelpManager) == 0x000078, "Member 'UMinimapManager::M_IconHelpManager' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_RadarManager) == 0x000080, "Member 'UMinimapManager::M_RadarManager' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_PopUpIconManager) == 0x000088, "Member 'UMinimapManager::M_PopUpIconManager' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_CoasterLineManager) == 0x000090, "Member 'UMinimapManager::M_CoasterLineManager' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_CoasterLineMinimap) == 0x000098, "Member 'UMinimapManager::M_CoasterLineMinimap' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_AreaTable) == 0x0000A0, "Member 'UMinimapManager::M_AreaTable' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_TopCameraIconEntries) == 0x0000C0, "Member 'UMinimapManager::M_TopCameraIconEntries' has a wrong offset!");
static_assert(offsetof(UMinimapManager, M_PlayerScreenLocation) == 0x0000D0, "Member 'UMinimapManager::M_PlayerScreenLocation' has a wrong offset!");

// Class Project.BPL_Input
// 0x0000 (0x0028 - 0x0028)
class UBPL_Input final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckConnect_PsGamepad(bool IsLog, class FString* OutLog);
	static struct FKey ConvertButton_ForGamepad(const struct FKey& PrevKey);
	static E_KeyboardLanguage GetKeyboardLanguage();
	static class FString GetKeyName_KeyboardLanguage(const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Input">();
	}
	static class UBPL_Input* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Input>();
	}
};
static_assert(alignof(UBPL_Input) == 0x000008, "Wrong alignment on UBPL_Input");
static_assert(sizeof(UBPL_Input) == 0x000028, "Wrong size on UBPL_Input");

// Class Project.BPL_LargeMap
// 0x0000 (0x0028 - 0x0028)
class UBPL_LargeMap final : public UBlueprintFunctionLibrary
{
public:
	static bool CurrentMapIsDaath(class UObject* WorldContextObject);
	static bool CurrentMapShouldPlayMoonAgeSE(class UObject* WorldContextObject);
	static bool MapIdIsDaath(int32 MapId);
	static void SetLandscapeMaterial_InDevelop(class ALandscape* InLandscape, class UMaterialInterface* InNewMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_LargeMap">();
	}
	static class UBPL_LargeMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_LargeMap>();
	}
};
static_assert(alignof(UBPL_LargeMap) == 0x000008, "Wrong alignment on UBPL_LargeMap");
static_assert(sizeof(UBPL_LargeMap) == 0x000028, "Wrong size on UBPL_LargeMap");

// Class Project.BPL_Localization
// 0x0000 (0x0028 - 0x0028)
class UBPL_Localization final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetPlatformLanguage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Localization">();
	}
	static class UBPL_Localization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Localization>();
	}
};
static_assert(alignof(UBPL_Localization) == 0x000008, "Wrong alignment on UBPL_Localization");
static_assert(sizeof(UBPL_Localization) == 0x000028, "Wrong size on UBPL_Localization");

// Class Project.BPL_MapAutoHeal
// 0x0000 (0x0028 - 0x0028)
class UBPL_MapAutoHeal final : public UBlueprintFunctionLibrary
{
public:
	static bool BPL_CheckNeedAutoHeal();
	static void BPL_ProcMapAutoHeal(bool Log, bool* OutUseHeal, bool* OutHaveRebornSkill, bool* OutHaveHPSkill, TArray<struct FMapAutoHealResult>* OutResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MapAutoHeal">();
	}
	static class UBPL_MapAutoHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MapAutoHeal>();
	}
};
static_assert(alignof(UBPL_MapAutoHeal) == 0x000008, "Wrong alignment on UBPL_MapAutoHeal");
static_assert(sizeof(UBPL_MapAutoHeal) == 0x000028, "Wrong size on UBPL_MapAutoHeal");

// Class Project.BPL_MapGimmick
// 0x0000 (0x0028 - 0x0028)
class UBPL_MapGimmick final : public UBlueprintFunctionLibrary
{
public:
	static bool BPL_DgRotateFlagGet();
	static void BPL_DgRotateFlagReset();
	static void BPL_MapNaviLog(const class FString& Str, float Time, const struct FColor& Color, bool bVerbose);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MapGimmick">();
	}
	static class UBPL_MapGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MapGimmick>();
	}
};
static_assert(alignof(UBPL_MapGimmick) == 0x000008, "Wrong alignment on UBPL_MapGimmick");
static_assert(sizeof(UBPL_MapGimmick) == 0x000028, "Wrong size on UBPL_MapGimmick");

// Class Project.TalkCamera
// 0x0150 (0x0900 - 0x07B0)
class ATalkCamera : public ACameraActor
{
public:
	struct FTalkCameraParam                       ParamFinal;                                        // 0x07B0(0x002C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTalkCameraParam                       ParamTable;                                        // 0x07DC(0x002C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTalkCameraParam                       ParamInterpolated;                                 // 0x0808(0x002C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTalkCameraParam                       Params;                                            // 0x0834(0x002C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTalkCameraParam                       ParamM;                                            // 0x0860(0x002C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTalkCameraParam                       ParamL;                                            // 0x088C(0x002C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTalkCameraParam                       ParamOffset;                                       // 0x08B8(0x002C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C9[0x4];                                     // 0x08E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTalkCameraParam>               TableArray;                                        // 0x08E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17CA[0x8];                                     // 0x08F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcUniqueSkillCamera(class UDataTable* DataTable, int32 UniqueSkillDevilId, float TargetHeight, struct FVector* OutLocation, struct FVector* OutRotation);
	E_TALK_CAMERA_DATA_TYPE GetCameraTableDataType(int32 TableIndex);
	E_TALK_CAMERA_MODEL_HIDE GetCameraTableModelHide(int32 TableIndex);
	void MakeUpCameraTable(class UObject* PObject);
	void PrintOffsetCameraTable(int32 TableIndex, E_TALK_CAMERA_DATA_TYPE DebugDataType, E_TALK_CAMERA_MODEL_HIDE DebugModelHide);
	void SetOffset(const struct FTalkCameraParam& Offset);
	void UpdateParam(float TargetHeight);
	void UpdateTableParam(int32 TableIndex);

	const struct FTalkCameraParam GetCameraTableData(int32 TableIndex) const;
	struct FTalkCameraParam GetMythFriendUpParam(int32 TableIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TalkCamera">();
	}
	static class ATalkCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATalkCamera>();
	}
};
static_assert(alignof(ATalkCamera) == 0x000010, "Wrong alignment on ATalkCamera");
static_assert(sizeof(ATalkCamera) == 0x000900, "Wrong size on ATalkCamera");
static_assert(offsetof(ATalkCamera, ParamFinal) == 0x0007B0, "Member 'ATalkCamera::ParamFinal' has a wrong offset!");
static_assert(offsetof(ATalkCamera, ParamTable) == 0x0007DC, "Member 'ATalkCamera::ParamTable' has a wrong offset!");
static_assert(offsetof(ATalkCamera, ParamInterpolated) == 0x000808, "Member 'ATalkCamera::ParamInterpolated' has a wrong offset!");
static_assert(offsetof(ATalkCamera, Params) == 0x000834, "Member 'ATalkCamera::Params' has a wrong offset!");
static_assert(offsetof(ATalkCamera, ParamM) == 0x000860, "Member 'ATalkCamera::ParamM' has a wrong offset!");
static_assert(offsetof(ATalkCamera, ParamL) == 0x00088C, "Member 'ATalkCamera::ParamL' has a wrong offset!");
static_assert(offsetof(ATalkCamera, ParamOffset) == 0x0008B8, "Member 'ATalkCamera::ParamOffset' has a wrong offset!");
static_assert(offsetof(ATalkCamera, TableArray) == 0x0008E8, "Member 'ATalkCamera::TableArray' has a wrong offset!");

// Class Project.BPL_MapLoad
// 0x0000 (0x0028 - 0x0028)
class UBPL_MapLoad final : public UBlueprintFunctionLibrary
{
public:
	static void PreloadMap(class UObject* WorldContextObject, int32 MapId, int32 AreaId);
	static void UnLoadLevelInstance(class UObject* WorldContextObject, class ULevelStreamingDynamic* StreamingLevel, bool* bOutSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MapLoad">();
	}
	static class UBPL_MapLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MapLoad>();
	}
};
static_assert(alignof(UBPL_MapLoad) == 0x000008, "Wrong alignment on UBPL_MapLoad");
static_assert(sizeof(UBPL_MapLoad) == 0x000028, "Wrong size on UBPL_MapLoad");

// Class Project.BPL_MapSymbol_CPP
// 0x0000 (0x0028 - 0x0028)
class UBPL_MapSymbol_CPP final : public UBlueprintFunctionLibrary
{
public:
	static void BPL_MapSymbolLog(const class FString& Str, float Time, const struct FColor& Color, bool bVerbose);
	static void BPL_UpdateMapSymbolAll(float DeltaSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MapSymbol_CPP">();
	}
	static class UBPL_MapSymbol_CPP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MapSymbol_CPP>();
	}
};
static_assert(alignof(UBPL_MapSymbol_CPP) == 0x000008, "Wrong alignment on UBPL_MapSymbol_CPP");
static_assert(sizeof(UBPL_MapSymbol_CPP) == 0x000028, "Wrong size on UBPL_MapSymbol_CPP");

// Class Project.BPL_Math
// 0x0000 (0x0028 - 0x0028)
class UBPL_Math final : public UBlueprintFunctionLibrary
{
public:
	static void BreakRotToAxisAndAngle(const struct FRotator& Rotator, struct FVector* Axis, float* Angle);
	static void CalcCloserValue(float CurrentValue, float TargetValue, float DeltaValue, float* OutValue, bool* bMatched);
	static void CalcNearestPointOnLineSegment(struct FVector* OutPoint, float* OutDistance, const struct FVector& Point, const struct FVector& SegmentPoint0, const struct FVector& SegmentPoint1);
	static struct FVector CalcNearestPointOnSpline(const class USplineComponent* Spline, const struct FVector& Point);
	static int32 GetDigitLength(int32 Num);
	static int32 GetWeightedRandom(const TArray<int32>& WeightArray);
	static bool IsInsideOrientedBox2D(const struct FVector2D& Center, const struct FVector2D& Extent, float RotateZ, const struct FVector2D& Target);
	static bool IsInsideOrientedBox3D(const struct FTransform& Transform, const struct FVector& Extent, const struct FVector& Target);
	static float IsLeft2D(const struct FVector2D& V1, const struct FVector2D& V2, const struct FVector2D& Target);
	static bool LineToLineIntersection(const struct FVector& FromA, const struct FVector& FromB, const struct FVector& ToA, const struct FVector& ToB, struct FVector* OutIntersection);
	static struct FVector MakeNormalFromTrianglePoints(const struct FVector& A, const struct FVector& B, const struct FVector& C);
	static struct FTransform MakeRelativeTransform(const struct FTransform& A, const struct FTransform& B);
	static struct FRotator MakeRotFromAtoB(const struct FVector& A, const struct FVector& B);
	static bool QuadraticFormula(float A, float B, float C, float* X0, float* X1);
	static TArray<class AActor*> SortActorsByKey(const TArray<class AActor*>& InActors, const TArray<int32>& InKeys, bool Accending);
	static TArray<int32> SplitDigit(int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Math">();
	}
	static class UBPL_Math* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Math>();
	}
};
static_assert(alignof(UBPL_Math) == 0x000008, "Wrong alignment on UBPL_Math");
static_assert(sizeof(UBPL_Math) == 0x000028, "Wrong size on UBPL_Math");

// Class Project.BPL_MoonAge
// 0x0000 (0x0028 - 0x0028)
class UBPL_MoonAge final : public UBlueprintFunctionLibrary
{
public:
	static class FString E_MOON_AGE_ToString(E_MOON_AGE EnumValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MoonAge">();
	}
	static class UBPL_MoonAge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MoonAge>();
	}
};
static_assert(alignof(UBPL_MoonAge) == 0x000008, "Wrong alignment on UBPL_MoonAge");
static_assert(sizeof(UBPL_MoonAge) == 0x000028, "Wrong size on UBPL_MoonAge");

// Class Project.TalkToneTable
// 0x0020 (0x0048 - 0x0028)
class UTalkToneTable final : public UObject
{
public:
	TArray<struct FTalkScoutTable>                M_TalkScoutTableArray;                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D9[0x10];                                    // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TalkToneTable">();
	}
	static class UTalkToneTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTalkToneTable>();
	}
};
static_assert(alignof(UTalkToneTable) == 0x000008, "Wrong alignment on UTalkToneTable");
static_assert(sizeof(UTalkToneTable) == 0x000048, "Wrong size on UTalkToneTable");
static_assert(offsetof(UTalkToneTable, M_TalkScoutTableArray) == 0x000028, "Member 'UTalkToneTable::M_TalkScoutTableArray' has a wrong offset!");

// Class Project.BPL_Network
// 0x0000 (0x0028 - 0x0028)
class UBPL_Network final : public UBlueprintFunctionLibrary
{
public:
	static bool LoginUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Network">();
	}
	static class UBPL_Network* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Network>();
	}
};
static_assert(alignof(UBPL_Network) == 0x000008, "Wrong alignment on UBPL_Network");
static_assert(sizeof(UBPL_Network) == 0x000028, "Wrong size on UBPL_Network");

// Class Project.BPL_OptionBrightness
// 0x0000 (0x0028 - 0x0028)
class UBPL_OptionBrightness final : public UBlueprintFunctionLibrary
{
public:
	static float GetDisplayGamma();
	static void ResetDisplayGamma();
	static void SetDisplayGamma(float Gamma);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_OptionBrightness">();
	}
	static class UBPL_OptionBrightness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_OptionBrightness>();
	}
};
static_assert(alignof(UBPL_OptionBrightness) == 0x000008, "Wrong alignment on UBPL_OptionBrightness");
static_assert(sizeof(UBPL_OptionBrightness) == 0x000028, "Wrong size on UBPL_OptionBrightness");

// Class Project.BPL_PlatformTerms
// 0x0000 (0x0028 - 0x0028)
class UBPL_PlatformTerms final : public UBlueprintFunctionLibrary
{
public:
	static const class FText GetPlatformTerm_Button();
	static const class FText GetPlatformTerm_DLC();
	static const class FText GetPlatformTerm_DLC_Short();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_PlatformTerms">();
	}
	static class UBPL_PlatformTerms* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_PlatformTerms>();
	}
};
static_assert(alignof(UBPL_PlatformTerms) == 0x000008, "Wrong alignment on UBPL_PlatformTerms");
static_assert(sizeof(UBPL_PlatformTerms) == 0x000028, "Wrong size on UBPL_PlatformTerms");

// Class Project.BPL_RenderWidgetToTarget
// 0x0000 (0x0028 - 0x0028)
class UBPL_RenderWidgetToTarget final : public UBlueprintFunctionLibrary
{
public:
	static void CreateSlateBrushByWidgetToRender2D(class UUserWidget* InSourceWidget, class UTextureRenderTarget2D* InRenderTarget, struct FSlateBrush* InBlush);
	static bool DrawWidgetToTargetTex(class UTextureRenderTarget2D* Target, class UUserWidget* WidgetToRender, const struct FVector2D& DrawSize, bool UseGamma, ETextureFilter Filter, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_RenderWidgetToTarget">();
	}
	static class UBPL_RenderWidgetToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_RenderWidgetToTarget>();
	}
};
static_assert(alignof(UBPL_RenderWidgetToTarget) == 0x000008, "Wrong alignment on UBPL_RenderWidgetToTarget");
static_assert(sizeof(UBPL_RenderWidgetToTarget) == 0x000028, "Wrong size on UBPL_RenderWidgetToTarget");

// Class Project.TutorialWindowBase
// 0x0000 (0x0220 - 0x0220)
class ATutorialWindowBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialWindowBase">();
	}
	static class ATutorialWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialWindowBase>();
	}
};
static_assert(alignof(ATutorialWindowBase) == 0x000008, "Wrong alignment on ATutorialWindowBase");
static_assert(sizeof(ATutorialWindowBase) == 0x000220, "Wrong size on ATutorialWindowBase");

// Class Project.BPL_SaveLoad
// 0x0000 (0x0028 - 0x0028)
class UBPL_SaveLoad final : public UBlueprintFunctionLibrary
{
public:
	static void BindSaveGameInfo();
	static E_SaveExistsResult Check(const int32 ListIndex);
	static void CheckAsync(const int32 ListIndex);
	static void CheckSystemAsync();
	static bool DebugLoadSlot(const class FString& SaveName);
	static void DebugResaveAll();
	static E_SaveExistsResult DebugSaveExist(const class FString& SaveName);
	static void DebugSetClearAlignment(E_ALIGNMENT Alignment, bool Flag);
	static void DebugSetClearRound(const uint8 Count);
	static void DebugSetGameStartMode(E_GAME_START_MODE StartMode);
	static bool Delete(const int32 ListIndex);
	static void DeleteAsync(const int32 ListIndex);
	static void DeleteLoadAllSaveDataHeaderTask();
	static E_SaveExistsResult GetCheckResult();
	static bool GetDeleteResult();
	static bool GetLoadAllSaveDataHeaderResult();
	static bool GetLoadResult();
	static int32 GetMaxDateTimeSlotIndex();
	static int32 GetMinDateTimeAutoSaveIndex();
	static int32 GetSaveFileIndex(const class FString& Filename);
	static TArray<struct FSaveLoadHeaderData> GetSaveLoadHeaderDataArray();
	static bool GetSaveResult();
	static bool IsAnySlotSaveData();
	static bool IsCompletePrepareGettingSaveName();
	static bool Load(const int32 ListIndex);
	static bool LoadAllSaveDataHeader(const E_SaveListType SaveListType);
	static void LoadAllSaveDataHeaderAsync(const E_SaveListType SaveListType);
	static void LoadAsync(const int32 ListIndex);
	static void LoadSystemAsync();
	static bool Save(const int32 ListIndex);
	static void SaveAsync(const int32 ListIndex);
	static void SaveLoadAsyncTaskDelete();
	static void SaveSystemAsync();
	static bool WaitCheckAsync();
	static bool WaitDeleteAsync();
	static bool WaitLoadAllSaveDataHeaderAsync();
	static bool WaitLoadAsync();
	static bool WaitSaveAsync();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_SaveLoad">();
	}
	static class UBPL_SaveLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_SaveLoad>();
	}
};
static_assert(alignof(UBPL_SaveLoad) == 0x000008, "Wrong alignment on UBPL_SaveLoad");
static_assert(sizeof(UBPL_SaveLoad) == 0x000028, "Wrong size on UBPL_SaveLoad");

// Class Project.BPL_SkinnedMesh
// 0x0000 (0x0028 - 0x0028)
class UBPL_SkinnedMesh final : public UBlueprintFunctionLibrary
{
public:
	static struct FTransform GetComposedRefPoseTransform(const class USkinnedMeshComponent* Target, class FName BoneName);
	static float GetMaxDistanceFactor(const class USkinnedMeshComponent* Component);
	static struct FTransform GetRefPoseTransform(const class USkinnedMeshComponent* Target, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_SkinnedMesh">();
	}
	static class UBPL_SkinnedMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_SkinnedMesh>();
	}
};
static_assert(alignof(UBPL_SkinnedMesh) == 0x000008, "Wrong alignment on UBPL_SkinnedMesh");
static_assert(sizeof(UBPL_SkinnedMesh) == 0x000028, "Wrong size on UBPL_SkinnedMesh");

// Class Project.BPL_StaffRollData
// 0x0000 (0x0028 - 0x0028)
class UBPL_StaffRollData final : public UBlueprintFunctionLibrary
{
public:
	static float CalcMovieTime(float Speed);
	static float CalcSpeed(float Sec);
	static int32 CalcStartDataNo(float Position, float Height);
	static float GetAddLength(int32 ID);
	static class FString GetLeftName(int32 ID);
	static const float GetLineSpace(int32 ID);
	static float GetNowLength(float Position);
	static float GetNowPosition(float Length);
	static class FString GetOrganizationName(int32 ID);
	static class FString GetRightName(int32 ID);
	static const struct FStaffRollData GetStaffRollData(int32 ID);
	static int32 GetStaffRollDataMax();
	static float GetStaffRollLength();
	static const class UTexture2D* GetTexture(int32 ID);
	static class FString GetTitleName(int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_StaffRollData">();
	}
	static class UBPL_StaffRollData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_StaffRollData>();
	}
};
static_assert(alignof(UBPL_StaffRollData) == 0x000008, "Wrong alignment on UBPL_StaffRollData");
static_assert(sizeof(UBPL_StaffRollData) == 0x000028, "Wrong size on UBPL_StaffRollData");

// Class Project.BPL_TestEventLipSync
// 0x0000 (0x0028 - 0x0028)
class UBPL_TestEventLipSync final : public UBlueprintFunctionLibrary
{
public:
	static int32 ClampLODGroup(int32 LODGroup);
	static void Debug_RecreateSamplerStates(ETextureGroup LODGroup, float MipMapBias);
	static TSubclassOf<class AActor> GetAssetClass(class UObject* Object);
	static int32 GetLODBias(const int32 LODGroup);
	static class FString GetTextureGroupName(const int32 LODGroup);
	static void LogTextureLODInfo();
	static void SetLODBias(const int32 LODGroup, const int32 LODBias);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_TestEventLipSync">();
	}
	static class UBPL_TestEventLipSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_TestEventLipSync>();
	}
};
static_assert(alignof(UBPL_TestEventLipSync) == 0x000008, "Wrong alignment on UBPL_TestEventLipSync");
static_assert(sizeof(UBPL_TestEventLipSync) == 0x000028, "Wrong size on UBPL_TestEventLipSync");

// Class Project.BPL_TestLandscape
// 0x0000 (0x0028 - 0x0028)
class UBPL_TestLandscape final : public UBlueprintFunctionLibrary
{
public:
	static void SetWalkableSlopeOverride(const class ALandscape* Target, const struct FWalkableSlopeOverride& NewOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_TestLandscape">();
	}
	static class UBPL_TestLandscape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_TestLandscape>();
	}
};
static_assert(alignof(UBPL_TestLandscape) == 0x000008, "Wrong alignment on UBPL_TestLandscape");
static_assert(sizeof(UBPL_TestLandscape) == 0x000028, "Wrong size on UBPL_TestLandscape");

// Class Project.BPL_TestSaveLoad
// 0x0000 (0x0028 - 0x0028)
class UBPL_TestSaveLoad final : public UBlueprintFunctionLibrary
{
public:
	static bool LoadGamePlatformUI();
	static void LoadTest(bool bAttemptToUseUI);
	static bool SaveGamePlatformUI();
	static bool SaveTest(int32 ListIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_TestSaveLoad">();
	}
	static class UBPL_TestSaveLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_TestSaveLoad>();
	}
};
static_assert(alignof(UBPL_TestSaveLoad) == 0x000008, "Wrong alignment on UBPL_TestSaveLoad");
static_assert(sizeof(UBPL_TestSaveLoad) == 0x000028, "Wrong size on UBPL_TestSaveLoad");

// Class Project.BPL_TestSoftwareKeyboard
// 0x0000 (0x0028 - 0x0028)
class UBPL_TestSoftwareKeyboard final : public UBlueprintFunctionLibrary
{
public:
	static class FText GetText();
	static bool IsEndSoftwareKeyboardTest();
	static void SoftwareKeyboardTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_TestSoftwareKeyboard">();
	}
	static class UBPL_TestSoftwareKeyboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_TestSoftwareKeyboard>();
	}
};
static_assert(alignof(UBPL_TestSoftwareKeyboard) == 0x000008, "Wrong alignment on UBPL_TestSoftwareKeyboard");
static_assert(sizeof(UBPL_TestSoftwareKeyboard) == 0x000028, "Wrong size on UBPL_TestSoftwareKeyboard");

// Class Project.BPL_Title
// 0x0000 (0x0028 - 0x0028)
class UBPL_Title final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckDisplayCopyrightFromPlatform(const int32 Order);
	static bool CheckEnableConvertSaveData();
	static bool EnableCountUpNoInputTime();
	static E_OldNewRoute GetActivityTargetSaveDataType(const class UObject* WorldContextObject);
	static class FString GetGamertag(const struct FEnableCheckGamertagFontData& InFontData, const bool Modern, const bool ModernSuffix, const class FString& RepCharforGarbledChar);
	static void GetTitleTopSelection(const bool EnableConvert, TArray<E_TITLE_TOP_SELECTION>* RetSelection);
	static bool IsActivityStart(const class UObject* WorldContextObject);
	static bool IsRequestedTitleMovie();
	static void SetRequestTitleMovie(bool UseFirstMovie);
	static bool UseGamertag();
	static bool UsePCTitle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Title">();
	}
	static class UBPL_Title* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Title>();
	}
};
static_assert(alignof(UBPL_Title) == 0x000008, "Wrong alignment on UBPL_Title");
static_assert(sizeof(UBPL_Title) == 0x000028, "Wrong size on UBPL_Title");

// Class Project.BtnHelp_ActionMappingIconBase
// 0x0000 (0x0260 - 0x0260)
class UBtnHelp_ActionMappingIconBase : public UUserWidget
{
public:
	bool GetIconDispMode();
	int32 GetKeyboardIconDispNum();
	struct FSlateFontInfo GetKeyboardIconFont();
	TArray<int32> GetKeyboardIconSsPlayerFrame();
	TArray<class FString> GetKeyboardIconText();
	void SetIconColor(const struct FLinearColor& InColor);
	void SetIconColor_ByActiveState(bool IsActive);
	void SetIconDispMode(bool IsGamePad);
	void SetIconInfo(E_BTN_HELP_MAPPING_KEY_TYPE InIconMappingType);
	void SetIconSize(E_BTN_ICON_SIZE InIconSize);
	void SetIconTranslation(const struct FVector2D& InTranslation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtnHelp_ActionMappingIconBase">();
	}
	static class UBtnHelp_ActionMappingIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtnHelp_ActionMappingIconBase>();
	}
};
static_assert(alignof(UBtnHelp_ActionMappingIconBase) == 0x000008, "Wrong alignment on UBtnHelp_ActionMappingIconBase");
static_assert(sizeof(UBtnHelp_ActionMappingIconBase) == 0x000260, "Wrong size on UBtnHelp_ActionMappingIconBase");

// Class Project.ButtonHelpBase
// 0x0020 (0x0240 - 0x0220)
class AButtonHelpBase : public AActor
{
public:
	TArray<struct FBtnHelpInfo>                   M_BtnHelpInfo_Horizontal;                          // 0x0220(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBtnHelpInfo>                   M_BtnHelpInfo_Vertical;                            // 0x0230(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	TArray<struct FBtnHelpInfo> GetHelpInfo(E_BTN_HELP_DIR InDirection);
	void SetHelpInfo_Manual(E_BTN_HELP_DIR InDirection, TArray<struct FBtnHelpInfo>& InHelpInfo, bool IsSort);
	void SetHelpInfo_Preset(E_BTN_HELP_DIR InDirection, E_BTN_HELP_SET InPattern, bool IsSort);
	void SortHelpInfo(E_BTN_HELP_DIR InDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonHelpBase">();
	}
	static class AButtonHelpBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AButtonHelpBase>();
	}
};
static_assert(alignof(AButtonHelpBase) == 0x000008, "Wrong alignment on AButtonHelpBase");
static_assert(sizeof(AButtonHelpBase) == 0x000240, "Wrong size on AButtonHelpBase");
static_assert(offsetof(AButtonHelpBase, M_BtnHelpInfo_Horizontal) == 0x000220, "Member 'AButtonHelpBase::M_BtnHelpInfo_Horizontal' has a wrong offset!");
static_assert(offsetof(AButtonHelpBase, M_BtnHelpInfo_Vertical) == 0x000230, "Member 'AButtonHelpBase::M_BtnHelpInfo_Vertical' has a wrong offset!");

// Class Project.BPL_ButtonHelpData
// 0x0000 (0x0028 - 0x0028)
class UBPL_ButtonHelpData final : public UBlueprintFunctionLibrary
{
public:
	static E_BTN_HELP_MAPPING_KEY_TYPE GetActionMappingIconType_ByRichTextTag(const class FString& InTagName);
	static TArray<struct FKey> GetBtnHelpKeyList_ByMappingEnum(E_BTN_HELP_MAPPING_KEY_TYPE InMappingType, bool IsGamePad);
	static int32 GetBtnHelpMaxNum(E_BTN_HELP_DIR InDirection);
	static int32 GetBtnHelpSortOrder_ByMappingEnum(E_BTN_HELP_DIR InDirection, E_BTN_HELP_MAPPING_KEY_TYPE InMappingType);
	static struct FVector2D GetBtnHelpTexUV_ByMappingEnum(E_BTN_HELP_MAPPING_KEY_TYPE InMappingType);
	static struct FVector2D GetBtnIconWidgetSize_ByRichTextTag(const class FString& InTagName, bool IsGamePad, int32 InIconSize);
	static class FText GetButtonHelpMessage(E_BTN_HELP_MSG_TYPE InMsgtype);
	static struct FLinearColor GetExternalFontTexUV_ByMappingEnum(const struct FKey& InKey);
	static TArray<int32> GetKeyboardHelpSsPlayerFrame(const class FString& InTagName, int32 InIconSize);
	static TArray<class FString> GetKeyboardHelpText_ByMappingEnum(E_BTN_HELP_MAPPING_KEY_TYPE InMappingType);
	static TArray<class FString> GetKeyboardHelpText_ByRichTextTag(const class FString& InTagName);
	static int32 GetKeyboardIconDispNum_ByRichTextTag(const class FString& InTagName);
	static struct FSlateFontInfo GetKeyboardIconTextFont(int32 InIconSize);
	static TArray<int32> GetKeyboardIconTexUV(E_BTN_ICON_SIZE InIconSize);
	static E_BTN_HELP_MOUSE_ICON_TYPE GetMouseIconType_ByFKey(const struct FKey& InKey);
	static E_BTN_HELP_MOUSE_ICON_TYPE GetMouseIconType_ByRichTextTag(const class FString& InTagName);
	static class UObject* GetPadBtnTexture_ByOptionSetting(E_OPTION_CONTENT_BUTTON_ICON_TYPE InIconType, E_BTN_ICON_SIZE InIconSize);
	static class FString GetPadBtnTexturePath_ByOptionSetting(E_OPTION_CONTENT_BUTTON_ICON_TYPE InIconType, E_BTN_ICON_SIZE InIconSize);
	static bool IsAxisMapping_ByMappingEnum(E_BTN_HELP_MAPPING_KEY_TYPE InMappingType);
	static bool IsExternalFontKey(const struct FKey& InKey);
	static bool IsKeyboardIconDraw_ByRichTextTag(const class FString& InTagName);
	static bool OnClickedBtnHelpFunc(E_BTN_HELP_MAPPING_KEY_TYPE InMappingType, int32 InIconIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_ButtonHelpData">();
	}
	static class UBPL_ButtonHelpData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_ButtonHelpData>();
	}
};
static_assert(alignof(UBPL_ButtonHelpData) == 0x000008, "Wrong alignment on UBPL_ButtonHelpData");
static_assert(sizeof(UBPL_ButtonHelpData) == 0x000028, "Wrong size on UBPL_ButtonHelpData");

// Class Project.ButtonS5
// 0x0068 (0x0490 - 0x0428)
class UButtonS5 final : public UButton
{
public:
	bool                                          bExclusiveDragMode;                                // 0x0428(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1809[0x17];                                    // 0x0429(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnClickedS5;                                       // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectedS5;                                      // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDraggedS5;                                       // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDroppedS5;                                       // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDropCanceledS5;                                  // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static bool GetButtonS5ExclusiveDragging();
	static void SetButtonS5DebugColor(bool bEnableDebugColor);

	bool IsMouseDragging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonS5">();
	}
	static class UButtonS5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonS5>();
	}
};
static_assert(alignof(UButtonS5) == 0x000008, "Wrong alignment on UButtonS5");
static_assert(sizeof(UButtonS5) == 0x000490, "Wrong size on UButtonS5");
static_assert(offsetof(UButtonS5, bExclusiveDragMode) == 0x000428, "Member 'UButtonS5::bExclusiveDragMode' has a wrong offset!");
static_assert(offsetof(UButtonS5, OnClickedS5) == 0x000440, "Member 'UButtonS5::OnClickedS5' has a wrong offset!");
static_assert(offsetof(UButtonS5, OnSelectedS5) == 0x000450, "Member 'UButtonS5::OnSelectedS5' has a wrong offset!");
static_assert(offsetof(UButtonS5, OnDraggedS5) == 0x000460, "Member 'UButtonS5::OnDraggedS5' has a wrong offset!");
static_assert(offsetof(UButtonS5, OnDroppedS5) == 0x000470, "Member 'UButtonS5::OnDroppedS5' has a wrong offset!");
static_assert(offsetof(UButtonS5, OnDropCanceledS5) == 0x000480, "Member 'UButtonS5::OnDropCanceledS5' has a wrong offset!");

// Class Project.CameraAnimationAsset
// 0x0048 (0x0070 - 0x0028)
class UCameraAnimationAsset final : public UObject
{
public:
	float                                         AnimationTime;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180A[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCameraAnimationLocKey>         LocKeys;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FCameraAnimationRotKey>         RotKeys;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FCameraAnimationFovKey>         FovKeys;                                           // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FCameraAnimationDofKey>         DofKeys;                                           // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraAnimationAsset">();
	}
	static class UCameraAnimationAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraAnimationAsset>();
	}
};
static_assert(alignof(UCameraAnimationAsset) == 0x000008, "Wrong alignment on UCameraAnimationAsset");
static_assert(sizeof(UCameraAnimationAsset) == 0x000070, "Wrong size on UCameraAnimationAsset");
static_assert(offsetof(UCameraAnimationAsset, AnimationTime) == 0x000028, "Member 'UCameraAnimationAsset::AnimationTime' has a wrong offset!");
static_assert(offsetof(UCameraAnimationAsset, LocKeys) == 0x000030, "Member 'UCameraAnimationAsset::LocKeys' has a wrong offset!");
static_assert(offsetof(UCameraAnimationAsset, RotKeys) == 0x000040, "Member 'UCameraAnimationAsset::RotKeys' has a wrong offset!");
static_assert(offsetof(UCameraAnimationAsset, FovKeys) == 0x000050, "Member 'UCameraAnimationAsset::FovKeys' has a wrong offset!");
static_assert(offsetof(UCameraAnimationAsset, DofKeys) == 0x000060, "Member 'UCameraAnimationAsset::DofKeys' has a wrong offset!");

// Class Project.CameraBlend
// 0x0018 (0x0238 - 0x0220)
class ACameraBlend final : public AActor
{
public:
	class AActor*                                 Blend1Actor;                                       // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Blend2Actor;                                       // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendAlpha;                                        // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180B[0x4];                                     // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBlend">();
	}
	static class ACameraBlend* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraBlend>();
	}
};
static_assert(alignof(ACameraBlend) == 0x000008, "Wrong alignment on ACameraBlend");
static_assert(sizeof(ACameraBlend) == 0x000238, "Wrong size on ACameraBlend");
static_assert(offsetof(ACameraBlend, Blend1Actor) == 0x000220, "Member 'ACameraBlend::Blend1Actor' has a wrong offset!");
static_assert(offsetof(ACameraBlend, Blend2Actor) == 0x000228, "Member 'ACameraBlend::Blend2Actor' has a wrong offset!");
static_assert(offsetof(ACameraBlend, BlendAlpha) == 0x000230, "Member 'ACameraBlend::BlendAlpha' has a wrong offset!");

// Class Project.BPL_CameraSettingsData
// 0x0000 (0x0028 - 0x0028)
class UBPL_CameraSettingsData final : public UBlueprintFunctionLibrary
{
public:
	static void GetCameraPresetData(const class UObject* WorldContextObject, int32 MapId, struct FCameraMapData* CameraMapData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CameraSettingsData">();
	}
	static class UBPL_CameraSettingsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CameraSettingsData>();
	}
};
static_assert(alignof(UBPL_CameraSettingsData) == 0x000008, "Wrong alignment on UBPL_CameraSettingsData");
static_assert(sizeof(UBPL_CameraSettingsData) == 0x000028, "Wrong size on UBPL_CameraSettingsData");

// Class Project.FoliageDitherData
// 0x0050 (0x0078 - 0x0028)
class UFoliageDitherData : public UObject
{
public:
	TMap<TSoftObjectPtr<class UStaticMesh>, struct FTreeDitherData> DitherExclusionData;                               // 0x0028(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageDitherData">();
	}
	static class UFoliageDitherData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageDitherData>();
	}
};
static_assert(alignof(UFoliageDitherData) == 0x000008, "Wrong alignment on UFoliageDitherData");
static_assert(sizeof(UFoliageDitherData) == 0x000078, "Wrong size on UFoliageDitherData");
static_assert(offsetof(UFoliageDitherData, DitherExclusionData) == 0x000028, "Member 'UFoliageDitherData::DitherExclusionData' has a wrong offset!");

// Class Project.CameraDitherComponent
// 0x00B0 (0x0160 - 0x00B0)
class UCameraDitherComponent : public UActorComponent
{
public:
	TSubclassOf<class UFoliageDitherData>         FoliageDitherDataClass;                            // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFoliageInstancedStaticMeshComponent*> FoliageCompList;                                   // 0x00B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaskedMeshStructure>           MaskedMeshes;                                      // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFadeInMeshStructure>           FadeMeshes;                                        // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaskedMeshStructure>           CheckMasks;                                        // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ECollisionChannel                             DitherChannel;                                     // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180C[0x3];                                     // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CurveFloat;                                        // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    M_CameraBoom;                                      // 0x0108(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       M_CameraComponent;                                 // 0x0110(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      M_CapsuleComponent;                                // 0x0118(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_TraceHeightOffset;                               // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_TraceHeight;                                     // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_TraceWidth;                                      // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               M_TraceChannel;                                    // 0x012C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDrawDebugTrace                               M_TraceVisibility;                                 // 0x012D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180D[0x2];                                     // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_LineWidth;                                       // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_FallOff;                                         // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_StartTraceLoc;                                   // 0x0138(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_EndTraceLoc;                                     // 0x0144(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_TraceSize;                                       // 0x0150(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180E[0x4];                                     // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateHitLocation(class UObject* WorldContextObject, struct FVector* HitLocation);
	void FadeInMaskedMeshes(float DeltaTime);
	void InitializeDitherState();
	void MaskExuldedFoliages();
	void MaskHitMeshes(class UObject* WorldContextObject, TArray<struct FHitResult>& HitResults);
	void ToggleDitherState(bool NewDitherState);
	bool TraceForMaskingObjects(class UObject* WorldContextObject, TArray<struct FHitResult>* HitResults);
	void UnmaskMeshes(class UObject* WorldContextObject);
	void UpdateDitherFoliageActorList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraDitherComponent">();
	}
	static class UCameraDitherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraDitherComponent>();
	}
};
static_assert(alignof(UCameraDitherComponent) == 0x000008, "Wrong alignment on UCameraDitherComponent");
static_assert(sizeof(UCameraDitherComponent) == 0x000160, "Wrong size on UCameraDitherComponent");
static_assert(offsetof(UCameraDitherComponent, FoliageDitherDataClass) == 0x0000B0, "Member 'UCameraDitherComponent::FoliageDitherDataClass' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, FoliageCompList) == 0x0000B8, "Member 'UCameraDitherComponent::FoliageCompList' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, MaskedMeshes) == 0x0000C8, "Member 'UCameraDitherComponent::MaskedMeshes' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, FadeMeshes) == 0x0000D8, "Member 'UCameraDitherComponent::FadeMeshes' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, CheckMasks) == 0x0000E8, "Member 'UCameraDitherComponent::CheckMasks' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, DitherChannel) == 0x0000F8, "Member 'UCameraDitherComponent::DitherChannel' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, FadeTime) == 0x0000FC, "Member 'UCameraDitherComponent::FadeTime' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, CurveFloat) == 0x000100, "Member 'UCameraDitherComponent::CurveFloat' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_CameraBoom) == 0x000108, "Member 'UCameraDitherComponent::M_CameraBoom' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_CameraComponent) == 0x000110, "Member 'UCameraDitherComponent::M_CameraComponent' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_CapsuleComponent) == 0x000118, "Member 'UCameraDitherComponent::M_CapsuleComponent' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_TraceHeightOffset) == 0x000120, "Member 'UCameraDitherComponent::M_TraceHeightOffset' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_TraceHeight) == 0x000124, "Member 'UCameraDitherComponent::M_TraceHeight' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_TraceWidth) == 0x000128, "Member 'UCameraDitherComponent::M_TraceWidth' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_TraceChannel) == 0x00012C, "Member 'UCameraDitherComponent::M_TraceChannel' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_TraceVisibility) == 0x00012D, "Member 'UCameraDitherComponent::M_TraceVisibility' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_LineWidth) == 0x000130, "Member 'UCameraDitherComponent::M_LineWidth' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_FallOff) == 0x000134, "Member 'UCameraDitherComponent::M_FallOff' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_StartTraceLoc) == 0x000138, "Member 'UCameraDitherComponent::M_StartTraceLoc' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_EndTraceLoc) == 0x000144, "Member 'UCameraDitherComponent::M_EndTraceLoc' has a wrong offset!");
static_assert(offsetof(UCameraDitherComponent, M_TraceSize) == 0x000150, "Member 'UCameraDitherComponent::M_TraceSize' has a wrong offset!");

// Class Project.CameraDitherVisualizer
// 0x0088 (0x02A8 - 0x0220)
class ACameraDitherVisualizer final : public AActor
{
public:
	ECollisionChannel                             MaskedCollisionChannel;                            // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1811[0x7];                                     // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           LevelGoodMaskedSMActorComponents;                  // 0x0228(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           LevelBadMaskedSMActorComponents;                   // 0x0238(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UMaterialInterface*>        InstanceOverridenMaterials;                        // 0x0248(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     GoodMaterial;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BadMaterial;                                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FindValidDitherTargets();
	void UnvisualizeMaskableMeshes();
	void VisualizeMaskableMeshes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraDitherVisualizer">();
	}
	static class ACameraDitherVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraDitherVisualizer>();
	}
};
static_assert(alignof(ACameraDitherVisualizer) == 0x000008, "Wrong alignment on ACameraDitherVisualizer");
static_assert(sizeof(ACameraDitherVisualizer) == 0x0002A8, "Wrong size on ACameraDitherVisualizer");
static_assert(offsetof(ACameraDitherVisualizer, MaskedCollisionChannel) == 0x000220, "Member 'ACameraDitherVisualizer::MaskedCollisionChannel' has a wrong offset!");
static_assert(offsetof(ACameraDitherVisualizer, LevelGoodMaskedSMActorComponents) == 0x000228, "Member 'ACameraDitherVisualizer::LevelGoodMaskedSMActorComponents' has a wrong offset!");
static_assert(offsetof(ACameraDitherVisualizer, LevelBadMaskedSMActorComponents) == 0x000238, "Member 'ACameraDitherVisualizer::LevelBadMaskedSMActorComponents' has a wrong offset!");
static_assert(offsetof(ACameraDitherVisualizer, InstanceOverridenMaterials) == 0x000248, "Member 'ACameraDitherVisualizer::InstanceOverridenMaterials' has a wrong offset!");
static_assert(offsetof(ACameraDitherVisualizer, GoodMaterial) == 0x000298, "Member 'ACameraDitherVisualizer::GoodMaterial' has a wrong offset!");
static_assert(offsetof(ACameraDitherVisualizer, BadMaterial) == 0x0002A0, "Member 'ACameraDitherVisualizer::BadMaterial' has a wrong offset!");

// Class Project.CameraPath
// 0x0088 (0x02A8 - 0x0220)
class ACameraPath final : public AActor
{
public:
	float                                         CurrentPositionOnPath;                             // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CAMERA_PATH_INPUT_KEY_MODE                  PathInputKeyMode;                                  // 0x0224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CAMERA_PATH_INPUT_KEY_MODE                  RailInputKeyMode;                                  // 0x0225(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CAMERA_PATH_INPUT_KEY_MODE                  TargetInputKeyMode;                                // 0x0226(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLookAtTracking;                             // 0x0227(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultUpVector;                                   // 0x0228(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePathUpVector;                                  // 0x0234(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePathFieldOfView;                               // 0x0235(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1812[0x2];                                     // 0x0236(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RailInterpSpeed;                                   // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetInterpSpeed;                                 // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param1Cache;                                       // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param2Cache;                                       // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param3Cache;                                       // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param4Cache;                                       // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param5Cache;                                       // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param6Cache;                                       // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param7Cache;                                       // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param8Cache;                                       // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TransformComponent;                                // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPathComponent*                         PathComponent;                                     // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       RailSplineComponent;                               // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RailCameraMount;                                   // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       TargetSplineComponent;                             // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1813[0x20];                                    // 0x0288(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LookAt(class USceneComponent* Point, class FName Socket);
	void ResetInterp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraPath">();
	}
	static class ACameraPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraPath>();
	}
};
static_assert(alignof(ACameraPath) == 0x000008, "Wrong alignment on ACameraPath");
static_assert(sizeof(ACameraPath) == 0x0002A8, "Wrong size on ACameraPath");
static_assert(offsetof(ACameraPath, CurrentPositionOnPath) == 0x000220, "Member 'ACameraPath::CurrentPositionOnPath' has a wrong offset!");
static_assert(offsetof(ACameraPath, PathInputKeyMode) == 0x000224, "Member 'ACameraPath::PathInputKeyMode' has a wrong offset!");
static_assert(offsetof(ACameraPath, RailInputKeyMode) == 0x000225, "Member 'ACameraPath::RailInputKeyMode' has a wrong offset!");
static_assert(offsetof(ACameraPath, TargetInputKeyMode) == 0x000226, "Member 'ACameraPath::TargetInputKeyMode' has a wrong offset!");
static_assert(offsetof(ACameraPath, bEnableLookAtTracking) == 0x000227, "Member 'ACameraPath::bEnableLookAtTracking' has a wrong offset!");
static_assert(offsetof(ACameraPath, DefaultUpVector) == 0x000228, "Member 'ACameraPath::DefaultUpVector' has a wrong offset!");
static_assert(offsetof(ACameraPath, bUsePathUpVector) == 0x000234, "Member 'ACameraPath::bUsePathUpVector' has a wrong offset!");
static_assert(offsetof(ACameraPath, bUsePathFieldOfView) == 0x000235, "Member 'ACameraPath::bUsePathFieldOfView' has a wrong offset!");
static_assert(offsetof(ACameraPath, RailInterpSpeed) == 0x000238, "Member 'ACameraPath::RailInterpSpeed' has a wrong offset!");
static_assert(offsetof(ACameraPath, TargetInterpSpeed) == 0x00023C, "Member 'ACameraPath::TargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(ACameraPath, Param1Cache) == 0x000240, "Member 'ACameraPath::Param1Cache' has a wrong offset!");
static_assert(offsetof(ACameraPath, Param2Cache) == 0x000244, "Member 'ACameraPath::Param2Cache' has a wrong offset!");
static_assert(offsetof(ACameraPath, Param3Cache) == 0x000248, "Member 'ACameraPath::Param3Cache' has a wrong offset!");
static_assert(offsetof(ACameraPath, Param4Cache) == 0x00024C, "Member 'ACameraPath::Param4Cache' has a wrong offset!");
static_assert(offsetof(ACameraPath, Param5Cache) == 0x000250, "Member 'ACameraPath::Param5Cache' has a wrong offset!");
static_assert(offsetof(ACameraPath, Param6Cache) == 0x000254, "Member 'ACameraPath::Param6Cache' has a wrong offset!");
static_assert(offsetof(ACameraPath, Param7Cache) == 0x000258, "Member 'ACameraPath::Param7Cache' has a wrong offset!");
static_assert(offsetof(ACameraPath, Param8Cache) == 0x00025C, "Member 'ACameraPath::Param8Cache' has a wrong offset!");
static_assert(offsetof(ACameraPath, TransformComponent) == 0x000260, "Member 'ACameraPath::TransformComponent' has a wrong offset!");
static_assert(offsetof(ACameraPath, PathComponent) == 0x000268, "Member 'ACameraPath::PathComponent' has a wrong offset!");
static_assert(offsetof(ACameraPath, RailSplineComponent) == 0x000270, "Member 'ACameraPath::RailSplineComponent' has a wrong offset!");
static_assert(offsetof(ACameraPath, RailCameraMount) == 0x000278, "Member 'ACameraPath::RailCameraMount' has a wrong offset!");
static_assert(offsetof(ACameraPath, TargetSplineComponent) == 0x000280, "Member 'ACameraPath::TargetSplineComponent' has a wrong offset!");

// Class Project.BPL_CampAnalyze
// 0x0000 (0x0028 - 0x0028)
class UBPL_CampAnalyze final : public UBlueprintFunctionLibrary
{
public:
	static TArray<int32> CampAnalyze_GetAnalyzeOpenList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CampAnalyze">();
	}
	static class UBPL_CampAnalyze* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CampAnalyze>();
	}
};
static_assert(alignof(UBPL_CampAnalyze) == 0x000008, "Wrong alignment on UBPL_CampAnalyze");
static_assert(sizeof(UBPL_CampAnalyze) == 0x000028, "Wrong size on UBPL_CampAnalyze");

// Class Project.BPL_MapEventData
// 0x0000 (0x0028 - 0x0028)
class UBPL_MapEventData final : public UBlueprintFunctionLibrary
{
public:
	static const struct FMapEventData GetMapEventData(int32 ID);
	static const struct FMapEventData GetMapEventDataFromMapEventId(int32 _mapEventID);
	static int32 GetMapEventDataNum();
	static int32 GetMapEventIdFromIndex(int32 _mapEventID);
	static void GetMapEventNext(int32 _nowMapEventId, int32* NextMapId, int32* NextAreaId, int32* NextWarpPoint, int32* _nextMapEventId);
	static bool IsMapEventActivateFlags(int32 _mapEventID);
	static bool IsMapEventActivateFlagsFromData(const struct FMapEventData& MapEventData);
	static void SetMapEventAfterFlag(int32 _mapEventID, bool Value);
	static void SetMapEventEndFlag(int32 _mapEventID, bool Value);
	static void SetMapEventStartFlags(int32 _mapEventID, bool Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MapEventData">();
	}
	static class UBPL_MapEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MapEventData>();
	}
};
static_assert(alignof(UBPL_MapEventData) == 0x000008, "Wrong alignment on UBPL_MapEventData");
static_assert(sizeof(UBPL_MapEventData) == 0x000028, "Wrong size on UBPL_MapEventData");

// Class Project.CampCharaPanelCtrlBase
// 0x0278 (0x0498 - 0x0220)
class ACampCharaPanelCtrlBase final : public AActor
{
public:
	uint8                                         Pad_181B[0x278];                                   // 0x0220(0x0278)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddPartyListFlag(int32 InIndex, E_CAMPCHARAPANELFLAG InType, int32 InCursorOffset);
	bool BackUpForSortAnalyzeData();
	bool BackUpForSortPartyData(int32 InIndex, int32 InOffset);
	bool BackUpForSortUtsusemiData();
	void BIEResetCampCharaPanelReserveHPMPParam(int32 InIndex);
	void BIESetCampCharaPanelAllRecoveryEffect(float InStartTime);
	void BIESetCampCharaPanelCalcHPMPParam(int32 InIndex, int32 InHp, int32 InMp, int32 InFrame);
	void BIESetCampCharaPanelMaxHPMPParam(int32 InIndex, int32 InNkmIndex, int32 InNowType);
	void BIESetCampCharaPanelReserveHPMPParam(int32 InIndex, int32 InHp, int32 InMp);
	void BIESetCampCharaPanelUnselectablePanelOff(int32 InIndex);
	void BIESetCampCharaPanelUnselectablePanelOn(int32 InIndex);
	void BIESetFadeOutPanelAnimation(int32 InIndex);
	void BIESetInitializePanelAnimation(int32 InIndex);
	void BIESetNewIconFrame();
	void BIESetRecoveryAnimation(int32 InIndex, int32 InParam);
	void BIESetRecoveryAnimationTime(int32 InIndex, float InStartTime, int32 InParam);
	void BIESetRecoveryVNumberHPMP(int32 InIndex, float InStartTime, int32 InValueHp, int32 InValueMp);
	int32 CalcScrollBarClickedByAnalyze(float InRate, int32 InOffsetType);
	int32 CalcScrollBarClickedByParty(float InRate, int32 InType);
	int32 CalcScrollBarClickedByUtsusemi(float InRate, int32 InOffsetType);
	int32 CalcUseItemMaxNumber(int32 InUseItemId, int32 InIndex, bool InSingleUsed);
	bool CalcUseMessageTagParam(int32 InUseMessageType, int32 InUseId, int32 InIndex);
	int32 CanBeDeletedAsSrc(int32 InSrcIndex);
	int32 CanBeSelectedAsDst(int32 InSrcIndex, int32 InSrcType, int32 InDstIndex, int32 InSrcCursorOffset, int32 InDstCursorOffset);
	int32 CanBeSelectedAsSrc(int32 InSrcIndex);
	bool CanBeSelectedAsStatusTarget(int32 InSrcIndex, int32 InOffsetCursor);
	bool CanBeSelectedTarget(int32 InIndex, bool InAllTarget);
	bool CanBeUseSelectedItem(int32 InItemId);
	bool CanBeUseSelectedSkill(int32 InUseSkillId, int32 InUseNkmIndex);
	bool ChangeSelectedPanel(int32 InSrcIndex, int32 InSrcType, int32 InDstIndex, int32 InDstType);
	bool ChangeSortAscending();
	bool CreateAnalyzeEntryList(int32 InMode);
	bool CreateStockSortList();
	bool CreateUseItemTargetList(int32 InUseItemId);
	bool CreateUseSkillTargetList(int32 InUseSkillId, int32 InUseNkmIndex);
	bool CreateUtsusemiEntryList();
	bool CreateUtsusemiSkillBuffer();
	bool DeleteCharaPanel(int32 InSrcIndex);
	bool DeletePanelList();
	int32 DelPartyListFlag(int32 InIndex, E_CAMPCHARAPANELFLAG InType, int32 InCursorOffset);
	bool DidUseInUtsusemi(int32 InIndex);
	bool EntryNkmList(int32 InIndex, int32 InNkmIndex, int32 InCursorOffset);
	int32 EntryPartyList(int32 InIndex, E_CAMPCHARAPANELFLAG InType, int32 InCursorOffset);
	int32 GetAddGodParameterPoint();
	int32 GetAnalyzeCount();
	int32 GetAnalyzeCursorPosition();
	int32 GetAnalyzeDevilIdByIndex(int32 InIndex);
	int32 GetAnalyzeMaxDisplayCount();
	int32 GetAnalyzeMoveCursorOffsetPositionIndex(int32 InIndex, int32 InMoveIndex, bool InScrollLock);
	int32 GetAnalyzeMoveCursorOffsetPositionIndexByScrollBar(int32 InIndex, int32 InMoveIndex, int32 InScrollLock);
	int32 GetAnalyzeMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex);
	bool GetAnalyzeNewIconByIndex(int32 InIndex);
	int32 GetAnalyzeOffsetCursorPosition();
	int32 GetBattleIndexByStockIndex(int32 InIndex);
	bool GetCharaMovingCursor(int32 InType);
	int32 GetCursorIndexByUseTargetList(int32 InStartIndex);
	int32 GetDevilIdByIndex(int32 InIndex);
	int32 GetEnemyType();
	E_ABILITYNAME_TYPE GetISAbilityNameType();
	uint8 GetISNkmIndex();
	E_SKILL_TEKISEI_CATEGORY GetISSkillTekiseiGategory();
	int32 GetISValueParam(int32 InValueIndex);
	int32 GetItemNumber();
	int32 GetItemNumberPosition();
	int32 GetMaxNumberOfItem();
	int32 GetMaxStockNumber();
	int32 GetMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex, int32 InOffsetType);
	int32 GetMoveOffsetCursorPositionIndex(int32 InIndex, int32 InMoveIndex, int32 InOffsetType, bool InScrollLock);
	int32 GetMoveOffsetCursorPositionIndexByScrollBar(int32 InIndex, int32 InOffsetIndex, int32 InMoveIndex, int32 InOffsetType);
	struct FVector2D GetMovePanelAnimation(int32 InCategory);
	struct FVector2D GetMovePanelPosition(int32 InCategory);
	int32 GetNewIconFrameRate();
	int32 GetNkmIndexOfUseTargetList(int32 InIndex);
	int32 GetNkmIndexOfUseTargetListInOffset(int32 InIndex, int32 InCursorOffset);
	int32 GetPanelIndexByNkmIndex(int32 InNkmIndex);
	struct FVector2D GetPanelPositionByIndex(int32 InIndex, const struct FVector2D& InVec2D, int32 InCheckType);
	int32 GetPartyCursorWithInDrawRange(int32 InIndex, int32 InCursorOffset);
	int32 GetPartyListDstOffsetIndex();
	int32 GetPartyListOffsetIndex();
	int32 GetPartyMaxDisplayCount();
	bool GetRecoveryAllSEFlag();
	int32 GetSkillCostByNkmIndex(int32 InUseSkillId, int32 InUseNkmIndex);
	bool GetSortAscending();
	int32 GetSortCursorOffset();
	int32 GetSortType(int32 InPanelType);
	int32 GetStockDispNumber();
	int32 GetStockIndexByAddOffset(int32 InIndex, int32 InCursorOffset);
	int32 GetStockIndexByBattleIndex(int32 InIndex);
	int32 GetStockIndexByNkmIndex(int32 InNkmIndex);
	int32 GetStockNumber();
	int32 GetSummonTargetInStock(int32 InIndex);
	int32 GetTargetListOffsetIndex();
	int32 GetUseItemMessage(int32 InUseItemId, int32 InIndex);
	bool GetUseMessageTagParam(int32 InUseMessageType, int32 InUseId, int32 InIndex);
	int32 GetUtsusemiCount();
	int32 GetUtsusemiCursorPosition();
	int32 GetUtsusemiDevilIdByIndex(int32 InIndex);
	int32 GetUtsusemiItemHelpMessageIdByIndex(int32 InIndex);
	int32 GetUtsusemiMaxDisplayCount();
	int32 GetUtsusemiMoveCursorOffsetPositionIndex(int32 InIndex, int32 InMoveIndex, bool InScrollLock);
	int32 GetUtsusemiMoveCursorOffsetPositionIndexByScroll(int32 InIndex, int32 InMoveIndex, int32 InScrollLock);
	int32 GetUtsusemiMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex);
	bool GetUtsusemiNewIconByIndex(int32 InIndex);
	int32 GetUtsusemiOffsetCursorPosition();
	bool InitializeCharaPanelCursor(int32 InType);
	bool InitializeEntryPartyList();
	bool InitializeSortCursor(int32 InType, int32 InCursorPosition, int32 InCursorOffset);
	bool InitializeUtsusemiSkillBuffer();
	bool IsAnalyzeExistIndexInParty(int32 InIndex);
	bool IsCharaPanelAnimation();
	bool IsDead(int32 InIndex);
	bool IsExistUtsusemiInShop(int32 InIndex);
	bool IsGuestParty(int32 InIndex, int32 InOffsetCursor);
	bool IsIndexPanelSummoned(int32 InIndex);
	bool IsMovePanelAnimation(int32 InCategory);
	int32 IsMultipleUseItem(int32 InUseItemId);
	bool IsNewIconOfAllAnalyzesOff();
	bool IsNewIconOfAllUtsusemiOff();
	bool IsPartyCursorWithInDrawRange(int32 InIndex, int32 InCursorOffset);
	bool IsSummonAnimation();
	int32 MoveEnemyType(int32 InMoveIndex);
	int32 MoveItemNumberPosition(int32 InMoveIndex, bool InForceLoopEnd);
	int32 MoveOffsetSortType(int32 InPanelType, int32 InMoveOffsetSortType, bool InScrollLock);
	int32 MoveSortType(int32 InPanelType, int32 InMoveSortType);
	void RebuildStatusCharaList(class UUIStatusCtrlDataObjCampParty* StatusUIDataObj);
	void RebuildStatusCharaList_Analyze(class UUIStatusCtrlDataObjCampParty* StatusUIDataObj);
	void RebuildStatusCharaList_Utsusemi(class UUIStatusCtrlDataObjCampParty* StatusUIDataObj);
	bool ResetCharaMovingCursor(int32 InType);
	bool ResetMovingCursor(int32 InType);
	bool ResetReserveHPMPParam();
	bool ResetUnselectablePanel();
	bool ResetUnselectablePanelByUtsusemi(int32 InIndex);
	int32 SetAnalyzeCursorPositionIndex(int32 InCursorPosition, int32 InCursorOffset);
	int32 SetAnalyzeInitializeCursorPositionIndex(int32 InIndex);
	bool SetAnalyzeNewIconByIndex(int32 InIndex);
	bool SetAnalyzeNewIconByOffsetIndex(int32 InEnemyType, int32 InOffsetIndex, int32 InIndex);
	int32 SetAnalyzePanelPositionBySelectAnalyzeId();
	bool SetCharaMovingCursor(int32 InType);
	bool SetEnemyType(int32 InEnemyType);
	int32 SetEnemyTypeCursor(int32 InIndex);
	bool SetExtractSortUtsusemiList(int32 InSortType);
	bool SetItemCalcOnPanelAll(int32 InUseItemId, int32 InUseItemNumber);
	bool SetItemCalcOnPanelByIndex(int32 InUseItemId, int32 InIndex, int32 InUseItemNumber);
	bool SetItemNumberPosition();
	bool SetMovePanelPosition(const struct FVector2D& InPos, int32 InCategory, int32 InType);
	bool SetMovePanelSpeed(int32 InCategory, float InMoveSpeed);
	bool SetMovingCursor(int32 InType);
	bool SetPartyCursorParameter(int32 InCursor, int32 InOffset);
	int32 SetPartyInitializeCursorPositionIndex(int32 InIndex);
	bool SetPartyListDstOffsetIndex(int32 InOffsetIndex);
	bool SetPartyListOffsetIndex(int32 InOffsetIndex);
	int32 SetPartyPanelPositionBySelectNkmId(int32 InType);
	bool SetSkillCalcOnPanelAll(int32 InUseSkillId, int32 InUseNkmIndex);
	bool SetSkillCalcOnPanelByIndex(int32 InUseSkillId, int32 InUseNkmIndex, int32 InIndex);
	bool SetSortAnalyzeList(int32 InSortType);
	bool SetSortAscending(bool InAscending);
	bool SetSortStockList(int32 InSortType);
	bool SetSortType(int32 InPanelType, int32 InSortType);
	bool SetSortUtsusemiList(int32 InSortType);
	int32 SetStockInitializeCursorPositionIndex(int32 InIndex, int32 InType);
	bool SetStockSortToParty();
	bool SetTargetListOffsetIndex(int32 InOffsetIndex);
	bool SetUnselectablePanelByUtsusemi(int32 InIndex);
	int32 SetUnselectableTargetPanelOn(int32 InIndex);
	bool SetUseItemTargetListPanel(int32 InUseItemId);
	bool SetUseSkillTargetListPanel(int32 InUseSkillId, int32 InUseNkmIndex);
	int32 SetUtsusemiCursorPositionIndex(int32 InCursorPosition, int32 InCursorOffset);
	int32 SetUtsusemiInitializeCursorPositionIndex(int32 InIndex);
	bool SetUtsusemiNewIconByIndex(int32 InIndex);
	bool SetUtsusemiNewIconByOffsetIndex(int32 InOffsetIndex, int32 InIndex);
	int32 SetUtsusemiPanelPositionBySelectUtsusemiId();
	bool SortUtsusemiSkillBuffer();
	bool StartCharaPanelAnimation();
	bool StartCharaPanelFadeOutAnimation();
	bool StartMovePanelAnimation(int32 InCategory);
	bool StartSummonAnimation(float InWaitTime);
	bool StopCharaPanelAnimation();
	bool StopMovePanelAnimation(int32 InCategory);
	bool StopSummonAnimation();
	bool UpDateAnalyzeExistInParty();
	bool UseItem(int32 InUseItemId, int32 InIndex, bool InSingleUsed, int32 InUseItemNumber);
	bool UseSkill(int32 InUseSkillId, int32 InUseNkmIndex, int32 InTargetIndex, bool InSingleUsed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampCharaPanelCtrlBase">();
	}
	static class ACampCharaPanelCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampCharaPanelCtrlBase>();
	}
};
static_assert(alignof(ACampCharaPanelCtrlBase) == 0x000008, "Wrong alignment on ACampCharaPanelCtrlBase");
static_assert(sizeof(ACampCharaPanelCtrlBase) == 0x000498, "Wrong size on ACampCharaPanelCtrlBase");

// Class Project.CampCommandTable
// 0x0088 (0x00B0 - 0x0028)
class UCampCommandTable final : public UObject
{
public:
	TArray<struct FCampCommandData>               M_CommandData;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_CommandName;                                     // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_CommandHelp;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1861[0x58];                                    // 0x0058(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Finalize();
	struct FCampCommandData GetCampCommandData(E_CAMP_COMMAND_ID ID);
	TArray<struct FCampCommandData> GetCampCommandDataAll();
	class FText GetCampCommandHelp(E_CAMP_COMMAND_ID ID);
	class FText GetCampCommandName(E_CAMP_COMMAND_ID ID);
	bool MakeUp(class UMMIAsset* PAsset, class UScriptMessageAsset* PCommandName, class UScriptMessageAsset* PCommandHelp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampCommandTable">();
	}
	static class UCampCommandTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampCommandTable>();
	}
};
static_assert(alignof(UCampCommandTable) == 0x000008, "Wrong alignment on UCampCommandTable");
static_assert(sizeof(UCampCommandTable) == 0x0000B0, "Wrong size on UCampCommandTable");
static_assert(offsetof(UCampCommandTable, M_CommandData) == 0x000028, "Member 'UCampCommandTable::M_CommandData' has a wrong offset!");
static_assert(offsetof(UCampCommandTable, M_CommandName) == 0x000038, "Member 'UCampCommandTable::M_CommandName' has a wrong offset!");
static_assert(offsetof(UCampCommandTable, M_CommandHelp) == 0x000048, "Member 'UCampCommandTable::M_CommandHelp' has a wrong offset!");

// Class Project.BPL_KeyConfig
// 0x0000 (0x0028 - 0x0028)
class UBPL_KeyConfig final : public UBlueprintFunctionLibrary
{
public:
	static void AddActionMappingKey(E_ACTION_MAPPING_TYPE ActionMapping, const struct FKey& Key);
	static void AddAxisMappingKey(E_AXIS_MAPPING_TYPE AxisMapping, const struct FKey& Key, float Scale);
	static void ClearActionMappingKey(E_ACTION_MAPPING_TYPE ActionMapping, bool Gamepad, bool Keyboard, bool MouseButton, bool OtherKey);
	static void ClearAxisMappingKey(E_AXIS_MAPPING_TYPE AxisMapping, bool Gamepad, bool Keyboard, bool MouseButton, bool OtherKey);
	static void ConvertKeys_ForController(const TArray<struct FKey>& InKeys, TArray<struct FKey>* OutKeys, bool Gamepad, bool Keyboard, bool Mouse, bool OtherKey);
	static void GetActionMapping_FromKey(const struct FKey& Key, TArray<E_ACTION_MAPPING_TYPE>* ActionMappings);
	static bool GetActionMappingKey_ForHelp(E_ACTION_MAPPING_TYPE ActionMapping, struct FKey* Key);
	static void GetActionMappingKeys(E_ACTION_MAPPING_TYPE ActionMapping, TArray<struct FKey>* Keys, bool Gamepad, bool Keyboard, bool MouseButton, bool OtherKey);
	static void GetAxisMapping_FromKey(const struct FKey& Key, TArray<E_AXIS_MAPPING_TYPE>* AxisMappings);
	static void GetAxisMappingKeys(E_AXIS_MAPPING_TYPE AxisMapping, TArray<struct FKey>* Keys, TArray<float>* Scales, bool Gamepad, bool Keyboard, bool MouseButton, bool OtherKey);
	static bool GetAxisMappingKeys_ForHelp(E_AXIS_MAPPING_TYPE AxisMapping, TArray<struct FKey>* Keys);
	static TArray<struct FActionMappingInfoRow> GetDefaultActionMappingRows(const class UObject* WorldContextObject);
	static bool GetDefaultMainKey_FromActionMapping(const class UObject* WorldContextObject, E_ACTION_MAPPING_TYPE ActionMapping, struct FKey* Key, bool Gamepad);
	static bool GetDefaultMainKey_FromAxisMapping(const class UObject* WorldContextObject, E_AXIS_MAPPING_TYPE AxisMapping, bool Plus, struct FKey* Key, bool Gamepad);
	static bool GetDefaultSubKey_FromActionMapping(const class UObject* WorldContextObject, E_ACTION_MAPPING_TYPE ActionMapping, struct FKey* Key, bool Gamepad);
	static bool GetDefaultSubKey_FromAxisMapping(const class UObject* WorldContextObject, E_AXIS_MAPPING_TYPE AxisMapping, bool Plus, struct FKey* Key, bool Gamepad);
	static bool GetMainKey_FromActionMapping(E_ACTION_MAPPING_TYPE ActionMapping, struct FKey* Key, bool Gamepad);
	static bool GetMainKey_FromAxisMapping(E_AXIS_MAPPING_TYPE AxisMapping, bool Plus, struct FKey* Key, bool Gamepad);
	static bool GetSafetyKey_FromActionMapping(E_ACTION_MAPPING_TYPE ActionMapping, struct FKey* Key);
	static bool GetSafetyKey_FromAxisMapping(E_AXIS_MAPPING_TYPE AxisMapping, bool Plus, struct FKey* Key);
	static float GetStickSensitivityScale(const class UObject* WorldContextObject);
	static bool GetSubKey_FromActionMapping(E_ACTION_MAPPING_TYPE ActionMapping, struct FKey* Key, bool Gamepad);
	static bool GetSubKey_FromAxisMapping(E_AXIS_MAPPING_TYPE AxisMapping, bool Plus, struct FKey* Key, bool Gamepad);
	static void LoadActionAxisMapping(const class UObject* WorldContextObject, bool SystemSaveLoad);
	static void RemoveActionMappingKey(E_ACTION_MAPPING_TYPE ActionMapping, const struct FKey& Key);
	static void RemoveAxisMappingKey(E_AXIS_MAPPING_TYPE AxisMapping, const struct FKey& Key);
	static void ResetActionMappingToDefault(const class UObject* WorldContextObject, bool Gamepad, bool Keyboard, bool MouseButton, bool OtherKey);
	static void ResetAxisMappingToDefault(const class UObject* WorldContextObject, bool Gamepad, bool Keyboard, bool MouseButton, bool OtherKey);
	static void RewriteActionMapping_ActionAndCancel(const class UObject* WorldContextObject, bool Reverse);
	static void RewriteActionMapping_FieldL3(E_StickButtonAction StickButtonAction);
	static void RewriteActionMapping_FieldR3(E_StickButtonAction StickButtonAction);
	static void RewriteActionMapping_MovieSkip(const class UObject* WorldContextObject, bool Reverse);
	static void SaveActionAxisMapping(const class UObject* WorldContextObject, bool SystemSave);
	static bool SetMainKey_FromActionMapping(E_ACTION_MAPPING_TYPE ActionMapping, const struct FKey& Key);
	static bool SetMainKey_FromAxisMapping(E_AXIS_MAPPING_TYPE AxisMapping, bool Plus, const struct FKey& Key);
	static void SetStickSensitivity(int32 Volume);
	static bool SetSubKey_FromActionMapping(E_ACTION_MAPPING_TYPE ActionMapping, const struct FKey& Key);
	static bool SetSubKey_FromAxisMapping(E_AXIS_MAPPING_TYPE AxisMapping, bool Plus, const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_KeyConfig">();
	}
	static class UBPL_KeyConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_KeyConfig>();
	}
};
static_assert(alignof(UBPL_KeyConfig) == 0x000008, "Wrong alignment on UBPL_KeyConfig");
static_assert(sizeof(UBPL_KeyConfig) == 0x000028, "Wrong size on UBPL_KeyConfig");

// Class Project.CampControlBase
// 0x0000 (0x0220 - 0x0220)
class ACampControlBase final : public AActor
{
public:
	void AddTaskDebugUpDate(E_CAMP_DEBUG_UPDATE_TASK_TYPE TaskType);
	bool CheckCampOpenFlag();
	bool IsCampOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampControlBase">();
	}
	static class ACampControlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampControlBase>();
	}
};
static_assert(alignof(ACampControlBase) == 0x000008, "Wrong alignment on ACampControlBase");
static_assert(sizeof(ACampControlBase) == 0x000220, "Wrong size on ACampControlBase");

// Class Project.BPL_CampDebug
// 0x0000 (0x0028 - 0x0028)
class UBPL_CampDebug final : public UBlueprintFunctionLibrary
{
public:
	static void CampDebug_AddNkmHp(int32 NkmIndex, int32 Add);
	static void CampDebug_AddNkmMp(int32 NkmIndex, int32 Add);
	static void CampDebug_AddPlayerHp(int32 Add);
	static void CampDebug_AddPlayerMp(int32 Add);
	static void CampDebug_AllCure();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CampDebug">();
	}
	static class UBPL_CampDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CampDebug>();
	}
};
static_assert(alignof(UBPL_CampDebug) == 0x000008, "Wrong alignment on UBPL_CampDebug");
static_assert(sizeof(UBPL_CampDebug) == 0x000028, "Wrong size on UBPL_CampDebug");

// Class Project.MapGimmickDebug
// 0x0000 (0x0028 - 0x0028)
class UMapGimmickDebug final : public UObject
{
public:
	bool CheckEditor();
	TArray<class AActor*> GetAllActor_FromSave();
	TArray<class FString> GetLevelNames();
	TArray<class FString> GetLevelPathNames();
	float GetTrueCMDD(class AActor* Actor);
	void UpdateCullDistanceVolumes(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapGimmickDebug">();
	}
	static class UMapGimmickDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapGimmickDebug>();
	}
};
static_assert(alignof(UMapGimmickDebug) == 0x000008, "Wrong alignment on UMapGimmickDebug");
static_assert(sizeof(UMapGimmickDebug) == 0x000028, "Wrong size on UMapGimmickDebug");

// Class Project.CampHelpCtrlBase
// 0x00A8 (0x02C8 - 0x0220)
class ACampHelpCtrlBase final : public AActor
{
public:
	uint8                                         Pad_1898[0xA8];                                    // 0x0220(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BIEHelpPanelDispOff(int32 InIndex);
	void BIEHelpPanelDispOn(int32 InIndex);
	void BIEPanelHelpDarkMaskDispOff(int32 InIndex);
	void BIEPanelHelpDarkMaskDispOn(int32 InIndex);
	void BIEPanelHelpNoDataTextDispOff();
	void BIEPanelHelpNoDataTextDispOn();
	void BIESetHelpCursorAnimation(int32 InIndex, int32 InType, int32 InAnimeType, bool InCursorOn, bool InNewIcon);
	void BIESetHelpCursorAnimationByUseAnimeType(int32 InIndex, int32 InType);
	void BIESetHelpNameColor(int32 InIndex, int32 InUseItem);
	void BIESetHelpPanel(int32 InIndex, int32 InCategoryId, int32 InHelpId, int32 InUseHelpNo, bool InDispOnFlag);
	void BIESetInitializeListAnimation(int32 InIndex, int32 InType, int32 InAnimeType, bool InCursorOn, bool InCursorLoop, bool InNewIcon);
	void BIEStartNewIconAnimation(int32 InIndex);
	int32 CalcScrollBarClicked(float InRate);
	void ChangeHelpPanelList(int32 InType);
	bool CreateHelpList();
	bool DeleteList();
	int32 GetCategoryId();
	int32 GetCursorDispIndex();
	int32 GetCursorIndex(int32 InCategory);
	int32 GetCursorListIndex();
	int32 GetDisplayCursorIndex(int32 InCategory);
	int32 GetHelpDisplayNumber();
	int32 GetHelpId(int32 InCategory);
	int32 GetHelpIdFromIndex(int32 InCategory, int32 InIndex);
	int32 GetHelpListMax();
	int32 GetHelpMessageId(int32 InCategory);
	bool GetHelpNewIcon(int32 InCategory, int32 InIndex);
	int32 GetHelpNumber();
	int32 GetHelpType();
	int32 HelpMoveCursor(int32 InMoveCursor, int32 InScrollStartOffset);
	int32 HelpMoveCursorOffset(int32 InMoveCursor, int32 InScrollStartOffset, bool InScrollLock);
	bool InitializeHelpListCursor();
	bool IsExistDLCFlag(E_CAMPHELPLIST_CONDITIONTYPE InType);
	bool IsItPossibleDisclose(int32 InconditionId, int32 InMessageTextId);
	bool IsListAnimation();
	int32 MoveHelpType(int32 InMoveIndex);
	bool ResetHelpNewIcon();
	bool ResetHelpTypeMovingCursor();
	bool ResetMovingCursor();
	bool SetHelpNewIcon(int32 InCategory, int32 InIndex, bool InFlag);
	bool SetHelpPanel(int32 InType);
	bool SetHelpType(int32 InHelpType);
	int32 SetHelpTypeCursor(int32 InIndex);
	bool SetHelpTypeMovingCursor();
	bool SetMovingCursor();
	bool StartFadeOutListAnimation();
	bool StartListAnimation(bool InCursorAnimation, bool InCursorLoop, bool InDarkMaskOnFlag);
	bool StopListAnimation();
	bool SynchronizedNewIconAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampHelpCtrlBase">();
	}
	static class ACampHelpCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampHelpCtrlBase>();
	}
};
static_assert(alignof(ACampHelpCtrlBase) == 0x000008, "Wrong alignment on ACampHelpCtrlBase");
static_assert(sizeof(ACampHelpCtrlBase) == 0x0002C8, "Wrong size on ACampHelpCtrlBase");

// Class Project.BPL_CampItem
// 0x0000 (0x0028 - 0x0028)
class UBPL_CampItem final : public UBlueprintFunctionLibrary
{
public:
	static TArray<int32> CampItem_GetHaveImportantItemId();
	static TArray<int32> CampItem_GetHaveNormalItemId();
	static TArray<int32> CampItem_GetHaveRelicItemId();
	static TArray<int32> CampItem_GetHaveSkillGetItemId();
	static TArray<int32> CampItem_GetHaveUseItemId();
	static TArray<int32> CampItem_GetHaveUtsusemiItemId();
	static int32 CampItem_GetTabKindMax();
	static TArray<struct FCampCommonCharaData> CampItem_GetUsedCharData(int32 ItemId);
	static bool CampItem_IsAllEffect(int32 ItemId);
	static bool CampItem_IsCureItem(int32 ItemId);
	static bool CampItem_IsPartySel(int32 ItemId);
	static bool CampItem_IsUse(int32 ItemId);
	static struct FCampItemResult CampItem_Use(int32 ItemId, int32 TarNkmIndex, E_PLAYER_TYPE PlyType, bool IsAll, bool IsCheck, int32 Param1);
	static bool CampItem_UseAll(int32 ItemId, bool IsCheck, int32 Param1);
	static bool CanBeUseItemByScene(int32 InItemId);
	static struct FCampItemResult GetItemUseCountPlayer(int32 ItemId);
	static struct FCampItemResult GetItemUseCountPlayerDevil(int32 ItemId, int32 InNkmIndex);
	static bool HaveTraportItem();
	static bool IsTraportLocked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CampItem">();
	}
	static class UBPL_CampItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CampItem>();
	}
};
static_assert(alignof(UBPL_CampItem) == 0x000008, "Wrong alignment on UBPL_CampItem");
static_assert(sizeof(UBPL_CampItem) == 0x000028, "Wrong size on UBPL_CampItem");

// Class Project.BPL_NaviDevilData
// 0x0000 (0x0028 - 0x0028)
class UBPL_NaviDevilData final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertNaviDevilGimmickActors(TArray<struct FNaviDevilGimmickActors>* Out, const TArray<class AActor*>& PActorList, const TArray<int32>& CategoryList);
	static struct FNaviDevilData GetNaviDevilData(int32 Param_Index);
	static struct FNaviDevilData GetNaviDevilData_FromDevilID(int32 DevilID);
	static struct FNaviDevilData GetNaviDevilData_FromEnum(E_NAVI_DEVIL DevilEnum);
	static int32 GetNaviDevilDataMax();
	static struct FNaviDevilGimmickData GetNaviDevilGimmickData(int32 Param_Index);
	static struct FNaviDevilGimmickData GetNaviDevilGimmickData_FromID(int32 MapId, int32 Param_Index, int32 ExcavateType, int32 NowNavi, int32* TableIndex);
	static int32 GetNaviDevilGimmickDataMax();
	static int32 GetNaviDevilGimmickUniqueSaveID(int32 TableIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_NaviDevilData">();
	}
	static class UBPL_NaviDevilData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_NaviDevilData>();
	}
};
static_assert(alignof(UBPL_NaviDevilData) == 0x000008, "Wrong alignment on UBPL_NaviDevilData");
static_assert(sizeof(UBPL_NaviDevilData) == 0x000028, "Wrong size on UBPL_NaviDevilData");

// Class Project.CampItemCtrlBase
// 0x00C0 (0x02E0 - 0x0220)
class ACampItemCtrlBase final : public AActor
{
public:
	uint8                                         Pad_18AE[0xC0];                                    // 0x0220(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BackUpForSortItemData(int32 InType);
	void BIEItemPanelDispOff(int32 InIndex);
	void BIEItemPanelDispOn(int32 InIndex);
	void BIEPanelItemDarkMaskDispOff(int32 InIndex);
	void BIEPanelItemDarkMaskDispOn(int32 InIndex);
	void BIEPanelItemNoDataTextDispOff();
	void BIEPanelItemNoDataTextDispOn();
	void BIESetInitializeListAnimation(int32 InIndex, int32 InType, int32 InAnimeType, bool InCursorOn, bool InCursorLoop);
	void BIESetItemCursorAnimation(int32 InIndex, int32 InType, int32 InAnimeType, bool InCursorOn);
	void BIESetItemCursorAnimationByUseAnimeType(int32 InIndex, int32 InType);
	void BIESetItemName(int32 InIndex, int32 InItemId);
	void BIESetItemNameColor(int32 InIndex, int32 InUseItem);
	void BIESetItemNumber(int32 InIndex, int32 InItemNumber);
	void BIESetItemNumberMax(int32 InIndex, int32 InItemNumberMax);
	void BIESetItemPanel(int32 InIndex, int32 InItemId, int32 InItemNumber, int32 InItemNumberMax, int32 InUseItem, bool InDispOnFlag);
	void BIESetItemSelectCursorAnimation(int32 InIndex);
	bool CalcCanBeUseItem(int32 InNumber);
	int32 CalcScrollBarClicked(float InRate);
	int32 CanBeUsedSelectedItem();
	int32 CanBeUseItem(int32 InItemId);
	bool ChangeSortAscending(int32 InItemType);
	bool CreateItemList();
	bool DeleteItemList();
	int32 GetCanBeUseItemNumber();
	int32 GetCursorDispIndex();
	int32 GetCursorItemId();
	int32 GetCursorListIndex();
	int32 GetItemCursorOffset();
	int32 GetItemDisplayNumber();
	int32 GetItemNumber();
	int32 GetItemType();
	E_CAMPITEMLIST_CANSELTYPE GetReasonForCansel();
	bool GetSortAscending(int32 InItemType);
	int32 GetSortMovingCursorSpeed(int32 InType);
	int32 GetSortType(int32 InItemType);
	bool InitializeItemListCursor();
	bool IsListAnimation();
	int32 MoveCursor(int32 InMoveCursor, int32 InScrollStartOffset);
	int32 MoveCursorOffset(int32 InMoveCursor, int32 InScrollStartOffset, bool InScrollLock);
	int32 MoveItemType(int32 InMoveIndex);
	int32 MoveSortType(int32 InItemType, int32 InMoveSortType);
	bool ResetItemTypeMovingCursor();
	bool ResetMovingCursor();
	bool ResetSortMovingCursor(int32 InItemType);
	bool ResettingCursorListIndex();
	bool SetCanselType(E_CAMPITEMLIST_CANSELTYPE InType);
	bool SetItemPanel(int32 InType);
	bool SetItemPanelPositionBySelectItem(int32 InType);
	bool SetItemType(int32 InItemType);
	int32 SetItemTypeCursor(int32 InMoveIndex);
	bool SetItemTypeMovingCursor();
	bool SetMovingCursor();
	bool SetSelectedDarkmaskOff(int32 InCanselType);
	bool SetSelectedDarkmaskOn();
	bool SetSortAscending(int32 InItemType, bool InAscending);
	bool SetSortImportantItem(int32 InSortType);
	bool SetSortMovingCursor(int32 InItemType);
	bool SetSortRelicItem(int32 InSortType);
	bool SetSortType(int32 InItemType, int32 InSortType);
	bool SetSortUseItem(int32 InSortType);
	bool StartFadeOutListAnimation();
	bool StartListAnimation(bool InCursorAnimation, bool InCursorLoop, bool InDarkMaskOnFlag);
	bool StopListAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampItemCtrlBase">();
	}
	static class ACampItemCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampItemCtrlBase>();
	}
};
static_assert(alignof(ACampItemCtrlBase) == 0x000008, "Wrong alignment on ACampItemCtrlBase");
static_assert(sizeof(ACampItemCtrlBase) == 0x0002E0, "Wrong size on ACampItemCtrlBase");

// Class Project.CampMissionCtrlBase
// 0x0000 (0x0220 - 0x0220)
class ACampMissionCtrlBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampMissionCtrlBase">();
	}
	static class ACampMissionCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampMissionCtrlBase>();
	}
};
static_assert(alignof(ACampMissionCtrlBase) == 0x000008, "Wrong alignment on ACampMissionCtrlBase");
static_assert(sizeof(ACampMissionCtrlBase) == 0x000220, "Wrong size on ACampMissionCtrlBase");

// Class Project.MapWarpPoint
// 0x0000 (0x0220 - 0x0220)
class AMapWarpPoint : public AActor
{
public:
	int32 GetWarpPointIndex() const;
	class FString GetWarpPointName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWarpPoint">();
	}
	static class AMapWarpPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapWarpPoint>();
	}
};
static_assert(alignof(AMapWarpPoint) == 0x000008, "Wrong alignment on AMapWarpPoint");
static_assert(sizeof(AMapWarpPoint) == 0x000220, "Wrong size on AMapWarpPoint");

// Class Project.BPL_CampPartyPanel
// 0x0000 (0x0028 - 0x0028)
class UBPL_CampPartyPanel final : public UBlueprintFunctionLibrary
{
public:
	static E_DEFENCE_RESISTANCE CampPartyPanel_CheckResistanceType(int32 Param);
	static int32 CampPartyPanel_GetAttribute_Type_Max();
	static int32 CampPartyPanel_GetStockPanelNum();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CampPartyPanel">();
	}
	static class UBPL_CampPartyPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CampPartyPanel>();
	}
};
static_assert(alignof(UBPL_CampPartyPanel) == 0x000008, "Wrong alignment on UBPL_CampPartyPanel");
static_assert(sizeof(UBPL_CampPartyPanel) == 0x000028, "Wrong size on UBPL_CampPartyPanel");

// Class Project.CampQuestCtrlBase
// 0x0058 (0x0278 - 0x0220)
class ACampQuestCtrlBase final : public AActor
{
public:
	uint8                                         Pad_18C3[0x20];                                    // 0x0220(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_padButtonIndex;                                  // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_padCrsorIndex;                                   // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MISSION_MAJOR_TYPE                          M_currentSelectMissionMajorType;                   // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C4[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMissionData>                   M_mainMissionData;                                 // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMissionData>                   M_subMissionData;                                  // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_selectIndex;                                     // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_oldIndex;                                        // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void LoadMission();
	void PadCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampQuestCtrlBase">();
	}
	static class ACampQuestCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampQuestCtrlBase>();
	}
};
static_assert(alignof(ACampQuestCtrlBase) == 0x000008, "Wrong alignment on ACampQuestCtrlBase");
static_assert(sizeof(ACampQuestCtrlBase) == 0x000278, "Wrong size on ACampQuestCtrlBase");
static_assert(offsetof(ACampQuestCtrlBase, M_padButtonIndex) == 0x000240, "Member 'ACampQuestCtrlBase::M_padButtonIndex' has a wrong offset!");
static_assert(offsetof(ACampQuestCtrlBase, M_padCrsorIndex) == 0x000244, "Member 'ACampQuestCtrlBase::M_padCrsorIndex' has a wrong offset!");
static_assert(offsetof(ACampQuestCtrlBase, M_currentSelectMissionMajorType) == 0x000248, "Member 'ACampQuestCtrlBase::M_currentSelectMissionMajorType' has a wrong offset!");
static_assert(offsetof(ACampQuestCtrlBase, M_mainMissionData) == 0x000250, "Member 'ACampQuestCtrlBase::M_mainMissionData' has a wrong offset!");
static_assert(offsetof(ACampQuestCtrlBase, M_subMissionData) == 0x000260, "Member 'ACampQuestCtrlBase::M_subMissionData' has a wrong offset!");
static_assert(offsetof(ACampQuestCtrlBase, M_selectIndex) == 0x000270, "Member 'ACampQuestCtrlBase::M_selectIndex' has a wrong offset!");
static_assert(offsetof(ACampQuestCtrlBase, M_oldIndex) == 0x000274, "Member 'ACampQuestCtrlBase::M_oldIndex' has a wrong offset!");

// Class Project.EstomaData_Base
// 0x0010 (0x0038 - 0x0028)
class UEstomaData_Base : public UObject
{
public:
	int32                                         M_Magatsuhi_WhenUsed;                              // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Magatsuhi_WhenChangeMoon;                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LightMagatsuhi_WhenUsed;                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LightMagatsuhi_WhenChangeMoon;                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EstomaData_Base">();
	}
	static class UEstomaData_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEstomaData_Base>();
	}
};
static_assert(alignof(UEstomaData_Base) == 0x000008, "Wrong alignment on UEstomaData_Base");
static_assert(sizeof(UEstomaData_Base) == 0x000038, "Wrong size on UEstomaData_Base");
static_assert(offsetof(UEstomaData_Base, M_Magatsuhi_WhenUsed) == 0x000028, "Member 'UEstomaData_Base::M_Magatsuhi_WhenUsed' has a wrong offset!");
static_assert(offsetof(UEstomaData_Base, M_Magatsuhi_WhenChangeMoon) == 0x00002C, "Member 'UEstomaData_Base::M_Magatsuhi_WhenChangeMoon' has a wrong offset!");
static_assert(offsetof(UEstomaData_Base, M_LightMagatsuhi_WhenUsed) == 0x000030, "Member 'UEstomaData_Base::M_LightMagatsuhi_WhenUsed' has a wrong offset!");
static_assert(offsetof(UEstomaData_Base, M_LightMagatsuhi_WhenChangeMoon) == 0x000034, "Member 'UEstomaData_Base::M_LightMagatsuhi_WhenChangeMoon' has a wrong offset!");

// Class Project.CampQuestWindowCtrlBase
// 0x0058 (0x0278 - 0x0220)
class ACampQuestWindowCtrlBase final : public AActor
{
public:
	E_CAMP_QUEST_INPUT_TYPE                       M_CampQuestInputType;                              // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_CAMP_QUEST_USE_KEY                          M_CampQuestInputKey;                               // 0x0221(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C5[0x56];                                    // 0x0222(0x0056)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FCampQuestListData> GetDataList(E_MISSION_MAJOR_TYPE InQuestCategory);
	TArray<struct FCampQuestListData> GetDataList_InRange(E_MISSION_MAJOR_TYPE InQuestCategory, int32 StartIdx, int32 EndIdx);
	bool IsExistNewQuest();
	void LoadQuestList();
	void SetNewIconState(E_MISSION_MAJOR_TYPE InQuestCategory, int32 InListIdx, bool IsVisibleIcon);
	void SetUpdateIconState(E_MISSION_MAJOR_TYPE InQuestCategory, int32 InListIdx, bool IsVisibleIcon);
	void UpdateInputInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampQuestWindowCtrlBase">();
	}
	static class ACampQuestWindowCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampQuestWindowCtrlBase>();
	}
};
static_assert(alignof(ACampQuestWindowCtrlBase) == 0x000008, "Wrong alignment on ACampQuestWindowCtrlBase");
static_assert(sizeof(ACampQuestWindowCtrlBase) == 0x000278, "Wrong size on ACampQuestWindowCtrlBase");
static_assert(offsetof(ACampQuestWindowCtrlBase, M_CampQuestInputType) == 0x000220, "Member 'ACampQuestWindowCtrlBase::M_CampQuestInputType' has a wrong offset!");
static_assert(offsetof(ACampQuestWindowCtrlBase, M_CampQuestInputKey) == 0x000221, "Member 'ACampQuestWindowCtrlBase::M_CampQuestInputKey' has a wrong offset!");

// Class Project.BPL_CampSkill
// 0x0000 (0x0028 - 0x0028)
class UBPL_CampSkill final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FCampCommonCharaData> CampSkill_GetUsedCharData(const struct FCampCommonCharaData& ActCharaData, int32 SkillId);
	static bool CampSkill_IsAllEffect(int32 SkillId);
	static bool CampSkill_IsCureSkill(int32 SkillId);
	static bool CampSkill_IsUseSkill(const struct FCampCommonCharaData& ActCharaData, int32 SkillId);
	static struct FCampSkilResult CampSkill_Used(const struct FCampCommonCharaData& ActCharaData, const struct FCampCommonCharaData& TarCharaData, int32 SkillId, bool IsCheck);
	static bool CampSkill_UsedAll(const struct FCampCommonCharaData& ActCharaData, int32 SkillId, bool IsCheck);
	static struct FCampSkilResult CampSkill_UsedNonCost(const struct FCampCommonCharaData& ActCharaData, const struct FCampCommonCharaData& TarCharaData, int32 SkillId, bool IsCalcOnly);
	static bool CanBeUseSkillByScene(int32 InSkillId);
	static void ExpenditureMp(const struct FCampCommonCharaData& ActCharaData, int32 SkillId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CampSkill">();
	}
	static class UBPL_CampSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CampSkill>();
	}
};
static_assert(alignof(UBPL_CampSkill) == 0x000008, "Wrong alignment on UBPL_CampSkill");
static_assert(sizeof(UBPL_CampSkill) == 0x000028, "Wrong size on UBPL_CampSkill");

// Class Project.CampSkillCtrlBase
// 0x00B0 (0x02D0 - 0x0220)
class ACampSkillCtrlBase final : public AActor
{
public:
	uint8                                         Pad_18D5[0xB0];                                    // 0x0220(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BackUpForSortSkillData();
	void BIEPanelSkillDarkMaskDispOff(int32 InIndex);
	void BIEPanelSkillDarkMaskDispOn(int32 InIndex);
	void BIEPanelSkillNoDataTextDispOff();
	void BIEPanelSkillNoDataTextDispOn(bool InHelpMessage);
	void BIESetBlankPanel(int32 InIndex, int32 InBlankType, int32 InFaceIconId, int32 InUseSkill, bool InDispOnFlag, bool InDispOnFaceIcon, bool InDispOnMagatsuhi);
	void BIESetInitializeCursorAnimation(int32 InIndex);
	void BIESetInitializeListAnimation(int32 InIndex, int32 InType, bool InCursorOn);
	void BIESetMagatsuhiGaugeAnimation(int32 InMode, int32 InRatio);
	void BIESetMagatsuhiPanel(int32 InIndex, int32 InSkillId, int32 InFaceIconId, int32 InCost, int32 InUseSkill, int32 InTekiseiParam, int32 InUseType, bool InDispOnFlag);
	void BIESetSkillCost(int32 InIndex, int32 InSkillCost);
	void BIESetSkillCursorAnimation(int32 InIndex, int32 InType, int32 InAnimeType, bool InCursorOn);
	void BIESetSkillCursorAnimationByUseAnimeType(int32 InIndex, int32 InType);
	void BIESetSkillName(int32 InIndex, int32 InSkillId);
	void BIESetSkillNameColor(int32 InIndex, int32 InUseSkill);
	void BIESetSkillPanel(int32 InIndex, int32 InSkillId, int32 InFaceIconId, int32 InCost, int32 InUseSkill, int32 InTekiseiParam, int32 InUseType, bool InDispOnFlag);
	void BIESetSkillPanelFaceIconColor(int32 InIndex, int32 InType);
	void BIESetSkillSelectCursorAnimation(int32 InIndex);
	void BIESetUniquePanel(int32 InIndex, int32 InSkillId, int32 InFaceIconId, int32 InCost, int32 InUseSkill, int32 InTekiseiParam, int32 InUseType, bool InDispOnFlag);
	void BIESetUseTypeWidget(int32 InIndex, int32 InUseType);
	void BIESkillPanelDispOff(int32 InIndex);
	void BIESkillPanelDispOn(int32 InIndex);
	void BIEStopListAnimationWidget();
	bool CalcCanBeUseSkill(int32 InNumber);
	int32 CalcScrollBarClicked(float InRate);
	int32 CanBeUsedSelectedSkill();
	bool ChangeSortAscending();
	bool CreateAnalyzeMagatsuhiSkillList(int32 InDevilId);
	bool CreateAnalyzeSkillList(int32 InDevilId);
	bool CreateDevilBookMagatsuhiSkillList(int32 InDevilId);
	bool CreateDevilBookSkillList(int32 InDevilId, int32 InDevilBookType);
	bool CreateFusionResultMagatsuhiSkillList(int32 InDevilId, bool bInUnknown);
	bool CreateFusionResultSkillList(int32 InDevilId, bool bInUnknown);
	bool CreatePartyMagatsuhiSkillList(int32 InNkmIndex);
	bool CreatePartySkillList(int32 InNkmIndex);
	bool CreateSkillList();
	bool CreateUtsusemiSkillList();
	bool CreateUtsusemiSkillListForCampOnly();
	bool DeleteSkillList();
	int32 GetCanBeUseSkillNumber();
	int32 GetCursorDispIndex();
	int32 GetCursorListIndex();
	int32 GetCursorNkmIndex();
	int32 GetCursorSkillId();
	int32 GetMagatsuhiGaugeMode();
	E_CAMPSKILLLIST_CANSELTYPE GetReasonForCansel();
	int32 GetSkillDisplayNumber();
	bool GetSortAscending();
	int32 GetSortType();
	int32 GetUseSkillCount();
	int32 GetUtsusemiCursorDispIndex();
	int32 GetUtsusemiCursorListIndex();
	int32 GetUtsusemiCursorSkillId();
	int32 GetUtsusemiSkillCount();
	bool InitializeMagatsuhiGauge();
	bool InitializeSkillListCursor();
	bool IsListAnimation();
	int32 MoveCursor(int32 InMoveCursor, int32 InScrollStartOffset);
	int32 MoveCursorOffset(int32 InMoveCursor, int32 InScrollStartOffset, bool InScrollLock);
	int32 MoveSortType(int32 InMoveSortType);
	int32 MoveUtsusemiCursor(int32 InMoveCursor);
	bool ResetMovingCursor(int32 InType);
	bool ResetSortMovingCursor();
	bool RestartUtsusemiSkillList(int32 InIndex);
	bool SetAnalyzeDevilId(int32 InDevilId);
	bool SetAnalyzeSkillPanel(int32 InType);
	bool SetDevilBookSkillPanel(int32 InType);
	bool SetFusionResultSkillPanel(int32 InType);
	bool SetMovingCursor(int32 InType);
	bool SetPartySkillPanel(int32 InType);
	bool SetSelectedDarkmaskOff(int32 InCanselType);
	bool SetSelectedDarkmaskOn();
	bool SetSkillPanel(int32 InType);
	bool SetSkillPanelPositionBySelectSkill();
	bool SetSortAscending(bool InAscending);
	bool SetSortMovingCursor();
	bool SetSortSkillList(int32 InSortType);
	bool SetSortType(int32 InSortType);
	bool SetUtsusemiDevilId(int32 InDevilId);
	bool SetUtsusemiSkillPanel(int32 InType, int32 InCursorType);
	bool StartFadeOutListAnimation();
	bool StartListAnimation(bool InCursorAnimation, int32 InMode);
	bool StartUseSkillListAnimation(bool InCursorAnimation, bool InCursorLoop, bool InDarkMaskOn);
	bool StopListAnimation();
	bool UpdateSkillListAnimation(int32 InType, bool InCursorOn, int32 InMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampSkillCtrlBase">();
	}
	static class ACampSkillCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampSkillCtrlBase>();
	}
};
static_assert(alignof(ACampSkillCtrlBase) == 0x000008, "Wrong alignment on ACampSkillCtrlBase");
static_assert(sizeof(ACampSkillCtrlBase) == 0x0002D0, "Wrong size on ACampSkillCtrlBase");

// Class Project.CampTopCtrlBase
// 0x0068 (0x0288 - 0x0220)
class ACampTopCtrlBase final : public AActor
{
public:
	uint8                                         Pad_18F8[0x68];                                    // 0x0220(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BIESetInitializeSubMenuAnimation(int32 InIndex);
	void BIESetInitializeSubMenuCursorAnimation(int32 InIndex);
	void BIESetInitializeTopMenuAnimation(int32 InIndex, int32 InType);
	void BIESetInitializeTopMenuCursorAnimation(int32 InIndex);
	void BIESetInitializeTopMenuCursorOn(int32 InIndex);
	void BIESetInitializeTopMenuNewIcon();
	void BIESetInitializeTopMenuOn(int32 InIndex, int32 InType);
	int32 CalcSubMenuCursor(int32 InCursor, int32 InCursorMax, int32 InCalcNumber);
	int32 CalcTopMenuCursor(int32 InCursor, int32 InCursorMax, int32 InCalcNumber);
	bool DeleteTopMenuList();
	int32 GetSubMenuColor(int32 InIndex, int32 InType, bool InMask);
	bool InitializeTopMenuOn(bool InCursorFlag);
	bool IsSubMenuAnimation();
	bool IsTopMenuAnimation();
	int32 IsTopMenuSelected(int32 InIndex);
	bool ResetMovingCursor(int32 InType);
	bool SetMovingCursor(int32 InType);
	bool SetSubMenuCursorIndex(int32 InIndex);
	bool SetTopMenuCursorIndex(int32 InIndex);
	bool SetTopMenuMode();
	bool StartSubMenuAnimation(bool InCursorAnimation, float InStartTime);
	bool StartTopMenuAnimation(bool InCursorAnimation);
	bool StopSubMenuAnimation();
	bool StopTopMenuAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampTopCtrlBase">();
	}
	static class ACampTopCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampTopCtrlBase>();
	}
};
static_assert(alignof(ACampTopCtrlBase) == 0x000008, "Wrong alignment on ACampTopCtrlBase");
static_assert(sizeof(ACampTopCtrlBase) == 0x000288, "Wrong size on ACampTopCtrlBase");

// Class Project.JsonDataCtrl
// 0x0048 (0x0070 - 0x0028)
class UJsonDataCtrl final : public UObject
{
public:
	uint8                                         Pad_1900[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Content;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetResult;                                       // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UJsonDataCtrl* Create(class UObject* WorldContextObject);
	static class UJsonDataCtrl* GetRequest(class UObject* WorldContextObject, const class FString& Filename);
	static bool IsJsonEditor();

	void FromString(const class FString& DataString);
	class UJsonDataCtrl* GetObject(const class FString& Key);
	TArray<class UJsonDataCtrl*> GetObjectArray(class UObject* WorldContextObject, const class FString& Key);
	TArray<class FString> GetObjectKeys(class UObject* WorldContextObject);
	TArray<class FString> GetStringArray(const class FString& Key);
	void PostRequest(class UObject* WorldContextObject, const class FString& Filename);
	void PrePostRequest(class UObject* WorldContextObject, const class FString& Filename);
	class UJsonDataCtrl* SetObject(const class FString& Key, const class UJsonDataCtrl* ObjectData);
	class UJsonDataCtrl* SetObjectArray(const class FString& Key, const TArray<class UJsonDataCtrl*>& ArrayData);
	class UJsonDataCtrl* SetString(const class FString& Key, const class FString& Value);
	class UJsonDataCtrl* SetStringArray(const class FString& Key, const TArray<class FString>& ArrayData);

	class FString GetString(const class FString& Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JsonDataCtrl">();
	}
	static class UJsonDataCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJsonDataCtrl>();
	}
};
static_assert(alignof(UJsonDataCtrl) == 0x000008, "Wrong alignment on UJsonDataCtrl");
static_assert(sizeof(UJsonDataCtrl) == 0x000070, "Wrong size on UJsonDataCtrl");
static_assert(offsetof(UJsonDataCtrl, Content) == 0x000040, "Member 'UJsonDataCtrl::Content' has a wrong offset!");
static_assert(offsetof(UJsonDataCtrl, OnGetResult) == 0x000050, "Member 'UJsonDataCtrl::OnGetResult' has a wrong offset!");
static_assert(offsetof(UJsonDataCtrl, OnFailed) == 0x000060, "Member 'UJsonDataCtrl::OnFailed' has a wrong offset!");

// Class Project.CaptureByFrameGrabberAction
// 0x0030 (0x0060 - 0x0030)
class UCaptureByFrameGrabberAction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTexture2D*                             CaptureTexture;                                    // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1901[0x18];                                    // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCaptureByFrameGrabberAction* CaptureByFrameGrabber(class UObject* WorldContextObject, class UTexture2D* ReuseCaptureTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureByFrameGrabberAction">();
	}
	static class UCaptureByFrameGrabberAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptureByFrameGrabberAction>();
	}
};
static_assert(alignof(UCaptureByFrameGrabberAction) == 0x000008, "Wrong alignment on UCaptureByFrameGrabberAction");
static_assert(sizeof(UCaptureByFrameGrabberAction) == 0x000060, "Wrong size on UCaptureByFrameGrabberAction");
static_assert(offsetof(UCaptureByFrameGrabberAction, Completed) == 0x000030, "Member 'UCaptureByFrameGrabberAction::Completed' has a wrong offset!");
static_assert(offsetof(UCaptureByFrameGrabberAction, CaptureTexture) == 0x000040, "Member 'UCaptureByFrameGrabberAction::CaptureTexture' has a wrong offset!");

// Class Project.CategoryWindowBase
// 0x0000 (0x0220 - 0x0220)
class ACategoryWindowBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CategoryWindowBase">();
	}
	static class ACategoryWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACategoryWindowBase>();
	}
};
static_assert(alignof(ACategoryWindowBase) == 0x000008, "Wrong alignment on ACategoryWindowBase");
static_assert(sizeof(ACategoryWindowBase) == 0x000220, "Wrong size on ACategoryWindowBase");

// Class Project.ProjectIKAnimInstance
// 0x0140 (0x0400 - 0x02C0)
class UProjectIKAnimInstance : public UAnimInstance
{
public:
	bool                                          bEnableFootIK;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1902[0x3];                                     // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RootJoint;                                         // 0x02BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PelvisJoint;                                       // 0x02C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFootIkJoint;                                   // 0x02CC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFootGroundJoint;                               // 0x02D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftHeelJoint;                                     // 0x02DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftToeJoint;                                      // 0x02E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFootIkJoint;                                  // 0x02EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFootGroundJoint;                              // 0x02F4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightHeelJoint;                                    // 0x02FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightToeJoint;                                     // 0x0304(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundingCorrectDistance;                          // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundingCheckHeight;                              // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRangeUp;                                      // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRangeDown;                                    // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepHeightLimitMax;                                // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepHeightLimitMin;                                // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompHeightInterpSpeed_Down_Grounding;              // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompHeightInterpSpeed_Down;                        // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompHeightInterpSpeed_Up_Grounding;                // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompHeightInterpSpeed_Up;                          // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootHeightInterpSpeed;                             // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootInterpSpeed;                                   // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnkleRotationInterpSpeed_Up;                       // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnkleRotationInterpSpeed_Down;                     // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PelvisOffset;                                      // 0x0344(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftFootOffset;                                    // 0x0350(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightFootOffset;                                   // 0x035C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftAnkleRotationOffset;                           // 0x0368(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RightAnkleRotationOffset;                          // 0x0374(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFootGrounding;                                   // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         FootEffectReTriggerSlipDistance;                   // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootEffectReTriggerInterval;                       // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdatedFootIK;                                    // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1903[0x67];                                    // 0x0399(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetFootIK();
	void TickFootIK(float DeltaSeconds);
	void UpdateParameters(bool bInMoveOnGround, float InCurrentSpeed, float InMaxSpeedRun, float InMaxSpeedDash);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectIKAnimInstance">();
	}
	static class UProjectIKAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectIKAnimInstance>();
	}
};
static_assert(alignof(UProjectIKAnimInstance) == 0x000010, "Wrong alignment on UProjectIKAnimInstance");
static_assert(sizeof(UProjectIKAnimInstance) == 0x000400, "Wrong size on UProjectIKAnimInstance");
static_assert(offsetof(UProjectIKAnimInstance, bEnableFootIK) == 0x0002B8, "Member 'UProjectIKAnimInstance::bEnableFootIK' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, RootJoint) == 0x0002BC, "Member 'UProjectIKAnimInstance::RootJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, PelvisJoint) == 0x0002C4, "Member 'UProjectIKAnimInstance::PelvisJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, LeftFootIkJoint) == 0x0002CC, "Member 'UProjectIKAnimInstance::LeftFootIkJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, LeftFootGroundJoint) == 0x0002D4, "Member 'UProjectIKAnimInstance::LeftFootGroundJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, LeftHeelJoint) == 0x0002DC, "Member 'UProjectIKAnimInstance::LeftHeelJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, LeftToeJoint) == 0x0002E4, "Member 'UProjectIKAnimInstance::LeftToeJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, RightFootIkJoint) == 0x0002EC, "Member 'UProjectIKAnimInstance::RightFootIkJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, RightFootGroundJoint) == 0x0002F4, "Member 'UProjectIKAnimInstance::RightFootGroundJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, RightHeelJoint) == 0x0002FC, "Member 'UProjectIKAnimInstance::RightHeelJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, RightToeJoint) == 0x000304, "Member 'UProjectIKAnimInstance::RightToeJoint' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, GroundingCorrectDistance) == 0x00030C, "Member 'UProjectIKAnimInstance::GroundingCorrectDistance' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, GroundingCheckHeight) == 0x000310, "Member 'UProjectIKAnimInstance::GroundingCheckHeight' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, TraceRangeUp) == 0x000314, "Member 'UProjectIKAnimInstance::TraceRangeUp' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, TraceRangeDown) == 0x000318, "Member 'UProjectIKAnimInstance::TraceRangeDown' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, StepHeightLimitMax) == 0x00031C, "Member 'UProjectIKAnimInstance::StepHeightLimitMax' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, StepHeightLimitMin) == 0x000320, "Member 'UProjectIKAnimInstance::StepHeightLimitMin' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, CompHeightInterpSpeed_Down_Grounding) == 0x000324, "Member 'UProjectIKAnimInstance::CompHeightInterpSpeed_Down_Grounding' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, CompHeightInterpSpeed_Down) == 0x000328, "Member 'UProjectIKAnimInstance::CompHeightInterpSpeed_Down' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, CompHeightInterpSpeed_Up_Grounding) == 0x00032C, "Member 'UProjectIKAnimInstance::CompHeightInterpSpeed_Up_Grounding' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, CompHeightInterpSpeed_Up) == 0x000330, "Member 'UProjectIKAnimInstance::CompHeightInterpSpeed_Up' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, FootHeightInterpSpeed) == 0x000334, "Member 'UProjectIKAnimInstance::FootHeightInterpSpeed' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, FootInterpSpeed) == 0x000338, "Member 'UProjectIKAnimInstance::FootInterpSpeed' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, AnkleRotationInterpSpeed_Up) == 0x00033C, "Member 'UProjectIKAnimInstance::AnkleRotationInterpSpeed_Up' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, AnkleRotationInterpSpeed_Down) == 0x000340, "Member 'UProjectIKAnimInstance::AnkleRotationInterpSpeed_Down' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, PelvisOffset) == 0x000344, "Member 'UProjectIKAnimInstance::PelvisOffset' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, LeftFootOffset) == 0x000350, "Member 'UProjectIKAnimInstance::LeftFootOffset' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, RightFootOffset) == 0x00035C, "Member 'UProjectIKAnimInstance::RightFootOffset' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, LeftAnkleRotationOffset) == 0x000368, "Member 'UProjectIKAnimInstance::LeftAnkleRotationOffset' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, RightAnkleRotationOffset) == 0x000374, "Member 'UProjectIKAnimInstance::RightAnkleRotationOffset' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, OnFootGrounding) == 0x000380, "Member 'UProjectIKAnimInstance::OnFootGrounding' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, FootEffectReTriggerSlipDistance) == 0x000390, "Member 'UProjectIKAnimInstance::FootEffectReTriggerSlipDistance' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, FootEffectReTriggerInterval) == 0x000394, "Member 'UProjectIKAnimInstance::FootEffectReTriggerInterval' has a wrong offset!");
static_assert(offsetof(UProjectIKAnimInstance, bUpdatedFootIK) == 0x000398, "Member 'UProjectIKAnimInstance::bUpdatedFootIK' has a wrong offset!");

// Class Project.CharaBlink
// 0x0010 (0x0038 - 0x0028)
class UCharaBlink final : public UObject
{
public:
	TArray<struct FCharaBlinkKey>                 KeyList;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaBlink">();
	}
	static class UCharaBlink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaBlink>();
	}
};
static_assert(alignof(UCharaBlink) == 0x000008, "Wrong alignment on UCharaBlink");
static_assert(sizeof(UCharaBlink) == 0x000038, "Wrong size on UCharaBlink");
static_assert(offsetof(UCharaBlink, KeyList) == 0x000028, "Member 'UCharaBlink::KeyList' has a wrong offset!");

// Class Project.CharaExpressionTable
// 0x0050 (0x0078 - 0x0028)
class UCharaExpressionTable final : public UObject
{
public:
	TMap<class FName, struct FCharaExpression>    Map;                                               // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaExpressionTable">();
	}
	static class UCharaExpressionTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaExpressionTable>();
	}
};
static_assert(alignof(UCharaExpressionTable) == 0x000008, "Wrong alignment on UCharaExpressionTable");
static_assert(sizeof(UCharaExpressionTable) == 0x000078, "Wrong size on UCharaExpressionTable");
static_assert(offsetof(UCharaExpressionTable, Map) == 0x000028, "Member 'UCharaExpressionTable::Map' has a wrong offset!");

// Class Project.MapSymbolComponentCPP
// 0x00F0 (0x01A0 - 0x00B0)
class UMapSymbolComponentCPP : public UActorComponent
{
public:
	uint8                                         Pad_1905[0x2C];                                    // 0x00B0(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_ActCounter;                                      // 0x00DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_ActCounterEnd;                                   // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_SmallActCounter;                                 // 0x00E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_SmallActCounterEnd;                              // 0x00E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_PlayerLocation;                                  // 0x00EC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_PrevLocation;                                    // 0x00F8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_PrevRotation;                                    // 0x0104(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_NextLocation;                                    // 0x0110(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_NextRotation;                                    // 0x011C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_NextForward;                                     // 0x0128(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_IsMove_PrevFrame;                                // 0x0134(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1906[0x3];                                     // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_DeltaSec;                                        // 0x0138(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_DeltaSecAfterMove;                               // 0x013C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_SelfActor;                                       // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_PlayerActor;                                     // 0x0148(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EObjectTypeQuery>                      M_CollisionObjectTypes;                            // 0x0150(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_CollisionRadius;                                 // 0x0160(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EncountCollisionSizeX;                           // 0x0164(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_MinimapLocation;                                 // 0x0168(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_MinimapRotation;                                 // 0x0174(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_DeltaTime_ForMinimap;                            // 0x0180(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_SpaceWhenSpawning;                               // 0x0184(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_UniqueSymbolBGM;                                 // 0x0188(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1907[0x17];                                    // 0x0189(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDeltaSecAfterMove(float DeltaSec);
	void AddNextLocation(const struct FVector& Add);
	void AsyncLineTrace(const struct FVector& StartPos, const struct FVector& GoalPos, ECollisionChannel Channel);
	void Calc_ShouldChangeDir_NearbySymbols(bool IsTarget, const struct FVector& Target, bool* ShouldChange, struct FVector* TargetVec, float DevilLength, float PlayerLength);
	void CalcNextLocation_StickWall_cpp(class FName CollisionProfileName, bool Ground, const struct FVector& HitNormal, int32 TraceFrameCount, const struct FVector& SymbolSize, float ClimbableHeight, float CollisionHeight, EDrawDebugTrace DrawDebugTrace, bool* Out_hit, struct FVector* Out_wallLocation, struct FVector* Out_deltaMove);
	void CalcRouteCore(const TArray<struct FMapSymbolRouteNode>& RouteNodeList, const struct FVector& StartLoc, const struct FVector& GoalLoc, class FName CollisionProfileName, float RouteNodeSpace, float Radius, bool Fly, bool* Success, TArray<struct FVector>* ResultRoute, struct FHitResult* StraightHit);
	void CalcSlope_cpp(float Slope, const struct FVector& HitNormal, float ClimbableHeight, float CollisionRadius, float CollisionHeight, class FName CollisionProfileName, EDrawDebugTrace DrawDebugTrace, bool WillMove, bool* Out_move, struct FVector* Out_deltaMove, float* Out_adjustMin, float* Out_adjustMax);
	bool CheckAttackMotionCounterEnd_cpp();
	bool CheckRender();
	bool CheckSomeTimes_cpp();
	bool CheckSomeTimes_Long_cpp();
	bool CheckSomeTimes_Short_cpp();
	bool CheckUniqueSymbolBGM();
	int32 ConvertDevilLevel(int32 DevilID);
	float GetDeltaSecAfterMove();
	float GetMotionBlendAlpha_cpp();
	float GetMotionBlendCounterEnd_cpp();
	const TArray<class ACustomPawn*> GetNearSymbols();
	const struct FVector GetPrevLocation();
	const struct FRotator GetPrevRotation();
	float GetSpaceWhenSpawning();
	void Notify_EndInhale_Begin(float TotalTime);
	void Notify_EndInhale_End();
	void Notify_EndInhale_Tick(float DeltaSec);
	void Notify_StartInhale_Begin(float TotalTime);
	void Notify_StartInhale_End();
	void Notify_StartInhale_Tick(float DeltaSec);
	void ReserveAsyncLineTrace(const TArray<struct FHitResult>& HitResult);
	void SetNextLocation(const struct FVector& Location);
	void SetNextRotation(const struct FRotator& Rotation);
	void StartAttackMotionCounter_cpp(float EndSec);
	void StartMotionBlendCounter_cpp(float EndSec);
	void TraceStickWall_cpp(const struct FVector& MoveDir, float MoveLength, int32 TraceFrameCount, class FName CollisionProfileName, bool Ground, const struct FVector& HitNormal, const struct FVector& SymbolSize, float ClimbableHeight, float CollisionHeight, EDrawDebugTrace DrawDebugTrace, bool* Out_hit, struct FVector* Out_hitLocation, float* Out_canMoveLength, bool* Out_beginningHit);
	void UpdateActCounter();
	void UpdateAttackMotionCounter_cpp();
	void UpdateLocationInfo(const class UObject* WorldContextObject);
	void UpdateMotionBlendCounter_cpp();
	void UpdateSomeTimes_cpp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSymbolComponentCPP">();
	}
	static class UMapSymbolComponentCPP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSymbolComponentCPP>();
	}
};
static_assert(alignof(UMapSymbolComponentCPP) == 0x000008, "Wrong alignment on UMapSymbolComponentCPP");
static_assert(sizeof(UMapSymbolComponentCPP) == 0x0001A0, "Wrong size on UMapSymbolComponentCPP");
static_assert(offsetof(UMapSymbolComponentCPP, M_ActCounter) == 0x0000DC, "Member 'UMapSymbolComponentCPP::M_ActCounter' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_ActCounterEnd) == 0x0000E0, "Member 'UMapSymbolComponentCPP::M_ActCounterEnd' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_SmallActCounter) == 0x0000E4, "Member 'UMapSymbolComponentCPP::M_SmallActCounter' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_SmallActCounterEnd) == 0x0000E8, "Member 'UMapSymbolComponentCPP::M_SmallActCounterEnd' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_PlayerLocation) == 0x0000EC, "Member 'UMapSymbolComponentCPP::M_PlayerLocation' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_PrevLocation) == 0x0000F8, "Member 'UMapSymbolComponentCPP::M_PrevLocation' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_PrevRotation) == 0x000104, "Member 'UMapSymbolComponentCPP::M_PrevRotation' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_NextLocation) == 0x000110, "Member 'UMapSymbolComponentCPP::M_NextLocation' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_NextRotation) == 0x00011C, "Member 'UMapSymbolComponentCPP::M_NextRotation' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_NextForward) == 0x000128, "Member 'UMapSymbolComponentCPP::M_NextForward' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_IsMove_PrevFrame) == 0x000134, "Member 'UMapSymbolComponentCPP::M_IsMove_PrevFrame' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_DeltaSec) == 0x000138, "Member 'UMapSymbolComponentCPP::M_DeltaSec' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_DeltaSecAfterMove) == 0x00013C, "Member 'UMapSymbolComponentCPP::M_DeltaSecAfterMove' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_SelfActor) == 0x000140, "Member 'UMapSymbolComponentCPP::M_SelfActor' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_PlayerActor) == 0x000148, "Member 'UMapSymbolComponentCPP::M_PlayerActor' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_CollisionObjectTypes) == 0x000150, "Member 'UMapSymbolComponentCPP::M_CollisionObjectTypes' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_CollisionRadius) == 0x000160, "Member 'UMapSymbolComponentCPP::M_CollisionRadius' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_EncountCollisionSizeX) == 0x000164, "Member 'UMapSymbolComponentCPP::M_EncountCollisionSizeX' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_MinimapLocation) == 0x000168, "Member 'UMapSymbolComponentCPP::M_MinimapLocation' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_MinimapRotation) == 0x000174, "Member 'UMapSymbolComponentCPP::M_MinimapRotation' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_DeltaTime_ForMinimap) == 0x000180, "Member 'UMapSymbolComponentCPP::M_DeltaTime_ForMinimap' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_SpaceWhenSpawning) == 0x000184, "Member 'UMapSymbolComponentCPP::M_SpaceWhenSpawning' has a wrong offset!");
static_assert(offsetof(UMapSymbolComponentCPP, M_UniqueSymbolBGM) == 0x000188, "Member 'UMapSymbolComponentCPP::M_UniqueSymbolBGM' has a wrong offset!");

// Class Project.CharaFaceComponent
// 0x0268 (0x0318 - 0x00B0)
class UCharaFaceComponent final : public UActorComponent
{
public:
	int32                                         Index_CharaFaceComponent;                          // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1912[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharaExpressionTable*                  ExpressionTable;                                   // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharaLidTable>                 LidTableList;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharaLipTable>                 LipTableList;                                      // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1913[0x230];                                   // 0x00E8(0x0230)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeExpression(class FName ExpressionID, float BlendTimeOverride);
	void ChangeLid(E_CHARA_LID_ID LidID, float Duration, float BlendInTime, float BlendOutTime);
	void ChangeLip(E_CHARA_LIP_ID LipID, float Duration, float BlendInTime, float BlendOutTime);
	void ClearExpression();
	void ClearLid();
	void ClearLip();
	TSoftObjectPtr<class UTexture> GetExpressionEx(class FName ExpressionID, int32 Type, float* OpacityL, float* OpacityR);
	void PlayBlink(const class UCharaBlink* Blink, bool Loop, float BlendInTime, float BlendOutTime);
	void PlayLipSync(const class UCharaLipSync* LipSync, bool Loop, float BlendInTime, float BlendOutTime);
	void StopBlink(bool Reset, float Duration, float BlendInTime, float BlendOutTime);
	void StopLipSync();
	void Update(float DeltaTime, class UAnimInstance* AnimInstance, class UCustomPoseWeightTable* PoseWeightTable);
	bool UseExpressionEx(class FName ExpressionID);

	class FName GetCurrentExpressionID() const;
	E_CHARA_LID_ID GetCurrentLidID() const;
	E_CHARA_LIP_ID GetCurrentLipID() const;
	float GetLidExpressionAttenuate() const;
	float GetLipExpressionAttenuate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaFaceComponent">();
	}
	static class UCharaFaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaFaceComponent>();
	}
};
static_assert(alignof(UCharaFaceComponent) == 0x000008, "Wrong alignment on UCharaFaceComponent");
static_assert(sizeof(UCharaFaceComponent) == 0x000318, "Wrong size on UCharaFaceComponent");
static_assert(offsetof(UCharaFaceComponent, Index_CharaFaceComponent) == 0x0000B0, "Member 'UCharaFaceComponent::Index_CharaFaceComponent' has a wrong offset!");
static_assert(offsetof(UCharaFaceComponent, ExpressionTable) == 0x0000B8, "Member 'UCharaFaceComponent::ExpressionTable' has a wrong offset!");
static_assert(offsetof(UCharaFaceComponent, LidTableList) == 0x0000C0, "Member 'UCharaFaceComponent::LidTableList' has a wrong offset!");
static_assert(offsetof(UCharaFaceComponent, LipTableList) == 0x0000D0, "Member 'UCharaFaceComponent::LipTableList' has a wrong offset!");
static_assert(offsetof(UCharaFaceComponent, SlotName) == 0x0000E0, "Member 'UCharaFaceComponent::SlotName' has a wrong offset!");

// Class Project.CharaLipSync
// 0x0010 (0x0038 - 0x0028)
class UCharaLipSync final : public UObject
{
public:
	TArray<struct FCharaLipSyncKey>               KeyList;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaLipSync">();
	}
	static class UCharaLipSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaLipSync>();
	}
};
static_assert(alignof(UCharaLipSync) == 0x000008, "Wrong alignment on UCharaLipSync");
static_assert(sizeof(UCharaLipSync) == 0x000038, "Wrong size on UCharaLipSync");
static_assert(offsetof(UCharaLipSync, KeyList) == 0x000028, "Member 'UCharaLipSync::KeyList' has a wrong offset!");

// Class Project.ProjectSoundStatics
// 0x0000 (0x0028 - 0x0028)
class UProjectSoundStatics final : public UBlueprintFunctionLibrary
{
public:
	static class USceneComponent* AddResidentSoundComponent(TSubclassOf<class USceneComponent> ComponentClass, class AActor* Owner);
	static void ForceUpdateAtomListenersImmediately();
	static TArray<struct FTransform> GetPlacementSeFoliageTransforms(class UStaticMesh* TargetMesh, float MinScale, class AActor* LevelGetActor);
	static class UAtomComponent* PlayCharacterVoice(class AActor* Talker, class USoundAtomCue* Cue, class FName Socket, bool bDontAttachToTalker);
	static class UAtomComponent* PlayDevilVoice(class AActor* Talker, EDevilVoiceType DevilVoiceType, class FName Socket, bool bDontAttachToTalker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectSoundStatics">();
	}
	static class UProjectSoundStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectSoundStatics>();
	}
};
static_assert(alignof(UProjectSoundStatics) == 0x000008, "Wrong alignment on UProjectSoundStatics");
static_assert(sizeof(UProjectSoundStatics) == 0x000028, "Wrong size on UProjectSoundStatics");

// Class Project.BPI_CharaMotionHeadInterface
// 0x0000 (0x0028 - 0x0028)
class IBPI_CharaMotionHeadInterface final : public IInterface
{
public:
	void MotionHeadNotifyEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPI_CharaMotionHeadInterface">();
	}
	static class IBPI_CharaMotionHeadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_CharaMotionHeadInterface>();
	}
};
static_assert(alignof(IBPI_CharaMotionHeadInterface) == 0x000008, "Wrong alignment on IBPI_CharaMotionHeadInterface");
static_assert(sizeof(IBPI_CharaMotionHeadInterface) == 0x000028, "Wrong size on IBPI_CharaMotionHeadInterface");

// Class Project.CharaMotionPlayerComponent
// 0x0100 (0x01B0 - 0x00B0)
class UCharaMotionPlayerComponent final : public UActorComponent
{
public:
	class UCharaMotionTable*                      MotionTable;                                       // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharaMotionOverrideBlendTimeTable*     MotionBlendTable;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharaMotionOverrideBlendTimeTable*     MotionBlendTable_Append;                           // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCharaMotionTable>       MotionTableAssetID;                                // 0x00C8(0x0028)(Edit, BlueprintVisible, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharaMotionPlayerLoadCompleted;                  // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1922[0x90];                                    // 0x0108(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1923[0x10];                                    // 0x01A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceProgressCurrentAnim();
	class UAnimSequenceBase* GetAnimationDefault();
	class UAnimSequenceBase* GetAnimationLoop();
	E_CHARA_MOTION_ID GetBeforeMotionID();
	E_CHARA_MOTION_ID GetCurrentMotionID();
	float GetPlayRate();
	void InitMotionQueue();
	void InsertEvent(TDelegate<void(E_CHARA_MOTION_ID MotionID)> OnEvent);
	void Load();
	void Play(E_CHARA_MOTION_ID MotionID, float PlayRate, float BlendTimeOverride, float StartOffsetTime);
	void PlayExternalReference(const struct FCharaMotion& Motion, float PlayRate, float StartOffsetTime);
	void PlayExternalReferenceWithDuration(const struct FCharaMotion& Motion, float PlayRate, float StartOffsetTime, float Duration, float PlayRateRough, float BlendTimeOverride);
	void PlayWithDuration(E_CHARA_MOTION_ID MotionID, float Duration, float PlayRateRough, float BlendTimeOverride, float StartOffsetTime);
	void SetPlayRate(float PlayRate);
	void Stop();
	void Update(float DeltaTime, class UAnimInstance* AnimInstance, TArray<E_CHARA_MOTION_ID>* OutputPlayingMotions);

	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaMotionPlayerComponent">();
	}
	static class UCharaMotionPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaMotionPlayerComponent>();
	}
};
static_assert(alignof(UCharaMotionPlayerComponent) == 0x000008, "Wrong alignment on UCharaMotionPlayerComponent");
static_assert(sizeof(UCharaMotionPlayerComponent) == 0x0001B0, "Wrong size on UCharaMotionPlayerComponent");
static_assert(offsetof(UCharaMotionPlayerComponent, MotionTable) == 0x0000B0, "Member 'UCharaMotionPlayerComponent::MotionTable' has a wrong offset!");
static_assert(offsetof(UCharaMotionPlayerComponent, MotionBlendTable) == 0x0000B8, "Member 'UCharaMotionPlayerComponent::MotionBlendTable' has a wrong offset!");
static_assert(offsetof(UCharaMotionPlayerComponent, MotionBlendTable_Append) == 0x0000C0, "Member 'UCharaMotionPlayerComponent::MotionBlendTable_Append' has a wrong offset!");
static_assert(offsetof(UCharaMotionPlayerComponent, MotionTableAssetID) == 0x0000C8, "Member 'UCharaMotionPlayerComponent::MotionTableAssetID' has a wrong offset!");
static_assert(offsetof(UCharaMotionPlayerComponent, SlotName) == 0x0000F0, "Member 'UCharaMotionPlayerComponent::SlotName' has a wrong offset!");
static_assert(offsetof(UCharaMotionPlayerComponent, OnCharaMotionPlayerLoadCompleted) == 0x0000F8, "Member 'UCharaMotionPlayerComponent::OnCharaMotionPlayerLoadCompleted' has a wrong offset!");
static_assert(offsetof(UCharaMotionPlayerComponent, Montage) == 0x000198, "Member 'UCharaMotionPlayerComponent::Montage' has a wrong offset!");

// Class Project.MapActorCoreCPP
// 0x0000 (0x0220 - 0x0220)
class AMapActorCoreCPP : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorCoreCPP">();
	}
	static class AMapActorCoreCPP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapActorCoreCPP>();
	}
};
static_assert(alignof(AMapActorCoreCPP) == 0x000008, "Wrong alignment on AMapActorCoreCPP");
static_assert(sizeof(AMapActorCoreCPP) == 0x000220, "Wrong size on AMapActorCoreCPP");

// Class Project.CharaMotionTable
// 0x0050 (0x0078 - 0x0028)
class UCharaMotionTable final : public UObject
{
public:
	TMap<E_CHARA_MOTION_ID, struct FCharaMotion>  Map;                                               // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaMotionTable">();
	}
	static class UCharaMotionTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaMotionTable>();
	}
};
static_assert(alignof(UCharaMotionTable) == 0x000008, "Wrong alignment on UCharaMotionTable");
static_assert(sizeof(UCharaMotionTable) == 0x000078, "Wrong size on UCharaMotionTable");
static_assert(offsetof(UCharaMotionTable, Map) == 0x000028, "Member 'UCharaMotionTable::Map' has a wrong offset!");

// Class Project.CharaMotionOverrideBlendTimeTable
// 0x0050 (0x0078 - 0x0028)
class UCharaMotionOverrideBlendTimeTable final : public UObject
{
public:
	TMap<E_CHARA_MOTION_ID, struct FCharaMotionOverrideBlendTime> BlendMap;                                          // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaMotionOverrideBlendTimeTable">();
	}
	static class UCharaMotionOverrideBlendTimeTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaMotionOverrideBlendTimeTable>();
	}
};
static_assert(alignof(UCharaMotionOverrideBlendTimeTable) == 0x000008, "Wrong alignment on UCharaMotionOverrideBlendTimeTable");
static_assert(sizeof(UCharaMotionOverrideBlendTimeTable) == 0x000078, "Wrong size on UCharaMotionOverrideBlendTimeTable");
static_assert(offsetof(UCharaMotionOverrideBlendTimeTable, BlendMap) == 0x000028, "Member 'UCharaMotionOverrideBlendTimeTable::BlendMap' has a wrong offset!");

// Class Project.CharaMovementComponent
// 0x0018 (0x0150 - 0x0138)
class UCharaMovementComponent : public UPawnMovementComponent
{
public:
	bool                                          bDebug;                                            // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugUpVector;                                    // 0x0139(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugVelocity;                                    // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlyMovement;                                 // 0x013B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugJumpTrigger;                                 // 0x013C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1928[0x3];                                     // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharaMovementUpdated;                            // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void MoveLocalOffset(const struct FVector& DeltaLocation, float AdjustHeightMin, float AdjustHeightMax);
	void MoveWorldOffset(const struct FVector& DeltaLocation, float AdjustHeightMin, float AdjustHeightMax);

	EPhysicalSurface GetSurfaceType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaMovementComponent">();
	}
	static class UCharaMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaMovementComponent>();
	}
};
static_assert(alignof(UCharaMovementComponent) == 0x000008, "Wrong alignment on UCharaMovementComponent");
static_assert(sizeof(UCharaMovementComponent) == 0x000150, "Wrong size on UCharaMovementComponent");
static_assert(offsetof(UCharaMovementComponent, bDebug) == 0x000138, "Member 'UCharaMovementComponent::bDebug' has a wrong offset!");
static_assert(offsetof(UCharaMovementComponent, bDebugUpVector) == 0x000139, "Member 'UCharaMovementComponent::bDebugUpVector' has a wrong offset!");
static_assert(offsetof(UCharaMovementComponent, bDebugVelocity) == 0x00013A, "Member 'UCharaMovementComponent::bDebugVelocity' has a wrong offset!");
static_assert(offsetof(UCharaMovementComponent, bDebugFlyMovement) == 0x00013B, "Member 'UCharaMovementComponent::bDebugFlyMovement' has a wrong offset!");
static_assert(offsetof(UCharaMovementComponent, bDebugJumpTrigger) == 0x00013C, "Member 'UCharaMovementComponent::bDebugJumpTrigger' has a wrong offset!");
static_assert(offsetof(UCharaMovementComponent, OnCharaMovementUpdated) == 0x000140, "Member 'UCharaMovementComponent::OnCharaMovementUpdated' has a wrong offset!");

// Class Project.ResultExpBarBase
// 0x0000 (0x0260 - 0x0260)
class UResultExpBarBase final : public UUserWidget
{
public:
	static int32 CalcUpHP(int32 DevilID, int32 beforeMaxHP, int32 beforeLv, int32 AfterLv);
	static int32 CalcUpMP(int32 DevilID, int32 beforeMaxMP, int32 beforeLv, int32 AfterLv);
	static int32 GetInterval_EndRatio(float EndRatio);
	static int32 GetInterval_LvUp();
	static int32 GetInterval_Top2ExpMove();
	static int32 GetInterval_Zero2Max();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResultExpBarBase">();
	}
	static class UResultExpBarBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResultExpBarBase>();
	}
};
static_assert(alignof(UResultExpBarBase) == 0x000008, "Wrong alignment on UResultExpBarBase");
static_assert(sizeof(UResultExpBarBase) == 0x000260, "Wrong size on UResultExpBarBase");

// Class Project.BPL_CharaNameData
// 0x0000 (0x0028 - 0x0028)
class UBPL_CharaNameData final : public UBlueprintFunctionLibrary
{
public:
	static const class FText GetCharaName(int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CharaNameData">();
	}
	static class UBPL_CharaNameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CharaNameData>();
	}
};
static_assert(alignof(UBPL_CharaNameData) == 0x000008, "Wrong alignment on UBPL_CharaNameData");
static_assert(sizeof(UBPL_CharaNameData) == 0x000028, "Wrong size on UBPL_CharaNameData");

// Class Project.CharaPanelBase
// 0x0158 (0x0378 - 0x0220)
class ACharaPanelBase : public AActor
{
public:
	struct FCharaPanelBaseData                    M_CharaPanelData;                                  // 0x0220(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture*                               PmsPanelIcon;                                      // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192A[0xE8];                                    // 0x0290(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BIECalcGaugeAlpha();
	void BIEPAnimeIsPanelFadeIn();
	void BIEPAnimeIsPanelFadeOut();
	void BIEPAnimeSetEmptyPanelFadeIn();
	void BIEPAnimeSetPanelFadeOut();
	void BIEPAnimeSetSummonPanelFadeIn();
	void BIEResetSupportIcon(E_CHARAPANEL_SUPPORTICON_TYPE ArgSupportType);
	void BIESetActorMovePosition();
	void BIESetRecoveryAnimation();
	void BIESetSupportIcon(E_CHARAPANEL_SUPPORTICON_TYPE ArgSupportType);
	bool CalcActorMoveProc(float InDelta);
	int32 CalcAdjustParam(int32 Type);
	void CalcParameter(int32 Type, int32 Param0, int32 Param1, int32 Param2, bool Execution);
	bool DeleteCharaPanel();
	int32 ForceFinishedAdjustParam(int32 Type);
	int32 GetActorMoveMode();
	int32 GetActorMovePosition(int32 InPosMode);
	int32 GetAdjustParam(int32 Type);
	int32 GetAdjustParamType(int32 Type);
	E_BAD_STATUS GetBadstatusParameter(int32 InPosition);
	float GetGaugeAlpha(int32 InType);
	float GetGaugeRatio(int32 Param0, int32 Param1);
	struct FVector2D GetNumberCountAnimationPosition(int32 InMode, int32 InMove, int32 InType);
	int32 GetParameter(int32 Type);
	class FText GetParameterText(int32 Type);
	bool IsAdjustParam(int32 Type);
	bool IsPanelRecoveryAnimation();
	class UObject* LoadCharaPanelIcon(int32 InCharaId);
	bool ResetActorMoveMode();
	int32 ResetBadstatusParameter(E_BAD_STATUS Type);
	int32 ResetSupportParameter(E_CHARAPANEL_SUPPORTICON_TYPE Type);
	bool SetActorMoveMode(int32 InMode);
	int32 SetBadstatusParameter(E_BAD_STATUS Type);
	bool SetGaugeAlphaAnimation(int32 InType, bool InFlag);
	bool SetNextPAnimeStack();
	bool SetPAnimeStack(int32 InType, float InStartTime);
	void SetParameter(int32 Type, int32 Param0, int32 Param1, int32 Param2);
	void SetParameterText(int32 Type, const class FText& Text);
	int32 SetSupportParameter(E_CHARAPANEL_SUPPORTICON_TYPE Type);
	bool StartNumberCountAnimation(int32 InPosMode);
	bool StartPanelRecoveryAnimation(float InStartTime);
	bool StopPanelRecoveryAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaPanelBase">();
	}
	static class ACharaPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharaPanelBase>();
	}
};
static_assert(alignof(ACharaPanelBase) == 0x000008, "Wrong alignment on ACharaPanelBase");
static_assert(sizeof(ACharaPanelBase) == 0x000378, "Wrong size on ACharaPanelBase");
static_assert(offsetof(ACharaPanelBase, M_CharaPanelData) == 0x000220, "Member 'ACharaPanelBase::M_CharaPanelData' has a wrong offset!");
static_assert(offsetof(ACharaPanelBase, PmsPanelIcon) == 0x000288, "Member 'ACharaPanelBase::PmsPanelIcon' has a wrong offset!");

// Class Project.MapEventManager
// 0x0010 (0x0038 - 0x0028)
class UMapEventManager final : public UObject
{
public:
	TArray<class UObject*>                        MapEventHits;                                      // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void RegisterMapEventHits(const TArray<class UObject*>& InMapEventHits);
	void UnregisterMapEventHits();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEventManager">();
	}
	static class UMapEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEventManager>();
	}
};
static_assert(alignof(UMapEventManager) == 0x000008, "Wrong alignment on UMapEventManager");
static_assert(sizeof(UMapEventManager) == 0x000038, "Wrong size on UMapEventManager");
static_assert(offsetof(UMapEventManager, MapEventHits) == 0x000028, "Member 'UMapEventManager::MapEventHits' has a wrong offset!");

// Class Project.CharaPanelVNumberCtrlBase
// 0x0048 (0x0268 - 0x0220)
class ACharaPanelVNumberCtrlBase : public AActor
{
public:
	uint8                                         Pad_193B[0x48];                                    // 0x0220(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BIESetInitializeVNumberAnimation(int32 InIndex, int32 InDataType, int32 InNumber);
	void BIESetStartFadeOutVNumberAnimation(int32 InIndex, int32 InDataType);
	bool DeleteVNumberList();
	struct FVector2D GetCenterPosition();
	struct FVector2D GetSignPosition();
	int32 GetVNumberMode();
	bool IsVNumberAnimation();
	bool SetVNumberMode(int32 InMode);
	bool SetVNumberValue(int32 InType, int32 InNumber);
	bool StartFadeOut();
	bool StartVNumberAnimation(float InStartTime);
	bool StopVNumberAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaPanelVNumberCtrlBase">();
	}
	static class ACharaPanelVNumberCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharaPanelVNumberCtrlBase>();
	}
};
static_assert(alignof(ACharaPanelVNumberCtrlBase) == 0x000008, "Wrong alignment on ACharaPanelVNumberCtrlBase");
static_assert(sizeof(ACharaPanelVNumberCtrlBase) == 0x000268, "Wrong size on ACharaPanelVNumberCtrlBase");

// Class Project.CharaParamComponent
// 0x00F8 (0x01A8 - 0x00B0)
class UCharaParamComponent final : public UActorComponent
{
public:
	E_BTL_CHAR_TYPE                               M_charatype;                                       // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193F[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_Id;                                              // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PlaceIndex;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_DefenseArea;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AttackReach;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_BattleMoveSpeed;                                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_MoveSpeedRatio;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsInterpAttackMotion;                            // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1940[0x3];                                     // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_InterpAttackMotionBlendTime;                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_OffsetZ;                                         // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_NkmScale;                                        // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EncMaxScale;                                     // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EncMinScale;                                     // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_CameraAndEffectScale;                            // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_NkmCameraScale;                                  // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_NkmEffectScale;                                  // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EncCameraScale;                                  // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EncEffectScale;                                  // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_EnableBadStatusEffectScale;                      // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1941[0x3];                                     // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_BadStatusEffectScale;                            // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_NkmUpliftingEffectScale;                         // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EncUpliftingEffectScale;                         // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_NkmBoundsScale;                                  // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EncBoundsScale;                                  // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_GardenBoundsScale;                               // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_EncHugeBattleCameraScale;                        // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_BattleCamCategory;                               // 0x0118(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_UITexture;                                       // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_MoveValid;                                       // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_MoveValid_RangedSkill;                           // 0x0139(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsLeader;                                        // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsAvoidDistanceOverride;                         // 0x013B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AvoidDistance;                                   // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AvoidDurationSec;                                // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_SKILL_HIT_STAMP_TYPE                        M_AttackHitStampType;                              // 0x0144(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1942[0x3];                                     // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_AttackPerformanceName;                           // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_ChantCameraOptionName;                           // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_SkillAnimCameraTallSocketName;                   // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsChangeCameraOnApplyHit;                        // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1943[0x3];                                     // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_TalkEyeOffsetDevilUp;                            // 0x0174(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_TalkLookOffsetDevilUp;                           // 0x0180(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_TalkHeroLocationOffset;                          // 0x018C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsWarpAtIntroductionMelee;                       // 0x0198(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsOverrideShortRangeAttackCamera;                // 0x0199(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1944[0x2];                                     // 0x019A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_FixedRangeSkillDistanceScale;                    // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsMagatsuhiDevil;                                // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1945[0x7];                                     // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaParamComponent">();
	}
	static class UCharaParamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaParamComponent>();
	}
};
static_assert(alignof(UCharaParamComponent) == 0x000008, "Wrong alignment on UCharaParamComponent");
static_assert(sizeof(UCharaParamComponent) == 0x0001A8, "Wrong size on UCharaParamComponent");
static_assert(offsetof(UCharaParamComponent, M_charatype) == 0x0000B0, "Member 'UCharaParamComponent::M_charatype' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_Id) == 0x0000B4, "Member 'UCharaParamComponent::M_Id' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_PlaceIndex) == 0x0000B8, "Member 'UCharaParamComponent::M_PlaceIndex' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_DefenseArea) == 0x0000BC, "Member 'UCharaParamComponent::M_DefenseArea' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_AttackReach) == 0x0000C0, "Member 'UCharaParamComponent::M_AttackReach' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_BattleMoveSpeed) == 0x0000C4, "Member 'UCharaParamComponent::M_BattleMoveSpeed' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_MoveSpeedRatio) == 0x0000C8, "Member 'UCharaParamComponent::M_MoveSpeedRatio' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_IsInterpAttackMotion) == 0x0000CC, "Member 'UCharaParamComponent::M_IsInterpAttackMotion' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_InterpAttackMotionBlendTime) == 0x0000D0, "Member 'UCharaParamComponent::M_InterpAttackMotionBlendTime' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_OffsetZ) == 0x0000D4, "Member 'UCharaParamComponent::M_OffsetZ' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_NkmScale) == 0x0000D8, "Member 'UCharaParamComponent::M_NkmScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_EncMaxScale) == 0x0000DC, "Member 'UCharaParamComponent::M_EncMaxScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_EncMinScale) == 0x0000E0, "Member 'UCharaParamComponent::M_EncMinScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_CameraAndEffectScale) == 0x0000E4, "Member 'UCharaParamComponent::M_CameraAndEffectScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_NkmCameraScale) == 0x0000E8, "Member 'UCharaParamComponent::M_NkmCameraScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_NkmEffectScale) == 0x0000EC, "Member 'UCharaParamComponent::M_NkmEffectScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_EncCameraScale) == 0x0000F0, "Member 'UCharaParamComponent::M_EncCameraScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_EncEffectScale) == 0x0000F4, "Member 'UCharaParamComponent::M_EncEffectScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_EnableBadStatusEffectScale) == 0x0000F8, "Member 'UCharaParamComponent::M_EnableBadStatusEffectScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_BadStatusEffectScale) == 0x0000FC, "Member 'UCharaParamComponent::M_BadStatusEffectScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_NkmUpliftingEffectScale) == 0x000100, "Member 'UCharaParamComponent::M_NkmUpliftingEffectScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_EncUpliftingEffectScale) == 0x000104, "Member 'UCharaParamComponent::M_EncUpliftingEffectScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_NkmBoundsScale) == 0x000108, "Member 'UCharaParamComponent::M_NkmBoundsScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_EncBoundsScale) == 0x00010C, "Member 'UCharaParamComponent::M_EncBoundsScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_GardenBoundsScale) == 0x000110, "Member 'UCharaParamComponent::M_GardenBoundsScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_EncHugeBattleCameraScale) == 0x000114, "Member 'UCharaParamComponent::M_EncHugeBattleCameraScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_BattleCamCategory) == 0x000118, "Member 'UCharaParamComponent::M_BattleCamCategory' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_UITexture) == 0x000130, "Member 'UCharaParamComponent::M_UITexture' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_MoveValid) == 0x000138, "Member 'UCharaParamComponent::M_MoveValid' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_MoveValid_RangedSkill) == 0x000139, "Member 'UCharaParamComponent::M_MoveValid_RangedSkill' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_IsLeader) == 0x00013A, "Member 'UCharaParamComponent::M_IsLeader' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_IsAvoidDistanceOverride) == 0x00013B, "Member 'UCharaParamComponent::M_IsAvoidDistanceOverride' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_AvoidDistance) == 0x00013C, "Member 'UCharaParamComponent::M_AvoidDistance' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_AvoidDurationSec) == 0x000140, "Member 'UCharaParamComponent::M_AvoidDurationSec' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_AttackHitStampType) == 0x000144, "Member 'UCharaParamComponent::M_AttackHitStampType' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_AttackPerformanceName) == 0x000148, "Member 'UCharaParamComponent::M_AttackPerformanceName' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_ChantCameraOptionName) == 0x000158, "Member 'UCharaParamComponent::M_ChantCameraOptionName' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_SkillAnimCameraTallSocketName) == 0x000168, "Member 'UCharaParamComponent::M_SkillAnimCameraTallSocketName' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_IsChangeCameraOnApplyHit) == 0x000170, "Member 'UCharaParamComponent::M_IsChangeCameraOnApplyHit' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_TalkEyeOffsetDevilUp) == 0x000174, "Member 'UCharaParamComponent::M_TalkEyeOffsetDevilUp' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_TalkLookOffsetDevilUp) == 0x000180, "Member 'UCharaParamComponent::M_TalkLookOffsetDevilUp' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_TalkHeroLocationOffset) == 0x00018C, "Member 'UCharaParamComponent::M_TalkHeroLocationOffset' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_IsWarpAtIntroductionMelee) == 0x000198, "Member 'UCharaParamComponent::M_IsWarpAtIntroductionMelee' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_IsOverrideShortRangeAttackCamera) == 0x000199, "Member 'UCharaParamComponent::M_IsOverrideShortRangeAttackCamera' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_FixedRangeSkillDistanceScale) == 0x00019C, "Member 'UCharaParamComponent::M_FixedRangeSkillDistanceScale' has a wrong offset!");
static_assert(offsetof(UCharaParamComponent, M_IsMagatsuhiDevil) == 0x0001A0, "Member 'UCharaParamComponent::M_IsMagatsuhiDevil' has a wrong offset!");

// Class Project.BPL_MissionData
// 0x0000 (0x0028 - 0x0028)
class UBPL_MissionData final : public UBlueprintFunctionLibrary
{
public:
	static void AddMissionGeneralCount(int32 MissionId, int32 CountIndex, int32 Add);
	static void AddMissionHuntCount(int32 DevilID, int32 Add);
	static void ChangeMissionNewIcon(int32 MissionId, bool IsView);
	static bool CheckMissionComplete(int32 MissionId);
	static bool CheckMissionCompleteCond(int32 MissionId, bool CheckEntryComplete);
	static bool CheckMissionEntry(int32 MissionId);
	static bool CheckMissionEntryCond(int32 MissionId);
	static bool CheckMissionNewIcon(int32 MissionId);
	static bool CheckTimeAttackReportable(int32 MissionId, bool* OutSuccess);
	static bool CheckViewMissionCompleteInfo(int32 MissionId);
	static void CompleteMission(int32 MissionId);
	static void EntryMission(int32 MissionId);
	static void FinishTimeAttackMission_CPP(int32 MissionId);
	static void GetCenterOfVisibleTargetIcons(int32 MissionId, bool IsMessageWindow, int32* OutNum, int32* OutMapId, int32* OutAreaId, struct FVector* OutLocation, float* OutZoom);
	static int32 GetCreationModeExp(int32 MissionId);
	static bool GetIconLocationForReport(int32 MissionId, int32* OutMapId, int32* OutAreaId, struct FVector* OutLocation, float* OutZoom);
	static const class FText GetMissionClientName(int32 MissionId);
	static const struct FScriptMessage GetMissionClientNameMsg(int32 MissionId);
	static const struct FMissionData GetMissionData(int32 ID);
	static int32 GetMissionDataMax();
	static const struct FScriptMessage GetMissionExplainMsg(int32 MissionId);
	static const class FText GetMissionExplainText(int32 MissionId);
	static int32 GetMissionGeneralCount(int32 MissionId, int32 CountIndex);
	static const struct FScriptMessage GetMissionHelpMessage(int32 MissionId, class FText* OutPlaceText1, class FText* OutPlaceText2, class FText* OutPlaceText3);
	static int32 GetMissionHuntCount(int32 MissionId, int32 DevilID);
	static int32 GetMissionIdMax();
	static const struct FScriptMessage GetMissionInfoTagMessage(int32 MissionId, E_MISSION_INFO_TEXT InfoText);
	static class FText GetMissionMajorTypeText(E_MISSION_MAJOR_TYPE Type);
	static int32 GetMissionNakamaDevilId(int32 MissionId);
	static const class FText GetMissionName(int32 MissionId);
	static const struct FScriptMessage GetMissionNameMsg(int32 MissionId);
	static const struct FScriptMessage GetMissionRewardMsg(int32 MissionId, int32* OutTag1, int32* OutTag2);
	static E_MISSION_STATE GetMissionState(int32 MissionId);
	static const struct FMissionTargetIcon GetMissionTargetIcon(int32 MissionId, int32 IconIndex);
	static const TArray<struct FMissionTargetIcon> GetMissionTargetIconAll(int32 MissionId);
	static class FText GetMissionTypeText(E_MISSION_TYPE Type);
	static int32 GetMissionVisibleTargetIconNum(int32 MissionId);
	static TArray<E_GROUP_ID> GetTimeAttackEnemyGroupList();
	static TArray<int32> GetTimeAttackEnemyList();
	static E_TIME_ATTACK_MISSION_STATE GetTimeAttackState(int32 MissionId);
	static void InitMissionData();
	static bool IsInOtherTimeAttack(int32 MyMissionId, int32* OutOtherMissionId);
	static bool IsInTimeAttack(int32 MissionId);
	static bool IsLogUpdated(int32 MissionId);
	static bool IsRyuketsuWarpLockedByMission();
	static TArray<int32> MakeReportableList();
	static TArray<struct FMissionTimeAttackInfo> MakeTimeAttackInfoList();
	static TArray<struct FMissionUpdateInfo> MakeUpdateInfoList();
	static void OnMovedToOtherMapInTimeAttack(int32 MissionId);
	static void RegisterRadarToTargetIconAll(int32 MissionId);
	static void RemoveRadarFromTargetIconAll(int32 MissionId);
	static void SetIsLogUpdated(int32 MissionId, bool IsLogUpdated);
	static void SetMissionCompleteInfo(int32 MissionId);
	static void SetMissionGeneralCount(int32 MissionId, int32 CountIndex, int32 Value);
	static void ShowMissionTargetIcon(int32 MissionId, int32 IconIndex);
	static void ShowMissionTargetIconAll(int32 MissionId);
	static void StartTimeAttackMission_CPP(int32 MissionId);
	static bool TimeAttackMissionUpdateMoonAge(int32 Add);
	static void TimeAttackReachedGoal(int32 MissionId);
	static void UpdateCompleteFlags(int32 MissionId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MissionData">();
	}
	static class UBPL_MissionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MissionData>();
	}
};
static_assert(alignof(UBPL_MissionData) == 0x000008, "Wrong alignment on UBPL_MissionData");
static_assert(sizeof(UBPL_MissionData) == 0x000028, "Wrong size on UBPL_MissionData");

// Class Project.CharaStampEffectTable
// 0x0050 (0x0078 - 0x0028)
class UCharaStampEffectTable final : public UObject
{
public:
	TMap<EPhysicalSurface, struct FCharaStampEffect> Map;                                               // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	const struct FCharaStampEffect FindNonPure(EPhysicalSurface InSurfaceType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaStampEffectTable">();
	}
	static class UCharaStampEffectTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaStampEffectTable>();
	}
};
static_assert(alignof(UCharaStampEffectTable) == 0x000008, "Wrong alignment on UCharaStampEffectTable");
static_assert(sizeof(UCharaStampEffectTable) == 0x000078, "Wrong size on UCharaStampEffectTable");
static_assert(offsetof(UCharaStampEffectTable, Map) == 0x000028, "Member 'UCharaStampEffectTable::Map' has a wrong offset!");

// Class Project.BPL_CharaUtil
// 0x0000 (0x0028 - 0x0028)
class UBPL_CharaUtil final : public UBlueprintFunctionLibrary
{
public:
	static int32 FindOriginalDevilIByRawMap(int32 DevilID, const TMap<int32, struct FDevilAssetTable_Raw>& RawMap);
	static int32 GetCalcIKLevel(class USkinnedMeshComponent* Mesh);
	static int32 GetLODLevel(class USkinnedMeshComponent* Mesh);
	static void GetSyncGroupPosition(const class UAnimInstance* AnimInstance, const class FName& GroupName, class FName* OutPreviousMarkerName, class FName* OutNextMarkerName, float* OutPositionBetweenMarkers);
	static bool LoadDevilAssetTableRawData(class UDataTable* DataTable, TMap<int32, struct FDevilAssetTable_Raw>& OutMap);
	static TArray<E_BAD_STATUS> PickUpStatus_inner(int32 State);
	static void PickUpSurfaceStatus_inner(int32 State, E_BAD_STATUS BeforeStatus, E_BAD_STATUS* Ret, bool* IsNeedResetMaterial);
	static int32 SetUpState_inner(const TArray<E_BAD_STATUS>& BadStatus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CharaUtil">();
	}
	static class UBPL_CharaUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CharaUtil>();
	}
};
static_assert(alignof(UBPL_CharaUtil) == 0x000008, "Wrong alignment on UBPL_CharaUtil");
static_assert(sizeof(UBPL_CharaUtil) == 0x000028, "Wrong size on UBPL_CharaUtil");

// Class Project.MinimapCoasterLineMinimap
// 0x0070 (0x0098 - 0x0028)
class UMinimapCoasterLineMinimap final : public UObject
{
public:
	uint8                                         Pad_196E[0x58];                                    // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 M_Image;                                           // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_196F[0x10];                                    // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapCoasterLineMinimap">();
	}
	static class UMinimapCoasterLineMinimap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapCoasterLineMinimap>();
	}
};
static_assert(alignof(UMinimapCoasterLineMinimap) == 0x000008, "Wrong alignment on UMinimapCoasterLineMinimap");
static_assert(sizeof(UMinimapCoasterLineMinimap) == 0x000098, "Wrong size on UMinimapCoasterLineMinimap");
static_assert(offsetof(UMinimapCoasterLineMinimap, M_Image) == 0x000080, "Member 'UMinimapCoasterLineMinimap::M_Image' has a wrong offset!");

// Class Project.BPL_CharGrow
// 0x0000 (0x0028 - 0x0028)
class UBPL_CharGrow final : public UBlueprintFunctionLibrary
{
public:
	static struct FPlayerGrowData GetPlayerGrowTableData();
	static const class FText GetPlayerRace(E_PLAYER_TYPE PlayerType);
	static bool PlayerGrowDataIsDummy(const struct FPlayerGrowData& PData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CharGrow">();
	}
	static class UBPL_CharGrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CharGrow>();
	}
};
static_assert(alignof(UBPL_CharGrow) == 0x000008, "Wrong alignment on UBPL_CharGrow");
static_assert(sizeof(UBPL_CharGrow) == 0x000028, "Wrong size on UBPL_CharGrow");

// Class Project.BPL_CoasterData
// 0x0000 (0x0028 - 0x0028)
class UBPL_CoasterData final : public UBlueprintFunctionLibrary
{
public:
	static const struct FCoasterSaveBuffer GetCoasterSaveBufferData(int32 TableID);
	static int32 GetCoasterSaveBufferDataMax();
	static int32 GetCoasterSaveBufferNum(int32 MapId);
	static int32 GetCoasterSaveBufferStart(int32 MapId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CoasterData">();
	}
	static class UBPL_CoasterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CoasterData>();
	}
};
static_assert(alignof(UBPL_CoasterData) == 0x000008, "Wrong alignment on UBPL_CoasterData");
static_assert(sizeof(UBPL_CoasterData) == 0x000028, "Wrong size on UBPL_CoasterData");

// Class Project.MovieSceneActorEventTrack
// 0x0030 (0x00C0 - 0x0090)
class UMovieSceneActorEventTrack final : public UMovieSceneNameableTrack
{
public:
	uint8                                         Pad_1972[0x8];                                     // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1973[0x3];                                     // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFireActorEventsAtPosition                    EventPosition;                                     // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1974[0x3];                                     // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovieSceneObjectBindingID>     EventReceivers;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneActorEventTrack">();
	}
	static class UMovieSceneActorEventTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneActorEventTrack>();
	}
};
static_assert(alignof(UMovieSceneActorEventTrack) == 0x000008, "Wrong alignment on UMovieSceneActorEventTrack");
static_assert(sizeof(UMovieSceneActorEventTrack) == 0x0000C0, "Wrong size on UMovieSceneActorEventTrack");
static_assert(offsetof(UMovieSceneActorEventTrack, EventPosition) == 0x00009C, "Member 'UMovieSceneActorEventTrack::EventPosition' has a wrong offset!");
static_assert(offsetof(UMovieSceneActorEventTrack, EventReceivers) == 0x0000A0, "Member 'UMovieSceneActorEventTrack::EventReceivers' has a wrong offset!");
static_assert(offsetof(UMovieSceneActorEventTrack, Sections) == 0x0000B0, "Member 'UMovieSceneActorEventTrack::Sections' has a wrong offset!");

// Class Project.CustomCameraRig_Rail
// 0x0050 (0x0270 - 0x0220)
class ACustomCameraRig_Rail : public AActor
{
public:
	struct FRigRailPlayInfo                       M_PlayInfo;                                        // 0x0220(0x0034)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurrentPositionOnRail;                             // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TransformComponent;                                // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       RailSplineComponent;                               // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RailCameraMount;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector GetDirectionAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace);
	struct FVector GetLocationDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace);
	struct FRotator GetRotationAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace);
	float GetSplineLength();
	void MakeupSpline(const TArray<struct FCustomSplinePoint>& SplinePoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCameraRig_Rail">();
	}
	static class ACustomCameraRig_Rail* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomCameraRig_Rail>();
	}
};
static_assert(alignof(ACustomCameraRig_Rail) == 0x000008, "Wrong alignment on ACustomCameraRig_Rail");
static_assert(sizeof(ACustomCameraRig_Rail) == 0x000270, "Wrong size on ACustomCameraRig_Rail");
static_assert(offsetof(ACustomCameraRig_Rail, M_PlayInfo) == 0x000220, "Member 'ACustomCameraRig_Rail::M_PlayInfo' has a wrong offset!");
static_assert(offsetof(ACustomCameraRig_Rail, CurrentPositionOnRail) == 0x000254, "Member 'ACustomCameraRig_Rail::CurrentPositionOnRail' has a wrong offset!");
static_assert(offsetof(ACustomCameraRig_Rail, TransformComponent) == 0x000258, "Member 'ACustomCameraRig_Rail::TransformComponent' has a wrong offset!");
static_assert(offsetof(ACustomCameraRig_Rail, RailSplineComponent) == 0x000260, "Member 'ACustomCameraRig_Rail::RailSplineComponent' has a wrong offset!");
static_assert(offsetof(ACustomCameraRig_Rail, RailCameraMount) == 0x000268, "Member 'ACustomCameraRig_Rail::RailCameraMount' has a wrong offset!");

// Class Project.CustomComponent
// 0x0000 (0x00B0 - 0x00B0)
class UCustomComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomComponent">();
	}
	static class UCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomComponent>();
	}
};
static_assert(alignof(UCustomComponent) == 0x000008, "Wrong alignment on UCustomComponent");
static_assert(sizeof(UCustomComponent) == 0x0000B0, "Wrong size on UCustomComponent");

// Class Project.CustomPawn
// 0x0068 (0x02E8 - 0x0280)
class ACustomPawn : public APawn
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAbsoluteViewRotation;                             // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1978[0x7];                                     // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTransformUpdated;                                // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIgnoreMovementInputByNotifyState;                 // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1979[0x3];                                     // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterId;                                       // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRootMotion;                                 // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRootMotionRotationXY;                       // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRootMotionTransient;                        // 0x02B2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_197A[0x1D];                                    // 0x02B3(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCueSheet*                     VoiceCueSheet;                                     // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapSymbolComponentCPP*                 SymbolComponent;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNahobino;                                        // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_197B[0x7];                                     // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallMapEventOnReadyDelegate();
	void ForceEnableMovementInput(float Time, bool bMovement, bool bRotate);
	const class UCharaParamComponent* GetCharaParam();
	void OnPrepareMapEvent();
	void PrepareMapEvent(TDelegate<void()> OnReady);
	void ResetForceEnableMovementInput();
	class UParticleSystemComponent* SpawnTrailEmitter(class UParticleSystem* EmitterTemplate, class FName FirstSocketName, class FName SecondSocketName, ETrailWidthMode WidthMode, float Width);

	bool CheckMagatsuhiDevil() const;
	bool CheckPlayAnimNotifyDevilVoice(EDevilVoiceType DevilVoiceType) const;
	float GetGravityZ() const;
	bool IsForceEnabledMovementInput() const;
	bool IsForceEnabledRotateInput() const;
	bool IsMovingOnGround() const;
	bool IsRootMotionPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPawn">();
	}
	static class ACustomPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomPawn>();
	}
};
static_assert(alignof(ACustomPawn) == 0x000008, "Wrong alignment on ACustomPawn");
static_assert(sizeof(ACustomPawn) == 0x0002E8, "Wrong size on ACustomPawn");
static_assert(offsetof(ACustomPawn, Mesh) == 0x000280, "Member 'ACustomPawn::Mesh' has a wrong offset!");
static_assert(offsetof(ACustomPawn, CapsuleComponent) == 0x000288, "Member 'ACustomPawn::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ACustomPawn, bAbsoluteViewRotation) == 0x000290, "Member 'ACustomPawn::bAbsoluteViewRotation' has a wrong offset!");
static_assert(offsetof(ACustomPawn, OnTransformUpdated) == 0x000298, "Member 'ACustomPawn::OnTransformUpdated' has a wrong offset!");
static_assert(offsetof(ACustomPawn, bIgnoreMovementInputByNotifyState) == 0x0002A8, "Member 'ACustomPawn::bIgnoreMovementInputByNotifyState' has a wrong offset!");
static_assert(offsetof(ACustomPawn, CharacterId) == 0x0002AC, "Member 'ACustomPawn::CharacterId' has a wrong offset!");
static_assert(offsetof(ACustomPawn, bEnableRootMotion) == 0x0002B0, "Member 'ACustomPawn::bEnableRootMotion' has a wrong offset!");
static_assert(offsetof(ACustomPawn, bIgnoreRootMotionRotationXY) == 0x0002B1, "Member 'ACustomPawn::bIgnoreRootMotionRotationXY' has a wrong offset!");
static_assert(offsetof(ACustomPawn, bIgnoreRootMotionTransient) == 0x0002B2, "Member 'ACustomPawn::bIgnoreRootMotionTransient' has a wrong offset!");
static_assert(offsetof(ACustomPawn, VoiceCueSheet) == 0x0002D0, "Member 'ACustomPawn::VoiceCueSheet' has a wrong offset!");
static_assert(offsetof(ACustomPawn, SymbolComponent) == 0x0002D8, "Member 'ACustomPawn::SymbolComponent' has a wrong offset!");
static_assert(offsetof(ACustomPawn, IsNahobino) == 0x0002E0, "Member 'ACustomPawn::IsNahobino' has a wrong offset!");

// Class Project.MovieSceneFacialAnimationPresetTrack
// 0x0018 (0x00A8 - 0x0090)
class UMovieSceneFacialAnimationPresetTrack final : public UMovieSceneNameableTrack
{
public:
	uint8                                         Pad_197E[0x8];                                     // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x0098(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFacialAnimationPresetTrack">();
	}
	static class UMovieSceneFacialAnimationPresetTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFacialAnimationPresetTrack>();
	}
};
static_assert(alignof(UMovieSceneFacialAnimationPresetTrack) == 0x000008, "Wrong alignment on UMovieSceneFacialAnimationPresetTrack");
static_assert(sizeof(UMovieSceneFacialAnimationPresetTrack) == 0x0000A8, "Wrong size on UMovieSceneFacialAnimationPresetTrack");
static_assert(offsetof(UMovieSceneFacialAnimationPresetTrack, Sections) == 0x000098, "Member 'UMovieSceneFacialAnimationPresetTrack::Sections' has a wrong offset!");

// Class Project.CustomPlayerCameraManager
// 0x0010 (0x2820 - 0x2810)
class ACustomPlayerCameraManager : public APlayerCameraManager
{
public:
	uint8                                         bEnableQuartanionBlending : 1;                     // 0x2810(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_197F[0x7];                                     // 0x2811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendCurve;                                        // 0x2818(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ForceUpdateCameraCache();
	void SetCameraFOV(E_OPTION_CONTENT_FOV_TYPE FOVType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPlayerCameraManager">();
	}
	static class ACustomPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomPlayerCameraManager>();
	}
};
static_assert(alignof(ACustomPlayerCameraManager) == 0x000010, "Wrong alignment on ACustomPlayerCameraManager");
static_assert(sizeof(ACustomPlayerCameraManager) == 0x002820, "Wrong size on ACustomPlayerCameraManager");
static_assert(offsetof(ACustomPlayerCameraManager, BlendCurve) == 0x002818, "Member 'ACustomPlayerCameraManager::BlendCurve' has a wrong offset!");

// Class Project.PadController
// 0x0128 (0x0698 - 0x0570)
class APadController : public APlayerController
{
public:
	uint8                                         Pad_1980[0x128];                                   // 0x0570(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CallBeforeOutputDefaultTable();
	static bool CheckKeyConfigLoaded();
	static class FName GetActionMappingName(E_ACTION_MAPPING_TYPE ActionMapping);
	static class FName GetAxisMappingName(E_AXIS_MAPPING_TYPE AxisMapping);
	static E_GAMEPAD_TYPE GetConnectedGamepadType_ForSteam();

	void CallManualActionMapping_Core(E_ACTION_MAPPING_TYPE ActionMapping);
	void CallManualAnalogStickValue(bool IsLeftStick, bool IsX, float Value);
	void CallManualAxisMapping_Core(E_AXIS_MAPPING_TYPE AxisMapping, float Scale);
	bool CheckGamePadEnable();
	bool CheckGamePadUI();
	bool CheckMouseKeyboardEnable();
	void GetAxisPadCore(E_AXIS_MAPPING_TYPE AxisMapType, float* Value);
	void GetInputActionMappingsCore(E_INPUT_TYPE InputType, TArray<E_ACTION_MAPPING_TYPE>* ActionMappings);
	bool GetMousePos(float* X, float* Y);
	bool GetMouseWheelAxis(float* WheelAxis);
	bool IsActionPadCheckCore(E_ACTION_MAPPING_TYPE ActionMapType, E_INPUT_TYPE InputType, struct FKey* Key);
	bool IsHold_MouseAction(bool* bHold);
	bool IsHold_MouseAnyButton(bool* bHold);
	bool IsMovedMouseCursor(bool* bMoved);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PadController">();
	}
	static class APadController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APadController>();
	}
};
static_assert(alignof(APadController) == 0x000008, "Wrong alignment on APadController");
static_assert(sizeof(APadController) == 0x000698, "Wrong size on APadController");

// Class Project.OptionData
// 0x0000 (0x0028 - 0x0028)
class UOptionData final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionData">();
	}
	static class UOptionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionData>();
	}
};
static_assert(alignof(UOptionData) == 0x000008, "Wrong alignment on UOptionData");
static_assert(sizeof(UOptionData) == 0x000028, "Wrong size on UOptionData");

// Class Project.CustomPlayerController
// 0x0020 (0x06B8 - 0x0698)
class ACustomPlayerController : public APadController
{
public:
	class UCurveFloat*                            M_SwitchPlayerCameraInputCurve;                    // 0x0698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_ConstCameraSpeedLR;                              // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_ConstCameraSpeedUD;                              // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198B[0x10];                                    // 0x06A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalulateCameraSpeed(E_AXIS_MAPPING_TYPE CameraAxis, float InputSpeed, bool IsMouseInput);
	float ClampCameraInputSpeed(float InputSpeed, bool IsMouseInput);
	void LookRightCamera(float InputSpeed, bool IsMouseInput);
	void LookUpCamera(float InputSpeed, bool IsMouseInput);
	void OnChangeIgnoreActionInput(bool bNewIgnoreInput);
	void OnChangeIgnoreLookInput(bool bNewIgnoreInput);
	void OnChangeIgnoreMoveInput(bool bNewIgnoreInput);
	void SetProjectIgnoreActionInput(bool bNewIgnoreInput, EInputIgnoreReason InReason);
	void SetProjectIgnoreAllInput(bool bNewIgnoreInput, EInputIgnoreReason InReason);
	void SetProjectIgnoreLookInput(bool bNewIgnoreInput, EInputIgnoreReason InReason);
	void SetProjectIgnoreMasterInput(bool bNewIgnoreInput);
	void SetProjectIgnoreMoveInput(bool bNewIgnoreInput, EInputIgnoreReason InReason);
	void SetViewTargetWithBlendCurve(class AActor* NewViewTarget, float BlendTime, const class UCurveFloat* BlendCurve, bool bForceOverwrite);
	void SetViewTargetWithBlendQuartanion(class AActor* NewViewTarget, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing, bool bForceOverwrite);

	bool IsProjectActionInputIgnored() const;
	bool IsProjectLookInputIgnored() const;
	bool IsProjectMoveInputIgnored() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPlayerController">();
	}
	static class ACustomPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomPlayerController>();
	}
};
static_assert(alignof(ACustomPlayerController) == 0x000008, "Wrong alignment on ACustomPlayerController");
static_assert(sizeof(ACustomPlayerController) == 0x0006B8, "Wrong size on ACustomPlayerController");
static_assert(offsetof(ACustomPlayerController, M_SwitchPlayerCameraInputCurve) == 0x000698, "Member 'ACustomPlayerController::M_SwitchPlayerCameraInputCurve' has a wrong offset!");
static_assert(offsetof(ACustomPlayerController, M_ConstCameraSpeedLR) == 0x0006A0, "Member 'ACustomPlayerController::M_ConstCameraSpeedLR' has a wrong offset!");
static_assert(offsetof(ACustomPlayerController, M_ConstCameraSpeedUD) == 0x0006A4, "Member 'ACustomPlayerController::M_ConstCameraSpeedUD' has a wrong offset!");

// Class Project.BPL_MimanRewardData
// 0x0000 (0x0028 - 0x0028)
class UBPL_MimanRewardData final : public UBlueprintFunctionLibrary
{
public:
	static const class FText GetMimanRewardItemSetName(int32 ItemSetID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MimanRewardData">();
	}
	static class UBPL_MimanRewardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MimanRewardData>();
	}
};
static_assert(alignof(UBPL_MimanRewardData) == 0x000008, "Wrong alignment on UBPL_MimanRewardData");
static_assert(sizeof(UBPL_MimanRewardData) == 0x000028, "Wrong size on UBPL_MimanRewardData");

// Class Project.CustomSpringArmComponent
// 0x0020 (0x02A0 - 0x0280)
class UCustomSpringArmComponent final : public USpringArmComponent
{
public:
	uint8                                         bEnableCameraTraceLag : 1;                         // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1996[0x3];                                     // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTraceLagSpeed;                               // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTraceLagBackSpeed;                           // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandscapeCameraTraceLagSpeed;                      // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableCameraFallingTrace : 1;                     // 0x0290(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1997[0x3];                                     // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProbeFallingHeightAdd;                             // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousDesiredArmlength;                          // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1998[0x4];                                     // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SendDiscardLagRequest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomSpringArmComponent">();
	}
	static class UCustomSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomSpringArmComponent>();
	}
};
static_assert(alignof(UCustomSpringArmComponent) == 0x000010, "Wrong alignment on UCustomSpringArmComponent");
static_assert(sizeof(UCustomSpringArmComponent) == 0x0002A0, "Wrong size on UCustomSpringArmComponent");
static_assert(offsetof(UCustomSpringArmComponent, CameraTraceLagSpeed) == 0x000284, "Member 'UCustomSpringArmComponent::CameraTraceLagSpeed' has a wrong offset!");
static_assert(offsetof(UCustomSpringArmComponent, CameraTraceLagBackSpeed) == 0x000288, "Member 'UCustomSpringArmComponent::CameraTraceLagBackSpeed' has a wrong offset!");
static_assert(offsetof(UCustomSpringArmComponent, LandscapeCameraTraceLagSpeed) == 0x00028C, "Member 'UCustomSpringArmComponent::LandscapeCameraTraceLagSpeed' has a wrong offset!");
static_assert(offsetof(UCustomSpringArmComponent, ProbeFallingHeightAdd) == 0x000294, "Member 'UCustomSpringArmComponent::ProbeFallingHeightAdd' has a wrong offset!");
static_assert(offsetof(UCustomSpringArmComponent, PreviousDesiredArmlength) == 0x000298, "Member 'UCustomSpringArmComponent::PreviousDesiredArmlength' has a wrong offset!");

// Class Project.DaathMeshPlacerSpline
// 0x0080 (0x02A0 - 0x0220)
class ADaathMeshPlacerSpline final : public AActor
{
public:
	bool                                          bInstancing;                                       // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1999[0x7];                                     // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SplineLinkActor;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDaathMeshPlacerSplineMeshData         StartMesh;                                         // 0x0238(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDaathMeshPlacerSplineMeshData         EndMesh;                                           // 0x0258(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDaathMeshPlacerSplineMeshData> LoopMeshes;                                        // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StartComponentIndex;                               // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndComponentIndex;                                 // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightOffseet;                                      // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpOffseet;                                         // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignForward;                                     // 0x029C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199A[0x3];                                     // 0x029D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaathMeshPlacerSpline">();
	}
	static class ADaathMeshPlacerSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADaathMeshPlacerSpline>();
	}
};
static_assert(alignof(ADaathMeshPlacerSpline) == 0x000008, "Wrong alignment on ADaathMeshPlacerSpline");
static_assert(sizeof(ADaathMeshPlacerSpline) == 0x0002A0, "Wrong size on ADaathMeshPlacerSpline");
static_assert(offsetof(ADaathMeshPlacerSpline, bInstancing) == 0x000220, "Member 'ADaathMeshPlacerSpline::bInstancing' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, SplineComponent) == 0x000228, "Member 'ADaathMeshPlacerSpline::SplineComponent' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, SplineLinkActor) == 0x000230, "Member 'ADaathMeshPlacerSpline::SplineLinkActor' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, StartMesh) == 0x000238, "Member 'ADaathMeshPlacerSpline::StartMesh' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, EndMesh) == 0x000258, "Member 'ADaathMeshPlacerSpline::EndMesh' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, LoopMeshes) == 0x000278, "Member 'ADaathMeshPlacerSpline::LoopMeshes' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, StartComponentIndex) == 0x000288, "Member 'ADaathMeshPlacerSpline::StartComponentIndex' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, EndComponentIndex) == 0x00028C, "Member 'ADaathMeshPlacerSpline::EndComponentIndex' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, Interval) == 0x000290, "Member 'ADaathMeshPlacerSpline::Interval' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, RightOffseet) == 0x000294, "Member 'ADaathMeshPlacerSpline::RightOffseet' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, UpOffseet) == 0x000298, "Member 'ADaathMeshPlacerSpline::UpOffseet' has a wrong offset!");
static_assert(offsetof(ADaathMeshPlacerSpline, bAlignForward) == 0x00029C, "Member 'ADaathMeshPlacerSpline::bAlignForward' has a wrong offset!");

// Class Project.GazeTarget
// 0x0000 (0x0028 - 0x0028)
class IGazeTarget final : public IInterface
{
public:
	struct FVector GetGazeTargetLocation() const;
	EGazeTargetType GetGazeTargetType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GazeTarget">();
	}
	static class IGazeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGazeTarget>();
	}
};
static_assert(alignof(IGazeTarget) == 0x000008, "Wrong alignment on IGazeTarget");
static_assert(sizeof(IGazeTarget) == 0x000028, "Wrong size on IGazeTarget");

// Class Project.DaathSplineMesh
// 0x00A0 (0x02C0 - 0x0220)
class ADaathSplineMesh final : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDaathSplineMeshData                   StartMesh;                                         // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDaathSplineMeshData                   EndMesh;                                           // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDaathSplineMeshData>           LoopMeshes;                                        // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FDaathSplineMeshData>      ReplaceMeshes;                                     // 0x0258(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         StartComponentIndex;                               // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndComponentIndex;                                 // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEulerFilter;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199B[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SplineUpOverride;                                  // 0x02B4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DaathSplineMesh">();
	}
	static class ADaathSplineMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADaathSplineMesh>();
	}
};
static_assert(alignof(ADaathSplineMesh) == 0x000008, "Wrong alignment on ADaathSplineMesh");
static_assert(sizeof(ADaathSplineMesh) == 0x0002C0, "Wrong size on ADaathSplineMesh");
static_assert(offsetof(ADaathSplineMesh, SplineComponent) == 0x000220, "Member 'ADaathSplineMesh::SplineComponent' has a wrong offset!");
static_assert(offsetof(ADaathSplineMesh, StartMesh) == 0x000228, "Member 'ADaathSplineMesh::StartMesh' has a wrong offset!");
static_assert(offsetof(ADaathSplineMesh, EndMesh) == 0x000238, "Member 'ADaathSplineMesh::EndMesh' has a wrong offset!");
static_assert(offsetof(ADaathSplineMesh, LoopMeshes) == 0x000248, "Member 'ADaathSplineMesh::LoopMeshes' has a wrong offset!");
static_assert(offsetof(ADaathSplineMesh, ReplaceMeshes) == 0x000258, "Member 'ADaathSplineMesh::ReplaceMeshes' has a wrong offset!");
static_assert(offsetof(ADaathSplineMesh, StartComponentIndex) == 0x0002A8, "Member 'ADaathSplineMesh::StartComponentIndex' has a wrong offset!");
static_assert(offsetof(ADaathSplineMesh, EndComponentIndex) == 0x0002AC, "Member 'ADaathSplineMesh::EndComponentIndex' has a wrong offset!");
static_assert(offsetof(ADaathSplineMesh, bEulerFilter) == 0x0002B0, "Member 'ADaathSplineMesh::bEulerFilter' has a wrong offset!");
static_assert(offsetof(ADaathSplineMesh, SplineUpOverride) == 0x0002B4, "Member 'ADaathSplineMesh::SplineUpOverride' has a wrong offset!");

// Class Project.BPL_DBaseData
// 0x0000 (0x0028 - 0x0028)
class UBPL_DBaseData final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckMagatsukaDead_FromGodParam(int32 GodParamID);
	static const struct FMapDBaseData GetDBaseData(int32 ID);
	static TArray<int32> GetMagatsukaID_FromGodParam(int32 GodParamID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_DBaseData">();
	}
	static class UBPL_DBaseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_DBaseData>();
	}
};
static_assert(alignof(UBPL_DBaseData) == 0x000008, "Wrong alignment on UBPL_DBaseData");
static_assert(sizeof(UBPL_DBaseData) == 0x000028, "Wrong size on UBPL_DBaseData");

// Class Project.MovieSceneAllMaterialTrack
// 0x0008 (0x00A8 - 0x00A0)
class UMovieSceneAllMaterialTrack final : public UMovieSceneMaterialTrack
{
public:
	uint8                                         Pad_199F[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneAllMaterialTrack">();
	}
	static class UMovieSceneAllMaterialTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneAllMaterialTrack>();
	}
};
static_assert(alignof(UMovieSceneAllMaterialTrack) == 0x000008, "Wrong alignment on UMovieSceneAllMaterialTrack");
static_assert(sizeof(UMovieSceneAllMaterialTrack) == 0x0000A8, "Wrong size on UMovieSceneAllMaterialTrack");

// Class Project.DebugBtlAITempView
// 0x0020 (0x0048 - 0x0028)
class UDebugBtlAITempView final : public UObject
{
public:
	uint8                                         Pad_19A0[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFlagData(const struct FDebugBtlAITempViewData& Data);
	void AddValueData(const struct FDebugBtlAITempViewData& Data);
	void ClearAllData();
	TArray<struct FDebugBtlAITempViewData> GetFlagData();
	TArray<struct FDebugBtlAITempViewData> GetFlagData_Index(int32 Param_Index);
	TArray<struct FDebugBtlAITempViewData> GetValueData();
	TArray<struct FDebugBtlAITempViewData> GetValueData_Index(int32 Param_Index);
	void Sort();
	void Sort_Data(TArray<struct FDebugBtlAITempViewData>* Data, bool IsDown);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugBtlAITempView">();
	}
	static class UDebugBtlAITempView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugBtlAITempView>();
	}
};
static_assert(alignof(UDebugBtlAITempView) == 0x000008, "Wrong alignment on UDebugBtlAITempView");
static_assert(sizeof(UDebugBtlAITempView) == 0x000048, "Wrong size on UDebugBtlAITempView");

// Class Project.PlayerCameraManagerLimitless
// 0x0000 (0x2810 - 0x2810)
class APlayerCameraManagerLimitless final : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraManagerLimitless">();
	}
	static class APlayerCameraManagerLimitless* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCameraManagerLimitless>();
	}
};
static_assert(alignof(APlayerCameraManagerLimitless) == 0x000010, "Wrong alignment on APlayerCameraManagerLimitless");
static_assert(sizeof(APlayerCameraManagerLimitless) == 0x002810, "Wrong size on APlayerCameraManagerLimitless");

// Class Project.ProjectDebugCameraController
// 0x0050 (0x06C0 - 0x0670)
class AProjectDebugCameraController final : public ADebugCameraController
{
public:
	FMulticastInlineDelegateProperty_             OnInputTriggered;                                  // 0x0670(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A4[0x40];                                    // 0x0680(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectDebugCameraController">();
	}
	static class AProjectDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectDebugCameraController>();
	}
};
static_assert(alignof(AProjectDebugCameraController) == 0x000008, "Wrong alignment on AProjectDebugCameraController");
static_assert(sizeof(AProjectDebugCameraController) == 0x0006C0, "Wrong size on AProjectDebugCameraController");
static_assert(offsetof(AProjectDebugCameraController, OnInputTriggered) == 0x000670, "Member 'AProjectDebugCameraController::OnInputTriggered' has a wrong offset!");

// Class Project.MinimapIconTableInterface
// 0x0000 (0x0028 - 0x0028)
class IMinimapIconTableInterface final : public IInterface
{
public:
	void SetMinimapIconTableRow(int32 Param_Index, struct FMinimapIconTableRow* OutRow, bool* NeedToAddMore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapIconTableInterface">();
	}
	static class IMinimapIconTableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMinimapIconTableInterface>();
	}
};
static_assert(alignof(IMinimapIconTableInterface) == 0x000008, "Wrong alignment on IMinimapIconTableInterface");
static_assert(sizeof(IMinimapIconTableInterface) == 0x000028, "Wrong size on IMinimapIconTableInterface");

// Class Project.DebugCameraManager
// 0x0010 (0x0038 - 0x0028)
class UDebugCameraManager final : public UObject
{
public:
	class AProjectDebugCameraController*          ProjectDebugCameraControllerRef;                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectDebugCameraController> ProjectDebugCameraControllerClass;                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugCameraManager">();
	}
	static class UDebugCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugCameraManager>();
	}
};
static_assert(alignof(UDebugCameraManager) == 0x000008, "Wrong alignment on UDebugCameraManager");
static_assert(sizeof(UDebugCameraManager) == 0x000038, "Wrong size on UDebugCameraManager");
static_assert(offsetof(UDebugCameraManager, ProjectDebugCameraControllerRef) == 0x000028, "Member 'UDebugCameraManager::ProjectDebugCameraControllerRef' has a wrong offset!");
static_assert(offsetof(UDebugCameraManager, ProjectDebugCameraControllerClass) == 0x000030, "Member 'UDebugCameraManager::ProjectDebugCameraControllerClass' has a wrong offset!");

// Class Project.DebugFuncBaseObj
// 0x0010 (0x0038 - 0x0028)
class UDebugFuncBaseObj : public UObject
{
public:
	bool                                          M_IsFuncAlways;                                    // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsDebugMenuKeyLock;                              // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsUpdateAlways;                                  // 0x002A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A7[0x1];                                     // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x002C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CheckAddMenu();
	bool ExecFunc(const class FName& ItemPathName);
	bool ExecFuncAlways();
	bool Initialize();
	bool IsDebugMenuKeyLock();
	bool IsFuncAlways();
	void ReceiveDestroyed();
	void SetIsDebugMenuKeyLock(bool IsLock);
	void SetIsFuncAlways(bool IsAlways);
	bool UpdateAlwaysFunc(const class FName& ItemPathName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugFuncBaseObj">();
	}
	static class UDebugFuncBaseObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugFuncBaseObj>();
	}
};
static_assert(alignof(UDebugFuncBaseObj) == 0x000008, "Wrong alignment on UDebugFuncBaseObj");
static_assert(sizeof(UDebugFuncBaseObj) == 0x000038, "Wrong size on UDebugFuncBaseObj");
static_assert(offsetof(UDebugFuncBaseObj, M_IsFuncAlways) == 0x000028, "Member 'UDebugFuncBaseObj::M_IsFuncAlways' has a wrong offset!");
static_assert(offsetof(UDebugFuncBaseObj, M_IsDebugMenuKeyLock) == 0x000029, "Member 'UDebugFuncBaseObj::M_IsDebugMenuKeyLock' has a wrong offset!");
static_assert(offsetof(UDebugFuncBaseObj, M_IsUpdateAlways) == 0x00002A, "Member 'UDebugFuncBaseObj::M_IsUpdateAlways' has a wrong offset!");
static_assert(offsetof(UDebugFuncBaseObj, Location) == 0x00002C, "Member 'UDebugFuncBaseObj::Location' has a wrong offset!");

// Class Project.MakkaWindowBase
// 0x0000 (0x0220 - 0x0220)
class AMakkaWindowBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MakkaWindowBase">();
	}
	static class AMakkaWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMakkaWindowBase>();
	}
};
static_assert(alignof(AMakkaWindowBase) == 0x000008, "Wrong alignment on AMakkaWindowBase");
static_assert(sizeof(AMakkaWindowBase) == 0x000220, "Wrong size on AMakkaWindowBase");

// Class Project.BPL_DebugMenuAdmin
// 0x0000 (0x0028 - 0x0028)
class UBPL_DebugMenuAdmin final : public UBlueprintFunctionLibrary
{
public:
	static int32 AddDebugMenuItem(const class FName Path, E_D_MENU_TYPE TypeE, const struct FDebugMenuItemDataParam& Data);
	static int32 AddDebugMenuItemFromId(const int32 ParentID, const class FName Param_Name, E_D_MENU_TYPE Type, const struct FDebugMenuItemDataParam& Data);
	static int32 AddDebugMenuItemTypeCheckBox(const class FName Path, const class FString& DispName, const bool IsCheck, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeCheckBoxFromId(const int32 ParentID, const class FName Param_Name, const class FString& DispName, const bool IsCheck, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeFuncObj(const class FName Path, const class FString& DispName, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeFuncObjFromId(const int32 ParentID, const class FName Param_Name, const class FString& DispName, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeJumpPage(const class FName Path, const class FString& DispName);
	static int32 AddDebugMenuItemTypeJumpPageFromId(const int32 ParentID, const class FName Param_Name, const class FString& DispName);
	static int32 AddDebugMenuItemTypeNameChange(const class FName Path, const class FString& DispName, const E_D_MENU_NAME_CHANGE_TYPE NameChangeType, const struct FDebugMenuNameChangeObj& NameChangeObj, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeNameChangeFromId(const int32 ParentID, const class FName Param_Name, const class FString& DispName, const E_D_MENU_NAME_CHANGE_TYPE NameChangeType, const struct FDebugMenuNameChangeObj& NameChangeObj, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeNameChangeNoLimit(const class FName Path, const class FString& DispName, const E_D_MENU_NAME_CHANGE_TYPE NameChangeType, const struct FDebugMenuNameChangeObj& NameChangeObj, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock, TSoftClassPtr<class UClass> ObjFunc, const bool NoLimit);
	static int32 AddDebugMenuItemTypeParam(const class FName Path, const class FString& DispName, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeParamFromId(const int32 ParentID, const class FName Param_Name, const class FString& DispName, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeParamNoLimit(const class FName Path, const class FString& DispName, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock, TSoftClassPtr<class UClass> ObjFunc, const bool NoLimit);
	static int32 AddDebugMenuItemTypePullDown(const class FName Path, const class FString& DispName, int32 CursorIndex, const TArray<class FString>& Arr, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypePullDownFromId(const int32 ParentID, const class FName Param_Name, const class FString& DispName, int32 CursorIndex, const TArray<class FString>& Arr, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeText(const class FName Path, const class FString& DispName, const class FString& Text, TSoftClassPtr<class UClass> ObjFunc);
	static int32 AddDebugMenuItemTypeTextFromId(const int32 ParentID, const class FName Param_Name, const class FString& DispName, const class FString& Text, TSoftClassPtr<class UClass> ObjFunc);
	static void CallViewLogAllItem();
	static bool CheckAddMenu(TSubclassOf<class UDebugFuncBaseObj> FuncObj);
	static bool CheckDebugMenuFlag(E_DEBUG_MENU_FLAG Flg);
	static bool DebugFuncObj_IsDebugMenuKeyLock(TSubclassOf<class UDebugFuncBaseObj> FuncObj);
	static bool DebugFuncObj_IsFuncAlways(TSubclassOf<class UDebugFuncBaseObj> FuncObj);
	static bool DebugFuncObj_IsUpdateAlways(TSubclassOf<class UDebugFuncBaseObj> FuncObj);
	static void DebugNameChangeObj_Destroy(TSubclassOf<class UDebugMenuNameChangeBaseObj> NameChangeObj);
	static class FText DebugNameChangeObj_GetDispName(TSubclassOf<class UDebugMenuNameChangeBaseObj> NameChangeObj, int32 Param);
	static void DebugNameChangeObj_Init(TSubclassOf<class UDebugMenuNameChangeBaseObj> NameChangeObj);
	static void DeleteBtlEndDeleteItemData();
	static void DeleteDebugMenuItem(const int32 ItemId);
	static void DeleteDebugMenuItemFromName(const class FName Param_Name);
	static void DeleteDebugMenuItemFromPathName(const class FName PathName);
	static void DeleteDebugMenuPage(const int32 PageId);
	static void DeleteDebugMenuPageFromName(const class FName Param_Name);
	static void DeleteDebugMenuPageFromPathName(const class FName PathName);
	static void DestroyFuncObj(TSubclassOf<class UDebugFuncBaseObj> FuncObj);
	static bool ExecFunc(TSubclassOf<class UDebugFuncBaseObj> FuncObj, const class FName& ItemPathName);
	static void ExecFuncAlways(TSubclassOf<class UDebugFuncBaseObj> FuncObj);
	static struct FDebugMenuItemData GetDebugMenuItem(const int32 ItemId);
	static struct FDebugMenuItemData GetDebugMenuItemFromIndex(const int32 PageId, const int32 Param_Index);
	static struct FDebugMenuItemData GetDebugMenuItemFromName(const class FName Param_Name);
	static struct FDebugMenuItemData GetDebugMenuItemFromPathName(const class FString& PathName);
	static struct FDebugMenuItemData GetDebugMenuItemFromPathName_Name(const class FName PathName);
	static int32 GetDebugMenuItemNum();
	static struct FDebugMenuPageData GetDebugMenuPage(const int32 PageId);
	static struct FDebugMenuPageData GetDebugMenuPageFromItemId(const int32 ParentItemId);
	static struct FDebugMenuPageData GetDebugMenuPageFromName(const class FName Param_Name);
	static int32 GetDebugMenuPageNum();
	static bool GetDebugMenuPageWidth(const int32 _itemID, float* _width);
	static TArray<struct FDebugMenuItemData> GetMenuEndDeleteItem();
	static struct FDebugMenuItemDataParam GetSPData(const class FName PathName, const struct FDebugMenuItemDataParam& InitParam);
	static bool GetSPDataTypeCheckBox(const class FName PathName, const bool InitParam);
	static int32 GetSPDataTypeParam(const class FName PathName, const int32 InitParam);
	static int32 GetSPDataTypePullDown(const class FName PathName, const int32 InitParam);
	static class FString GetSPDataTypeText(const class FName PathName, const class FString& InitParam);
	static bool IsCreateDebugMenuData();
	static bool IsDebugMenuActiveItemPage(const class FString& ItemPathName);
	static bool IsDebugMenuItemExistFromPathName(const class FString& PathName);
	static bool IsDebugMenuItemExistFromPathName_Name(const class FName PathName);
	static bool IsOpenDebugMenu();
	static void ResetDebugMenuData();
	static void SetCheckBoxParam(const int32 ItemId, const bool IsCheck);
	static void SetCheckBoxParamFromName(const class FName Param_Name, const bool IsCheck);
	static void SetCheckBoxParamFromPathName(const class FName PathName, const bool IsCheck);
	static void SetDebugMenuActiveItemPageName(const class FString& PathName);
	static void SetDebugMenuFlag(E_DEBUG_MENU_FLAG Flg, bool Sw);
	static void SetDebugMenuItemLock(const class FString& Path, const bool IsLock);
	static void SetDebugMenuItemLockItemId(const int32 ItemId, const bool IsLock);
	static void SetDebugMenuOnOff(bool IsOn);
	static void SetDebugMenuPageWidth(const int32 _itemID, const float _width);
	static void SetDebugMenuPageWidthFromLen(const int32 _itemID, const int32 _length, const float _space);
	static void SetDispName(const int32 ItemId, const class FString& DispName);
	static void SetDispNameFromName(const class FName Param_Name, const class FString& DispName);
	static void SetDispNameFromPathName(const class FName PathName, const class FString& DispName);
	static void SetFuncClass(const int32 ItemId, TSubclassOf<class UDebugFuncBaseObj> FuncObj);
	static void SetFuncClassFromName(const class FName Param_Name, TSubclassOf<class UDebugFuncBaseObj> FuncObj);
	static void SetIsAddItemEndBtlDelete(const bool Ret);
	static void SetIsAddItemEndDelete(const bool Ret);
	static void SetParamData(const int32 ItemId, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock);
	static void SetParamDataFromName(const class FName Param_Name, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock);
	static void SetParamDataFromPathName(const class FName PathName, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock);
	static void SetParamDataNoLimit(const int32 ItemId, const int32 Param, const int32 Min, const int32 Max, const bool LimitLock, const bool NoLimit);
	static void SetPullDownData(const int32 ItemId, int32 CursorIndex, const TArray<class FString>& Arr);
	static void SetPullDownDataFromName(const class FName Param_Name, int32 CursorIndex, const TArray<class FString>& Arr);
	static void SetPullDownDataFromPathName(const class FName PathName, int32 CursorIndex, const TArray<class FString>& Arr);
	static void SetTextData(const int32 ItemId, const class FString& Text);
	static void SetTextFromName(const class FName Param_Name, const class FString& Text);
	static void SetTextFromPathName(const class FName PathName, const class FString& Text);
	static class AActor* SpawnFuncActor(class UClass* Class_p);
	static void TestTestTest(TSoftObjectPtr<class UDebugFuncBaseObj> Str, TSoftClassPtr<class UClass> Str2);
	static void UpdateAlwaysFunc(TSubclassOf<class UDebugFuncBaseObj> FuncObj, const class FName& ItemPathName);
	static void UpLoadItemData(const struct FDebugMenuItemData& ItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_DebugMenuAdmin">();
	}
	static class UBPL_DebugMenuAdmin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_DebugMenuAdmin>();
	}
};
static_assert(alignof(UBPL_DebugMenuAdmin) == 0x000008, "Wrong alignment on UBPL_DebugMenuAdmin");
static_assert(sizeof(UBPL_DebugMenuAdmin) == 0x000028, "Wrong size on UBPL_DebugMenuAdmin");

// Class Project.DebugMenuData
// 0x0090 (0x00B8 - 0x0028)
class UDebugMenuData final : public UObject
{
public:
	uint8                                         Pad_19EC[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDebugMenuPage>                 M_Pages;                                           // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDebugMenuItem>                 M_SPItemData;                                      // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         M_DebugFlag;                                       // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsOpen;                                          // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19ED[0x3];                                     // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_ActivePageName;                                  // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsAddItemEndDelete;                              // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsAddItemEndBtlDelete;                           // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19EE[0x56];                                    // 0x0062(0x0056)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuData">();
	}
	static class UDebugMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuData>();
	}
};
static_assert(alignof(UDebugMenuData) == 0x000008, "Wrong alignment on UDebugMenuData");
static_assert(sizeof(UDebugMenuData) == 0x0000B8, "Wrong size on UDebugMenuData");
static_assert(offsetof(UDebugMenuData, M_Pages) == 0x000030, "Member 'UDebugMenuData::M_Pages' has a wrong offset!");
static_assert(offsetof(UDebugMenuData, M_SPItemData) == 0x000040, "Member 'UDebugMenuData::M_SPItemData' has a wrong offset!");
static_assert(offsetof(UDebugMenuData, M_DebugFlag) == 0x000050, "Member 'UDebugMenuData::M_DebugFlag' has a wrong offset!");
static_assert(offsetof(UDebugMenuData, M_IsOpen) == 0x000054, "Member 'UDebugMenuData::M_IsOpen' has a wrong offset!");
static_assert(offsetof(UDebugMenuData, M_ActivePageName) == 0x000058, "Member 'UDebugMenuData::M_ActivePageName' has a wrong offset!");
static_assert(offsetof(UDebugMenuData, M_IsAddItemEndDelete) == 0x000060, "Member 'UDebugMenuData::M_IsAddItemEndDelete' has a wrong offset!");
static_assert(offsetof(UDebugMenuData, M_IsAddItemEndBtlDelete) == 0x000061, "Member 'UDebugMenuData::M_IsAddItemEndBtlDelete' has a wrong offset!");

// Class Project.ActionPadDelegateBinding
// 0x0018 (0x0040 - 0x0028)
class UActionPadDelegateBinding final : public UDynamicBlueprintBinding
{
public:
	TArray<struct FBlueprintActionPadDelegateBinding> ActionPadDelegateBindings;                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19EF[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionPadDelegateBinding">();
	}
	static class UActionPadDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionPadDelegateBinding>();
	}
};
static_assert(alignof(UActionPadDelegateBinding) == 0x000008, "Wrong alignment on UActionPadDelegateBinding");
static_assert(sizeof(UActionPadDelegateBinding) == 0x000040, "Wrong size on UActionPadDelegateBinding");
static_assert(offsetof(UActionPadDelegateBinding, ActionPadDelegateBindings) == 0x000028, "Member 'UActionPadDelegateBinding::ActionPadDelegateBindings' has a wrong offset!");

// Class Project.DebugMenuNameChangeBaseObj
// 0x0000 (0x0028 - 0x0028)
class UDebugMenuNameChangeBaseObj final : public UObject
{
public:
	class FText GetDispName(int32 Param);
	void ReceiveDestroyed();
	void ReceiveInitialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuNameChangeBaseObj">();
	}
	static class UDebugMenuNameChangeBaseObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuNameChangeBaseObj>();
	}
};
static_assert(alignof(UDebugMenuNameChangeBaseObj) == 0x000008, "Wrong alignment on UDebugMenuNameChangeBaseObj");
static_assert(sizeof(UDebugMenuNameChangeBaseObj) == 0x000028, "Wrong size on UDebugMenuNameChangeBaseObj");

// Class Project.DebugMenuSetting
// 0x0000 (0x0028 - 0x0028)
class UDebugMenuSetting final : public UBlueprintFunctionLibrary
{
public:
	static void CallAddDebugMenuData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuSetting">();
	}
	static class UDebugMenuSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuSetting>();
	}
};
static_assert(alignof(UDebugMenuSetting) == 0x000008, "Wrong alignment on UDebugMenuSetting");
static_assert(sizeof(UDebugMenuSetting) == 0x000028, "Wrong size on UDebugMenuSetting");

// Class Project.MapCharaPanelCtrlBase
// 0x0010 (0x0230 - 0x0220)
class AMapCharaPanelCtrlBase : public AActor
{
public:
	uint8                                         Pad_19F1[0x10];                                    // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BIESetInitializeMapCharaPanelAnimation(int32 InIndex);
	void BIESetMapCharaPanelFadeOutPanelAnimation(int32 InIndex);
	bool IsMapCharaPanelAnimation();
	bool StartMapCharaPanelAnimation();
	bool StartMapCharaPanelFadeOutAnimation();
	bool StopMapCharaPanelAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapCharaPanelCtrlBase">();
	}
	static class AMapCharaPanelCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapCharaPanelCtrlBase>();
	}
};
static_assert(alignof(AMapCharaPanelCtrlBase) == 0x000008, "Wrong alignment on AMapCharaPanelCtrlBase");
static_assert(sizeof(AMapCharaPanelCtrlBase) == 0x000230, "Wrong size on AMapCharaPanelCtrlBase");

// Class Project.MotionViewerTableCtrl
// 0x0030 (0x0058 - 0x0028)
class UMotionViewerTableCtrl final : public UObject
{
public:
	uint8                                         Pad_19F2[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_TableData;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19F3[0x18];                                    // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsRunCreateTable();
	void StartCreateTable(const TArray<class FName>& PackagePath);
	void StartCreateTableBlocking(const TArray<class FName>& PackagePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionViewerTableCtrl">();
	}
	static class UMotionViewerTableCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionViewerTableCtrl>();
	}
};
static_assert(alignof(UMotionViewerTableCtrl) == 0x000008, "Wrong alignment on UMotionViewerTableCtrl");
static_assert(sizeof(UMotionViewerTableCtrl) == 0x000058, "Wrong size on UMotionViewerTableCtrl");
static_assert(offsetof(UMotionViewerTableCtrl, M_TableData) == 0x000038, "Member 'UMotionViewerTableCtrl::M_TableData' has a wrong offset!");

// Class Project.BPL_DevilData
// 0x0000 (0x0028 - 0x0028)
class UBPL_DevilData final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckUniqueSkillEffect(int32 ID, E_AUTO_SKILL_EXTRA_EFFECT SkillExtraEffect);
	static bool DevilBaseDataGetValue_IsDummy(const struct FDevilBaseData& PData);
	static bool EnemyBaseDataGetValue_IsDummy(const struct FEnemyData& PData);
	static const int32 GetAreaPriorityByDevilId(int32 InDevilId);
	static const struct FAbilData GetCreateModeDevilAbilData(int32 DevilID);
	static const TArray<struct FCreateModeDevilData> GetCreateModeDevilDataArray();
	static const struct FCreateModeDevilRate GetCreateModeDevilRate();
	static const struct FDevilBaseData GetDevilBaseData(int32 ID);
	static int32 GetDevilBaseTableNum();
	static const class FText GetDevilName(int32 ID);
	static const class FText GetDevilRaceName(int32 ID);
	static const class FText GetDevilRaceNameByRaceID(int32 RaceID);
	static int32 GetEmemyBaseTableNum();
	static const struct FEnemyData GetEnemyBaseData(int32 ID);
	static int32 GetEnemyDefaultMagatsuhiSkillId(int32 DevilID, bool IsChallengeBtl);
	static int32 GetEnemyMagatsuhiSkillId(int32 DevilID, int32 Param_Index, bool IsChallengeBtl);
	static const int32 GetMapAreaPriority(int32 InAreaId);
	static const int32 GetMapPosPriority(int32 InPosId);
	static const int32 GetRaceIdByDevilId(int32 InDevilId);
	static const int32 GetRacePriorityByDevilId(int32 InDevilId);
	static bool IsGuestByDevilID(int32 DevilID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_DevilData">();
	}
	static class UBPL_DevilData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_DevilData>();
	}
};
static_assert(alignof(UBPL_DevilData) == 0x000008, "Wrong alignment on UBPL_DevilData");
static_assert(sizeof(UBPL_DevilData) == 0x000028, "Wrong size on UBPL_DevilData");

// Class Project.MMIAsset
// 0x0010 (0x0038 - 0x0028)
class UMMIAsset final : public UObject
{
public:
	TArray<uint8>                                 MyFmtData;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MMIAsset">();
	}
	static class UMMIAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMMIAsset>();
	}
};
static_assert(alignof(UMMIAsset) == 0x000008, "Wrong alignment on UMMIAsset");
static_assert(sizeof(UMMIAsset) == 0x000038, "Wrong size on UMMIAsset");
static_assert(offsetof(UMMIAsset, MyFmtData) == 0x000028, "Member 'UMMIAsset::MyFmtData' has a wrong offset!");

// Class Project.DevilMovementComponent
// 0x0008 (0x0158 - 0x0150)
class UDevilMovementComponent final : public UCharaMovementComponent
{
public:
	uint8                                         Pad_19FF[0x8];                                     // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRootMotion(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DevilMovementComponent">();
	}
	static class UDevilMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDevilMovementComponent>();
	}
};
static_assert(alignof(UDevilMovementComponent) == 0x000008, "Wrong alignment on UDevilMovementComponent");
static_assert(sizeof(UDevilMovementComponent) == 0x000158, "Wrong size on UDevilMovementComponent");

// Class Project.EncountPostDataBase
// 0x0000 (0x0220 - 0x0220)
class AEncountPostDataBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EncountPostDataBase">();
	}
	static class AEncountPostDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEncountPostDataBase>();
	}
};
static_assert(alignof(AEncountPostDataBase) == 0x000008, "Wrong alignment on AEncountPostDataBase");
static_assert(sizeof(AEncountPostDataBase) == 0x000220, "Wrong size on AEncountPostDataBase");

// Class Project.PlayerCheatManager
// 0x0000 (0x0088 - 0x0088)
class UPlayerCheatManager final : public UCheatManager
{
public:
	static bool GetDebugGazeEnabled();

	void DebugMenu();
	bool PlayerFly();
	bool PlayerGhost();
	bool PlayerWalk();
	void PreloadTestM061();
	void SlomoDown();
	void SlomoFast();
	void SlomoReset();
	void SlomoUp();

	bool IsDebugFlyMovement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCheatManager">();
	}
	static class UPlayerCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCheatManager>();
	}
};
static_assert(alignof(UPlayerCheatManager) == 0x000008, "Wrong alignment on UPlayerCheatManager");
static_assert(sizeof(UPlayerCheatManager) == 0x000088, "Wrong size on UPlayerCheatManager");

// Class Project.BPL_DevilPostData
// 0x0000 (0x0028 - 0x0028)
class UBPL_DevilPostData final : public UBlueprintFunctionLibrary
{
public:
	static bool DevilPostDataInitialize();
	static TArray<class FString> DevilPostDataLoadToArray();
	static bool DevilPostDataSaveArray(const TArray<class FString>& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_DevilPostData">();
	}
	static class UBPL_DevilPostData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_DevilPostData>();
	}
};
static_assert(alignof(UBPL_DevilPostData) == 0x000008, "Wrong alignment on UBPL_DevilPostData");
static_assert(sizeof(UBPL_DevilPostData) == 0x000028, "Wrong size on UBPL_DevilPostData");

// Class Project.BPL_EncountPostData
// 0x0000 (0x0028 - 0x0028)
class UBPL_EncountPostData final : public UBlueprintFunctionLibrary
{
public:
	static bool EncountPostDataInitialize();
	static TArray<class FString> EncountPostDataLoadToArray();
	static bool EncountPostDataSaveArray(const TArray<class FString>& Data);
	static bool EventEncountPostDataInitialize();
	static TArray<class FString> EventEncountPostDataLoadToArray();
	static bool EventEncountPostDataSaveArray(const TArray<class FString>& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_EncountPostData">();
	}
	static class UBPL_EncountPostData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_EncountPostData>();
	}
};
static_assert(alignof(UBPL_EncountPostData) == 0x000008, "Wrong alignment on UBPL_EncountPostData");
static_assert(sizeof(UBPL_EncountPostData) == 0x000028, "Wrong size on UBPL_EncountPostData");

// Class Project.DevilProfileTable
// 0x0028 (0x0050 - 0x0028)
class UDevilProfileTable final : public UObject
{
public:
	TArray<class FText>                           M_DevilProfileMsg;                                 // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A03[0x18];                                    // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Finalize();
	class FText GetDevilProfile(int32 ID);
	bool MakeUp(class UScriptMessageAsset* PDevilProfile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DevilProfileTable">();
	}
	static class UDevilProfileTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDevilProfileTable>();
	}
};
static_assert(alignof(UDevilProfileTable) == 0x000008, "Wrong alignment on UDevilProfileTable");
static_assert(sizeof(UDevilProfileTable) == 0x000050, "Wrong size on UDevilProfileTable");
static_assert(offsetof(UDevilProfileTable, M_DevilProfileMsg) == 0x000028, "Member 'UDevilProfileTable::M_DevilProfileMsg' has a wrong offset!");

// Class Project.BPL_DevilUIGraphicsData
// 0x0000 (0x0028 - 0x0028)
class UBPL_DevilUIGraphicsData final : public UBlueprintFunctionLibrary
{
public:
	static const int32 GetDevilUIFaceId(int32 InDevilId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_DevilUIGraphicsData">();
	}
	static class UBPL_DevilUIGraphicsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_DevilUIGraphicsData>();
	}
};
static_assert(alignof(UBPL_DevilUIGraphicsData) == 0x000008, "Wrong alignment on UBPL_DevilUIGraphicsData");
static_assert(sizeof(UBPL_DevilUIGraphicsData) == 0x000028, "Wrong size on UBPL_DevilUIGraphicsData");

// Class Project.ProjectDebugDraw
// 0x0010 (0x0230 - 0x0220)
class AProjectDebugDraw final : public AActor
{
public:
	uint8                                         Pad_1A06[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  M_FontObject;                                      // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectDebugDraw">();
	}
	static class AProjectDebugDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectDebugDraw>();
	}
};
static_assert(alignof(AProjectDebugDraw) == 0x000008, "Wrong alignment on AProjectDebugDraw");
static_assert(sizeof(AProjectDebugDraw) == 0x000230, "Wrong size on AProjectDebugDraw");
static_assert(offsetof(AProjectDebugDraw, M_FontObject) == 0x000228, "Member 'AProjectDebugDraw::M_FontObject' has a wrong offset!");

// Class Project.DevilVoiceAssetMap
// 0x0050 (0x0078 - 0x0028)
class UDevilVoiceAssetMap : public UObject
{
public:
	TMap<int32, struct FDevilVoiceContainer>      DevilMap;                                          // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DevilVoiceAssetMap">();
	}
	static class UDevilVoiceAssetMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDevilVoiceAssetMap>();
	}
};
static_assert(alignof(UDevilVoiceAssetMap) == 0x000008, "Wrong alignment on UDevilVoiceAssetMap");
static_assert(sizeof(UDevilVoiceAssetMap) == 0x000078, "Wrong size on UDevilVoiceAssetMap");
static_assert(offsetof(UDevilVoiceAssetMap, DevilMap) == 0x000028, "Member 'UDevilVoiceAssetMap::DevilMap' has a wrong offset!");

// Class Project.DG_ActorVisibilityVolume
// 0x0060 (0x0280 - 0x0220)
class ADG_ActorVisibilityVolume final : public AActor
{
public:
	uint8                                         Pad_1A07[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        TransformComponent;                                // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AStaticMeshActor*>               StaticMeshList;                                    // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ObjectList;                                        // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ModelHitSize;                                      // 0x0250(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A08[0x4];                                     // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          ModelHitBox;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VisibilityHitSize;                                 // 0x0268(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A09[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          VisibilityHitBox;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CollectObjects();
	void CollectStaticMeshActors();
	void RemoveAllObjects();
	void RemoveAllStaticMesh();
	void UpdateHitBox();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DG_ActorVisibilityVolume">();
	}
	static class ADG_ActorVisibilityVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADG_ActorVisibilityVolume>();
	}
};
static_assert(alignof(ADG_ActorVisibilityVolume) == 0x000008, "Wrong alignment on ADG_ActorVisibilityVolume");
static_assert(sizeof(ADG_ActorVisibilityVolume) == 0x000280, "Wrong size on ADG_ActorVisibilityVolume");
static_assert(offsetof(ADG_ActorVisibilityVolume, TransformComponent) == 0x000228, "Member 'ADG_ActorVisibilityVolume::TransformComponent' has a wrong offset!");
static_assert(offsetof(ADG_ActorVisibilityVolume, StaticMeshList) == 0x000230, "Member 'ADG_ActorVisibilityVolume::StaticMeshList' has a wrong offset!");
static_assert(offsetof(ADG_ActorVisibilityVolume, ObjectList) == 0x000240, "Member 'ADG_ActorVisibilityVolume::ObjectList' has a wrong offset!");
static_assert(offsetof(ADG_ActorVisibilityVolume, ModelHitSize) == 0x000250, "Member 'ADG_ActorVisibilityVolume::ModelHitSize' has a wrong offset!");
static_assert(offsetof(ADG_ActorVisibilityVolume, ModelHitBox) == 0x000260, "Member 'ADG_ActorVisibilityVolume::ModelHitBox' has a wrong offset!");
static_assert(offsetof(ADG_ActorVisibilityVolume, VisibilityHitSize) == 0x000268, "Member 'ADG_ActorVisibilityVolume::VisibilityHitSize' has a wrong offset!");
static_assert(offsetof(ADG_ActorVisibilityVolume, VisibilityHitBox) == 0x000278, "Member 'ADG_ActorVisibilityVolume::VisibilityHitBox' has a wrong offset!");

// Class Project.ShopItemList
// 0x0010 (0x0038 - 0x0028)
class UShopItemList final : public UObject
{
public:
	TArray<struct FShopItemData>                  M_ItemList;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void Add(const struct FShopItemData& Data);
	void Empty();
	int32 GetDataIndex(const struct FShopItemData& Data);
	bool IsExistNewIcon();
	void Remove(const struct FShopItemData& Data);
	void RemoveAt(int32 Param_Index);
	void Reset();
	void SetNewItemFlag(int32 Param_Index, bool bNew);
	void Sort(E_SHOP_ITEM_SORT_TYPE Type, bool bAscending);

	const struct FShopItemData GetData(int32 Param_Index) const;
	const TArray<struct FShopItemData> GetList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopItemList">();
	}
	static class UShopItemList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopItemList>();
	}
};
static_assert(alignof(UShopItemList) == 0x000008, "Wrong alignment on UShopItemList");
static_assert(sizeof(UShopItemList) == 0x000038, "Wrong size on UShopItemList");
static_assert(offsetof(UShopItemList, M_ItemList) == 0x000028, "Member 'UShopItemList::M_ItemList' has a wrong offset!");

// Class Project.DG_ActorVisibilityVolumeManager
// 0x0020 (0x00D0 - 0x00B0)
class UDG_ActorVisibilityVolumeManager final : public UActorComponent
{
public:
	bool                                          bEnabled;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0B[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADG_ActorVisibilityVolume*>      VisibilityVolumes;                                 // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bForceShowAll;                                     // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceHideAll;                                     // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdateAll;                                   // 0x00CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0C[0x5];                                     // 0x00CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init();
	void ProcessVisibilityVolume(const struct FVector& ViewLocation);
	void RegisterVibilityVolume(class ADG_ActorVisibilityVolume* InActorVisibilityVolumeVolume);
	void ShowAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DG_ActorVisibilityVolumeManager">();
	}
	static class UDG_ActorVisibilityVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDG_ActorVisibilityVolumeManager>();
	}
};
static_assert(alignof(UDG_ActorVisibilityVolumeManager) == 0x000008, "Wrong alignment on UDG_ActorVisibilityVolumeManager");
static_assert(sizeof(UDG_ActorVisibilityVolumeManager) == 0x0000D0, "Wrong size on UDG_ActorVisibilityVolumeManager");
static_assert(offsetof(UDG_ActorVisibilityVolumeManager, bEnabled) == 0x0000B0, "Member 'UDG_ActorVisibilityVolumeManager::bEnabled' has a wrong offset!");
static_assert(offsetof(UDG_ActorVisibilityVolumeManager, VisibilityVolumes) == 0x0000B8, "Member 'UDG_ActorVisibilityVolumeManager::VisibilityVolumes' has a wrong offset!");
static_assert(offsetof(UDG_ActorVisibilityVolumeManager, bForceShowAll) == 0x0000C8, "Member 'UDG_ActorVisibilityVolumeManager::bForceShowAll' has a wrong offset!");
static_assert(offsetof(UDG_ActorVisibilityVolumeManager, bForceHideAll) == 0x0000C9, "Member 'UDG_ActorVisibilityVolumeManager::bForceHideAll' has a wrong offset!");
static_assert(offsetof(UDG_ActorVisibilityVolumeManager, bForceUpdateAll) == 0x0000CA, "Member 'UDG_ActorVisibilityVolumeManager::bForceUpdateAll' has a wrong offset!");

// Class Project.DG_RoomRotatableInterface
// 0x0000 (0x0028 - 0x0028)
class IDG_RoomRotatableInterface final : public IInterface
{
public:
	class ADG_RoomRotator* GetRoomRotator();
	void OnRotateFinished(bool IsSkipped);
	void OnRotateStarted();
	bool SetRoomRotator(class ADG_RoomRotator* RoomRotator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DG_RoomRotatableInterface">();
	}
	static class IDG_RoomRotatableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDG_RoomRotatableInterface>();
	}
};
static_assert(alignof(IDG_RoomRotatableInterface) == 0x000008, "Wrong alignment on IDG_RoomRotatableInterface");
static_assert(sizeof(IDG_RoomRotatableInterface) == 0x000028, "Wrong size on IDG_RoomRotatableInterface");

// Class Project.ProjectGameEngine
// 0x0000 (0x0DB8 - 0x0DB8)
class UProjectGameEngine final : public UGameEngine
{
public:
	static void FontFlush();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectGameEngine">();
	}
	static class UProjectGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectGameEngine>();
	}
};
static_assert(alignof(UProjectGameEngine) == 0x000008, "Wrong alignment on UProjectGameEngine");
static_assert(sizeof(UProjectGameEngine) == 0x000DB8, "Wrong size on UProjectGameEngine");

// Class Project.DG_RoomRotator
// 0x00A8 (0x02C8 - 0x0220)
class ADG_RoomRotator final : public AActor
{
public:
	TArray<class AStaticMeshActor*>               StaticMeshList;                                    // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ObjectList;                                        // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDG_RoomRotatorDynamicActor>    DynamicActorList;                                  // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	E_DG_ROOM_ROTATOR_STATE                       RotateDirection;                                   // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0E[0x3];                                     // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AreaId;                                            // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataId;                                            // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_DG_ROOM_ROTATOR_STATE                       RotateState;                                       // 0x025C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0F[0x3];                                     // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitSize;                                           // 0x0260(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSecondsDuration;                             // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          HitBox;                                            // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateAngleNow;                                    // 0x0278(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateAngleStart;                                  // 0x0284(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateAngleTarget;                                 // 0x0290(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateAngleOffsetNow;                              // 0x029C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateAngleOffsetTarget;                           // 0x02A8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A10[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotateCurve;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A11[0x8];                                     // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyGameData(bool bDoStaticMesh, bool bDoObject, bool bDoPhysics);
	void CollectObjects();
	void CollectStaticMeshActors();
	void ForceFinishRotate();
	int32 GetDataId();
	class FName GetEventFlagName();
	int32 GetEventFlagValue();
	int32 GetRotateCountX();
	int32 GetRotateCountY();
	float GetRotateRate();
	bool IsInOriginalState();
	void RegisterDynamicActors(const TArray<class AActor*>& DynamicActors);
	void RemoveAllObjects();
	void RemoveAllStaticMesh();
	void RemoveDynamicActors();
	void SetRotateCountX(int32 Count);
	void SetRotateCountY(int32 Count);
	void StartRotate();
	void UpdateHitBox();
	void UpdateRotate(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DG_RoomRotator">();
	}
	static class ADG_RoomRotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADG_RoomRotator>();
	}
};
static_assert(alignof(ADG_RoomRotator) == 0x000008, "Wrong alignment on ADG_RoomRotator");
static_assert(sizeof(ADG_RoomRotator) == 0x0002C8, "Wrong size on ADG_RoomRotator");
static_assert(offsetof(ADG_RoomRotator, StaticMeshList) == 0x000220, "Member 'ADG_RoomRotator::StaticMeshList' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, ObjectList) == 0x000230, "Member 'ADG_RoomRotator::ObjectList' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, DynamicActorList) == 0x000240, "Member 'ADG_RoomRotator::DynamicActorList' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, RotateDirection) == 0x000250, "Member 'ADG_RoomRotator::RotateDirection' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, AreaId) == 0x000254, "Member 'ADG_RoomRotator::AreaId' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, DataId) == 0x000258, "Member 'ADG_RoomRotator::DataId' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, RotateState) == 0x00025C, "Member 'ADG_RoomRotator::RotateState' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, HitSize) == 0x000260, "Member 'ADG_RoomRotator::HitSize' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, RotateSecondsDuration) == 0x00026C, "Member 'ADG_RoomRotator::RotateSecondsDuration' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, HitBox) == 0x000270, "Member 'ADG_RoomRotator::HitBox' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, RotateAngleNow) == 0x000278, "Member 'ADG_RoomRotator::RotateAngleNow' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, RotateAngleStart) == 0x000284, "Member 'ADG_RoomRotator::RotateAngleStart' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, RotateAngleTarget) == 0x000290, "Member 'ADG_RoomRotator::RotateAngleTarget' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, RotateAngleOffsetNow) == 0x00029C, "Member 'ADG_RoomRotator::RotateAngleOffsetNow' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, RotateAngleOffsetTarget) == 0x0002A8, "Member 'ADG_RoomRotator::RotateAngleOffsetTarget' has a wrong offset!");
static_assert(offsetof(ADG_RoomRotator, RotateCurve) == 0x0002B8, "Member 'ADG_RoomRotator::RotateCurve' has a wrong offset!");

// Class Project.DG_RoomRotatorVisibility
// 0x0018 (0x0238 - 0x0220)
class ADG_RoomRotatorVisibility final : public AActor
{
public:
	uint8                                         Pad_1A12[0x18];                                    // 0x0220(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterRotators(const TArray<class ADG_RoomRotator*>& Rotators);
	void SetEnabled(bool IsEnabled);
	void UnregisterRotators();
	void UpdateVisibility(const struct FVector& PlayerLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DG_RoomRotatorVisibility">();
	}
	static class ADG_RoomRotatorVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADG_RoomRotatorVisibility>();
	}
};
static_assert(alignof(ADG_RoomRotatorVisibility) == 0x000008, "Wrong alignment on ADG_RoomRotatorVisibility");
static_assert(sizeof(ADG_RoomRotatorVisibility) == 0x000238, "Wrong size on ADG_RoomRotatorVisibility");

// Class Project.DistributionFloatAbsUniform
// 0x0000 (0x0040 - 0x0040)
class UDistributionFloatAbsUniform final : public UDistributionFloatUniform
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionFloatAbsUniform">();
	}
	static class UDistributionFloatAbsUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionFloatAbsUniform>();
	}
};
static_assert(alignof(UDistributionFloatAbsUniform) == 0x000008, "Wrong alignment on UDistributionFloatAbsUniform");
static_assert(sizeof(UDistributionFloatAbsUniform) == 0x000040, "Wrong size on UDistributionFloatAbsUniform");

// Class Project.UIBtlUpliftingGaugeBase
// 0x0010 (0x0288 - 0x0278)
class UUIBtlUpliftingGaugeBase : public UUIWidgetBase
{
public:
	int32                                         M_Gauge;                                           // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_IsFirstSetGauge;                                 // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A13[0x3];                                     // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_FluctuationAmount;                               // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A14[0x4];                                     // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_InStart();
	void BP_OutStart();
	void BP_SetGaugeValue();
	void BP_SlideInStart();
	void BP_SlideOutStart();
	void Init();
	void InStart();
	void OutStart();
	void SetGaugeValue(int32 Root_gauge_value);
	void SlideInStart();
	void SlideOutStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBtlUpliftingGaugeBase">();
	}
	static class UUIBtlUpliftingGaugeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBtlUpliftingGaugeBase>();
	}
};
static_assert(alignof(UUIBtlUpliftingGaugeBase) == 0x000008, "Wrong alignment on UUIBtlUpliftingGaugeBase");
static_assert(sizeof(UUIBtlUpliftingGaugeBase) == 0x000288, "Wrong size on UUIBtlUpliftingGaugeBase");
static_assert(offsetof(UUIBtlUpliftingGaugeBase, M_Gauge) == 0x000278, "Member 'UUIBtlUpliftingGaugeBase::M_Gauge' has a wrong offset!");
static_assert(offsetof(UUIBtlUpliftingGaugeBase, M_IsFirstSetGauge) == 0x00027C, "Member 'UUIBtlUpliftingGaugeBase::M_IsFirstSetGauge' has a wrong offset!");
static_assert(offsetof(UUIBtlUpliftingGaugeBase, M_FluctuationAmount) == 0x000280, "Member 'UUIBtlUpliftingGaugeBase::M_FluctuationAmount' has a wrong offset!");

// Class Project.DistributionVectorAbsUniform
// 0x0000 (0x0060 - 0x0060)
class UDistributionVectorAbsUniform final : public UDistributionVectorUniform
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionVectorAbsUniform">();
	}
	static class UDistributionVectorAbsUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionVectorAbsUniform>();
	}
};
static_assert(alignof(UDistributionVectorAbsUniform) == 0x000008, "Wrong alignment on UDistributionVectorAbsUniform");
static_assert(sizeof(UDistributionVectorAbsUniform) == 0x000060, "Wrong size on UDistributionVectorAbsUniform");

// Class Project.PathComponent
// 0x0120 (0x0570 - 0x0450)
class UPathComponent final : public UPrimitiveComponent
{
public:
	struct FPathCurves                            SplineCurves;                                      // 0x0450(0x0108)(Edit, NativeAccessSpecifierPublic)
	int32                                         ReparamStepsPerSegment;                            // 0x0558(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStationaryEndpoints;                              // 0x0560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSplineHasBeenEdited;                              // 0x0561(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifiedByConstructionScript;                     // 0x0562(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputSplinePointsToConstructionScript;            // 0x0563(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0564(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomFindNearest;                             // 0x0565(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClosedLoop;                                       // 0x0566(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A15[0x9];                                     // 0x0567(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPoint(const struct FPathPoint& Point, bool bUpdateSpline);
	void ClearSplinePoints(bool bUpdateSpline);
	void UpdateSpline();

	float FindDistanceClosestToSplineInputKey(float InKey) const;
	float FindInputKeyClosestToWorldLocation(const struct FVector& WorldLocation) const;
	struct FVector GetArriveTangentAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	float GetDistanceAlongSplineAtSplinePoint(int32 PointIndex) const;
	struct FVector GetLeaveTangentAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetLocationAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetLocationAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	float GetParam1AtDistanceAlongSpline(float Distance) const;
	float GetParam2AtDistanceAlongSpline(float Distance) const;
	float GetParam3AtDistanceAlongSpline(float Distance) const;
	float GetParam4AtDistanceAlongSpline(float Distance) const;
	float GetParam5AtDistanceAlongSpline(float Distance) const;
	float GetParam6AtDistanceAlongSpline(float Distance) const;
	float GetParam7AtDistanceAlongSpline(float Distance) const;
	float GetParam8AtDistanceAlongSpline(float Distance) const;
	struct FRotator GetRotationAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	struct FRotator GetRotationAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	float GetSplineLength() const;
	struct FVector GetUpVectorAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetUpVectorAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	bool IsClosedLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathComponent">();
	}
	static class UPathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathComponent>();
	}
};
static_assert(alignof(UPathComponent) == 0x000010, "Wrong alignment on UPathComponent");
static_assert(sizeof(UPathComponent) == 0x000570, "Wrong size on UPathComponent");
static_assert(offsetof(UPathComponent, SplineCurves) == 0x000450, "Member 'UPathComponent::SplineCurves' has a wrong offset!");
static_assert(offsetof(UPathComponent, ReparamStepsPerSegment) == 0x000558, "Member 'UPathComponent::ReparamStepsPerSegment' has a wrong offset!");
static_assert(offsetof(UPathComponent, Duration) == 0x00055C, "Member 'UPathComponent::Duration' has a wrong offset!");
static_assert(offsetof(UPathComponent, bStationaryEndpoints) == 0x000560, "Member 'UPathComponent::bStationaryEndpoints' has a wrong offset!");
static_assert(offsetof(UPathComponent, bSplineHasBeenEdited) == 0x000561, "Member 'UPathComponent::bSplineHasBeenEdited' has a wrong offset!");
static_assert(offsetof(UPathComponent, bModifiedByConstructionScript) == 0x000562, "Member 'UPathComponent::bModifiedByConstructionScript' has a wrong offset!");
static_assert(offsetof(UPathComponent, bInputSplinePointsToConstructionScript) == 0x000563, "Member 'UPathComponent::bInputSplinePointsToConstructionScript' has a wrong offset!");
static_assert(offsetof(UPathComponent, bDrawDebug) == 0x000564, "Member 'UPathComponent::bDrawDebug' has a wrong offset!");
static_assert(offsetof(UPathComponent, bUseCustomFindNearest) == 0x000565, "Member 'UPathComponent::bUseCustomFindNearest' has a wrong offset!");
static_assert(offsetof(UPathComponent, bClosedLoop) == 0x000566, "Member 'UPathComponent::bClosedLoop' has a wrong offset!");

// Class Project.DitherFoliageInstancedStaticMeshComponent
// 0x0000 (0x06C0 - 0x06C0)
class UDitherFoliageInstancedStaticMeshComponent final : public UFoliageInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DitherFoliageInstancedStaticMeshComponent">();
	}
	static class UDitherFoliageInstancedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDitherFoliageInstancedStaticMeshComponent>();
	}
};
static_assert(alignof(UDitherFoliageInstancedStaticMeshComponent) == 0x000010, "Wrong alignment on UDitherFoliageInstancedStaticMeshComponent");
static_assert(sizeof(UDitherFoliageInstancedStaticMeshComponent) == 0x0006C0, "Wrong size on UDitherFoliageInstancedStaticMeshComponent");

// Class Project.DLCAnnouncerBase
// 0x0000 (0x0220 - 0x0220)
class ADLCAnnouncerBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCAnnouncerBase">();
	}
	static class ADLCAnnouncerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADLCAnnouncerBase>();
	}
};
static_assert(alignof(ADLCAnnouncerBase) == 0x000008, "Wrong alignment on ADLCAnnouncerBase");
static_assert(sizeof(ADLCAnnouncerBase) == 0x000220, "Wrong size on ADLCAnnouncerBase");

// Class Project.BPL_CharaStatusObject
// 0x0000 (0x0028 - 0x0028)
class UBPL_CharaStatusObject final : public UBlueprintFunctionLibrary
{
public:
	static void AddViewSlaveLocationBP(const struct FVector& SlaveLocation, float BoostFactor, bool bOverrideLocation, float Duration);
	static int32 ConvertResistancesBadIndex2Index(int32 ResistancesBadIndex);
	static class FText GetConditionText(const class UScriptMessageAsset* ConditionMessage, int32 TextID);
	static class FText GetDevilProfile(int32 DevilID, const class UScriptMessageAsset* StatusMessage, const class UScriptMessageAsset* DevilProfile);
	static class FText GetDevilSpawnAreaText(int32 DevilID, const bool IsTop, const class UScriptMessageAsset* MapAreaMessage);
	static class FText GetPlayerFullName();
	static class FText GetPlayerName();
	static class FText GetPlayerProfile(const class UScriptMessageAsset* Profile);
	static int32 GetResistancesBadIconID(int32 ResistancesBadIndex);
	static class FText GetResistancesBadText(E_DEFENCE_RESISTANCE Type, bool IsLast, const class UScriptMessageAsset* StatusMessage);
	static class FText GetSkillNameText(const int32& SkillId, const int32& AddNum, const class UScriptMessageAsset* SystemMessage);
	static int32 GetSpawnDelayForCharaChanger2DBase(int32 StepNum);
	static int32 GetSpawnEarlyDelayForCharaChanger2DBase(int32 StepNum);
	static bool IsCompleteLoadTexture(class ACustomPawn*& CustomPawn);
	static bool IsMagatsuhiSkillSlot(const struct FUIStatusSlotItemData& SlotData);
	static bool IsSlotAnimSimpleType(E_UI_STATUS_SLOT Type);
	static bool IsSlotItem(E_UI_STATUS_SLOT Type);
	static bool IsSlotTitle(E_UI_STATUS_SLOT Type);
	static void PreStreamStatusModelTexture(class ACustomPawn*& CustomPawn, float Second);
	static void ReleaseResidentStreamingTexture(class ACustomPawn*& CustomPawn);
	static void SetBiographyText(const TArray<class UTextBlock*>& TextArr, int32 DevilID, const class UScriptMessageAsset* StatusMessage, const class UScriptMessageAsset* DevilProfile, int32 Offset, int32* NewOffset, float* ScrollBarRate, int32* RowMax);
	static void Test_LogStatus(class UUIStatusCtrlDataObjBase* DataObj);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_CharaStatusObject">();
	}
	static class UBPL_CharaStatusObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_CharaStatusObject>();
	}
};
static_assert(alignof(UBPL_CharaStatusObject) == 0x000008, "Wrong alignment on UBPL_CharaStatusObject");
static_assert(sizeof(UBPL_CharaStatusObject) == 0x000028, "Wrong size on UBPL_CharaStatusObject");

// Class Project.DlcTableData
// 0x0068 (0x0098 - 0x0030)
class UDlcTableData final : public UDataAsset
{
public:
	FMulticastInlineDelegateProperty_             OnContentEnable;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnContentDisable;                                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MountComplete;                                     // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FDlcTableData_One>              DataArray;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMountCheck;                                       // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A28[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDlcTableData_One                      DLC_DummyData;                                     // 0x0074(0x0020)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A29[0x4];                                     // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllDlcSystemSaveFlag(bool InClearMountFlag, bool InClearSystemFlag);
	TArray<class FName> GetDlcNameTagList();
	int32 GetDLCSaveId(class FName NameTag);
	bool IsCheckDLCFlag(class FName NameTag);
	void MountCheck();
	void SetDLCFlag(class FName NameTag, bool IsOn);
	void UpdateDLCFlag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcTableData">();
	}
	static class UDlcTableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcTableData>();
	}
};
static_assert(alignof(UDlcTableData) == 0x000008, "Wrong alignment on UDlcTableData");
static_assert(sizeof(UDlcTableData) == 0x000098, "Wrong size on UDlcTableData");
static_assert(offsetof(UDlcTableData, OnContentEnable) == 0x000030, "Member 'UDlcTableData::OnContentEnable' has a wrong offset!");
static_assert(offsetof(UDlcTableData, OnContentDisable) == 0x000040, "Member 'UDlcTableData::OnContentDisable' has a wrong offset!");
static_assert(offsetof(UDlcTableData, MountComplete) == 0x000050, "Member 'UDlcTableData::MountComplete' has a wrong offset!");
static_assert(offsetof(UDlcTableData, DataArray) == 0x000060, "Member 'UDlcTableData::DataArray' has a wrong offset!");
static_assert(offsetof(UDlcTableData, bMountCheck) == 0x000070, "Member 'UDlcTableData::bMountCheck' has a wrong offset!");
static_assert(offsetof(UDlcTableData, DLC_DummyData) == 0x000074, "Member 'UDlcTableData::DLC_DummyData' has a wrong offset!");

// Class Project.DlcSubIdTableData
// 0x0010 (0x0040 - 0x0030)
class UDlcSubIdTableData final : public UDataAsset
{
public:
	TArray<struct FDlcSubIdTableData_One>         DataArray;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcSubIdTableData">();
	}
	static class UDlcSubIdTableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcSubIdTableData>();
	}
};
static_assert(alignof(UDlcSubIdTableData) == 0x000008, "Wrong alignment on UDlcSubIdTableData");
static_assert(sizeof(UDlcSubIdTableData) == 0x000040, "Wrong size on UDlcSubIdTableData");
static_assert(offsetof(UDlcSubIdTableData, DataArray) == 0x000030, "Member 'UDlcSubIdTableData::DataArray' has a wrong offset!");

// Class Project.ProjectGameModeBase
// 0x0038 (0x0340 - 0x0308)
class AProjectGameModeBase : public AGameMode
{
public:
	class UMapEventManager*                       MapEventManager;                                   // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEditorNoDebugMenu;                               // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A2C[0x7];                                     // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGazeTargetHolder>          GazeTargetHolderClass;                             // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGazeTargetHolder*                      GazeTargetHolder;                                  // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  DisableMenuArray;                                  // 0x0328(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UEnum>                   EDisableMenuReason_EnumPtr;                        // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGazeTargetHolder* GetGazeTargetHolder(const class UObject* WorldContextObject);
	static bool IsSpawnDebugMenu(const class UObject* WorldContextObject);
	static void ProjectDisableMenu(const class UObject* WorldContextObject, const EDisableMenuReason DisableMenuReason);
	static void ProjectEnableMenu(const class UObject* WorldContextObject, const EDisableMenuReason DisableMenuReason);
	static void ProjectEnableMenuAll(const class UObject* WorldContextObject);
	static bool ProjectIsMenuDisabled(const class UObject* WorldContextObject);
	static bool ProjectIsMenuDisabledByReason(const class UObject* WorldContextObject, EDisableMenuReason DisableMenuReason);

	void CallAutoPause_ForConsumer();
	void CallReactivatedApp_ForConsumer();
	void PreloadMap(int32 MapId, int32 AreaId);
	void TestCrash();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectGameModeBase">();
	}
	static class AProjectGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectGameModeBase>();
	}
};
static_assert(alignof(AProjectGameModeBase) == 0x000008, "Wrong alignment on AProjectGameModeBase");
static_assert(sizeof(AProjectGameModeBase) == 0x000340, "Wrong size on AProjectGameModeBase");
static_assert(offsetof(AProjectGameModeBase, MapEventManager) == 0x000308, "Member 'AProjectGameModeBase::MapEventManager' has a wrong offset!");
static_assert(offsetof(AProjectGameModeBase, IsEditorNoDebugMenu) == 0x000310, "Member 'AProjectGameModeBase::IsEditorNoDebugMenu' has a wrong offset!");
static_assert(offsetof(AProjectGameModeBase, GazeTargetHolderClass) == 0x000318, "Member 'AProjectGameModeBase::GazeTargetHolderClass' has a wrong offset!");
static_assert(offsetof(AProjectGameModeBase, GazeTargetHolder) == 0x000320, "Member 'AProjectGameModeBase::GazeTargetHolder' has a wrong offset!");
static_assert(offsetof(AProjectGameModeBase, DisableMenuArray) == 0x000328, "Member 'AProjectGameModeBase::DisableMenuArray' has a wrong offset!");
static_assert(offsetof(AProjectGameModeBase, EDisableMenuReason_EnumPtr) == 0x000338, "Member 'AProjectGameModeBase::EDisableMenuReason_EnumPtr' has a wrong offset!");

// Class Project.DrawDebugPauseHelper
// 0x0048 (0x0268 - 0x0220)
class ADrawDebugPauseHelper final : public AActor
{
public:
	uint8                                         Pad_1A32[0x48];                                    // 0x0220(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawDebugPauseHelper">();
	}
	static class ADrawDebugPauseHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADrawDebugPauseHelper>();
	}
};
static_assert(alignof(ADrawDebugPauseHelper) == 0x000008, "Wrong alignment on ADrawDebugPauseHelper");
static_assert(sizeof(ADrawDebugPauseHelper) == 0x000268, "Wrong size on ADrawDebugPauseHelper");

// Class Project.EncountAreaComp_CPP
// 0x0028 (0x00D8 - 0x00B0)
class UEncountAreaComp_CPP final : public UActorComponent
{
public:
	TArray<struct FTransform>                     M_SpawnPointList;                                  // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     M_SpawnPointList_Prio;                             // 0x00C0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A33[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcSpawnPointList_Box(const struct FVector& BoxSize, float Space, const TArray<class AActor*>& AddPointActors, bool AddPointOnly);
	void CalcSpawnPointList_Spline(class USplineComponent* SplineComp, const TArray<int32>& SpawnKeyList, float Space);
	bool CheckSpaceWhenSpawning(const class UObject* WorldContextObject, const struct FVector& SpawnPos);
	int32 ConvertDevilLevel(int32 PrevLevel);
	float GetSpaceWhenSpawning();
	void SetNeedData(float SpaceWhenSpawning);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EncountAreaComp_CPP">();
	}
	static class UEncountAreaComp_CPP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEncountAreaComp_CPP>();
	}
};
static_assert(alignof(UEncountAreaComp_CPP) == 0x000008, "Wrong alignment on UEncountAreaComp_CPP");
static_assert(sizeof(UEncountAreaComp_CPP) == 0x0000D8, "Wrong size on UEncountAreaComp_CPP");
static_assert(offsetof(UEncountAreaComp_CPP, M_SpawnPointList) == 0x0000B0, "Member 'UEncountAreaComp_CPP::M_SpawnPointList' has a wrong offset!");
static_assert(offsetof(UEncountAreaComp_CPP, M_SpawnPointList_Prio) == 0x0000C0, "Member 'UEncountAreaComp_CPP::M_SpawnPointList_Prio' has a wrong offset!");

// Class Project.UIFadePause
// 0x0008 (0x0268 - 0x0260)
class UUIFadePause : public UUserWidget
{
public:
	bool                                          bIsPaused;                                         // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A37[0x7];                                     // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsPaused();
	void SetIsPaused(bool Sw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFadePause">();
	}
	static class UUIFadePause* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFadePause>();
	}
};
static_assert(alignof(UUIFadePause) == 0x000008, "Wrong alignment on UUIFadePause");
static_assert(sizeof(UUIFadePause) == 0x000268, "Wrong size on UUIFadePause");
static_assert(offsetof(UUIFadePause, bIsPaused) == 0x000260, "Member 'UUIFadePause::bIsPaused' has a wrong offset!");

// Class Project.BPL_EncountData
// 0x0000 (0x0028 - 0x0028)
class UBPL_EncountData final : public UBlueprintFunctionLibrary
{
public:
	static const struct FOneEncountData GetEncountData(int32 ID);
	static int32 GetEncountDataNum();
	static const struct FPackEncount GetEncountPackData(int32 ID);
	static const struct FPackEncount GetEncountPackData_Dungeon(int32 MapId, int32 Param_Index, int32* PackId);
	static int32 GetEncountPackDataNum();
	static int32 GetRandomEncountId(int32 Pack_id);
	static int32 GetRandomEncountId_Dungeon(int32 MapId, int32 Param_Index);
	static void ReleaseEncountDataRandomStream();
	static void SettingEncountDataRandomStream(const struct FRandomStream& RandomStream);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_EncountData">();
	}
	static class UBPL_EncountData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_EncountData>();
	}
};
static_assert(alignof(UBPL_EncountData) == 0x000008, "Wrong alignment on UBPL_EncountData");
static_assert(sizeof(UBPL_EncountData) == 0x000028, "Wrong size on UBPL_EncountData");

// Class Project.EventBase
// 0x0000 (0x0220 - 0x0220)
class AEventBase : public AActor
{
public:
	bool CheckPauseEvent();
	void EndPauseMovieEvent();
	bool IsPauseMovieEvent();
	bool IsPlayingMovieEvent();
	bool IsTalkPart();
	void PauseMovie();
	void StartPauseMovieEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventBase">();
	}
	static class AEventBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventBase>();
	}
};
static_assert(alignof(AEventBase) == 0x000008, "Wrong alignment on AEventBase");
static_assert(sizeof(AEventBase) == 0x000220, "Wrong size on AEventBase");

// Class Project.BPL_PlayerPawnUtil
// 0x0000 (0x0028 - 0x0028)
class UBPL_PlayerPawnUtil final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeFormSound(bool bTsukuyomi);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_PlayerPawnUtil">();
	}
	static class UBPL_PlayerPawnUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_PlayerPawnUtil>();
	}
};
static_assert(alignof(UBPL_PlayerPawnUtil) == 0x000008, "Wrong alignment on UBPL_PlayerPawnUtil");
static_assert(sizeof(UBPL_PlayerPawnUtil) == 0x000028, "Wrong size on UBPL_PlayerPawnUtil");

// Class Project.BPL_EventEncountData
// 0x0000 (0x0028 - 0x0028)
class UBPL_EventEncountData final : public UBlueprintFunctionLibrary
{
public:
	static void ClearBossRushChallengeMode(const int32& EventEncountId);
	static void ClearBossRushOneDataAll();
	static int32 GetBossRushChallengeModeLevel(const int32& EventEncountId);
	static int32 GetEventEncountDataNum();
	static const struct FEventEncountData GetEvtEncountData(int32 Encount_id);
	static bool IsFirstClearBossRushOriginalMode(const int32& EventEncountId);
	static bool IsUnlockBossRush(const int32& EventEncountId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_EventEncountData">();
	}
	static class UBPL_EventEncountData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_EventEncountData>();
	}
};
static_assert(alignof(UBPL_EventEncountData) == 0x000008, "Wrong alignment on UBPL_EventEncountData");
static_assert(sizeof(UBPL_EventEncountData) == 0x000028, "Wrong size on UBPL_EventEncountData");

// Class Project.EventFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UEventFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddClearRound();
	static void AddEventTrack_PlaySE(class ALevelSequenceActor* Sequence);
	static void AllBinding(const class FString& Param_Name, class AActor* Actor);
	static void ChangeAtomOnly2DSound(class UAtomComponent* AtomComponent, bool bOnly2DSound);
	static bool CheckActorBegunPlay(const class AActor* Actor);
	static bool CheckAllSequenceActorLoaded(const class AActor* EventBase);
	static void CheckAogamiUtsusemiTalkIcon();
	static bool CheckClass(const class AActor* Actor, TSubclassOf<class AActor> ActorClass);
	static bool CheckEventActive_E0170(const struct FVector2D& Pos);
	static float CheckEventEmitterRate(const float Rate);
	static bool CheckEventScope_E0170(const struct FVector2D& Pos, const struct FVector2D& Min, const struct FVector2D& Max);
	static bool CheckNoTap_E0170(float NowX, float NowY, float DefX, float DefY);
	static void CheckPostProcessSettings(const struct FPostProcessSettings& Setting);
	static int32 CountAlreadyClearBossRush_ChallengeMode(const TArray<class FName>& ClearFlags);
	static int32 CountAlreadyClearBossRush_OriginalMode(const TArray<int32>& EncountIDs);
	static void EndPlay(class ALevelSequenceActor* Sequence);
	static bool EntryBibleShiseijoTao();
	static void EntryNkmForce(const int32 DevilID);
	static void EntryNkmForceParty(const TArray<int32>& DevilIDs);
	static class UMatineeCameraShake* EventCameraPlayShake(class ACustomPlayerController* Controller, TSubclassOf<class UMatineeCameraShake> ShakeClass, float Scale, ECameraShakePlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot);
	static void EventCameraStopShake(class ACustomPlayerController* Controller, class UMatineeCameraShake* Inst, bool bImmediately);
	static void EventScreenshot(const class FString& Directory, const int32 FileIndex);
	static TArray<class AActor*> GetActorsFromLevel(const class ULevelStreaming* Levelstr);
	static TArray<class AActor*> GetActorsThisLevel(const class AActor* Actor);
	static E_ALIGNMENT GetAlignmentBias();
	static E_ALIGNMENT GetAlignmentBias_New();
	static E_ALIGNMENT GetAlignmentBias_Old();
	static class UAnimSequenceBase* GetAnimConv(const class ALevelSequenceActor* Sequence, const class FString& Tag, const class FString& AnimName);
	static class UAnimSequenceBase* GetAnimSequence(const class ALevelSequenceActor* Sequence, const class FString& Tag);
	static bool GetAutoRead();
	static struct FMovieSceneObjectBindingID GetBindingID(const class ALevelSequenceActor* Sequence, const class FString& Param_Name);
	static uint8 GetClearRound();
	static float GetCurve(float DeltaTime, bool Init, float EndSeconds);
	static float GetCurveLoop(float DeltaTime, bool Init, float LoopSeconds);
	static int32 GetDebugAlignmentFlagPoint(bool IsLaw);
	static class AActor* GetECSActorsThisLevel(const class AActor* Actor);
	static class AActor* GetEventBase(const class ULevelStreaming* Levelstr);
	static class AActor* GetEventCtrl(const class ULevelStreaming* Levelstr);
	static class FString GetEventLevelName();
	static float GetEventMaxFrameTime(const class AActor* Actor);
	static class FText GetEventText(const class UScriptMessageAsset* Asset, int32 ID, int32* Line);
	static class FString GetEventVoice(const class UScriptMessageAsset* Asset, int32 ID);
	static E_GAME_START_MODE GetGameStartMode();
	static TArray<bool> GetInitCursorPosition(const TArray<class FName>& History, const class FName Select1, const class FName Select2, const class FName Select3, int32* Position, bool* Finish);
	static TArray<bool> GetInitCursorPositionEx(const TArray<class FName>& History, const TArray<class FName>& Select, int32* Position, bool* Finish);
	static TArray<bool> GetInitCursorPositionIndex(const TArray<int32>& History, const int32 SelIndex1, const int32 SelIndex2, const int32 SelIndex3, int32* Position, bool* Finish);
	static TArray<class FString> GetLevelVisible(bool IsVisible);
	static float GetLinear(float DeltaTime, bool Init, float EndSeconds);
	static float GetLinearLoop(float DeltaTime, bool Init, float LoopSeconds);
	static float GetMaxFPS();
	static E_ALIGNMENT GetNowAlignment();
	static E_ALIGNMENT GetNowAlignment_NewRouteForce();
	static float GetPlayTime(class ALevelSequenceActor* Sequence);
	static struct FPostProcessSettings GetPostProcessSetting(const struct FPostProcessSettings& Setting, class UCineCameraComponent* Camera);
	static bool GetShippingBuild();
	static class USoundAtomCue* GetSoundData(const class ALevelSequenceActor* Sequence, const class FString& CueName);
	static float GetSoundDuration(const class USoundAtomCue* Cue);
	static int32 GetStrLenEvtDebug(const class FString& CheckStr);
	static TArray<class FString> GetVoiceAssetNames(const class FString& Filter);
	static float GetVoiceAutoTime(const int32 StrLen);
	static bool IsActionCancelTrigger();
	static bool IsAlreadyClearBossRush(const int32& EncountID);
	static bool IsAlreadyClearBossRushAll_ChallengeMode(const TArray<class FName>& ClearFlags);
	static bool IsAlreadyClearBossRushAll_OriginalMode(const TArray<int32>& EncountIDs);
	static bool IsAlreadyHaveAogamiUtsusemi(int32 Amount);
	static bool IsClearAlignment(E_ALIGNMENT Alignment);
	static bool IsCompareClearAlignment(uint8 ClearAlignment, E_ALIGNMENT Alignment);
	static bool IsCreationMode();
	static bool IsJpEdition();
	static bool IsOriginalMovieResolution();
	static bool IsPlayerHaveSkill(int32 ID);
	static void LevelTick(class AActor* Actor);
	static void LevelUpWhenCreateEntryNkm(const int32 NkmIndex);
	static void OpenSequenceWindow(class ALevelSequenceActor* Sequence);
	static void PickUpKeyTime(class ALevelSequenceActor* Sequence);
	static void PlayFromAtomComponent(class UAtomComponent* AtomComponent, float StartTime);
	static void RestoreAllSequenceActor(const class AActor* EventBase);
	static class UAnimSequence* SearchAnimSequence(const class FString& InName);
	static void SetAllActorHidden(class ULevelStreaming* Levelstr, bool Hidden);
	static void SetAllViewportRealtime(bool Realtime);
	static void SetAutoRead(bool AutoRead);
	static void SetClearAlignment(E_ALIGNMENT Alignment);
	static void SetEffectLOD(class UParticleSystemComponent* Obj, int32 LODSetting);
	static void SetEventMaxFrameTime(const class AActor* Actor, float FrameTime);
	static void SetGameStartMode(E_GAME_START_MODE StartMode);
	static void SetLightingChannels(class UPrimitiveComponent* InComponent, bool bChannel0, bool bChannel1, bool bChannel2);
	static void SetNameEntry(const class FString& First, const class FString& Second, bool bSwitch);
	static void SetPlayerDevilBaseParam(class UPlayerMovementComponent* Comp, float VelMin, float VelMax, float Fallen, float RotSpeed, float RotSpeedOnSpot, float Acceleration, float Deceleration, float StepupHeight);
	static void SetPlayTime(class ALevelSequenceActor* Sequence, float Time);
	static bool ShiseijyoTaoNoLeaveFlagProc(int32 DevilID);
	static void StartPlay(class ALevelSequenceActor* Sequence);
	static void TargetBinding(class ALevelSequenceActor* Sequence, const class FString& Param_Name, class AActor* Actor);
	static void UseEventTemplate(const class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventFunctionLibrary">();
	}
	static class UEventFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventFunctionLibrary>();
	}
};
static_assert(alignof(UEventFunctionLibrary) == 0x000008, "Wrong alignment on UEventFunctionLibrary");
static_assert(sizeof(UEventFunctionLibrary) == 0x000028, "Wrong size on UEventFunctionLibrary");

// Class Project.LevelUpManager
// 0x0058 (0x0080 - 0x0028)
class ULevelUpManager final : public UObject
{
public:
	uint8                                         Pad_1A67[0x50];                                    // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIStatusCtrlDataObjResult*             M_CtrlData;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static int32 GetHeroBonusPointMargin();
	static bool IsEnableGardenSkillExEvent(int32 NkmIndex, int32 AddRank);

	class UUIStatusCtrlDataObjResult* GetDataObj();
	int32 GetDevilID();
	int32 GetEmptySlotIndex();
	int32 GetLearnableSkillNum();
	int32 GetRemainingPoint();
	int32 GetSkillSlotIndex(int32 TotalIndex);
	bool GotoNextCharacter();
	bool GrowUpAndCreateEventData(const struct FResultData& ResultData);
	bool GrowUpAndCreateEventDataForCamp(const int32 NkmIndex, const int32 UpLv);
	bool InitGardenResult(const int32 NkmIndex, const struct FUIStatusDataUpParam& In_UpParam, const bool In_ExSkillEvent);
	void InitShowUpParam();
	bool IsExistEvent();
	bool IsExistNextCharacter();
	bool IsHeroEvent();
	bool LearnNextSkill(int32 DestIndex);
	void PlayerPointUp(struct FAbilData& AddParam);
	void ReturnSkillDataToEventStart();
	void SetTalkerName(class UScriptMessageAsset* ScriptMessageAsset, const class FName& MessageLabel, int32 DevilID);
	void SkillDataOverride();
	bool TryExSkillEventCreate(const int32 AddRank);
	bool TryGiftEventCreateAndGetGiftItem();
	bool TryLvUpEventCreate_ForUnite(const int32 NkmIndex);
	bool TrySkillEventCreate();
	void UpdateSlotLookForSkillEvent();

	int32 GetDevilIDRelative(const int32 RelativePosition) const;
	int32 GetExSkillID() const;
	int32 GetGiftID() const;
	int32 GetLearningSkillID() const;
	int32 GetSkillID(int32 Param_Index) const;
	int32 GetUpLv() const;
	bool IsGiftDevilSoul() const;
	bool IsSoulGiftAlreadyGot() const;
	bool IsValidRelativeData(const int32 RelativePosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelUpManager">();
	}
	static class ULevelUpManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelUpManager>();
	}
};
static_assert(alignof(ULevelUpManager) == 0x000008, "Wrong alignment on ULevelUpManager");
static_assert(sizeof(ULevelUpManager) == 0x000080, "Wrong size on ULevelUpManager");
static_assert(offsetof(ULevelUpManager, M_CtrlData) == 0x000078, "Member 'ULevelUpManager::M_CtrlData' has a wrong offset!");

// Class Project.FacialAnimationPreset
// 0x01C8 (0x01F0 - 0x0028)
class UFacialAnimationPreset final : public UObject
{
public:
	struct FFacialAnimationPreset_EVT01_PresetData EVT01;                                             // 0x0028(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFacialAnimationPreset_EVT02_PresetData EVT02;                                             // 0x004C(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFacialAnimationPreset_EVT03_PresetData EVT03;                                             // 0x0060(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFacialAnimationPreset_EVT04_PresetData EVT04;                                             // 0x00A0(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFacialAnimationPreset_EVT05_PresetData EVT05;                                             // 0x00E0(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A72[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFacialAnimationPreset_EVT06_PresetData EVT06;                                             // 0x00F8(0x0050)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFacialAnimationPreset_EVT07_PresetData EVT07;                                             // 0x0148(0x0050)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFacialAnimationPreset_EVT08_PresetData EVT08;                                             // 0x0198(0x0058)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FacialAnimationPreset">();
	}
	static class UFacialAnimationPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFacialAnimationPreset>();
	}
};
static_assert(alignof(UFacialAnimationPreset) == 0x000008, "Wrong alignment on UFacialAnimationPreset");
static_assert(sizeof(UFacialAnimationPreset) == 0x0001F0, "Wrong size on UFacialAnimationPreset");
static_assert(offsetof(UFacialAnimationPreset, EVT01) == 0x000028, "Member 'UFacialAnimationPreset::EVT01' has a wrong offset!");
static_assert(offsetof(UFacialAnimationPreset, EVT02) == 0x00004C, "Member 'UFacialAnimationPreset::EVT02' has a wrong offset!");
static_assert(offsetof(UFacialAnimationPreset, EVT03) == 0x000060, "Member 'UFacialAnimationPreset::EVT03' has a wrong offset!");
static_assert(offsetof(UFacialAnimationPreset, EVT04) == 0x0000A0, "Member 'UFacialAnimationPreset::EVT04' has a wrong offset!");
static_assert(offsetof(UFacialAnimationPreset, EVT05) == 0x0000E0, "Member 'UFacialAnimationPreset::EVT05' has a wrong offset!");
static_assert(offsetof(UFacialAnimationPreset, EVT06) == 0x0000F8, "Member 'UFacialAnimationPreset::EVT06' has a wrong offset!");
static_assert(offsetof(UFacialAnimationPreset, EVT07) == 0x000148, "Member 'UFacialAnimationPreset::EVT07' has a wrong offset!");
static_assert(offsetof(UFacialAnimationPreset, EVT08) == 0x000198, "Member 'UFacialAnimationPreset::EVT08' has a wrong offset!");

// Class Project.BPL_FacilitySaveData
// 0x0000 (0x0028 - 0x0028)
class UBPL_FacilitySaveData final : public UBlueprintFunctionLibrary
{
public:
	static void GetFacilityReturnMap(int32* MapId, int32* AreaId, int32* WarpPoint);
	static void SetFacilityReturnMap(int32 MapId, int32 AreaId, int32 WarpPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_FacilitySaveData">();
	}
	static class UBPL_FacilitySaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_FacilitySaveData>();
	}
};
static_assert(alignof(UBPL_FacilitySaveData) == 0x000008, "Wrong alignment on UBPL_FacilitySaveData");
static_assert(sizeof(UBPL_FacilitySaveData) == 0x000028, "Wrong size on UBPL_FacilitySaveData");

// Class Project.BPL_PurposeData
// 0x0000 (0x0028 - 0x0028)
class UBPL_PurposeData final : public UBlueprintFunctionLibrary
{
public:
	static class FName GetCurrentPurposeData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_PurposeData">();
	}
	static class UBPL_PurposeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_PurposeData>();
	}
};
static_assert(alignof(UBPL_PurposeData) == 0x000008, "Wrong alignment on UBPL_PurposeData");
static_assert(sizeof(UBPL_PurposeData) == 0x000028, "Wrong size on UBPL_PurposeData");

// Class Project.BPL_FacilityShop
// 0x0000 (0x0028 - 0x0028)
class UBPL_FacilityShop final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckShopFirstFlag();
	static bool CheckShopMimanRewardFlag(int32 ID);
	static bool CheckShopNewItemFlag(int32 ItemId);
	static bool CheckShopRelicEvent();
	static void ClearShopCommonFlag();
	static void ClearShopMimanRewardFlag();
	static void ClearShopNewItemFlag();
	static struct FShopSaveData GetShopSaveData();
	static bool IsOpenShopMimanRewardMenu();
	static int32 LotShopEnterMessage(int32 Min, int32 Max);
	static int32 LotShopExitMessage(int32 Min, int32 Max);
	static void SetShopFirstFlag(bool Sw);
	static void SetShopMimanRewardFlag(int32 ID, bool Sw);
	static void SetShopNewItemFlag(int32 ItemId, bool Sw);
	static void SetShopRelicEventFlag(bool Sw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_FacilityShop">();
	}
	static class UBPL_FacilityShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_FacilityShop>();
	}
};
static_assert(alignof(UBPL_FacilityShop) == 0x000008, "Wrong alignment on UBPL_FacilityShop");
static_assert(sizeof(UBPL_FacilityShop) == 0x000028, "Wrong size on UBPL_FacilityShop");

// Class Project.FoliageHitEffect
// 0x00A0 (0x00C8 - 0x0028)
class UFoliageHitEffect : public UObject
{
public:
	TMap<TSoftObjectPtr<class UStaticMesh>, struct FFoliageMoveEffectData> MoveHitEffect;                                     // 0x0028(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UStaticMesh>, struct FFoliageHitEffectData> AttackHitEffect;                                   // 0x0078(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageHitEffect">();
	}
	static class UFoliageHitEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageHitEffect>();
	}
};
static_assert(alignof(UFoliageHitEffect) == 0x000008, "Wrong alignment on UFoliageHitEffect");
static_assert(sizeof(UFoliageHitEffect) == 0x0000C8, "Wrong size on UFoliageHitEffect");
static_assert(offsetof(UFoliageHitEffect, MoveHitEffect) == 0x000028, "Member 'UFoliageHitEffect::MoveHitEffect' has a wrong offset!");
static_assert(offsetof(UFoliageHitEffect, AttackHitEffect) == 0x000078, "Member 'UFoliageHitEffect::AttackHitEffect' has a wrong offset!");

// Class Project.SaveDataConverter
// 0x0020 (0x0048 - 0x0028)
class USaveDataConverter final : public UObject
{
public:
	uint8                                         Pad_1A77[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ConvertComplete;                                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void OverrideTrophyDataByConvertResult(const class UObject* WorldContextObject, const struct FSaveDataConvertResult& ConvertResult);

	void ConvertSaveDataPS4toPS5Async();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveDataConverter">();
	}
	static class USaveDataConverter* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveDataConverter>();
	}
};
static_assert(alignof(USaveDataConverter) == 0x000008, "Wrong alignment on USaveDataConverter");
static_assert(sizeof(USaveDataConverter) == 0x000048, "Wrong size on USaveDataConverter");
static_assert(offsetof(USaveDataConverter, ConvertComplete) == 0x000038, "Member 'USaveDataConverter::ConvertComplete' has a wrong offset!");

// Class Project.FrameGrabberActor
// 0x0038 (0x0258 - 0x0220)
class AFrameGrabberActor final : public AActor
{
public:
	class UMaterialInstanceDynamic*               MaterialInstanceDynamic;                           // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 CaptureFrameData;                                  // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             CaptureFrameTexture;                               // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A78[0x18];                                    // 0x0240(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsCaptureFinish();
	void SetMaterialInstanceDynamic(class UMaterialInstanceDynamic* MI);
	bool StartFrameGrab();
	void StopFrameGrab();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrameGrabberActor">();
	}
	static class AFrameGrabberActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFrameGrabberActor>();
	}
};
static_assert(alignof(AFrameGrabberActor) == 0x000008, "Wrong alignment on AFrameGrabberActor");
static_assert(sizeof(AFrameGrabberActor) == 0x000258, "Wrong size on AFrameGrabberActor");
static_assert(offsetof(AFrameGrabberActor, MaterialInstanceDynamic) == 0x000220, "Member 'AFrameGrabberActor::MaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(AFrameGrabberActor, CaptureFrameData) == 0x000228, "Member 'AFrameGrabberActor::CaptureFrameData' has a wrong offset!");
static_assert(offsetof(AFrameGrabberActor, CaptureFrameTexture) == 0x000238, "Member 'AFrameGrabberActor::CaptureFrameTexture' has a wrong offset!");

// Class Project.FrameRateManager
// 0x0008 (0x0030 - 0x0028)
class UFrameRateManager final : public UObject
{
public:
	uint8                                         Pad_1A79[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFrameRateManager* Get(const class UObject* WorldContextObject);

	void OnBGMSceneChanged(EBgmScene NewScene);
	void OnMaxFpsOptionChanged(float NewMaxFPS);
	void SetDebugMode(bool bActive, float Fps);

	float GetCurrentFrameRateLimit() const;
	bool GetDebugMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrameRateManager">();
	}
	static class UFrameRateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFrameRateManager>();
	}
};
static_assert(alignof(UFrameRateManager) == 0x000008, "Wrong alignment on UFrameRateManager");
static_assert(sizeof(UFrameRateManager) == 0x000030, "Wrong size on UFrameRateManager");

// Class Project.MaterialParameterApplier
// 0x0020 (0x0048 - 0x0028)
class UMaterialParameterApplier final : public UObject
{
public:
	TArray<struct FMaterialParameterApplier_ScalarParam> ScalarParams;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMaterialParameterApplier_VectorParam> VectorParams;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialParameterApplier">();
	}
	static class UMaterialParameterApplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialParameterApplier>();
	}
};
static_assert(alignof(UMaterialParameterApplier) == 0x000008, "Wrong alignment on UMaterialParameterApplier");
static_assert(sizeof(UMaterialParameterApplier) == 0x000048, "Wrong size on UMaterialParameterApplier");
static_assert(offsetof(UMaterialParameterApplier, ScalarParams) == 0x000028, "Member 'UMaterialParameterApplier::ScalarParams' has a wrong offset!");
static_assert(offsetof(UMaterialParameterApplier, VectorParams) == 0x000038, "Member 'UMaterialParameterApplier::VectorParams' has a wrong offset!");

// Class Project.BPL_GameData
// 0x0000 (0x0028 - 0x0028)
class UBPL_GameData final : public UBlueprintFunctionLibrary
{
public:
	static void AddMoonAge(const int32 AddValue);
	static void ClearTotalGameTime();
	static bool Get_Debug_DLC_ClearAnnounceFlag();
	static bool GetBtnHelpIconModeTick();
	static bool GetBtnHelpInitIconMode();
	static bool GetCampHelpAllOnFlag();
	static bool GetCampUtsusemiSortAscendingType();
	static int32 GetCampUtsusemiSortType();
	static float GetCampWheelValue();
	static int32 GetIconHelpStatus();
	static E_MOON_AGE GetMoonAge();
	static bool GetNeedDlcCheckAndAnnounceFlag();
	static E_OldNewRoute GetOldNewRoute();
	static bool GetReleaseAllBuyItemFlag();
	static int32 GetTotalGameTime();
	static int32 GetUIListAnimationFadeType();
	static int32 GetUtsusemiSortSkillId();
	static bool GetUtsusemiSortUnusedFlag();
	static void InitCreationNewGame();
	static bool InitializeUtsusemiSortSkillBuffer(int32 InPriority);
	static bool InitializeUtsusemiSortSkillBuffer_AllAttr();
	static void InitNewGame();
	static void InitReincarnationNewGame();
	static void InitRenewalNewGame();
	static bool IsBootingIconHelp();
	static bool IsCampHelpNewIconFlag(int32 InMessageId);
	static bool IsCampHelpOpened(int32 InMessageId);
	static bool IsCampHelpOpenedByIndex(int32 InIndex);
	static bool IsCampMenuNewIconOpened(int32 InMenuIndex);
	static bool ResetUtsusemiSortSkillBuffer(int32 InPriority);
	static bool ResetUtsusemiSortSkillBuffer_AllAttr();
	static void RestoreActivityIDfromGameData(const class UObject* WorldContextObject);
	static bool Set_Debug_DLC_ClearAnnounceFlag(bool InParam);
	static bool SetBtnHelpIconModeTick(bool IsActiveTick);
	static bool SetBtnHelpInitIconMode(bool IsGamePad);
	static bool SetCampHelpAllClosed();
	static bool SetCampHelpAllOnFlag(bool InFlag);
	static bool SetCampHelpAllOpened();
	static bool SetCampHelpClosedByIndex(int32 InIndex);
	static bool SetCampHelpNewIconFlag(int32 InMessageId, bool InFlag);
	static bool SetCampHelpOpened(int32 InMessageId);
	static bool SetCampHelpOpenedByIndex(int32 InIndex);
	static bool SetCampMenuNewIconFlag(int32 InMenuIndex);
	static bool SetCampUtsusemiSortAscendingType(bool InAscendingType);
	static bool SetCampUtsusemiSortType(int32 InSortKind);
	static bool SetCampWheelValue(float InValue);
	static bool SetIconHelpStatus(int32 InStatus);
	static void SetMoonAge(E_MOON_AGE MoonAge);
	static bool SetNeedDlcCheckAndAnnounceFlag(bool IsNeed, bool IsForce);
	static void SetOldNewRoute(E_OldNewRoute InOldNewRoute);
	static void SetOldNewRouteFromEventFlag();
	static bool SetReleaseAllBuyItemFlag(bool IsRelease);
	static bool SetUIListAnimationFadeType(int32 InType);
	static int32 SetUtsusemiSortSkillBuffer(int32 InDevilId);
	static bool SetUtsusemiSortSkillId(int32 InSkillId);
	static bool SetUtsusemiSortUnusedFlag(bool InFlag);
	static void StoreActivityIDtoGameData(const class UObject* WorldContextObject);
	static void UpdateTotalGameTime(float DeltaTime);
	static bool UtsusemiSortSkillBufferSort(int32 InSortKind, int32 InSortType, int32 InPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_GameData">();
	}
	static class UBPL_GameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_GameData>();
	}
};
static_assert(alignof(UBPL_GameData) == 0x000008, "Wrong alignment on UBPL_GameData");
static_assert(sizeof(UBPL_GameData) == 0x000028, "Wrong size on UBPL_GameData");

// Class Project.SaveObject
// 0x88BB0 (0x88BD8 - 0x0028)
class USaveObject final : public USaveGame
{
public:
	uint8                                         Pad_1A8C[0x88BB0];                                 // 0x0028(0x88BB0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveObject">();
	}
	static class USaveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveObject>();
	}
};
static_assert(alignof(USaveObject) == 0x000008, "Wrong alignment on USaveObject");
static_assert(sizeof(USaveObject) == 0x088BD8, "Wrong size on USaveObject");

// Class Project.ScriptMessageAsset
// 0x0010 (0x0038 - 0x0028)
class UScriptMessageAsset final : public UObject
{
public:
	TArray<struct FScriptMessage>                 Messages;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	int32 GetMessageIdByLabel(const class FName& InMessageLabel);
	void SetCharaNameByID(int32 CharaNameIndex, int32 MessageID);
	void SetCharaNameByLabel(int32 CharaNameIndex, const class FName& MessageLabel);

	class FText GetTextByLabel(const class FName& MessageLabel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptMessageAsset">();
	}
	static class UScriptMessageAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptMessageAsset>();
	}
};
static_assert(alignof(UScriptMessageAsset) == 0x000008, "Wrong alignment on UScriptMessageAsset");
static_assert(sizeof(UScriptMessageAsset) == 0x000038, "Wrong size on UScriptMessageAsset");
static_assert(offsetof(UScriptMessageAsset, Messages) == 0x000028, "Member 'UScriptMessageAsset::Messages' has a wrong offset!");

// Class Project.SystemSaveObject
// 0x1C28 (0x1C50 - 0x0028)
class USystemSaveObject final : public USaveGame
{
public:
	uint8                                         Pad_1A8D[0x1C28];                                  // 0x0028(0x1C28)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemSaveObject">();
	}
	static class USystemSaveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USystemSaveObject>();
	}
};
static_assert(alignof(USystemSaveObject) == 0x000008, "Wrong alignment on USystemSaveObject");
static_assert(sizeof(USystemSaveObject) == 0x001C50, "Wrong size on USystemSaveObject");

// Class Project.SystemLocalSaveObject
// 0x1558 (0x1580 - 0x0028)
class USystemLocalSaveObject final : public USaveGame
{
public:
	uint8                                         Pad_1A8E[0x1558];                                  // 0x0028(0x1558)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemLocalSaveObject">();
	}
	static class USystemLocalSaveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USystemLocalSaveObject>();
	}
};
static_assert(alignof(USystemLocalSaveObject) == 0x000008, "Wrong alignment on USystemLocalSaveObject");
static_assert(sizeof(USystemLocalSaveObject) == 0x001580, "Wrong size on USystemLocalSaveObject");

// Class Project.ResultTopDataObj
// 0x0050 (0x0078 - 0x0028)
class UResultTopDataObj final : public UObject
{
public:
	int32                                         M_AnimTime;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MoneyRatex10;                                    // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ExpRatex10;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_Money;                                           // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FResultTopItem>                 M_Items;                                           // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FResultTopCharaData>            M_PartyExp;                                        // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FResultTopCharaData>            M_StockExp;                                        // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8F[0x10];                                    // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetInterval_LvUp();
	static int32 GetInterval_Top2ExpMove();
	static int32 GetInterval_Zero2Max();

	void CheckLvUpHelpTiming(const int32& Param_Index, const float& PastDeltaSeconds, bool* AllEnd, bool* EnablePop, int32* DevilID);
	bool EnablePageChange();
	float PageScrollBarRate(int32 Param_Index);
	int32 PageScrollLastIndex();
	void UpdateExpBarState(const int32& Param_Index, const float& PastTime, bool* IsEnd, bool* LvUp, int32* barRate, int32* Lv);

	bool ExistLvUpChara() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResultTopDataObj">();
	}
	static class UResultTopDataObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResultTopDataObj>();
	}
};
static_assert(alignof(UResultTopDataObj) == 0x000008, "Wrong alignment on UResultTopDataObj");
static_assert(sizeof(UResultTopDataObj) == 0x000078, "Wrong size on UResultTopDataObj");
static_assert(offsetof(UResultTopDataObj, M_AnimTime) == 0x000028, "Member 'UResultTopDataObj::M_AnimTime' has a wrong offset!");
static_assert(offsetof(UResultTopDataObj, M_MoneyRatex10) == 0x00002C, "Member 'UResultTopDataObj::M_MoneyRatex10' has a wrong offset!");
static_assert(offsetof(UResultTopDataObj, M_ExpRatex10) == 0x000030, "Member 'UResultTopDataObj::M_ExpRatex10' has a wrong offset!");
static_assert(offsetof(UResultTopDataObj, M_Money) == 0x000034, "Member 'UResultTopDataObj::M_Money' has a wrong offset!");
static_assert(offsetof(UResultTopDataObj, M_Items) == 0x000038, "Member 'UResultTopDataObj::M_Items' has a wrong offset!");
static_assert(offsetof(UResultTopDataObj, M_PartyExp) == 0x000048, "Member 'UResultTopDataObj::M_PartyExp' has a wrong offset!");
static_assert(offsetof(UResultTopDataObj, M_StockExp) == 0x000058, "Member 'UResultTopDataObj::M_StockExp' has a wrong offset!");

// Class Project.BPL_Save
// 0x0000 (0x0028 - 0x0028)
class UBPL_Save final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Save">();
	}
	static class UBPL_Save* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Save>();
	}
};
static_assert(alignof(UBPL_Save) == 0x000008, "Wrong alignment on UBPL_Save");
static_assert(sizeof(UBPL_Save) == 0x000028, "Wrong size on UBPL_Save");

// Class Project.BPL_ShowMouseCursor
// 0x0000 (0x0028 - 0x0028)
class UBPL_ShowMouseCursor final : public UBlueprintFunctionLibrary
{
public:
	static void CallCloseDebugMenu_ShowMouseCursor();
	static void CallOpenDebugMenu_ShowMouseCursor();
	static void LogShowMouseCursorStack();
	static const struct FMouseCursorState PeekShowMouseCursor();
	static struct FMouseCursorState PopShowMouseCursor(const class FString& SceneName);
	static void PushShowMouseCursor(const class FString& SceneName, bool bShow);
	static void ResetMouseCursorBasePosition();
	static void SetForceShowMouseCursor(const class FString& SceneName, bool bForceShow);
	static void SetTopShowMouseCursor(const class FString& SceneName, bool bShow);
	static void UpdateShowMouseCursor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_ShowMouseCursor">();
	}
	static class UBPL_ShowMouseCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_ShowMouseCursor>();
	}
};
static_assert(alignof(UBPL_ShowMouseCursor) == 0x000008, "Wrong alignment on UBPL_ShowMouseCursor");
static_assert(sizeof(UBPL_ShowMouseCursor) == 0x000028, "Wrong size on UBPL_ShowMouseCursor");

// Class Project.MapObjectAssetUserData
// 0x0008 (0x0030 - 0x0028)
class UMapObjectAssetUserData final : public UAssetUserData
{
public:
	E_MAP_OBJ_BATTLE_TYPE                         M_DataType;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A95[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapObjectAssetUserData">();
	}
	static class UMapObjectAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapObjectAssetUserData>();
	}
};
static_assert(alignof(UMapObjectAssetUserData) == 0x000008, "Wrong alignment on UMapObjectAssetUserData");
static_assert(sizeof(UMapObjectAssetUserData) == 0x000030, "Wrong size on UMapObjectAssetUserData");
static_assert(offsetof(UMapObjectAssetUserData, M_DataType) == 0x000028, "Member 'UMapObjectAssetUserData::M_DataType' has a wrong offset!");

// Class Project.BPL_GameUtil
// 0x0000 (0x0028 - 0x0028)
class UBPL_GameUtil final : public UBlueprintFunctionLibrary
{
public:
	static void AI_PRINT(const class FString& Print);
	static void ApplyMaterialParameter(const TArray<class UMaterialInstanceDynamic*>& MIDs, class UMaterialParameterApplier* Param);
	static void ApplyMaterialParameterCollection(class UObject* WorldContext, class UMaterialParameterCollection* MPC, class UMaterialParameterApplier* Param);
	static void ASSERT(bool Value, const class FString& Print);
	static int32 BIT_ADD(int32 State, uint8 Value);
	static int32 BIT_ADD_INT(int32 State, int32 Value);
	static bool BIT_AND(int32 State, uint8 Value);
	static bool BIT_AND_INT(int32 State, int32 Value);
	static int32 BIT_DEL(int32 State, uint8 Value);
	static int32 BIT_DEL_INT(int32 State, int32 Value);
	static int32 BIT_SHIFT_L(uint8 Value);
	static bool CheckPersistentLevel(class AActor* ActorOnCheckLevel);
	static bool CopySoftClassRef(const TSoftClassPtr<class UClass>& Source, TSoftClassPtr<class UClass>& Target);
	static bool CopySoftObjRef(const TSoftObjectPtr<class UObject>& Source, TSoftObjectPtr<class UObject>& Target);
	static float GetChunkProgress(int32 ChunkId);
	static class FString GetNickName();
	static bool IS_EDITOR_BUILD();
	static bool IS_PREVIEW_WORLD(class UObject* WorldContextObject);
	static bool IS_SHIPPING_BUILD();
	static bool IS_TEST_BUILD();
	static bool IsChunkInstallComplete();
	static bool IsChunkInstalled(int32 ChunkId);
	static bool IsExistAssetUserData(class UObject* TargetObject, TSubclassOf<class UAssetUserData> AssetUserDataClass);
	static bool IsMapObjectAsset(class UObject* TargetObject);
	static bool IsValidSoftClassRef(const TSoftClassPtr<class UClass>& SoftClassReference);
	static bool IsValidSoftObjRef(const TSoftObjectPtr<class UObject>& SoftObjReference);
	static int32 LIMIT_ADD(int32 _src, int32 _v, int32 _max);
	static int32 LIMIT_VALUE(int32 Value, int32 Max);
	static int32 LIMIT_VALUE2(int32 Value, int32 Min, int32 Max);
	static float LIMIT_VALUE2_F(float Value, float Min, float Max);
	static float LIMIT_VALUE_F(float Value, float Max);
	static void LOG_PRINT(const class FString& Print);
	static TArray<class FString> RetrieveNotifyNames(class UAnimSequenceBase* Anim);
	static TArray<float> RetrieveNotifyTiming(class UAnimSequenceBase* Anim);
	static void SetAnimNotifyQueueSeed(class UAnimInstance* AnimInstance, class FName Seed);
	static bool SetSoftClassRef(const class FString& Source, TSoftClassPtr<class UClass>& Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_GameUtil">();
	}
	static class UBPL_GameUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_GameUtil>();
	}
};
static_assert(alignof(UBPL_GameUtil) == 0x000008, "Wrong alignment on UBPL_GameUtil");
static_assert(sizeof(UBPL_GameUtil) == 0x000028, "Wrong size on UBPL_GameUtil");

// Class Project.ProjectPlatformMiscFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UProjectPlatformMiscFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CurrentPlatformIsSwitch();
	static bool CurrentPlatformIsWindows();
	static int32 GetCurrentMonitorIndex();
	static struct FIntPoint GetCurrentResolution();
	static struct FProjectWindowState GetCurrentWindowState();
	static class FString GetGameVersionString();
	static struct FIntPoint GetLowSpecDefaultResolusion();
	static int32 GetMainMonitorIndex();
	static int32 GetMaxFPS();
	static const TArray<int32> GetMaxFpsList();
	static struct FIntPoint GetMonitorNativeResolution(int32 MonitorIndex);
	static struct FIntPoint GetMonitorResolution(int32 MonitorIndex);
	static void GetMonitorSupportedResolutions(int32 MonitorIndex, TArray<struct FIntPoint>* OutResolutions);
	static int32 GetNumMonitors();
	static bool GetVSyncEnabled();
	static EWindowsWindowMode GetWindowMode();
	static bool IsBootOnLowSpecPC();
	static bool IsSupportedFullscreen(int32 MonitorIndex);
	static bool IsWorkInProgress();
	static void RestoreWindowState(const struct FProjectWindowState& InState);
	static void RunBenchmark();
	static void SetMaxFps(int32 NewMaxFPS);
	static void SetPresenceForLocalPlayer(const class FString& StatusStr);
	static void SetVSyncEnable(bool bEnable);
	static void SetWindowSettings(int32 MonitorIndex, EWindowsWindowMode InMode, const struct FIntPoint& InResolution);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectPlatformMiscFunctionLibrary">();
	}
	static class UProjectPlatformMiscFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectPlatformMiscFunctionLibrary>();
	}
};
static_assert(alignof(UProjectPlatformMiscFunctionLibrary) == 0x000008, "Wrong alignment on UProjectPlatformMiscFunctionLibrary");
static_assert(sizeof(UProjectPlatformMiscFunctionLibrary) == 0x000028, "Wrong size on UProjectPlatformMiscFunctionLibrary");

// Class Project.GardenActorSpawner
// 0x0018 (0x0238 - 0x0220)
class AGardenActorSpawner final : public AActor
{
public:
	E_GARDEN_SPAWN_SIZE                           M_Size;                                            // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_SPAWN_ANIMATION                      M_Animation;                                       // 0x0221(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_GARDEN_SPAWN_AREA                           M_Area;                                            // 0x0222(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsPrerequisiteArea;                              // 0x0223(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_SkirtNGSpot;                                     // 0x0224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsSitArea;                                       // 0x0225(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA9[0x2];                                     // 0x0226(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_NGDevilIDList;                                   // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	bool CheckIfLevelToGround(const class UObject* WorldContextObject, class UStaticMeshComponent*& ActorStaticMesh, class UMaterialInterface* GoodMaterial, class UMaterialInterface* BadMaterial, TArray<class UCapsuleComponent*>& GroundedCheckCollisions, bool CheckOverlap, class UCapsuleComponent*& OverlapCheckCollision, ETraceTypeQuery TraceChannel);
	void SnapToGround(const class UObject* WorldContextObject, class UCapsuleComponent*& ActorCapsuleCollision, class USceneComponent*& ActorSpawnLocation, class UStaticMeshComponent*& ActorStaticMesh, class UMaterialInterface* GoodMaterial, class UMaterialInterface* BadMaterial, TArray<class UCapsuleComponent*>& GroundedCheckCollisions, bool CheckOverlap, ETraceTypeQuery TraceChannel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenActorSpawner">();
	}
	static class AGardenActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGardenActorSpawner>();
	}
};
static_assert(alignof(AGardenActorSpawner) == 0x000008, "Wrong alignment on AGardenActorSpawner");
static_assert(sizeof(AGardenActorSpawner) == 0x000238, "Wrong size on AGardenActorSpawner");
static_assert(offsetof(AGardenActorSpawner, M_Size) == 0x000220, "Member 'AGardenActorSpawner::M_Size' has a wrong offset!");
static_assert(offsetof(AGardenActorSpawner, M_Animation) == 0x000221, "Member 'AGardenActorSpawner::M_Animation' has a wrong offset!");
static_assert(offsetof(AGardenActorSpawner, M_Area) == 0x000222, "Member 'AGardenActorSpawner::M_Area' has a wrong offset!");
static_assert(offsetof(AGardenActorSpawner, M_IsPrerequisiteArea) == 0x000223, "Member 'AGardenActorSpawner::M_IsPrerequisiteArea' has a wrong offset!");
static_assert(offsetof(AGardenActorSpawner, M_SkirtNGSpot) == 0x000224, "Member 'AGardenActorSpawner::M_SkirtNGSpot' has a wrong offset!");
static_assert(offsetof(AGardenActorSpawner, M_IsSitArea) == 0x000225, "Member 'AGardenActorSpawner::M_IsSitArea' has a wrong offset!");
static_assert(offsetof(AGardenActorSpawner, M_NGDevilIDList) == 0x000228, "Member 'AGardenActorSpawner::M_NGDevilIDList' has a wrong offset!");

// Class Project.GardenBGMAssetMap
// 0x00A0 (0x00C8 - 0x0028)
class UGardenBGMAssetMap final : public UObject
{
public:
	TMap<E_RYUKETSU_GARDEN_TYPE, TSoftObjectPtr<class USoundAtomCue>> GardenBGMMap_Aogami;                               // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<E_RYUKETSU_GARDEN_TYPE, TSoftObjectPtr<class USoundAtomCue>> GardenBGMMap_Tsukuyomi;                            // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenBGMAssetMap">();
	}
	static class UGardenBGMAssetMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenBGMAssetMap>();
	}
};
static_assert(alignof(UGardenBGMAssetMap) == 0x000008, "Wrong alignment on UGardenBGMAssetMap");
static_assert(sizeof(UGardenBGMAssetMap) == 0x0000C8, "Wrong size on UGardenBGMAssetMap");
static_assert(offsetof(UGardenBGMAssetMap, GardenBGMMap_Aogami) == 0x000028, "Member 'UGardenBGMAssetMap::GardenBGMMap_Aogami' has a wrong offset!");
static_assert(offsetof(UGardenBGMAssetMap, GardenBGMMap_Tsukuyomi) == 0x000078, "Member 'UGardenBGMAssetMap::GardenBGMMap_Tsukuyomi' has a wrong offset!");

// Class Project.GardenBenchGodrayMap
// 0x0050 (0x0078 - 0x0028)
class UGardenBenchGodrayMap final : public UObject
{
public:
	TMap<E_RYUKETSU_GARDEN_TYPE, struct FGardenBenchGodray> GardenBenchGodrayMap;                              // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenBenchGodrayMap">();
	}
	static class UGardenBenchGodrayMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenBenchGodrayMap>();
	}
};
static_assert(alignof(UGardenBenchGodrayMap) == 0x000008, "Wrong alignment on UGardenBenchGodrayMap");
static_assert(sizeof(UGardenBenchGodrayMap) == 0x000078, "Wrong size on UGardenBenchGodrayMap");
static_assert(offsetof(UGardenBenchGodrayMap, GardenBenchGodrayMap) == 0x000028, "Member 'UGardenBenchGodrayMap::GardenBenchGodrayMap' has a wrong offset!");

// Class Project.GardenBenchEffectMap
// 0x0050 (0x0078 - 0x0028)
class UGardenBenchEffectMap final : public UObject
{
public:
	TMap<E_GARDENPLAYER_FADETYPE, struct FGardenBenchEffect> GardenBenchEffectMap;                              // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenBenchEffectMap">();
	}
	static class UGardenBenchEffectMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenBenchEffectMap>();
	}
};
static_assert(alignof(UGardenBenchEffectMap) == 0x000008, "Wrong alignment on UGardenBenchEffectMap");
static_assert(sizeof(UGardenBenchEffectMap) == 0x000078, "Wrong size on UGardenBenchEffectMap");
static_assert(offsetof(UGardenBenchEffectMap, GardenBenchEffectMap) == 0x000028, "Member 'UGardenBenchEffectMap::GardenBenchEffectMap' has a wrong offset!");

// Class Project.BPL_ScreenShot
// 0x0000 (0x0028 - 0x0028)
class UBPL_ScreenShot final : public UBlueprintFunctionLibrary
{
public:
	static void DisableScreenShot();
	static void EnableScreenShot();
	static void SwitchScreenShotEnable(bool Sw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_ScreenShot">();
	}
	static class UBPL_ScreenShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_ScreenShot>();
	}
};
static_assert(alignof(UBPL_ScreenShot) == 0x000008, "Wrong alignment on UBPL_ScreenShot");
static_assert(sizeof(UBPL_ScreenShot) == 0x000028, "Wrong size on UBPL_ScreenShot");

// Class Project.GardenDevil
// 0x0058 (0x0278 - 0x0220)
class AGardenDevil final : public AActor
{
public:
	int32                                         M_DevilID;                                         // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IsInitialiationDone;                             // 0x0224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AAD[0x3];                                     // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGardenTalkCameraParam                 ParamFinal;                                        // 0x0228(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenTalkCameraParam                 Params;                                            // 0x0238(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenTalkCameraParam                 ParamM;                                            // 0x0248(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenTalkCameraParam                 ParamL;                                            // 0x0258(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenTalkCameraParam                 ParamLL;                                           // 0x0268(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	void CalcGardenCameraParam(float TargetHeight);
	void Despawn();
	struct FGardenRespawnChatInfo GetUsedChatMsg();
	void SpawnDevil();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenDevil">();
	}
	static class AGardenDevil* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGardenDevil>();
	}
};
static_assert(alignof(AGardenDevil) == 0x000008, "Wrong alignment on AGardenDevil");
static_assert(sizeof(AGardenDevil) == 0x000278, "Wrong size on AGardenDevil");
static_assert(offsetof(AGardenDevil, M_DevilID) == 0x000220, "Member 'AGardenDevil::M_DevilID' has a wrong offset!");
static_assert(offsetof(AGardenDevil, M_IsInitialiationDone) == 0x000224, "Member 'AGardenDevil::M_IsInitialiationDone' has a wrong offset!");
static_assert(offsetof(AGardenDevil, ParamFinal) == 0x000228, "Member 'AGardenDevil::ParamFinal' has a wrong offset!");
static_assert(offsetof(AGardenDevil, Params) == 0x000238, "Member 'AGardenDevil::Params' has a wrong offset!");
static_assert(offsetof(AGardenDevil, ParamM) == 0x000248, "Member 'AGardenDevil::ParamM' has a wrong offset!");
static_assert(offsetof(AGardenDevil, ParamL) == 0x000258, "Member 'AGardenDevil::ParamL' has a wrong offset!");
static_assert(offsetof(AGardenDevil, ParamLL) == 0x000268, "Member 'AGardenDevil::ParamLL' has a wrong offset!");

// Class Project.GardenFreeCameraPawn
// 0x0008 (0x02B0 - 0x02A8)
class AGardenFreeCameraPawn final : public ASpectatorPawn
{
public:
	class UCapsuleComponent*                      FreeCamCollisionComponent;                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenFreeCameraPawn">();
	}
	static class AGardenFreeCameraPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGardenFreeCameraPawn>();
	}
};
static_assert(alignof(AGardenFreeCameraPawn) == 0x000008, "Wrong alignment on AGardenFreeCameraPawn");
static_assert(sizeof(AGardenFreeCameraPawn) == 0x0002B0, "Wrong size on AGardenFreeCameraPawn");
static_assert(offsetof(AGardenFreeCameraPawn, FreeCamCollisionComponent) == 0x0002A8, "Member 'AGardenFreeCameraPawn::FreeCamCollisionComponent' has a wrong offset!");

// Class Project.BPL_RelicData
// 0x0000 (0x0028 - 0x0028)
class UBPL_RelicData final : public UBlueprintFunctionLibrary
{
public:
	static const struct FRelicData GetRelicData(int32 MapId, int32 Param_Index);
	static const struct FRelicData GetRelicData_FromTableIndex(int32 TableIndex);
	static const struct FRelicSaveBuffer GetRelicSaveBufferData(int32 TableID);
	static int32 GetRelicSaveBufferDataMax();
	static int32 GetRelicSaveBufferNum(int32 MapId, int32 AreaId);
	static int32 GetRelicSaveBufferStart(int32 MapId, int32 AreaId);
	static int32 GetRelicTableIndex(int32 MapId, int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_RelicData">();
	}
	static class UBPL_RelicData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_RelicData>();
	}
};
static_assert(alignof(UBPL_RelicData) == 0x000008, "Wrong alignment on UBPL_RelicData");
static_assert(sizeof(UBPL_RelicData) == 0x000028, "Wrong size on UBPL_RelicData");

// Class Project.GardenFreeCameraController
// 0x0068 (0x0720 - 0x06B8)
class alignas(0x10) AGardenFreeCameraController final : public ACustomPlayerController
{
public:
	class APlayerController*                      OriginalControllerRef;                             // 0x06B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayer*                                OriginalPlayer;                                    // 0x06C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpectatorPawn*                         GardenFreeCameraPawnRef;                           // 0x06C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AAF[0x50];                                    // 0x06D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DestroyFreeCameraActors();
	bool InitFreeCamera();
	void MoveForward(float Val);
	void MoveRight(float Val);
	void MoveUp(float Val);
	void SetFreeCameraMovementSpeed(float MovementSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenFreeCameraController">();
	}
	static class AGardenFreeCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGardenFreeCameraController>();
	}
};
static_assert(alignof(AGardenFreeCameraController) == 0x000010, "Wrong alignment on AGardenFreeCameraController");
static_assert(sizeof(AGardenFreeCameraController) == 0x000720, "Wrong size on AGardenFreeCameraController");
static_assert(offsetof(AGardenFreeCameraController, OriginalControllerRef) == 0x0006B8, "Member 'AGardenFreeCameraController::OriginalControllerRef' has a wrong offset!");
static_assert(offsetof(AGardenFreeCameraController, OriginalPlayer) == 0x0006C0, "Member 'AGardenFreeCameraController::OriginalPlayer' has a wrong offset!");
static_assert(offsetof(AGardenFreeCameraController, GardenFreeCameraPawnRef) == 0x0006C8, "Member 'AGardenFreeCameraController::GardenFreeCameraPawnRef' has a wrong offset!");

// Class Project.GardenFreeCameraManager
// 0x0020 (0x00D0 - 0x00B0)
class UGardenFreeCameraManager final : public UActorComponent
{
public:
	bool                                          M_ShowFreeCamUI;                                   // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AB0[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGardenFreeCameraController*            GardenFreeCameraControllerRef;                     // 0x00B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGardenFreeCameraController> GardenFreeCameraControllerClass;                   // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_GARDEN_FREE_CAMERA_STATE                    M_FreeCameraState;                                 // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AB1[0x7];                                     // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableFreeCamera();
	bool DisableGardenFreeCamera();
	void EnableFreeCamera();
	bool EnableGardenFreeCamera(const struct FVector& Location, const struct FRotator& Rotation, const float CameraTurnSpeed, const float MovementSpeed, const float MovementAcceleration, const float CollisionRadius, const class FName CollisionProfile, const float MinUpViewAngle, const float MaxUpViewAngle);
	void Initialize(const struct FTransform& SafeSpawnTransform);
	void RequestEndFreeCamera();
	void RequestStartFreeCamera();
	void ToggleFreeCameraUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenFreeCameraManager">();
	}
	static class UGardenFreeCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenFreeCameraManager>();
	}
};
static_assert(alignof(UGardenFreeCameraManager) == 0x000008, "Wrong alignment on UGardenFreeCameraManager");
static_assert(sizeof(UGardenFreeCameraManager) == 0x0000D0, "Wrong size on UGardenFreeCameraManager");
static_assert(offsetof(UGardenFreeCameraManager, M_ShowFreeCamUI) == 0x0000B0, "Member 'UGardenFreeCameraManager::M_ShowFreeCamUI' has a wrong offset!");
static_assert(offsetof(UGardenFreeCameraManager, GardenFreeCameraControllerRef) == 0x0000B8, "Member 'UGardenFreeCameraManager::GardenFreeCameraControllerRef' has a wrong offset!");
static_assert(offsetof(UGardenFreeCameraManager, GardenFreeCameraControllerClass) == 0x0000C0, "Member 'UGardenFreeCameraManager::GardenFreeCameraControllerClass' has a wrong offset!");
static_assert(offsetof(UGardenFreeCameraManager, M_FreeCameraState) == 0x0000C8, "Member 'UGardenFreeCameraManager::M_FreeCameraState' has a wrong offset!");

// Class Project.ParticleModuleS3N2SubMesh
// 0x0048 (0x0088 - 0x0040)
class UParticleModuleS3N2SubMesh final : public UParticleModuleMeshMaterial
{
public:
	int64                                         FirstOwnerAddr;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mesh;                                              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRate;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameSec;                                          // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpendSec;                                          // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartIndex;                                        // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentSubMeshIndex;                               // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoop : 1;                                         // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCreatedMID : 1;                                   // 0x0064(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHalt : 1;                                         // 0x0064(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1AB3[0x3];                                     // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideMaterialName;                              // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 TargetMaterials;                                   // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleS3N2SubMesh">();
	}
	static class UParticleModuleS3N2SubMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleS3N2SubMesh>();
	}
};
static_assert(alignof(UParticleModuleS3N2SubMesh) == 0x000008, "Wrong alignment on UParticleModuleS3N2SubMesh");
static_assert(sizeof(UParticleModuleS3N2SubMesh) == 0x000088, "Wrong size on UParticleModuleS3N2SubMesh");
static_assert(offsetof(UParticleModuleS3N2SubMesh, FirstOwnerAddr) == 0x000040, "Member 'UParticleModuleS3N2SubMesh::FirstOwnerAddr' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2SubMesh, Mesh) == 0x000048, "Member 'UParticleModuleS3N2SubMesh::Mesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2SubMesh, FrameRate) == 0x000050, "Member 'UParticleModuleS3N2SubMesh::FrameRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2SubMesh, FrameSec) == 0x000054, "Member 'UParticleModuleS3N2SubMesh::FrameSec' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2SubMesh, SpendSec) == 0x000058, "Member 'UParticleModuleS3N2SubMesh::SpendSec' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2SubMesh, StartIndex) == 0x00005C, "Member 'UParticleModuleS3N2SubMesh::StartIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2SubMesh, CurrentSubMeshIndex) == 0x000060, "Member 'UParticleModuleS3N2SubMesh::CurrentSubMeshIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2SubMesh, OverrideMaterial) == 0x000068, "Member 'UParticleModuleS3N2SubMesh::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2SubMesh, OverrideMaterialName) == 0x000070, "Member 'UParticleModuleS3N2SubMesh::OverrideMaterialName' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2SubMesh, TargetMaterials) == 0x000078, "Member 'UParticleModuleS3N2SubMesh::TargetMaterials' has a wrong offset!");

// Class Project.GardenManager
// 0x0280 (0x04A0 - 0x0220)
class AGardenManager final : public AActor
{
public:
	TMap<int32, struct FGardenDevilSpawnInfo>     M_DevilSpawnLocations;                             // 0x0220(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<int32, E_GARDEN_FC_DEVIL_COL_TYPE>       M_GardenFCCollisionAdjustMap;                      // 0x0270(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          M_NeedRespawn;                                     // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AB4[0x7];                                     // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FGardenRespawnChatInfo>    M_RespawnChatMessages;                             // 0x02C8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AB5[0x188];                                   // 0x0318(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AGardenManager* GetGardenManager(const class UObject* WorldContextObject);
	static void SetGardenManager(const class UObject* WorldContextObject, class AGardenManager* NewGardenManager);

	E_MINIMAP_POI_ICON CheckGardenDevilIcon(int32 NkmIndex);
	const bool CheckGardenQuest(int32 DevilID, struct FGardenQuestInfo* GardenQuestInfo);
	void CheckGardenReady();
	bool CheckManagerInitializationDone();
	const bool CheckWaterDevil(int32 DevilID);
	void DestroyManager();
	struct FGardenDevilInfo FindDevilType(int32 GardenDevilID);
	void GardenQuestDespawn(int32 DevilID, const TArray<class AGardenDevil*>& GardenDevilArray);
	void GardenQuestRespawn();
	class AActor* GetActorOfClassFromLevel(const class ULevelStreaming* Levelstr, TSubclassOf<class AActor> ActorClass);
	const class FName GetGardenSystemMessageLabel(E_GARDEN_SYS_TEXT SystemID);
	const struct FGardenTypeData GetGardenTypeData(E_RYUKETSU_GARDEN_TYPE GardenType);
	const struct FGardenPhaseData GetPhaseData(uint8 PhaseValue);
	const int32 GetPhaseTableNum();
	const int32 GetPlayerTalkPlayOnceTalkNum();
	const int32 GetPlayerTalkPowerUpTalkNum();
	const int32 GetPlayerTalkRepeatableTalkNum();
	const struct FGardenSpeechTypeMsgData GetSpeechTypeMsgData(E_TALK_TONE_TYPE SpeechType);
	const struct FGardenUniqueDevilMsgData GetUniqueDevilMsgData(int32 DevilID);
	void Initialize();
	void InitializeManager(class FName FreeCameraDisableLevel);
	void ResetRespawnFlags();
	void SetGardenChatMessageFlag(E_TALK_TONE_TYPE SpeechType, E_GARDEN_MSG_USE_TYPE ChatMsgType, int32 DevilID, int32 ChatMsgIndex);
	void SetGardenDevilIcon(const class UObject* WorldContextObject, int32 NkmIndex, E_TALK_TONE_TYPE SpeechType, E_GARDEN_MSG_USE_TYPE ChatMsgType, int32 ChatMsgIndex);
	void SpawnDevilsDelayed();
	class AGardenDevil* SpawnGardenDevil(const struct FGardenDevilSpawnInfo& GardenDevilSpawnInfo, int32 DevilID);
	void SpawnGardenDevils(const float MinimumDistance, const float DesiredDistance);
	void SpawnTutorialGardenDevils(const float MinimumDistance, const float DesiredDistance, const struct FGardenTutorialSpotSettings& SmallGardenTutorialSpotSettings, const struct FGardenTutorialSpotSettings& BigGardenTutorialSpotSettings, TArray<E_GARDEN_SPAWN_SIZE>* UsedCameraSpots);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenManager">();
	}
	static class AGardenManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGardenManager>();
	}
};
static_assert(alignof(AGardenManager) == 0x000008, "Wrong alignment on AGardenManager");
static_assert(sizeof(AGardenManager) == 0x0004A0, "Wrong size on AGardenManager");
static_assert(offsetof(AGardenManager, M_DevilSpawnLocations) == 0x000220, "Member 'AGardenManager::M_DevilSpawnLocations' has a wrong offset!");
static_assert(offsetof(AGardenManager, M_GardenFCCollisionAdjustMap) == 0x000270, "Member 'AGardenManager::M_GardenFCCollisionAdjustMap' has a wrong offset!");
static_assert(offsetof(AGardenManager, M_NeedRespawn) == 0x0002C0, "Member 'AGardenManager::M_NeedRespawn' has a wrong offset!");
static_assert(offsetof(AGardenManager, M_RespawnChatMessages) == 0x0002C8, "Member 'AGardenManager::M_RespawnChatMessages' has a wrong offset!");

// Class Project.GardenPlayerTalk
// 0x0128 (0x01D8 - 0x00B0)
class UGardenPlayerTalk final : public UActorComponent
{
public:
	TMap<int32, struct FGardenPlayerTalkData>     RepeatableTalkList;                                // 0x00B0(0x0050)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	TMap<int32, struct FGardenPlayerTalkData>     PlayOnceTalkList;                                  // 0x0100(0x0050)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	TMap<int32, struct FGardenPlayerTalkData>     PowerUpTalkList;                                   // 0x0150(0x0050)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	int32                                         ChosenRepeatableTalkIndex;                         // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC6[0x34];                                    // 0x01A4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildPlayerTalkData(class UObject* WorldContextObject, E_RYUKETSU_GARDEN_TYPE GardenType);
	int32 EvaluatePlayerPowerUpAmount(class UObject* WorldContextObject);
	bool HasPlayOnceTalkQueued();
	bool HasPowerUpTalkQueued();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenPlayerTalk">();
	}
	static class UGardenPlayerTalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenPlayerTalk>();
	}
};
static_assert(alignof(UGardenPlayerTalk) == 0x000008, "Wrong alignment on UGardenPlayerTalk");
static_assert(sizeof(UGardenPlayerTalk) == 0x0001D8, "Wrong size on UGardenPlayerTalk");
static_assert(offsetof(UGardenPlayerTalk, RepeatableTalkList) == 0x0000B0, "Member 'UGardenPlayerTalk::RepeatableTalkList' has a wrong offset!");
static_assert(offsetof(UGardenPlayerTalk, PlayOnceTalkList) == 0x000100, "Member 'UGardenPlayerTalk::PlayOnceTalkList' has a wrong offset!");
static_assert(offsetof(UGardenPlayerTalk, PowerUpTalkList) == 0x000150, "Member 'UGardenPlayerTalk::PowerUpTalkList' has a wrong offset!");
static_assert(offsetof(UGardenPlayerTalk, ChosenRepeatableTalkIndex) == 0x0001A0, "Member 'UGardenPlayerTalk::ChosenRepeatableTalkIndex' has a wrong offset!");

// Class Project.BPL_SkillData
// 0x0000 (0x0028 - 0x0028)
class UBPL_SkillData final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetMagatsuhiSkillIdByGroupId(int32 InGroupId, int32 InIndex);
	static int32 GetMagatsuhiSkillIdByPlayer(int32 InIndex);
	static const struct FMultiDevilMagatsuhiSkillData GetMultiDevilMagatsuhiSkillData(const int32 SkillId);
	static const int32 GetMultiDevilMagatsuhiSkillNkmNum(const int32 SkillId);
	static const struct FSkillAutoErupt GetSkillAutoEruptData(int32 ID);
	static int32 GetSkillAutoEruptExtraEffectValue(const struct FSkillAutoErupt& PData, E_AUTO_SKILL_EXTRA_EFFECT Type);
	static const struct FSkillBaseData GetSkillBaseData(int32 ID);
	static const class FText GetSkillEffectName(int32 ID);
	static int32 GetSkillExtraEffectValue(E_SKILL_EXTRA_EFFECT Type);
	static const class FText GetSkillHelp(int32 ID);
	static int32 GetSkillIconIdBySkillId(int32 InSkillId);
	static int32 GetSkillIconPriority(int32 InSkillId);
	static int32 GetSkillIdMax();
	static const struct FSkillInfoMess GetSkillInfoMessData(int32 ID);
	static const class FText GetSkillInfoMessText(int32 MessageID, bool IsMaster);
	static const class FText GetSkillName(int32 ID);
	static E_SKILL_TEKISEI_CATEGORY GetSkillTekiseiCategory(int32 SkillId);
	static E_SKILL_UNIQUE_TYPE GetSkillUniqueType(int32 ID);
	static int32 GetSkillUniqueValue(int32 ID);
	static int32 GetUtsusemiSortSkillIdPriority(int32 InSkillId);
	static bool IsItPossibletoDisplayToCost(int32 InSkillId);
	static bool IsMagatsuhiSkill(int32 InSkillId);
	static bool IsSkillAutoEruptUnique(int32 ID);
	static void SkillAutoEruptGetExtraEffects(const struct FSkillAutoErupt& PData, TArray<E_AUTO_SKILL_EXTRA_EFFECT>* List);
	static E_ATTRIBUTE_TYPE SkillAutoEruptGetValue_Attr(const struct FSkillAutoErupt& PData);
	static uint8 SkillAutoEruptGetValue_BstRate(const struct FSkillAutoErupt& PData);
	static uint8 SkillAutoEruptGetValue_ClenchingType(const struct FSkillAutoErupt& PData);
	static E_AUTO_SKILL_EFT_TYPE SkillAutoEruptGetValue_EruptType(const struct FSkillAutoErupt& PData);
	static uint8 SkillAutoEruptGetValue_Kantuu(const struct FSkillAutoErupt& PData);
	static bool SkillAutoEruptIsHaveExtraEffect(const struct FSkillAutoErupt& PData, E_AUTO_SKILL_EXTRA_EFFECT Value);
	static uint8 SkillBaseDataGetValue_AbsorbHpRate(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_AbsorbMpRate(const struct FSkillBaseData& PData);
	static E_SKILL_TARGET SkillBaseDataGetValue_Area(const struct FSkillBaseData& PData);
	static E_ATTRIBUTE_TYPE SkillBaseDataGetValue_AtkAttr(const struct FSkillBaseData& PData);
	static TArray<E_ATTRIBUTE_TYPE> SkillBaseDataGetValue_AtkAttrTArray(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_AtkNum(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_AtkNumMax(const struct FSkillBaseData& PData);
	static float SkillBaseDataGetValue_AtkVal(const struct FSkillBaseData& PData);
	static int32 SkillBaseDataGetValue_Bst(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_BstRate(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_CriticalRate(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_DeadEffect(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_Icon(const struct FSkillBaseData& PData);
	static int32 SkillBaseDataGetValue_ID(const struct FSkillBaseData& PData);
	static bool SkillBaseDataGetValue_IsDummy(const struct FSkillBaseData& PData);
	static bool SkillBaseDataGetValue_IsEnableShowSkillName(const struct FSkillBaseData& PData);
	static bool SkillBaseDataGetValue_IsEnableSkip(const struct FSkillBaseData& PData);
	static bool SkillBaseDataGetValue_IsKantuu(const struct FSkillBaseData& PData);
	static bool SkillBaseDataGetValue_IsMagatsuhiSkill(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_Keishou(const struct FSkillBaseData& PData);
	static int32 SkillBaseDataGetValue_LibCost(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_LibEntry(const struct FSkillBaseData& PData);
	static E_SKILL_LIMITED SkillBaseDataGetValue_Limited(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_Maka(const struct FSkillBaseData& PData);
	static int32 SkillBaseDataGetValue_MasterCost(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_MP(const struct FSkillBaseData& PData);
	static int32 SkillBaseDataGetValue_NameSortID(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_Raku(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_Rank(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_Rate(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_RecBst(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_RecRate(const struct FSkillBaseData& PData);
	static E_SKILL_REC_TYPE SkillBaseDataGetValue_RecType(const struct FSkillBaseData& PData);
	static int32 SkillBaseDataGetValue_RecVal(const struct FSkillBaseData& PData);
	static int32 SkillBaseDataGetValue_SkillSource(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_Suku(const struct FSkillBaseData& PData);
	static uint8 SkillBaseDataGetValue_Taru(const struct FSkillBaseData& PData);
	static E_SKILL_TEKISEI_CATEGORY SkillBaseDataGetValue_TekiseiCategory(const struct FSkillBaseData& PData);
	static E_SKILL_TEKISEI_TYPE SkillBaseDataGetValue_TekiseiType(const struct FSkillBaseData& PData);
	static const TArray<uint8> SkillBaseDataGetValue_TekiseiTypeArray(const struct FSkillBaseData& PData);
	static E_SKILL_TYPE SkillBaseDataGetValue_Type(const struct FSkillBaseData& PData);
	static E_SKILL_ENABLE_SCENE SkillBaseDataGetValue_UseScene(const struct FSkillBaseData& PData);
	static bool SkillBaseDataIsAIDSkill(const struct FSkillBaseData& PData);
	static bool SkillBaseDataIsHaveExtraEffect(const struct FSkillBaseData& PData, E_SKILL_EXTRA_EFFECT Type);
	static bool SkillBaseDataIsRecome(const struct FSkillBaseData& PData);
	static bool SkillBaseDataIsRecoveryType(const struct FSkillBaseData& PData);
	static bool SkillBaseDataIsTargetAll(const struct FSkillBaseData& PData);
	static int32 SkillBstToNormalBst(uint8 SkillBst);
	static int32 SkillGetNKMWhisperVal(const struct FSkillBaseData& PData, int32 WhisperCount, E_SKILL_WHISPER_VAL_TYPE ValType);
	static int32 SkillGetWhisperVal(const struct FSkillBaseData& PData, int32 WhisperCount, E_SKILL_WHISPER_VAL_TYPE ValType);
	static E_SKILL_KIND SkillIDGetKind(int32 ID);
	static bool SkillIsMasicalAttack(int32 ID);
	static bool SkillIsPhysicalAttack(int32 ID);
	static bool SkillIsUseCamp(int32 InSkillId);
	static bool SkillMasterIsMasterOn(int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_SkillData">();
	}
	static class UBPL_SkillData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_SkillData>();
	}
};
static_assert(alignof(UBPL_SkillData) == 0x000008, "Wrong alignment on UBPL_SkillData");
static_assert(sizeof(UBPL_SkillData) == 0x000028, "Wrong size on UBPL_SkillData");

// Class Project.GardenTalk
// 0x0158 (0x0378 - 0x0220)
class AGardenTalk final : public AActor
{
public:
	int32                                         M_SpotType;                                        // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_DevilID;                                         // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_UsedChatIndex;                                   // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGardenChatMsgData                     M_ChosenChatMsgData;                               // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGardenMsgData                         M_TrustMsgData;                                    // 0x0230(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B14[0x5];                                     // 0x0233(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGardenMsgData>                 M_PowerUpMsgData;                                  // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B15[0x10];                                    // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGardenMsgData>                 M_ItemMsgData;                                     // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B16[0x10];                                    // 0x0268(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGardenTributeMsgData                  M_TributeMsgData;                                  // 0x0278(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B17[0x5];                                     // 0x027B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGardenChatMsgData>             M_ChatMsgData;                                     // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGardenSPTData                         M_GardenSPTData;                                   // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGardenMsgData>                 M_PowerUpDebugMsgData;                             // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGardenMsgData>                 M_ItemDebugMsgData;                                // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B18[0xC0];                                    // 0x02B8(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildGardenResultData(int32 NkmIndex, bool IsPowerUpMessage, struct FGardenResultData* GardenResultData);
	bool BuildMessageData(int32 DevilID, struct FGardenUniqueDevilMsgData& UNQData, struct FGardenSpeechTypeMsgData& SPTData);
	bool Debug_PickItemReward(int32 DevilLevel, int32 RepeatCount);
	void Initialize(class UObject* WorldContextObject);
	bool PickChatMessage(TArray<struct FGardenSPTData>& UsedGardenMessages, uint8& CurrentGardenArea, TArray<uint8>& ValidPhases);
	bool PickItemMessage(struct FGardenMsgData& ChosenItemMessage, int32& ChosenItemMessageIndex);
	bool PickItemReward(int32 DevilLevel, int32& ChosenItemID, int32& ChosenItemNum);
	void PickParameter(int32 NkmIndex, bool IsPowerUpMessage, E_ABILITY_TYPE* ChosenParameterType, class FText* ParameterName, int32* Amount, int32* OldParameterValue, int32* NewParameterValue);
	bool PickPowerUpMessage(struct FGardenMsgData& ChosenPowerMessage, int32& ChosenPowerMessageIndex);
	bool PickPowerUpReward(int32 NkmIndex);
	bool PickSkillTekisei(int32 NkmIndex, E_SKILL_TEKISEI_CATEGORY* ChosenSkillTekiseiType, class FText* SkillTekiseiName, int32* Amount, int32* OldSkillTekiseiValue, int32* NewSkillTekiseiValue);
	bool Respawn_SetChatMessage(TArray<struct FGardenSPTData>& UsedGardenMessages, uint8& CurrentGardenArea, TArray<uint8>& ValidPhases);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenTalk">();
	}
	static class AGardenTalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGardenTalk>();
	}
};
static_assert(alignof(AGardenTalk) == 0x000008, "Wrong alignment on AGardenTalk");
static_assert(sizeof(AGardenTalk) == 0x000378, "Wrong size on AGardenTalk");
static_assert(offsetof(AGardenTalk, M_SpotType) == 0x000220, "Member 'AGardenTalk::M_SpotType' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_DevilID) == 0x000224, "Member 'AGardenTalk::M_DevilID' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_UsedChatIndex) == 0x000228, "Member 'AGardenTalk::M_UsedChatIndex' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_ChosenChatMsgData) == 0x00022C, "Member 'AGardenTalk::M_ChosenChatMsgData' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_TrustMsgData) == 0x000230, "Member 'AGardenTalk::M_TrustMsgData' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_PowerUpMsgData) == 0x000238, "Member 'AGardenTalk::M_PowerUpMsgData' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_ItemMsgData) == 0x000258, "Member 'AGardenTalk::M_ItemMsgData' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_TributeMsgData) == 0x000278, "Member 'AGardenTalk::M_TributeMsgData' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_ChatMsgData) == 0x000280, "Member 'AGardenTalk::M_ChatMsgData' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_GardenSPTData) == 0x000290, "Member 'AGardenTalk::M_GardenSPTData' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_PowerUpDebugMsgData) == 0x000298, "Member 'AGardenTalk::M_PowerUpDebugMsgData' has a wrong offset!");
static_assert(offsetof(AGardenTalk, M_ItemDebugMsgData) == 0x0002A8, "Member 'AGardenTalk::M_ItemDebugMsgData' has a wrong offset!");

// Class Project.GardenTalkPointManager
// 0x0148 (0x0170 - 0x0028)
class UGardenTalkPointManager final : public UObject
{
public:
	uint8                                         Pad_1B2B[0x148];                                   // 0x0028(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGardenTalkPointManager* GetGardenTalkPointManager(const class UObject* WorldContextObject);

	int32 AddGardenTrophyCounter(E_GARDEN_TROPHY_COUNTER_TYPE GardenTrophyCounter);
	void AddPointMagatsukaDestroyGardenPoints();
	void AddPointMimanGardenPoints();
	void AddPointNewWaypointGardenPoints(int32 ExpectedDevilLevel);
	void AddPointQuestGardenPoints();
	void AddPointResultBattle();
	void AddPointStatueGardenPoints();
	void AddPointTributeGardenPoints(int32 DevilID, bool IsRare);
	void AddTempPointBattle(const struct FBtlGardenPointData& PBtlGardenPointData);
	void CheckAddPointNewMapGardenPoints(int32 MapReachFlag);
	bool CheckGardenPlayerTalkFlags(TArray<int32>* OutFlaggedPlayerTalkInfoFlagList);
	bool CheckGardenTalkFlag_All(TMap<int32, E_MINIMAP_POI_ICON>* OutFlaggedNkmIndexAndIconMap);
	bool CheckGardenTalkFlag_Any(E_MINIMAP_POI_ICON* DisplayIconType);
	bool CheckGardenTalkFlag_ByNkmIndex(int32 NkmIndex, E_MINIMAP_POI_ICON* DisplayIconType);
	bool CheckGardenTalkInfoFlag_All(TArray<int32>* OutFlaggedNkmIndexList);
	void CheckPowerUpMessageStep(int32 NkmIndex, uint8* MessageStep);
	void ClearTempPointBattle();
	bool Debug_GetGardenItemList(TArray<struct FTalkRequestItemTable>* OutGardenItemTable, TArray<struct FTalkRequestItemRankTable>* OutGardenItemRankTable);
	bool Debug_OutputDevilGardenSettings_ByNkmIndex(int32 NkmIndex, struct FGardenDevilData* OutGardenDevilData, int32* OutPartyTalkPoint);
	bool Debug_OutputPartyGardenSettings(int32* OutPartyTalkPoint);
	bool Debug_SetDevilGardenSettings_ByNkmIndex(int32 NkmIndex, const struct FGardenDevilData& InGardenDevilData);
	bool Debug_SetPartyGardenSettings(int32 InPartyTalkPoint);
	bool Debug_ToggleItemTalkFlag_ByNkmIndex(int32 NkmIndex, bool Enable);
	bool Debug_TogglePowerUpTalkFlag_ByNkmIndex(int32 NkmIndex, bool Enable);
	bool Debug_ToggleQuestTalkFlag_ByNkmIndex(int32 NkmIndex, bool Enable);
	bool Debug_ToggleTrustTalkFlag_ByNkmIndex(int32 NkmIndex, bool Enable);
	bool EnableQuestFlag_ByNkmIndex(int32 NkmIndex);
	bool FindMissionIDWithDevilID(int32 DevilID, int32* MissionId);
	int32 GetGardenTrophyCounter(E_GARDEN_TROPHY_COUNTER_TYPE GardenTrophyCounter);
	bool ResetGardenTalkFlag(int32 NkmIndex, E_GARDEN_TALK_TYPE FlagType);
	bool SetGardenTalkInfoFlag_Done(int32 NkmIndex);
	bool ShouldDisplayGardenPlayerTalkIcon(E_MINIMAP_POI_ICON* DisplayIconType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenTalkPointManager">();
	}
	static class UGardenTalkPointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenTalkPointManager>();
	}
};
static_assert(alignof(UGardenTalkPointManager) == 0x000008, "Wrong alignment on UGardenTalkPointManager");
static_assert(sizeof(UGardenTalkPointManager) == 0x000170, "Wrong size on UGardenTalkPointManager");

// Class Project.BPL_PCSave
// 0x0000 (0x0028 - 0x0028)
class UBPL_PCSave final : public UBlueprintFunctionLibrary
{
public:
	static bool PCSave_DeleteExecute(const class FString& Param_Name, int32 SlotNo);
	static void PCSave_Execute(const class FString& OverrideName, int32 SlotNo);
	static void PCSave_LoadExecute(const class FString& Param_Name, int32 SlotNo, bool* LoadedGameData);
	static void PCSave_OverwriteExecute(const class FString& Filename, int32 SlotNo);
	static TArray<class FString> PCSave_PickupFilePath();
	static void PCSave_ResaveAllInDirectory();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_PCSave">();
	}
	static class UBPL_PCSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_PCSave>();
	}
};
static_assert(alignof(UBPL_PCSave) == 0x000008, "Wrong alignment on UBPL_PCSave");
static_assert(sizeof(UBPL_PCSave) == 0x000028, "Wrong size on UBPL_PCSave");

// Class Project.GardenTutorialSettings
// 0x0220 (0x0440 - 0x0220)
class AGardenTutorialSettings final : public AActor
{
public:
	struct FGardenTutorialCameraSetting           InitialViewTutorialCameraSetting;                  // 0x0220(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenTutorialSpotSettings            SmallGardenTutorialSpotSettings;                   // 0x0260(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardenTutorialSpotSettings            BigGardenTutorialSpotSettings;                     // 0x0350(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenTutorialSettings">();
	}
	static class AGardenTutorialSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGardenTutorialSettings>();
	}
};
static_assert(alignof(AGardenTutorialSettings) == 0x000010, "Wrong alignment on AGardenTutorialSettings");
static_assert(sizeof(AGardenTutorialSettings) == 0x000440, "Wrong size on AGardenTutorialSettings");
static_assert(offsetof(AGardenTutorialSettings, InitialViewTutorialCameraSetting) == 0x000220, "Member 'AGardenTutorialSettings::InitialViewTutorialCameraSetting' has a wrong offset!");
static_assert(offsetof(AGardenTutorialSettings, SmallGardenTutorialSpotSettings) == 0x000260, "Member 'AGardenTutorialSettings::SmallGardenTutorialSpotSettings' has a wrong offset!");
static_assert(offsetof(AGardenTutorialSettings, BigGardenTutorialSpotSettings) == 0x000350, "Member 'AGardenTutorialSettings::BigGardenTutorialSpotSettings' has a wrong offset!");

// Class Project.GazeTargetHolder
// 0x0080 (0x00A8 - 0x0028)
class UGazeTargetHolder : public UObject
{
public:
	float                                         GazeMaxDistance;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GazeWeight_TargetType;                             // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GazeWeight_Distance;                               // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GazeWeight_CameraDirection;                        // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGazeTargetType, struct FGazeParameter>  GazeParams;                                        // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IGazeTarget>>   GazeTargets;                                       // 0x0088(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>                PriotiryGazeTargets;                               // 0x0098(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddPriorityGazeTarget(class USceneComponent* InTarget);
	bool FindGazeTargetFromPawn(class ACustomPawn* InPawn, struct FVector* OutLocation, float DistanceCoefficient);
	void RegisterGazeTarget(TScriptInterface<class IGazeTarget> InTarget);
	void RemovePriorityGazeTarget(class USceneComponent* InTarget);
	void UnregisterGazeTarget(TScriptInterface<class IGazeTarget> InTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GazeTargetHolder">();
	}
	static class UGazeTargetHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGazeTargetHolder>();
	}
};
static_assert(alignof(UGazeTargetHolder) == 0x000008, "Wrong alignment on UGazeTargetHolder");
static_assert(sizeof(UGazeTargetHolder) == 0x0000A8, "Wrong size on UGazeTargetHolder");
static_assert(offsetof(UGazeTargetHolder, GazeMaxDistance) == 0x000028, "Member 'UGazeTargetHolder::GazeMaxDistance' has a wrong offset!");
static_assert(offsetof(UGazeTargetHolder, GazeWeight_TargetType) == 0x00002C, "Member 'UGazeTargetHolder::GazeWeight_TargetType' has a wrong offset!");
static_assert(offsetof(UGazeTargetHolder, GazeWeight_Distance) == 0x000030, "Member 'UGazeTargetHolder::GazeWeight_Distance' has a wrong offset!");
static_assert(offsetof(UGazeTargetHolder, GazeWeight_CameraDirection) == 0x000034, "Member 'UGazeTargetHolder::GazeWeight_CameraDirection' has a wrong offset!");
static_assert(offsetof(UGazeTargetHolder, GazeParams) == 0x000038, "Member 'UGazeTargetHolder::GazeParams' has a wrong offset!");
static_assert(offsetof(UGazeTargetHolder, GazeTargets) == 0x000088, "Member 'UGazeTargetHolder::GazeTargets' has a wrong offset!");
static_assert(offsetof(UGazeTargetHolder, PriotiryGazeTargets) == 0x000098, "Member 'UGazeTargetHolder::PriotiryGazeTargets' has a wrong offset!");

// Class Project.RichTextInsertWidgetPool
// 0x0008 (0x0228 - 0x0220)
class ARichTextInsertWidgetPool final : public AActor
{
public:
	class UBtnHelp_ActionMappingIconBase*         M_ActionMappingIcon;                               // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextInsertWidgetPool">();
	}
	static class ARichTextInsertWidgetPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichTextInsertWidgetPool>();
	}
};
static_assert(alignof(ARichTextInsertWidgetPool) == 0x000008, "Wrong alignment on ARichTextInsertWidgetPool");
static_assert(sizeof(ARichTextInsertWidgetPool) == 0x000228, "Wrong size on ARichTextInsertWidgetPool");
static_assert(offsetof(ARichTextInsertWidgetPool, M_ActionMappingIcon) == 0x000220, "Member 'ARichTextInsertWidgetPool::M_ActionMappingIcon' has a wrong offset!");

// Class Project.BPL_GodParameter
// 0x0000 (0x0028 - 0x0028)
class UBPL_GodParameter final : public UBlueprintFunctionLibrary
{
public:
	static void AddGodParameterPoint(int32 Value);
	static void ClearGodParameterSkillLearning(int32 ArgSkillID);
	static void ClearGodParameterSkillLearningAll(bool IsRenewalNewGame);
	static const struct FGodParameterData GetGodParameterData(int32 ID);
	static const struct FGodParameterData GetGodParameterDataFromEnum(E_GODPARAMETER_ID ID);
	static const class FText GetGodParameterHelp(int32 ID);
	static const class FText GetGodParameterHelpFromEnum(E_GODPARAMETER_ID ID);
	static int32 GetGodParameterLearningNumFromType(E_GODPARAMETER_TYPE Type);
	static const class FText GetGodParameterName(int32 ID);
	static const class FText GetGodParameterNameFromEnum(E_GODPARAMETER_ID ID);
	static int32 GetGodParameterPoint();
	static int32 GetGodParameterPointMaxNum();
	static int32 GetGodParameterSKillNum();
	static E_GODPARAMETER_STATE GetGodParameterSkillState(int32 ArgSkillID);
	static int32 GetUserDataFromGodParameterData(E_GODPARAMETER_ID ID);
	static bool GodParameterSkillLearning(int32 ArgSkillID, bool Forced);
	static void GodParameterSkillLearningAll();
	static bool IsActiveGodParameterSkill(int32 ArgSkillID);
	static bool IsAddedSelectableGodParameterSkill(int32 ArgSkillID);
	static bool IsExistNewGodParameterSkill();
	static bool IsLearnableGodParameterSkill(int32 ArgSkillID);
	static bool IsLearningGodParameterSkill(int32 ArgSkillID);
	static bool IsLearningGodParameterSkillFromEnum(E_GODPARAMETER_ID ArgSkillID);
	static bool IsSetGodParameterSkillNewIcon(int32 ArgSkillID);
	static void ResetGodParameterSkill(int32 ArgSkillID);
	static void ResetGodParameterSkillNewIcon(int32 ArgSkillID);
	static void SetGodParameterPoint(int32 Value);
	static void SetGodParameterSkillActiveState(int32 ArgSkillID, bool IsActive);
	static void SetGodParameterSkillNewIcon(int32 ArgSkillID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_GodParameter">();
	}
	static class UBPL_GodParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_GodParameter>();
	}
};
static_assert(alignof(UBPL_GodParameter) == 0x000008, "Wrong alignment on UBPL_GodParameter");
static_assert(sizeof(UBPL_GodParameter) == 0x000028, "Wrong size on UBPL_GodParameter");

// Class Project.HealCharaPanelCtrlBase
// 0x0090 (0x02B0 - 0x0220)
class AHealCharaPanelCtrlBase final : public AActor
{
public:
	uint8                                         Pad_1B55[0x90];                                    // 0x0220(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddPartyListFlag(int32 InIndex, E_HEALCHARAPANELFLAG InType, int32 InCursorOffset);
	void BIESetCostFontColor(int32 InIndex, int32 InCost, int32 InUseCost);
	void BIESetFadeOutPanelAnimation(int32 InIndex);
	void BIESetInitializePanelAnimation(int32 InIndex);
	int32 CalcHealCost(int32 InIndex, int32 InCursorOffset);
	bool CalcHealCostFontColorAll(int32 InUseCost);
	int32 CalcScrollBarClickedByParty(float InRate);
	int32 CalcTargetHeal(int32 InIndex, int32 InCursorOffset);
	bool CalcTargetHealAll();
	int32 CanBeSelectedTarget(int32 InIndex, bool InAllHealFlag);
	bool CanBeUseSelected();
	bool CreateUseHealTargetList();
	bool DeletePanelList();
	int32 DelPartyListFlag(int32 InIndex, E_HEALCHARAPANELFLAG InType, int32 InCursorOffset);
	bool EntryNkmList(int32 InIndex, int32 InNkmIndex, int32 InCursorOffset);
	int32 EntryPartyList(int32 InIndex, E_HEALCHARAPANELFLAG InType, int32 InCursorOffset);
	int32 GetCursorIndexByUseTargetList(int32 InStartIndex);
	int32 GetHealCost(int32 InIndex, int32 InCursorOffset);
	int32 GetHealCostAllChara();
	int32 GetHealHp(int32 InIndex, int32 InCursorOffset);
	int32 GetHealMp(int32 InIndex, int32 InCursorOffset);
	int32 GetMaxStockNumber();
	int32 GetMoveCursorPositionIndex(int32 InIndex, int32 InMoveIndex);
	int32 GetMoveOffsetCursorPositionIndex(int32 InIndex, int32 InMoveIndex, bool InScrollLock);
	int32 GetMoveOffsetCursorPositionIndexByScrollBar(int32 InIndex, int32 InOffsetIndex, int32 InMoveIndex);
	int32 GetNkmIndexOfUseTargetList(int32 InIndex);
	struct FVector2D GetPanelPositionByIndex(int32 InIndex, const struct FVector2D& InVec2D, int32 InCheckType);
	int32 GetPartyDispNumber();
	int32 GetPartyListOffsetIndex();
	int32 GetPartyMaxDisplayCount();
	int32 GetStockDispNumber();
	int32 GetStockNumber();
	int32 GetTargetListOffsetIndex();
	bool InitializeCharaPanelCursor();
	bool InitializeEntryPartyList();
	bool IsCharaPanelAnimation();
	bool IsEmptyPanel(int32 InIndex, int32 InCursorOffset);
	void RebuildStatusCharaList(class UUIStatusCtrlDataObjCampParty* StatusUIDataObj);
	bool ResetMovingCursor();
	bool SetHealCost(int32 InIndex, int32 InCost, int32 InCursorOffset);
	bool SetHealCostAll(int32 InCost);
	bool SetMovingCursor();
	int32 SetPartyInitializeCursorPositionIndex(int32 InIndex);
	bool SetPartyListOffsetIndex(int32 InOffsetIndex);
	int32 SetStockInitializeCursorPositionIndex(int32 InIndex, int32 InType);
	bool SetTargetListOffsetIndex(int32 InOffsetIndex);
	bool StartCharaPanelAnimation();
	bool StartCharaPanelFadeOutAnimation();
	bool StopCharaPanelAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealCharaPanelCtrlBase">();
	}
	static class AHealCharaPanelCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHealCharaPanelCtrlBase>();
	}
};
static_assert(alignof(AHealCharaPanelCtrlBase) == 0x000008, "Wrong alignment on AHealCharaPanelCtrlBase");
static_assert(sizeof(AHealCharaPanelCtrlBase) == 0x0002B0, "Wrong size on AHealCharaPanelCtrlBase");

// Class Project.BPL_HelpMessage
// 0x0000 (0x0028 - 0x0028)
class UBPL_HelpMessage final : public UBlueprintFunctionLibrary
{
public:
	static void SetTagForItemHelp(class UMessageRichTextWidget* PAsset, int32 ItemId);
	static void SetTagForSkillHelp(class UMessageRichTextWidget* PAsset, int32 SkillId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_HelpMessage">();
	}
	static class UBPL_HelpMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_HelpMessage>();
	}
};
static_assert(alignof(UBPL_HelpMessage) == 0x000008, "Wrong alignment on UBPL_HelpMessage");
static_assert(sizeof(UBPL_HelpMessage) == 0x000028, "Wrong size on UBPL_HelpMessage");

// Class Project.BPL_ItemData
// 0x0000 (0x0028 - 0x0028)
class UBPL_ItemData final : public UBlueprintFunctionLibrary
{
public:
	static bool CanbeEntryMagatsuhiSkillByGroupId(int32 InGroupId, int32 InIndex);
	static bool CanbeEntryMagatsuhiSkillByPlayer(int32 InIndex);
	static bool CanNewIconBeDisplayed(int32 InItemId);
	static bool DidUseItemInUtsusemi(int32 InItemId);
	static int32 GetAllRelicSellingPrice();
	static int32 GetHaveItemNum_Gofu_Amulet();
	static int32 GetHaveItemNum_Reifu_Amulet();
	static const struct FImportantItemData GetImportantItemData(int32 ID);
	static int32 GetItemIconIdByItemId(int32 InItemId);
	static int32 GetNewIconPriority(int32 InItemId);
	static const struct FRelicItemData GetRelicItemData(int32 ID);
	static const struct FSkillGetItemData GetSkillGetItemData(int32 ID);
	static const struct FUseItemData GetUseItemData(int32 ID);
	static const struct FUtsusemiItemData GetUtsusemiItemData(int32 ID);
	static void ItemDataClearAll();
	static void ItemDataClearAllByReincarnation();
	static void ItemDataClearAllByRenewal();
	static void ItemDataClearOne(int32 ID);
	static void ItemErase(int32 ID, int32 Num);
	static void ItemErase_AllRelic();
	static void ItemGet(int32 ID, int32 Num);
	static int32 ItemGetBuyingPrice(int32 ID);
	static const class FText ItemGetEffectName(int32 ID);
	static TArray<int32> ItemGetHaveItems();
	static TArray<int32> ItemGetHaveItems_Battle(E_OPTION_CONTENT_ITEM_PRIORITIZE_TYPE SortType);
	static const class FText ItemGetHelpMess(int32 ID);
	static E_ITEM_KIND ItemGetKind(int32 ID);
	static int32 ItemGetMaxNum(int32 ID);
	static const class FText ItemGetName(int32 ID);
	static int32 ItemGetNum(int32 ID);
	static int32 ItemGetPriority(int32 ID);
	static int32 ItemGetSellingPrice(int32 ID);
	static bool ItemIDIsValid(int32 ID);
	static bool ItemIsFullHave(int32 ID);
	static bool ItemIsGotten(int32 ID);
	static bool ItemIsHave(int32 ID);
	static bool ItemIsHaveAnyItems_Battle();
	static bool ItemIsUseBattle(int32 ID);
	static bool ItemIsUseCamp(int32 ID);
	static bool ItemIsUseTargetNkm(int32 ID);
	static bool ItemIsUseTargetNkmFromData(const struct FUseItemData& Data);
	static bool ItemIsUseTargetPlayer(int32 ID);
	static bool ItemIsUseTargetPlayerFromData(const struct FUseItemData& Data);
	static bool ResetNewIconSawFlag(int32 InItemId);
	static bool ResetUseInUtsusemiFlag(int32 InItemId);
	static bool SetNewIconSawFlag(int32 InItemId);
	static bool SetUseInUtsusemiFlag(int32 InItemId);
	static uint8 UseItemDataGetValue_All(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_BuyingPrice(const struct FUseItemData& Data);
	static E_ITEM_KIND UseItemDataGetValue_EtcKind(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_GetExp(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_HaveMax(const struct FUseItemData& Data);
	static uint8 UseItemDataGetValue_HpRcvPercent(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_HpRecovery(const struct FUseItemData& Data);
	static uint8 UseItemDataGetValue_IsNotBuy(const struct FUseItemData& Data);
	static uint8 UseItemDataGetValue_IsNotRelease(const struct FUseItemData& Data);
	static uint8 UseItemDataGetValue_IsUseInfinite(const struct FUseItemData& Data);
	static uint8 UseItemDataGetValue_ItemIcon(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_ItemID(const struct FUseItemData& Data);
	static uint8 UseItemDataGetValue_MpRcvPercent(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_MpRecovery(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_NameSortId(const struct FUseItemData& Data);
	static uint8 UseItemDataGetValue_NkmUseType(const struct FUseItemData& Data);
	static uint8 UseItemDataGetValue_RecBst(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_SellingPrice(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_SkillNo(const struct FUseItemData& Data);
	static int32 UseItemDataGetValue_SortId(const struct FUseItemData& Data);
	static uint8 UseItemDataGetValue_UseScene(const struct FUseItemData& Data);
	static bool UseItemDataIsRecome(const struct FUseItemData& Data);
	static bool UseItemDataIsRecoveryType(const struct FUseItemData& Data);
	static int32 UtsusemiDevilIDToItemID(int32 DevilID);
	static int32 UtsusemiItemIDToDevilID(int32 ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_ItemData">();
	}
	static class UBPL_ItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_ItemData>();
	}
};
static_assert(alignof(UBPL_ItemData) == 0x000008, "Wrong alignment on UBPL_ItemData");
static_assert(sizeof(UBPL_ItemData) == 0x000028, "Wrong size on UBPL_ItemData");

// Class Project.KamuiSortList
// 0x0010 (0x0038 - 0x0028)
class UKamuiSortList final : public UObject
{
public:
	TArray<int32>                                 M_KamuiIDList;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddKamuiList(const int32& SkillId);
	void EmptyKamuiList();
	bool IsExistNewIcon();
	void RemoveAtKamuiList(int32 Param_Index);
	void RemoveKamuiList(const int32& SkillId);
	void ResetKamuiList();
	void SortKamuiList(E_KAMUI_SORT_TYPE Type, bool bDescending);

	const int32 GetData(int32 Param_Index) const;
	const int32 GetDataIndex(const int32& SkillId) const;
	const TArray<int32> GetList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KamuiSortList">();
	}
	static class UKamuiSortList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKamuiSortList>();
	}
};
static_assert(alignof(UKamuiSortList) == 0x000008, "Wrong alignment on UKamuiSortList");
static_assert(sizeof(UKamuiSortList) == 0x000038, "Wrong size on UKamuiSortList");
static_assert(offsetof(UKamuiSortList, M_KamuiIDList) == 0x000028, "Member 'UKamuiSortList::M_KamuiIDList' has a wrong offset!");

// Class Project.KamuiWindowBase
// 0x0028 (0x0248 - 0x0220)
class AKamuiWindowBase final : public AActor
{
public:
	E_KAMUI_UI_INPUT_TYPE                         M_KamuiWIndowInputType;                            // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_KAMUI_UI_USE_KEY                            M_KamuiWIndowInputKey;                             // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B89[0x26];                                    // 0x0222(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateKamuiWindowInputInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KamuiWindowBase">();
	}
	static class AKamuiWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKamuiWindowBase>();
	}
};
static_assert(alignof(AKamuiWindowBase) == 0x000008, "Wrong alignment on AKamuiWindowBase");
static_assert(sizeof(AKamuiWindowBase) == 0x000248, "Wrong size on AKamuiWindowBase");
static_assert(offsetof(AKamuiWindowBase, M_KamuiWIndowInputType) == 0x000220, "Member 'AKamuiWindowBase::M_KamuiWIndowInputType' has a wrong offset!");
static_assert(offsetof(AKamuiWindowBase, M_KamuiWIndowInputKey) == 0x000221, "Member 'AKamuiWindowBase::M_KamuiWIndowInputKey' has a wrong offset!");

// Class Project.KawaiiHairParameter
// 0x0118 (0x0140 - 0x0028)
class UKawaiiHairParameter : public UObject
{
public:
	float                                         MovementSpeedThreshold_WalkRun;                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedThreshold_RunDash;                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterInterpSpeed;                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JumpRiseForce;                                     // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JumpFallForce;                                     // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JumpForce_Stand;                                   // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForceDecaySpeed_Stand;                         // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JumpForce_Run;                                     // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForceDecaySpeed_Run;                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JumpForce_Dash;                                    // 0x006C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForceDecaySpeed_Dash;                          // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LandingForce_Stand;                                // 0x007C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingForceDecaySpeed_Stand;                      // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LandingForce_Run;                                  // 0x008C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingForceDecaySpeed_Run;                        // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LandingForce_Dash;                                 // 0x009C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingForceDecaySpeed_Dash;                       // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttackForce;                                       // 0x00AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackForceDecaySpeed;                             // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SlidingForceBase;                                  // 0x00BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SlidingForceAmplitude;                             // 0x00C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingForcePeriod;                                // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldDampingRotation;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitAngle;                                        // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8A[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EKawaiiHairActionType, struct FKawaiiHairBundleParameter> PerActionParameters;                               // 0x00F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static struct FRuntimeKawaiiHairParameter KawaiiHairAddForceToAllBundle(const struct FRuntimeKawaiiHairParameter& Param, const struct FVector& AddForce);
	static void KawaiiHairInterpTo(struct FRuntimeKawaiiHairParameter& Current, const struct FKawaiiHairBundleParameter& Target, float DeltaTime, float InterpSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KawaiiHairParameter">();
	}
	static class UKawaiiHairParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKawaiiHairParameter>();
	}
};
static_assert(alignof(UKawaiiHairParameter) == 0x000008, "Wrong alignment on UKawaiiHairParameter");
static_assert(sizeof(UKawaiiHairParameter) == 0x000140, "Wrong size on UKawaiiHairParameter");
static_assert(offsetof(UKawaiiHairParameter, MovementSpeedThreshold_WalkRun) == 0x000028, "Member 'UKawaiiHairParameter::MovementSpeedThreshold_WalkRun' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, MovementSpeedThreshold_RunDash) == 0x00002C, "Member 'UKawaiiHairParameter::MovementSpeedThreshold_RunDash' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, ParameterInterpSpeed) == 0x000030, "Member 'UKawaiiHairParameter::ParameterInterpSpeed' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, JumpRiseForce) == 0x000034, "Member 'UKawaiiHairParameter::JumpRiseForce' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, JumpFallForce) == 0x000040, "Member 'UKawaiiHairParameter::JumpFallForce' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, JumpForce_Stand) == 0x00004C, "Member 'UKawaiiHairParameter::JumpForce_Stand' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, JumpForceDecaySpeed_Stand) == 0x000058, "Member 'UKawaiiHairParameter::JumpForceDecaySpeed_Stand' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, JumpForce_Run) == 0x00005C, "Member 'UKawaiiHairParameter::JumpForce_Run' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, JumpForceDecaySpeed_Run) == 0x000068, "Member 'UKawaiiHairParameter::JumpForceDecaySpeed_Run' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, JumpForce_Dash) == 0x00006C, "Member 'UKawaiiHairParameter::JumpForce_Dash' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, JumpForceDecaySpeed_Dash) == 0x000078, "Member 'UKawaiiHairParameter::JumpForceDecaySpeed_Dash' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, LandingForce_Stand) == 0x00007C, "Member 'UKawaiiHairParameter::LandingForce_Stand' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, LandingForceDecaySpeed_Stand) == 0x000088, "Member 'UKawaiiHairParameter::LandingForceDecaySpeed_Stand' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, LandingForce_Run) == 0x00008C, "Member 'UKawaiiHairParameter::LandingForce_Run' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, LandingForceDecaySpeed_Run) == 0x000098, "Member 'UKawaiiHairParameter::LandingForceDecaySpeed_Run' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, LandingForce_Dash) == 0x00009C, "Member 'UKawaiiHairParameter::LandingForce_Dash' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, LandingForceDecaySpeed_Dash) == 0x0000A8, "Member 'UKawaiiHairParameter::LandingForceDecaySpeed_Dash' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, AttackForce) == 0x0000AC, "Member 'UKawaiiHairParameter::AttackForce' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, AttackForceDecaySpeed) == 0x0000B8, "Member 'UKawaiiHairParameter::AttackForceDecaySpeed' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, SlidingForceBase) == 0x0000BC, "Member 'UKawaiiHairParameter::SlidingForceBase' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, SlidingForceAmplitude) == 0x0000C8, "Member 'UKawaiiHairParameter::SlidingForceAmplitude' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, SlidingForcePeriod) == 0x0000D4, "Member 'UKawaiiHairParameter::SlidingForcePeriod' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, Damping) == 0x0000D8, "Member 'UKawaiiHairParameter::Damping' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, WorldDampingRotation) == 0x0000DC, "Member 'UKawaiiHairParameter::WorldDampingRotation' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, Stiffness) == 0x0000E0, "Member 'UKawaiiHairParameter::Stiffness' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, Radius) == 0x0000E4, "Member 'UKawaiiHairParameter::Radius' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, LimitAngle) == 0x0000E8, "Member 'UKawaiiHairParameter::LimitAngle' has a wrong offset!");
static_assert(offsetof(UKawaiiHairParameter, PerActionParameters) == 0x0000F0, "Member 'UKawaiiHairParameter::PerActionParameters' has a wrong offset!");

// Class Project.LocationWindowBase
// 0x0038 (0x0258 - 0x0220)
class ALocationWindowBase : public AActor
{
public:
	uint8                                         Pad_1B8B[0x38];                                    // 0x0220(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFacilityName(const class FText& InText);
	void SetTokyoLargeMapPlaceName(const class FText& InText);
	void SetType(E_LOCATION_WINDOW_TYPE InType);

	class FText GetCurrentName() const;
	const class FText GetFacilityName() const;
	const class FText GetTokyoLargeMapPlaceName() const;
	E_LOCATION_WINDOW_TYPE GetType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocationWindowBase">();
	}
	static class ALocationWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocationWindowBase>();
	}
};
static_assert(alignof(ALocationWindowBase) == 0x000008, "Wrong alignment on ALocationWindowBase");
static_assert(sizeof(ALocationWindowBase) == 0x000258, "Wrong size on ALocationWindowBase");

// Class Project.Map3DIconOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class IMap3DIconOwnerInterface final : public IInterface
{
public:
	struct FVector Map3DIconGetWorldLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Map3DIconOwnerInterface">();
	}
	static class IMap3DIconOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMap3DIconOwnerInterface>();
	}
};
static_assert(alignof(IMap3DIconOwnerInterface) == 0x000008, "Wrong alignment on IMap3DIconOwnerInterface");
static_assert(sizeof(IMap3DIconOwnerInterface) == 0x000028, "Wrong size on IMap3DIconOwnerInterface");

// Class Project.BPL_MapAreaName
// 0x0000 (0x0028 - 0x0028)
class UBPL_MapAreaName final : public UBlueprintFunctionLibrary
{
public:
	static const class FText GetMapAreaNameText(const class FName& Label);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MapAreaName">();
	}
	static class UBPL_MapAreaName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MapAreaName>();
	}
};
static_assert(alignof(UBPL_MapAreaName) == 0x000008, "Wrong alignment on UBPL_MapAreaName");
static_assert(sizeof(UBPL_MapAreaName) == 0x000028, "Wrong size on UBPL_MapAreaName");

// Class Project.BPL_MapData
// 0x0000 (0x0028 - 0x0028)
class UBPL_MapData final : public UBlueprintFunctionLibrary
{
public:
	static void AddAogamiDebrisGetCounter();
	static void AddMapSymbolParamIndex(int32 DevilID, int32 Param_Index);
	static void AddNaviDevilGimmickCheckCounter();
	static void AddRelicGetCounter();
	static void AddWaitingMapInfo(const struct FMapInfoData& Info);
	static bool CheckAogamiDebrisFlag(int32 TableIndex);
	static bool CheckAogamiDebrisGetIcon(int32 TableIndex);
	static bool CheckCoasterOpenFlag(int32 ID, bool StartGimmick);
	static bool CheckCoasterOpenFlag_ByMinimapID(int32 MinimapID);
	static bool CheckMapSymbolDeadFlag(int32 ID);
	static bool CheckMimanFlag(int32 ID);
	static bool CheckMimanPositionFlag(int32 Category);
	static TArray<bool> CheckMimanPositionFlagAll();
	static bool CheckNaviDevilGimmickExist(int32 ID);
	static bool CheckNaviDevilGimmickUniqueSaveID(int32 SaveId);
	static bool CheckRelicFlag(int32 ID);
	static bool CheckRelicGetIcon(int32 SaveId);
	static bool CheckRelicOnceFlag(int32 ID);
	static bool CheckRyuketsuOpen(int32 ID);
	static bool CheckShinseiFlag(int32 ID);
	static void ClearMapSymbolActors();
	static void ClearMapSymbolParamIndex();
	static void ClearTimeAttackEncountAreaKillFlag();
	static void ClearWaitingMapInfo();
	static bool CurrentLevelIsCustom();
	static TArray<E_MAGATSUKA_STATE> GetAllMagatsukaState();
	static TArray<uint8> GetAllTakaraBreakFlag(int32 ID);
	static TArray<uint8> GetAllTakaraFlag(int32 ID);
	static int32 GetAogamiDebrisGetCounter();
	static float GetAogamiDebrisTimer(int32 TableIndex);
	static int32 GetAreaID();
	static int32 GetBridgeNextAreaID();
	static int32 GetBridgeNextMapID();
	static int32 GetCoasterMinimapID_FromSaveID(int32 SaveId, bool StartGimmick);
	static int32 GetCoasterSaveID_FromMinimapID(int32 MinimapID);
	static E_NAVI_DEVIL GetCurrentNaviDevil();
	static int32 GetCurrentNaviDevilID();
	static class FName GetDebugMenuPath_ChangeMimanNum();
	static int32 GetLastRyuketsuTableIndex();
	static int32 GetMagatsukaBrokenNum();
	static E_MAGATSUKA_STATE GetMagatsukaState(int32 ID);
	static struct FMapData GetMapData();
	static int32 GetMapID();
	static const TArray<class AActor*> GetMapSymbolActors();
	static int32 GetMapSymbolParamIndex(int32 DevilID);
	static const TArray<class AActor*> GetMapSymbolSpawners();
	static int32 GetMimanFoundNum();
	static int32 GetMimanFoundNum_FromMap(int32 MapId);
	static struct FMinimapLandmark GetMinimapLandmark();
	static bool GetMinimapMaskOpenFlag(int32 MinimapMaskID);
	static E_NAVI_DEVIL GetNaviDevilEnum_FromDevilID(int32 DevilID);
	static int32 GetNaviDevilGimmickCheckCounter();
	static int32 GetNaviDevilID_FromEnum(E_NAVI_DEVIL NaviDevil);
	static bool GetNearbySymbolAfterBattle(class UProjectGameInstanceBase* PGameInst);
	static float GetNearbySymbolCounter(class UProjectGameInstanceBase* PGameInst);
	static int32 GetOtherCoasterMinimapID(int32 MinimapID);
	static int32 GetRelicGetCounter();
	static int32 GetRelicSaveMax();
	static float GetRelicTimer(int32 ID);
	static bool GetRyuketsuMinimapIconHideFlag();
	static int32 GetShinseiGetNum();
	static bool GetTakaraBreakFlag(int32 ID);
	static bool GetTakaraFlag(int32 ID);
	static int32 GetTakaraFlagMax();
	static TArray<bool> GetTimeAttackEncountAreaKillFlags(int32 SaveId);
	static int32 GetTimeAttackEncountAreaRandomSeed(int32 SaveId);
	static float GetTopCameraHeight();
	static const TArray<struct FMapInfoData> GetWaitingMapInfo();
	static void InitMapData();
	static void InitNaviDevilGimmickUniqueSaveID();
	static void RegisterMapSymbolActors(class AActor* PActor);
	static void RegisterMapSymbolSpawner(class AActor* PActor);
	static bool RemoveWaitingMapInfo(int32 Param_Index);
	static void ResetAogamiDebrisGetCounter();
	static void ResetMinimapLandmark();
	static void ResetNaviDevilGimmickCheckCounter();
	static void ResetRelicGetCounter();
	static void ResetRotatorCount();
	static void Ryuketsu_AutoOpenAndClose(const class UObject* WorldContextObject);
	static void SaveMapData_CPP(const class UObject* WorldContextObject);
	static void SetAllMapData(const struct FMapData& Data);
	static void SetAogamiDebrisFlag(int32 TableIndex, bool Flag);
	static void SetAogamiDebrisFlagAll(bool Flag);
	static void SetAogamiDebrisGetIcon(int32 TableIndex, bool Flag);
	static void SetAogamiDebrisGetIconUpdate(int32 TableIndex, bool Flag);
	static void SetAogamiDebrisTimer(int32 TableIndex, float Timer);
	static void SetAogamiDebrisTimerAllZero();
	static void SetAreaID(int32 Area_id);
	static void SetBridgeNextAreaID(int32 Area_id);
	static void SetBridgeNextMapID(int32 Map_id);
	static void SetCoasterOpenFlag(int32 ID, bool StartGimmick, bool Flag);
	static void SetCoasterOpenFlagAll(bool Flag);
	static void SetCurrentLevelCustom(bool Enable);
	static void SetCurrentNaviDevil(E_NAVI_DEVIL NaviDevil);
	static void SetLastRyuketsuTableIndex(int32 TableIndex);
	static void SetMagatsukaState(int32 ID, E_MAGATSUKA_STATE State);
	static void SetMapID(int32 Map_id);
	static void SetMapSymbolDeadFlag(int32 ID, bool Sw);
	static void SetMapSymbolDeadFlagAll(bool Sw);
	static void SetMimanFlag(int32 ID, bool Flag);
	static void SetMimanFlagAll(bool Flag);
	static void SetMimanPositionFlag(int32 Category, bool Open);
	static void SetMinimapLandmark(int32 MapId, int32 AreaId, float LocationX, float LocationY);
	static bool SetMinimapMaskOpenFlag(int32 MinimapMaskID, bool Flag);
	static void SetMinimapMaskOpenFlagAll(bool Flag);
	static void SetNaviDevilGimmickExist(int32 ID, bool Exist);
	static void SetNaviDevilGimmickExistAll(bool Exist);
	static void SetNaviDevilGimmickUniqueSaveID(int32 SaveId, bool Flag);
	static void SetNearbySymbolAfterBattle(class UProjectGameInstanceBase* PGameInst, bool Flag);
	static void SetNearbySymbolCounter(class UProjectGameInstanceBase* PGameInst, float Counter);
	static void SetPlayerPosForSave(const struct FTransform& PlayerPos);
	static void SetRelicFlag(int32 ID, bool Flag);
	static void SetRelicFlagAll(bool Flag);
	static void SetRelicGetIcon(int32 SaveId, bool Flag);
	static void SetRelicGetIconUpdate(int32 SaveId, bool Flag);
	static void SetRelicOnceFlag(int32 ID, bool Flag);
	static void SetRelicOnceFlagAll(bool Flag);
	static void SetRelicTableIndex(int32 SaveId, int32 MapId, int32 Param_Index);
	static void SetRelicTimer(int32 ID, float Timer);
	static void SetRelicTimerAllZero();
	static void SetRyuketsuMinimapIconHideFlag(bool IsHide);
	static void SetRyuketsuOpen(int32 ID, bool Open);
	static void SetRyuketsuOpenAll(bool Open);
	static void SetRyuketsuSaveAccess(bool Access, const struct FTransform& WarpPos);
	static void SetShinseiFlag(int32 ID, bool Flag);
	static void SetShinseiFlagAll(bool Flag);
	static void SetTakaraBreakFlag(int32 ID, bool Flag);
	static void SetTakaraFlag(int32 ID, bool Flag);
	static void SetTimeAttackEncountAreaKillFlag(int32 SaveId, int32 Param_Index, bool Kill);
	static void SetTimeAttackEncountAreaRandomSeed(int32 SaveId, int32 Seed);
	static void SetTopCameraHeight(float Height);
	static void SetWaitingMapInfo(const TArray<struct FMapInfoData>& Info);
	static void UnregisterMapSymbolActors(class AActor* PActor);
	static void UnregisterMapSymbolSpawner(class AActor* PActor);
	static void UpdateAogamiDebrisTimer(float DeltaSec, bool bMapPause);
	static void UpdateRelicTimer(float DeltaSec, bool bMapPause);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MapData">();
	}
	static class UBPL_MapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MapData>();
	}
};
static_assert(alignof(UBPL_MapData) == 0x000008, "Wrong alignment on UBPL_MapData");
static_assert(sizeof(UBPL_MapData) == 0x000028, "Wrong size on UBPL_MapData");

// Class Project.BPL_EstomaRiberama
// 0x0000 (0x0028 - 0x0028)
class UBPL_EstomaRiberama final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckEstomaUnlock();
	static bool CheckRiberamaUnlock();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_EstomaRiberama">();
	}
	static class UBPL_EstomaRiberama* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_EstomaRiberama>();
	}
};
static_assert(alignof(UBPL_EstomaRiberama) == 0x000008, "Wrong alignment on UBPL_EstomaRiberama");
static_assert(sizeof(UBPL_EstomaRiberama) == 0x000028, "Wrong size on UBPL_EstomaRiberama");

// Class Project.MapEventHitManageInterface
// 0x0000 (0x0028 - 0x0028)
class IMapEventHitManageInterface final : public IInterface
{
public:
	bool EnableHit(bool IsEnable);
	bool EnableIcon(bool IsEnable);
	int32 GetMapEventId();
	bool IsHitEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEventHitManageInterface">();
	}
	static class IMapEventHitManageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMapEventHitManageInterface>();
	}
};
static_assert(alignof(IMapEventHitManageInterface) == 0x000008, "Wrong alignment on IMapEventHitManageInterface");
static_assert(sizeof(IMapEventHitManageInterface) == 0x000028, "Wrong size on IMapEventHitManageInterface");

// Class Project.MapGimmickArea
// 0x0000 (0x0220 - 0x0220)
class AMapGimmickArea final : public AActor
{
public:
	TArray<class AActor*> GetActors_ThisLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapGimmickArea">();
	}
	static class AMapGimmickArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapGimmickArea>();
	}
};
static_assert(alignof(AMapGimmickArea) == 0x000008, "Wrong alignment on AMapGimmickArea");
static_assert(sizeof(AMapGimmickArea) == 0x000220, "Wrong size on AMapGimmickArea");

// Class Project.MapSoundSelectorBase
// 0x0028 (0x00D8 - 0x00B0)
class UMapSoundSelectorBase : public UActorComponent
{
public:
	class USoundAtomCue*                          MapDefaultBGM;                                     // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          MagatsukaBGM;                                      // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBGMState>                      BGMStateArray;                                     // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BC0[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InBGMArea(class USoundAtomCue* Cue, int32 Priority, EFadeType FadeType);
	void InMagatsukaArea(class USoundAtomCue* Cue);
	void MapInitialize(class USoundAtomCue* InMapDefaultBGM, EFadeType FadeType);
	void OutBGMArea(class USoundAtomCue* Cue, int32 Priority, EFadeType FadeType);
	void OutMagatsukaArea();
	void SetMapDefaultBGM(class USoundAtomCue* InMapDefaultBGM, EFadeType FadeType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSoundSelectorBase">();
	}
	static class UMapSoundSelectorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSoundSelectorBase>();
	}
};
static_assert(alignof(UMapSoundSelectorBase) == 0x000008, "Wrong alignment on UMapSoundSelectorBase");
static_assert(sizeof(UMapSoundSelectorBase) == 0x0000D8, "Wrong size on UMapSoundSelectorBase");
static_assert(offsetof(UMapSoundSelectorBase, MapDefaultBGM) == 0x0000B0, "Member 'UMapSoundSelectorBase::MapDefaultBGM' has a wrong offset!");
static_assert(offsetof(UMapSoundSelectorBase, MagatsukaBGM) == 0x0000B8, "Member 'UMapSoundSelectorBase::MagatsukaBGM' has a wrong offset!");
static_assert(offsetof(UMapSoundSelectorBase, BGMStateArray) == 0x0000C0, "Member 'UMapSoundSelectorBase::BGMStateArray' has a wrong offset!");

// Class Project.MapTopCamera
// 0x00B8 (0x02D8 - 0x0220)
class AMapTopCamera : public AActor
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComponent;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MAP_TOP_CAMERA_STEP                         Step;                                              // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MAP_TOP_CAMERA_TRANSITION_STEP              TransitionStep;                                    // 0x0231(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC5[0x2];                                     // 0x0232(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MapFOVY;                                           // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopFOVY;                                           // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MapCameraLocation;                                 // 0x023C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MapCameraRotation;                                 // 0x0248(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CurrentOffsetLocation;                             // 0x0254(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentCameraLocation;                             // 0x0260(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentCameraRotation;                             // 0x026C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TargetOffsetHeight;                                // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetCameraRotation;                              // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TransitionSeconds;                                 // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TransitionStartLocation;                           // 0x028C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapTopCameraTransitionParam           ToTop_NearMap_Param;                               // 0x0298(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMapTopCameraTransitionParam           ToTop_NearTop_Param;                               // 0x02A8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMapTopCameraTransitionParam           ToMap_NearMap_Param;                               // 0x02B8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMapTopCameraTransitionParam           ToMap_NearTop_Param;                               // 0x02C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	void Init(const struct FVector& InMapCameraLocation, const struct FRotator& InMapCameraRotation, float InTargetOffsetHeight, const struct FRotator& InTargetCameraRotation, float InMapFOVY, float InTopFOVY);
	void OnFinishTop();
	void OnStartTop();
	void SetMapCamera(const struct FVector& InMapCameraLocation, const struct FRotator& InMapCameraRotation);
	void StartTransitionToMap(const struct FVector& InTransitionStartLocation);
	void StartTransitionToTop();
	void Update_TransitionToMap(float DeltaSeconds);
	void Update_TransitionToTop(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapTopCamera">();
	}
	static class AMapTopCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapTopCamera>();
	}
};
static_assert(alignof(AMapTopCamera) == 0x000008, "Wrong alignment on AMapTopCamera");
static_assert(sizeof(AMapTopCamera) == 0x0002D8, "Wrong size on AMapTopCamera");
static_assert(offsetof(AMapTopCamera, CapsuleComponent) == 0x000220, "Member 'AMapTopCamera::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, CameraComponent) == 0x000228, "Member 'AMapTopCamera::CameraComponent' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, Step) == 0x000230, "Member 'AMapTopCamera::Step' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, TransitionStep) == 0x000231, "Member 'AMapTopCamera::TransitionStep' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, MapFOVY) == 0x000234, "Member 'AMapTopCamera::MapFOVY' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, TopFOVY) == 0x000238, "Member 'AMapTopCamera::TopFOVY' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, MapCameraLocation) == 0x00023C, "Member 'AMapTopCamera::MapCameraLocation' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, MapCameraRotation) == 0x000248, "Member 'AMapTopCamera::MapCameraRotation' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, CurrentOffsetLocation) == 0x000254, "Member 'AMapTopCamera::CurrentOffsetLocation' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, CurrentCameraLocation) == 0x000260, "Member 'AMapTopCamera::CurrentCameraLocation' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, CurrentCameraRotation) == 0x00026C, "Member 'AMapTopCamera::CurrentCameraRotation' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, TargetOffsetHeight) == 0x000278, "Member 'AMapTopCamera::TargetOffsetHeight' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, TargetCameraRotation) == 0x00027C, "Member 'AMapTopCamera::TargetCameraRotation' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, TransitionSeconds) == 0x000288, "Member 'AMapTopCamera::TransitionSeconds' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, TransitionStartLocation) == 0x00028C, "Member 'AMapTopCamera::TransitionStartLocation' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, ToTop_NearMap_Param) == 0x000298, "Member 'AMapTopCamera::ToTop_NearMap_Param' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, ToTop_NearTop_Param) == 0x0002A8, "Member 'AMapTopCamera::ToTop_NearTop_Param' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, ToMap_NearMap_Param) == 0x0002B8, "Member 'AMapTopCamera::ToMap_NearMap_Param' has a wrong offset!");
static_assert(offsetof(AMapTopCamera, ToMap_NearTop_Param) == 0x0002C8, "Member 'AMapTopCamera::ToMap_NearTop_Param' has a wrong offset!");

// Class Project.MaterialEventLightLocator
// 0x0008 (0x0228 - 0x0220)
class AMaterialEventLightLocator final : public AActor
{
public:
	bool                                          bActive;                                           // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC6[0x7];                                     // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialEventLightLocator">();
	}
	static class AMaterialEventLightLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaterialEventLightLocator>();
	}
};
static_assert(alignof(AMaterialEventLightLocator) == 0x000008, "Wrong alignment on AMaterialEventLightLocator");
static_assert(sizeof(AMaterialEventLightLocator) == 0x000228, "Wrong size on AMaterialEventLightLocator");
static_assert(offsetof(AMaterialEventLightLocator, bActive) == 0x000220, "Member 'AMaterialEventLightLocator::bActive' has a wrong offset!");

// Class Project.MessageRichTextWidget
// 0x0178 (0x0758 - 0x05E0)
class UMessageRichTextWidget final : public UAtRichText
{
public:
	uint8                                         Pad_1BC7[0xA0];                                    // 0x05E0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RevealPerSecond;                                   // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC8[0x4];                                     // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScriptMessageAsset*                    InitialScriptMessageAsset;                         // 0x0688(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InitialMessageLabel;                               // 0x0690(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialPageIndex;                                  // 0x0698(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC9[0xA4];                                    // 0x069C(0x00A4)(Fixing Size After Last Property [ Dumper-7 ])
	class UScriptMessageAsset*                    ScriptMessageAsset;                                // 0x0740(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BCA[0x10];                                    // 0x0748(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D GetTextEndOffset();
	bool IsNextPage();
	void RevealPageText();
	bool SetDecorator();
	bool SetRevealPerSecond(float InTime);
	void TickMessage(float DeltaTime);
	void ToNextPage();

	const struct FScriptMessagePageData GetCurrentPageData() const;
	class FString GetVoiceName(const class UScriptMessageAsset* InScriptMessage, int32 InMessageId) const;
	bool IsMessageCompleted() const;
	bool IsPageCompleted() const;
	bool IsVoicePlayEnd(const float VoiceTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageRichTextWidget">();
	}
	static class UMessageRichTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageRichTextWidget>();
	}
};
static_assert(alignof(UMessageRichTextWidget) == 0x000008, "Wrong alignment on UMessageRichTextWidget");
static_assert(sizeof(UMessageRichTextWidget) == 0x000758, "Wrong size on UMessageRichTextWidget");
static_assert(offsetof(UMessageRichTextWidget, RevealPerSecond) == 0x000680, "Member 'UMessageRichTextWidget::RevealPerSecond' has a wrong offset!");
static_assert(offsetof(UMessageRichTextWidget, InitialScriptMessageAsset) == 0x000688, "Member 'UMessageRichTextWidget::InitialScriptMessageAsset' has a wrong offset!");
static_assert(offsetof(UMessageRichTextWidget, InitialMessageLabel) == 0x000690, "Member 'UMessageRichTextWidget::InitialMessageLabel' has a wrong offset!");
static_assert(offsetof(UMessageRichTextWidget, InitialPageIndex) == 0x000698, "Member 'UMessageRichTextWidget::InitialPageIndex' has a wrong offset!");
static_assert(offsetof(UMessageRichTextWidget, ScriptMessageAsset) == 0x000740, "Member 'UMessageRichTextWidget::ScriptMessageAsset' has a wrong offset!");

// Class Project.MessageSimpleTextWidget
// 0x00C0 (0x0370 - 0x02B0)
class UMessageSimpleTextWidget final : public UTextBlock
{
public:
	uint8                                         Pad_1BCE[0xA0];                                    // 0x02B0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UScriptMessageAsset*                    InitialScriptMessageAsset;                         // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InitialMessageLabel;                               // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScriptMessageAsset*                    ScriptMessageAsset;                                // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BCF[0x8];                                     // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageSimpleTextWidget">();
	}
	static class UMessageSimpleTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageSimpleTextWidget>();
	}
};
static_assert(alignof(UMessageSimpleTextWidget) == 0x000008, "Wrong alignment on UMessageSimpleTextWidget");
static_assert(sizeof(UMessageSimpleTextWidget) == 0x000370, "Wrong size on UMessageSimpleTextWidget");
static_assert(offsetof(UMessageSimpleTextWidget, InitialScriptMessageAsset) == 0x000350, "Member 'UMessageSimpleTextWidget::InitialScriptMessageAsset' has a wrong offset!");
static_assert(offsetof(UMessageSimpleTextWidget, InitialMessageLabel) == 0x000358, "Member 'UMessageSimpleTextWidget::InitialMessageLabel' has a wrong offset!");
static_assert(offsetof(UMessageSimpleTextWidget, ScriptMessageAsset) == 0x000360, "Member 'UMessageSimpleTextWidget::ScriptMessageAsset' has a wrong offset!");

// Class Project.MessageTagInterface
// 0x0000 (0x0028 - 0x0028)
class IMessageTagInterface final : public IInterface
{
public:
	void BuildText();
	int32 GetValueParam(int32 InIndex);
	void SetItemHelpItemId(int32 InItemId);
	void SetProgramValue(int32 InIndex, const class FString& InValue);
	void SetProgramValueNum(int32 InIndex, int32 InNumber, int32 InFigure, bool bInZeroFill);
	void SetScriptMessageByID(const class UScriptMessageAsset* InAsset, int32 InMessageId, bool bBuildText);
	void SetScriptMessageByLabel(const class UScriptMessageAsset* InAsset, class FName InMessageLabel, bool bBuildText);
	void SetSkillHelpSkillId(int32 InSkillId);
	void SetValueParam(int32 InIndex, int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageTagInterface">();
	}
	static class IMessageTagInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMessageTagInterface>();
	}
};
static_assert(alignof(IMessageTagInterface) == 0x000008, "Wrong alignment on IMessageTagInterface");
static_assert(sizeof(IMessageTagInterface) == 0x000028, "Wrong size on IMessageTagInterface");

// Class Project.MessageUI
// 0x0000 (0x0028 - 0x0028)
class UMessageUI final : public UBlueprintFunctionLibrary
{
public:
	static struct FMessageData GetMessageDataFromId(const class UScriptMessageAsset* PScriptMessage, int32 MessageID);
	static struct FMessageData GetMessageDataFromLabel(const class UScriptMessageAsset* PScriptMessage, class FName Label);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageUI">();
	}
	static class UMessageUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageUI>();
	}
};
static_assert(alignof(UMessageUI) == 0x000008, "Wrong alignment on UMessageUI");
static_assert(sizeof(UMessageUI) == 0x000028, "Wrong size on UMessageUI");

// Class Project.BPL_MimanData
// 0x0000 (0x0028 - 0x0028)
class UBPL_MimanData final : public UBlueprintFunctionLibrary
{
public:
	static const struct FMimanData GetMimanData(int32 MapId);
	static const struct FMimanSaveBuffer GetMimanSaveBufferData(int32 TableID);
	static int32 GetMimanSaveBufferDataMax();
	static int32 GetMimanSaveBufferNum(int32 MapId, int32 AreaId);
	static int32 GetMimanSaveBufferStart(int32 MapId, int32 AreaId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MimanData">();
	}
	static class UBPL_MimanData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MimanData>();
	}
};
static_assert(alignof(UBPL_MimanData) == 0x000008, "Wrong alignment on UBPL_MimanData");
static_assert(sizeof(UBPL_MimanData) == 0x000028, "Wrong size on UBPL_MimanData");

// Class Project.MinimapBGTextureEntry
// 0x0018 (0x0040 - 0x0028)
class UMinimapBGTextureEntry final : public UObject
{
public:
	E_MINIMAP_LOAD_STATE                          M_LoadState;                                       // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BD5[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               M_BGTexture;                                       // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_MapID;                                           // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaId;                                          // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ReleaseResource();
	void Reset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapBGTextureEntry">();
	}
	static class UMinimapBGTextureEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapBGTextureEntry>();
	}
};
static_assert(alignof(UMinimapBGTextureEntry) == 0x000008, "Wrong alignment on UMinimapBGTextureEntry");
static_assert(sizeof(UMinimapBGTextureEntry) == 0x000040, "Wrong size on UMinimapBGTextureEntry");
static_assert(offsetof(UMinimapBGTextureEntry, M_LoadState) == 0x000028, "Member 'UMinimapBGTextureEntry::M_LoadState' has a wrong offset!");
static_assert(offsetof(UMinimapBGTextureEntry, M_BGTexture) == 0x000030, "Member 'UMinimapBGTextureEntry::M_BGTexture' has a wrong offset!");
static_assert(offsetof(UMinimapBGTextureEntry, M_MapID) == 0x000038, "Member 'UMinimapBGTextureEntry::M_MapID' has a wrong offset!");
static_assert(offsetof(UMinimapBGTextureEntry, M_AreaId) == 0x00003C, "Member 'UMinimapBGTextureEntry::M_AreaId' has a wrong offset!");

// Class Project.MinimapCoasterLineManager
// 0x0040 (0x0068 - 0x0028)
class UMinimapCoasterLineManager final : public UObject
{
public:
	uint8                                         Pad_1BD6[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMinimapCoasterLine>            M_Lines;                                           // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FMinimapCoasterLineRenderEntry> M_RenderEntries;                                   // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         M_ImageArray;                                      // 0x0058(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapCoasterLineManager">();
	}
	static class UMinimapCoasterLineManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapCoasterLineManager>();
	}
};
static_assert(alignof(UMinimapCoasterLineManager) == 0x000008, "Wrong alignment on UMinimapCoasterLineManager");
static_assert(sizeof(UMinimapCoasterLineManager) == 0x000068, "Wrong size on UMinimapCoasterLineManager");
static_assert(offsetof(UMinimapCoasterLineManager, M_Lines) == 0x000038, "Member 'UMinimapCoasterLineManager::M_Lines' has a wrong offset!");
static_assert(offsetof(UMinimapCoasterLineManager, M_RenderEntries) == 0x000048, "Member 'UMinimapCoasterLineManager::M_RenderEntries' has a wrong offset!");
static_assert(offsetof(UMinimapCoasterLineManager, M_ImageArray) == 0x000058, "Member 'UMinimapCoasterLineManager::M_ImageArray' has a wrong offset!");

// Class Project.MinimapFogGridManager
// 0x20018 (0x20040 - 0x0028)
class UMinimapFogGridManager final : public UObject
{
public:
	uint8                                         Pad_1BD7[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             M_Texture;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BD8[0x20000];                                 // 0x0040(0x20000)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapFogGridManager">();
	}
	static class UMinimapFogGridManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapFogGridManager>();
	}
};
static_assert(alignof(UMinimapFogGridManager) == 0x000008, "Wrong alignment on UMinimapFogGridManager");
static_assert(sizeof(UMinimapFogGridManager) == 0x020040, "Wrong size on UMinimapFogGridManager");
static_assert(offsetof(UMinimapFogGridManager, M_Texture) == 0x000038, "Member 'UMinimapFogGridManager::M_Texture' has a wrong offset!");

// Class Project.MinimapIconHelpManager
// 0x0028 (0x0050 - 0x0028)
class UMinimapIconHelpManager final : public UObject
{
public:
	TArray<struct FMinimapIconHelpData>           M_DataArray;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BD9[0x18];                                    // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMinimapIconHelpManager* GetMinimapIconHelpManager(const class UObject* WorldContextObject);

	TArray<struct FMinimapIconHelpEntry> GetDisplayList(int32 MapId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapIconHelpManager">();
	}
	static class UMinimapIconHelpManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapIconHelpManager>();
	}
};
static_assert(alignof(UMinimapIconHelpManager) == 0x000008, "Wrong alignment on UMinimapIconHelpManager");
static_assert(sizeof(UMinimapIconHelpManager) == 0x000050, "Wrong size on UMinimapIconHelpManager");
static_assert(offsetof(UMinimapIconHelpManager, M_DataArray) == 0x000028, "Member 'UMinimapIconHelpManager::M_DataArray' has a wrong offset!");

// Class Project.BPL_MinimapIconTable
// 0x0000 (0x0028 - 0x0028)
class UBPL_MinimapIconTable final : public UBlueprintFunctionLibrary
{
public:
	static void OutputMinimapIconTableCSV(int32 MapId, int32 AreaId, const TArray<class UObject*>& InObjects, const class FString& PostFix);
	static void SetMinimapIconTableRowFromHelper(const class AActor* Actor, const struct FMinimapIconTableHelper& Helper, struct FMinimapIconTableRow* OutRow);
	static void SetMinimapIconTableRowFromHelperLocation(const struct FVector& Location, const struct FMinimapIconTableHelper& Helper, struct FMinimapIconTableRow* OutRow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MinimapIconTable">();
	}
	static class UBPL_MinimapIconTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MinimapIconTable>();
	}
};
static_assert(alignof(UBPL_MinimapIconTable) == 0x000008, "Wrong alignment on UBPL_MinimapIconTable");
static_assert(sizeof(UBPL_MinimapIconTable) == 0x000028, "Wrong size on UBPL_MinimapIconTable");

// Class Project.MapSelectManager
// 0x0058 (0x0080 - 0x0028)
class UMapSelectManager final : public UObject
{
public:
	int32                                         M_ParentCursor;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ChildCursor;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MAP_SELECT_STEP                             M_Step;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BDC[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMinimapMapSelectItem>          M_ItemArray;                                       // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FMinimapMapSelectItem>          M_ParentArray;                                     // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FMinimapMapSelectItem>          M_ChildArray;                                      // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FMinimapMapSelectItem>          M_AreaInMapArray;                                  // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BDD[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMapSelectManager* GetMapSelectManager(const class UObject* WorldContextObject);

	TArray<class FText> GetMessageList();
	void Start();
	void ToChildStep(int32 ParentIndex);
	void ToParentStep();

	const struct FMinimapMapSelectItem GetChildItemByIndex(int32 Cursor, bool* OutFound) const;
	const struct FMinimapMapSelectItem GetDataItemByIndex(int32 Cursor, bool* OutFound) const;
	struct FMinimapMapSelectItem GetFirstChildItem(int32 Cursor, bool* OutFound) const;
	const struct FMinimapMapSelectItem GetParentItemByIndex(int32 Cursor, bool* OutFound) const;
	int32 SearchChildIndexByMapId(int32 MapId, int32 AreaId, bool* OutFound) const;
	const struct FMinimapMapSelectItem SearchItemByMapId(int32 MapId, int32 AreaId, bool* OutFound) const;
	int32 SearchParentIndexByMapId(int32 MapId, int32 AreaId, bool* OutFound) const;
	bool SharesParent(int32 MapIdA, int32 AreaIdA, int32 MapIdB, int32 AreaIdB) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSelectManager">();
	}
	static class UMapSelectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSelectManager>();
	}
};
static_assert(alignof(UMapSelectManager) == 0x000008, "Wrong alignment on UMapSelectManager");
static_assert(sizeof(UMapSelectManager) == 0x000080, "Wrong size on UMapSelectManager");
static_assert(offsetof(UMapSelectManager, M_ParentCursor) == 0x000028, "Member 'UMapSelectManager::M_ParentCursor' has a wrong offset!");
static_assert(offsetof(UMapSelectManager, M_ChildCursor) == 0x00002C, "Member 'UMapSelectManager::M_ChildCursor' has a wrong offset!");
static_assert(offsetof(UMapSelectManager, M_Step) == 0x000030, "Member 'UMapSelectManager::M_Step' has a wrong offset!");
static_assert(offsetof(UMapSelectManager, M_ItemArray) == 0x000038, "Member 'UMapSelectManager::M_ItemArray' has a wrong offset!");
static_assert(offsetof(UMapSelectManager, M_ParentArray) == 0x000048, "Member 'UMapSelectManager::M_ParentArray' has a wrong offset!");
static_assert(offsetof(UMapSelectManager, M_ChildArray) == 0x000058, "Member 'UMapSelectManager::M_ChildArray' has a wrong offset!");
static_assert(offsetof(UMapSelectManager, M_AreaInMapArray) == 0x000068, "Member 'UMapSelectManager::M_AreaInMapArray' has a wrong offset!");

// Class Project.MinimapPOIManager
// 0x00E8 (0x0110 - 0x0028)
class UMinimapPOIManager final : public UObject
{
public:
	uint8                                         Pad_1BE6[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMinimapPOIEntry>               M_DynamicEntries;                                  // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BE7[0x88];                                    // 0x0048(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMinimapPOIOneMapData>          M_StaticMapEntries;                                // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FMinimapPOIEntry>               M_RenderEntries;                                   // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         M_ImageArray;                                      // 0x00F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        M_OnOffEffectArray;                                // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	bool ChangeDynamicPOIIconByOwner(E_MINIMAP_POI_TYPE POIType, class AActor* Owner, E_MINIMAP_POI_ICON NewIcon);
	bool ClearControlActorFromStatic(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId);
	bool Delete3DIconByDataId(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId);
	bool Delete3DIconByOwner(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, class AActor* Owner);
	TArray<struct FMinimapPOIEntry> GetRenderEntries();
	void RegisterDynamicPOI(const struct FMinimapPOIParam& InParam, class AActor* Owner, bool Show3D, const struct FVector& WorldLocationOffset);
	void ResetDynamicPOI();
	bool SetControlActorToStatic(int32 MapId, int32 AreaId, E_MINIMAP_POI_TYPE POIType, int32 DataId, class AActor* ControlActor);
	bool UnregisterDynamicPOIByOwner(class AActor* Owner);

	int32 GetRenderEntriesMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapPOIManager">();
	}
	static class UMinimapPOIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapPOIManager>();
	}
};
static_assert(alignof(UMinimapPOIManager) == 0x000008, "Wrong alignment on UMinimapPOIManager");
static_assert(sizeof(UMinimapPOIManager) == 0x000110, "Wrong size on UMinimapPOIManager");
static_assert(offsetof(UMinimapPOIManager, M_DynamicEntries) == 0x000038, "Member 'UMinimapPOIManager::M_DynamicEntries' has a wrong offset!");
static_assert(offsetof(UMinimapPOIManager, M_StaticMapEntries) == 0x0000D0, "Member 'UMinimapPOIManager::M_StaticMapEntries' has a wrong offset!");
static_assert(offsetof(UMinimapPOIManager, M_RenderEntries) == 0x0000E0, "Member 'UMinimapPOIManager::M_RenderEntries' has a wrong offset!");
static_assert(offsetof(UMinimapPOIManager, M_ImageArray) == 0x0000F0, "Member 'UMinimapPOIManager::M_ImageArray' has a wrong offset!");
static_assert(offsetof(UMinimapPOIManager, M_OnOffEffectArray) == 0x000100, "Member 'UMinimapPOIManager::M_OnOffEffectArray' has a wrong offset!");

// Class Project.MinimapRadarManager
// 0x0020 (0x0048 - 0x0028)
class UMinimapRadarManager final : public UObject
{
public:
	uint8                                         Pad_1BF4[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMinimapRadarEntry>             M_Entries;                                         // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapRadarManager">();
	}
	static class UMinimapRadarManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapRadarManager>();
	}
};
static_assert(alignof(UMinimapRadarManager) == 0x000008, "Wrong alignment on UMinimapRadarManager");
static_assert(sizeof(UMinimapRadarManager) == 0x000048, "Wrong size on UMinimapRadarManager");
static_assert(offsetof(UMinimapRadarManager, M_Entries) == 0x000038, "Member 'UMinimapRadarManager::M_Entries' has a wrong offset!");

// Class Project.MissionEventBase
// 0x0000 (0x0220 - 0x0220)
class AMissionEventBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEventBase">();
	}
	static class AMissionEventBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionEventBase>();
	}
};
static_assert(alignof(AMissionEventBase) == 0x000008, "Wrong alignment on AMissionEventBase");
static_assert(sizeof(AMissionEventBase) == 0x000220, "Wrong size on AMissionEventBase");

// Class Project.MoonAgeBase
// 0x0000 (0x0220 - 0x0220)
class AMoonAgeBase : public AActor
{
public:
	void AddMoonAgeCount();
	bool CheckUpdateMoonAge(const float CheckValue);
	float GetMoonAgeUpdateCount(bool IsTokyo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonAgeBase">();
	}
	static class AMoonAgeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoonAgeBase>();
	}
};
static_assert(alignof(AMoonAgeBase) == 0x000008, "Wrong alignment on AMoonAgeBase");
static_assert(sizeof(AMoonAgeBase) == 0x000220, "Wrong size on AMoonAgeBase");

// Class Project.MovieSceneFacialAnimationPresetSection
// 0x0770 (0x0858 - 0x00E8)
class UMovieSceneFacialAnimationPresetSection final : public UMovieSceneSection
{
public:
	class UFacialAnimationPreset*                 PresetData;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT00_Effect;                                      // 0x00F0(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT01_FresnelEffect;                               // 0x0190(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT02_SilhouetteEffect;                            // 0x0230(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT03_LightEffectA;                                // 0x02D0(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT04_LightEffectB;                                // 0x0370(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT05_ShadowEffect;                                // 0x0410(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT06_FaceEffectA;                                 // 0x04B0(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT07_FaceEffectB;                                 // 0x0550(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT08_FaceSweatA;                                  // 0x05F0(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT08_FaceSweatB;                                  // 0x0690(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                EVT08_FaceSweatC;                                  // 0x0730(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneFacialEventSectionData      EventData;                                         // 0x07D0(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFacialAnimationPresetSection">();
	}
	static class UMovieSceneFacialAnimationPresetSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFacialAnimationPresetSection>();
	}
};
static_assert(alignof(UMovieSceneFacialAnimationPresetSection) == 0x000008, "Wrong alignment on UMovieSceneFacialAnimationPresetSection");
static_assert(sizeof(UMovieSceneFacialAnimationPresetSection) == 0x000858, "Wrong size on UMovieSceneFacialAnimationPresetSection");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, PresetData) == 0x0000E8, "Member 'UMovieSceneFacialAnimationPresetSection::PresetData' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT00_Effect) == 0x0000F0, "Member 'UMovieSceneFacialAnimationPresetSection::EVT00_Effect' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT01_FresnelEffect) == 0x000190, "Member 'UMovieSceneFacialAnimationPresetSection::EVT01_FresnelEffect' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT02_SilhouetteEffect) == 0x000230, "Member 'UMovieSceneFacialAnimationPresetSection::EVT02_SilhouetteEffect' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT03_LightEffectA) == 0x0002D0, "Member 'UMovieSceneFacialAnimationPresetSection::EVT03_LightEffectA' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT04_LightEffectB) == 0x000370, "Member 'UMovieSceneFacialAnimationPresetSection::EVT04_LightEffectB' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT05_ShadowEffect) == 0x000410, "Member 'UMovieSceneFacialAnimationPresetSection::EVT05_ShadowEffect' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT06_FaceEffectA) == 0x0004B0, "Member 'UMovieSceneFacialAnimationPresetSection::EVT06_FaceEffectA' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT07_FaceEffectB) == 0x000550, "Member 'UMovieSceneFacialAnimationPresetSection::EVT07_FaceEffectB' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT08_FaceSweatA) == 0x0005F0, "Member 'UMovieSceneFacialAnimationPresetSection::EVT08_FaceSweatA' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT08_FaceSweatB) == 0x000690, "Member 'UMovieSceneFacialAnimationPresetSection::EVT08_FaceSweatB' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EVT08_FaceSweatC) == 0x000730, "Member 'UMovieSceneFacialAnimationPresetSection::EVT08_FaceSweatC' has a wrong offset!");
static_assert(offsetof(UMovieSceneFacialAnimationPresetSection, EventData) == 0x0007D0, "Member 'UMovieSceneFacialAnimationPresetSection::EventData' has a wrong offset!");

// Class Project.BPL_MultiLineRichText
// 0x0000 (0x0028 - 0x0028)
class UBPL_MultiLineRichText final : public UBlueprintFunctionLibrary
{
public:
	static const TArray<class FString> CreateLineStringArray(class FString& SrcStr);
	static const struct FMargin GetLocalizedOffset(struct FSlateFontInfo& InFont);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_MultiLineRichText">();
	}
	static class UBPL_MultiLineRichText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_MultiLineRichText>();
	}
};
static_assert(alignof(UBPL_MultiLineRichText) == 0x000008, "Wrong alignment on UBPL_MultiLineRichText");
static_assert(sizeof(UBPL_MultiLineRichText) == 0x000028, "Wrong size on UBPL_MultiLineRichText");

// Class Project.OptionBase
// 0x00F0 (0x0310 - 0x0220)
class AOptionBase final : public AActor
{
public:
	uint8                                         Pad_1BF7[0xF0];                                    // 0x0220(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyChangedValue(const class UObject* WorldContextObject);
	void ApplyTimedItemSettings(bool Reset);
	void DiscardKeySelect(int32 Category);
	int32 GetCategoryMax();
	int32 GetDetailMainTextID(int32 Category, int32 SlotIndex);
	int32 GetDetailTitleID(int32 Category, int32 SlotIndex);
	bool GetEtcSaveNeeds();
	int32 GetHelpMessageId(int32 Category, int32 SlotIndex);
	int32 GetItemIndex(int32 Category, int32 SlotIndex);
	void GetKeySelectSlotSubText(TScriptInterface<class IMessageTagInterface> Dst, int32* ColorType, struct FKey* KeyType, const int32 Category, const int32 SlotIndex, const class UScriptMessageAsset* PMsgAsset);
	E_OPTION_CONTENT_LANGUAGE_TYPE GetSelectedVoiceType();
	int32 GetSelectionNum(int32 Category, int32 SlotIndex);
	E_BTN_HELP_MAPPING_KEY_TYPE GetSlotBtnIcon(const int32 Category, const int32 SlotIndex);
	int32 GetSlotListLength(int32 Category);
	const class FText GetSlotMainText(const int32 Category, const int32 SlotIndex, const class UScriptMessageAsset* PMsgAsset);
	void GetSlotSubText(TScriptInterface<class IMessageTagInterface> Dst, const int32 Category, const int32 SlotIndex, const class UScriptMessageAsset* PMsgAsset, const class UScriptMessageAsset* PDifficultyMsgAsset);
	E_OPTION_SLOT_TYPE GetSlotType(int32 Category, int32 SlotIndex);
	void Initialize(const class UObject* WorldContextObject, const uint8 UseType);
	bool IsAlreadyUsingKey(const struct FKey& Key, int32 Category, int32 Param_Index);
	bool IsChangedItemIndex();
	bool IsChangedKeyboardLayout();
	bool IsChangedSettingsbyExternalControl();
	bool IsChangedTimedItemIndex();
	bool IsEnableKey(const struct FKey& Key, int32 Category, int32 Param_Index);
	bool IsExistDLC(E_OPTION_DLC_TYPE DlcType);
	bool IsExistUnsetMainKeySelect(int32 Category);
	bool IsKeySelectCancel(const struct FKey& Key);
	bool IsMainKeySlot(int32 Category, int32 Param_Index);
	bool IsMouseOnlyKeySlot(int32 Category, int32 Param_Index);
	bool IsSelectableSlot(int32 Category, int32 SlotIndex);
	void RecordCategoryKeySelect(int32 Category);
	void RecordNowWindowsSettings(const bool Initialize);
	bool RefrectDisplayBrightness(int32 Volume);
	E_OPTION_ADDITIONAL_RESPONCE RefrectSettingsDuringOptionControl(const class UObject* WorldContextObject, const int32 Category, const int32 SlotIndex);
	void ResetKeySelectList(const class UObject* WorldContextObject);
	void SetDefaultValue(const class UObject* WorldContextObject, const int32 In_Category);
	void SetItemIndex(int32 Category, int32 SlotIndex, int32 NewItemIndex);
	void SetSlotKeySelect(const struct FKey& Key, int32 Category, int32 Param_Index);
	void UnsetSlotKeySelect(int32 Category, int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionBase">();
	}
	static class AOptionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOptionBase>();
	}
};
static_assert(alignof(AOptionBase) == 0x000008, "Wrong alignment on AOptionBase");
static_assert(sizeof(AOptionBase) == 0x000310, "Wrong size on AOptionBase");

// Class Project.BPL_ActionAxisMapping
// 0x0000 (0x0028 - 0x0028)
class UBPL_ActionAxisMapping final : public UBlueprintFunctionLibrary
{
public:
	static void LoadDefaultInputIniFile();
	static void OutputActionAxisMappingCSV();
	static void OutputDefaultActionAxisMappingCSV(const TArray<struct FActionMappingInfoRow>& ActonMappingRows, const TArray<struct FAxisMappingInfoRow>& AxisMappingRows);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_ActionAxisMapping">();
	}
	static class UBPL_ActionAxisMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_ActionAxisMapping>();
	}
};
static_assert(alignof(UBPL_ActionAxisMapping) == 0x000008, "Wrong alignment on UBPL_ActionAxisMapping");
static_assert(sizeof(UBPL_ActionAxisMapping) == 0x000028, "Wrong size on UBPL_ActionAxisMapping");

// Class Project.ParticleModuleS3N2Base
// 0x0000 (0x0030 - 0x0030)
class UParticleModuleS3N2Base : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleS3N2Base">();
	}
	static class UParticleModuleS3N2Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleS3N2Base>();
	}
};
static_assert(alignof(UParticleModuleS3N2Base) == 0x000008, "Wrong alignment on UParticleModuleS3N2Base");
static_assert(sizeof(UParticleModuleS3N2Base) == 0x000030, "Wrong size on UParticleModuleS3N2Base");

// Class Project.ParticleModuleS3N2ActorCollision
// 0x0148 (0x0178 - 0x0030)
class UParticleModuleS3N2ActorCollision final : public UParticleModuleS3N2Base
{
public:
	struct FRawDistributionVector                 DampingFactor;                                     // 0x0030(0x0048)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 DampingFactorRotation;                             // 0x0078(0x0048)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  MaxCollisions;                                     // 0x00C0(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EParticleCollisionComplete                    CollisionCompletionOption;                         // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ES3N2ParticleCollisionType                    CollisionType;                                     // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C06[0xA];                                     // 0x00F2(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bApplyPhysics : 1;                                 // 0x00FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreTriggerVolumes : 1;                         // 0x00FC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C07[0x3];                                     // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ParticleMass;                                      // 0x0100(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         DirScalar;                                         // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPawnsDoNotDecrementCount : 1;                     // 0x0134(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyVerticalNormalsDecrementCount : 1;            // 0x0134(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C08[0x3];                                     // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalFudgeFactor;                               // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C09[0x4];                                     // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  DelayAmount;                                       // 0x0140(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCollideOnlyIfVisible : 1;                         // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreSourceActor : 1;                            // 0x0170(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C0A[0x3];                                     // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCollisionDistance;                              // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleS3N2ActorCollision">();
	}
	static class UParticleModuleS3N2ActorCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleS3N2ActorCollision>();
	}
};
static_assert(alignof(UParticleModuleS3N2ActorCollision) == 0x000008, "Wrong alignment on UParticleModuleS3N2ActorCollision");
static_assert(sizeof(UParticleModuleS3N2ActorCollision) == 0x000178, "Wrong size on UParticleModuleS3N2ActorCollision");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, DampingFactor) == 0x000030, "Member 'UParticleModuleS3N2ActorCollision::DampingFactor' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, DampingFactorRotation) == 0x000078, "Member 'UParticleModuleS3N2ActorCollision::DampingFactorRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, MaxCollisions) == 0x0000C0, "Member 'UParticleModuleS3N2ActorCollision::MaxCollisions' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, CollisionCompletionOption) == 0x0000F0, "Member 'UParticleModuleS3N2ActorCollision::CollisionCompletionOption' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, CollisionType) == 0x0000F1, "Member 'UParticleModuleS3N2ActorCollision::CollisionType' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, ParticleMass) == 0x000100, "Member 'UParticleModuleS3N2ActorCollision::ParticleMass' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, DirScalar) == 0x000130, "Member 'UParticleModuleS3N2ActorCollision::DirScalar' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, VerticalFudgeFactor) == 0x000138, "Member 'UParticleModuleS3N2ActorCollision::VerticalFudgeFactor' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, DelayAmount) == 0x000140, "Member 'UParticleModuleS3N2ActorCollision::DelayAmount' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2ActorCollision, MaxCollisionDistance) == 0x000174, "Member 'UParticleModuleS3N2ActorCollision::MaxCollisionDistance' has a wrong offset!");

// Class Project.ParticleModuleS3N2AttractorLine
// 0x00F0 (0x0120 - 0x0030)
class UParticleModuleS3N2AttractorLine final : public UParticleModuleS3N2Base
{
public:
	struct FRawDistributionVector                 BeginPoint;                                        // 0x0030(0x0048)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 EndPoint;                                          // 0x0078(0x0048)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Range;                                             // 0x00C0(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Strength;                                          // 0x00F0(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleS3N2AttractorLine">();
	}
	static class UParticleModuleS3N2AttractorLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleS3N2AttractorLine>();
	}
};
static_assert(alignof(UParticleModuleS3N2AttractorLine) == 0x000008, "Wrong alignment on UParticleModuleS3N2AttractorLine");
static_assert(sizeof(UParticleModuleS3N2AttractorLine) == 0x000120, "Wrong size on UParticleModuleS3N2AttractorLine");
static_assert(offsetof(UParticleModuleS3N2AttractorLine, BeginPoint) == 0x000030, "Member 'UParticleModuleS3N2AttractorLine::BeginPoint' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2AttractorLine, EndPoint) == 0x000078, "Member 'UParticleModuleS3N2AttractorLine::EndPoint' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2AttractorLine, Range) == 0x0000C0, "Member 'UParticleModuleS3N2AttractorLine::Range' has a wrong offset!");
static_assert(offsetof(UParticleModuleS3N2AttractorLine, Strength) == 0x0000F0, "Member 'UParticleModuleS3N2AttractorLine::Strength' has a wrong offset!");

// Class Project.BPL_PartyData
// 0x0000 (0x0028 - 0x0028)
class UBPL_PartyData final : public UBlueprintFunctionLibrary
{
public:
	static void AddHeroStatFlag(E_HERO_STAT Stat);
	static void AddNkmBst(int32 NkmIndex, int32 bst);
	static void AddNkmBstOne(int32 NkmIndex, E_BAD_STATUS bst);
	static void AddNkmDeffenceAishou(int32 NkmIndex, E_ATTRIBUTE_TYPE Type, int32 Value);
	static void AddNkmExp(int32 NkmIndex, int32 GetExp);
	static void AddNkmHP(int32 NkmIndex, int32 Value);
	static void AddNkmMP(int32 NkmIndex, int32 Value);
	static void AddPartyMakka(int32 Makka);
	static void AddPartySkillSource(int32 Source);
	static void AddPlayerAbility(E_PLAYER_TYPE PlayerType, E_PARAM_TYPE Type, int32 Value);
	static void AddPlayerBst(E_PLAYER_TYPE PlayerType, int32 bst);
	static void AddPlayerBstOne(E_PLAYER_TYPE PlayerType, E_BAD_STATUS bst);
	static void AddPlayerDeffenceAishou(E_PLAYER_TYPE PlayerType, E_ATTRIBUTE_TYPE Type, int32 Value);
	static void AddPlayerExp(E_PLAYER_TYPE PlayerType, int32 GetExp);
	static void AddPlayerHP(E_PLAYER_TYPE PlayerType, int32 Value);
	static void AddPlayerMAGGauge(int32 Value);
	static void AddPlayerMP(E_PLAYER_TYPE PlayerType, int32 Value);
	static void AddUpliftingGauge(int32 Add);
	static void CalcPlayerBuildSkillTekisei(E_PLAYER_TYPE PlayerType, E_SKILL_TEKISEI_CATEGORY Type, int32 Value);
	static void CalcPlayerDevilBuildSkillTekisei(int32 NakamaIndex, E_SKILL_TEKISEI_CATEGORY Type, int32 Value);
	static bool CanBeCorrectedSkillTekiseiForPlayer(E_PLAYER_TYPE PlayerType, E_SKILL_TEKISEI_CATEGORY Type, int32 Value);
	static bool CanBeCorrectedSkillTekiseiForPlayerDevil(int32 InNkmIndex, E_SKILL_TEKISEI_CATEGORY InType, int32 InValue);
	static void ChangeBtlNkmIndexArray(const TArray<uint8>& IndexArray);
	static void ChangeNkmIndexArray(const TArray<uint8>& IndexArray);
	static bool CheckHeroStatFlag(E_HERO_STAT Stat);
	static bool CheckNkmBst(int32 NkmIndex, int32 bst);
	static bool CheckNkmBstOne(int32 NkmIndex, E_BAD_STATUS bst);
	static int32 CheckNkmSkillSlotNum(int32 InNkmIndex);
	static bool CheckPartyAllCure();
	static bool CheckPlayerBst(E_PLAYER_TYPE PlayerType, int32 bst);
	static bool CheckPlayerBstOne(E_PLAYER_TYPE PlayerType, E_BAD_STATUS bst);
	static bool CheckPrimeMinisterNahobino();
	static void ClearNkmBattleUnit();
	static void ClearPlayerSkill(E_PLAYER_TYPE PlayerType, int32 SkillSlot);
	static void ClearShiseijoBackupData(const E_SHISEIJO& Shiseijo);
	static bool ClearStockNkmIndex();
	static int32 Const_GetNkmEntryMax();
	static bool DebugNkmSetBonusDevilFlag(int32 NkmIndex, int32 Val);
	static bool DebugNkmSetLevel(int32 NkmIndex, int32 Level, bool TakeOver_skill, bool TakeOver_tekisei, bool TakeOver_param);
	static bool DebugNkmSetParameter(int32 NkmIndex, E_ABILITY_TYPE Type, int32 Val);
	static bool DebugPlayerSetLevel(E_PLAYER_TYPE PlyType, int32 Level, bool TakeOver_skill, bool TakeOver_tekisei, bool TakeOver_param);
	static void DeleteNkmBst(int32 NkmIndex, int32 bst);
	static void DeleteNkmBstOne(int32 NkmIndex, E_BAD_STATUS bst);
	static void DeletePlayerBst(E_PLAYER_TYPE PlayerType, int32 bst);
	static void DeletePlayerBstOne(E_PLAYER_TYPE PlayerType, E_BAD_STATUS bst);
	static void DelHeroStatFlag(E_HERO_STAT Stat);
	static int32 EntryMaouBlank(int32 DevilID);
	static int32 EntryNkmBlank(int32 DevilID);
	static int32 EntryNkmBlankForFusion(int32 DevilID, bool bOpenAnalyze, bool IsOriginalSummon);
	static int32 GetBonusDevilSkillSlotNum();
	static const TArray<uint8> GetBtlNkmIndexArray();
	static int32 GetEntryNkmMax();
	static int32 GetEntryNkmNum();
	static int32 GetGlobalEntryId();
	static int32 GetGuestNum();
	static int32 GetGuestSkillSlotNum(int32 InNkmIndex);
	static int32 GetHeroStatFlag();
	static int32 GetLevelMax();
	static E_HERO_KIND GetMainHero();
	static bool GetMultiMagatsuhiSkillList(TArray<int32>* OutSkillList, int32 InDevilId);
	static TArray<int32> GetMultiMagatsuhiSkillUsageNkmIndexArray(int32 SkillId);
	static const struct FAbilData GetNkmAbility(const struct FNkmData& Data, bool Param_IsNahobino);
	static int32 GetNkmAbilityDataByAbilityName(int32 InNkmIndex, E_ABILITYNAME_TYPE InType);
	static int32 GetNkmAddGetSkill(int32 NkmIndex, int32 NkmLevel);
	static TArray<int32> GetNkmAllSkillList(const struct FNkmData& Data, bool Param_IsNahobino);
	static TArray<int32> GetNkmAutoSkillList(const struct FNkmData& Data, bool Param_IsNahobino);
	static int32 GetNkmAutoSkillSlot(int32 NkmIndex);
	static const TArray<uint8> GetNkmBattleUnitList();
	static int32 GetNkmBattleUnitNum();
	static int32 GetNkmBtlEntryCnt(int32 NkmIndex);
	static const struct FNkmData GetNkmData(int32 NkmIndex);
	static const TArray<int32> GetNkmDefenceAishou(const struct FNkmData& Data, bool Param_IsNahobino);
	static int32 GetNkmdUpLevel(int32 NkmIndex);
	static const TArray<uint8> GetNkmEntryListArray();
	static int32 GetNkmFriendshipLv(int32 NkmIndex);
	static int32 GetNkmHP(int32 NkmIndex);
	static int32 GetNkmIndexByAttrType(uint8 Attr1, uint8 Attr2);
	static TArray<int32> GetNkmIndexByAttrTypeArray(uint8 Attr1, uint8 Attr2);
	static int32 GetNkmIndexByDevilID(int32 DevilID);
	static int32 GetNkmIndexByEntryList(int32 EntryIndex);
	static int32 GetNkmLevel(int32 NkmIndex);
	static int32 GetNkmMP(int32 NkmIndex);
	static int32 GetNkmNextExp(int32 NkmIndex);
	static int32 GetNkmNextExp_Level(int32 NkmIndex, int32 Level);
	static int32 GetNkmSkillCost_NkmIndex(int32 NkmIndex, int32 SkillId);
	static TArray<int32> GetNkmSkillList(const struct FNkmData& Data, bool Param_IsNahobino);
	static int32 GetNkmSkillSlot(int32 NkmIndex);
	static int32 GetNkmSkillSlotNum();
	static const TArray<int32> GetNkmSkillTekisei(const struct FNkmData& Data, bool Param_IsNahobino);
	static int32 GetNkmSkillValidNum(int32 NkmIndex);
	static int32 GetNkmUniqueSkillId(int32 InNkmIndex);
	static TArray<E_PARTNER_ID> GetPartnerBattleUnitList();
	static const struct FPartnerData GetPartnerData(E_PARTNER_ID PartnerID);
	static int32 GetPartyMakka();
	static int32 GetPartyMakkaMax();
	static int32 GetPartySkillSource();
	static int32 GetPlayerAbilityDataByAbilityName(E_ABILITYNAME_TYPE InType);
	static int32 GetPlayerAddGetSkill(E_PLAYER_TYPE PlayerType, int32 PlayerLevel);
	static TArray<struct FAddGetSkill> GetPlayerAddGetSkillArray(E_PLAYER_TYPE PlayerType, int32 Level);
	static int32 GetPlayerAutoSkillSlot(E_PLAYER_TYPE PlayerType);
	static int32 GetPlayerBuildSkillTekiseiMax(int32 InType, E_PLAYER_TYPE PlayerType, E_SKILL_TEKISEI_CATEGORY Type);
	static const struct FCharData GetPlayerData(E_PLAYER_TYPE PlayerType);
	static int32 GetPlayerDevilBuildSkillTekiseiMax(int32 InNkmIndex, int32 InType, E_SKILL_TEKISEI_CATEGORY Type);
	static uint8 GetPlayerDevilIndexAfterBattle(int32 Args32Index);
	static int32 GetPlayerDevilSkillTekisei(int32 NakamaIndex, E_SKILL_TEKISEI_CATEGORY Type, int32 InKind);
	static int32 GetPlayerHP(E_PLAYER_TYPE PlayerType);
	static int32 GetPlayerLevel(E_PLAYER_TYPE PlayerType);
	static int32 GetPlayerMAGGauge();
	static int32 GetPlayerMAGGaugeMax();
	static int32 GetPlayerMAGGaugeStockNum();
	static int32 GetPlayerMP(E_PLAYER_TYPE PlayerType);
	static int32 GetPlayerNextExp(E_PLAYER_TYPE PlayerType);
	static int32 GetPlayerNextExp_Level(int32 Level);
	static int32 GetPlayerPanelPositionInBattle();
	static int32 GetPlayerSkillCost(E_PLAYER_TYPE PlayerType, int32 SkillId);
	static int32 GetPlayerSkillSlot(E_PLAYER_TYPE PlayerType);
	static int32 GetPlayerSkillSlotNum();
	static int32 GetPlayerSkillTekisei(E_SKILL_TEKISEI_CATEGORY Type, int32 InKind);
	static int32 GetPlayerSkillValidNum(E_PLAYER_TYPE PlayerType);
	static uint8 GetPlayerUnionLevel();
	static int32 GetPlayerUniqueSkillId();
	static int32 GetPlayerUpLevel(E_PLAYER_TYPE Type);
	static int32 GetPriorityOfDefenceAishou(int32 InDevilId, int32 InType);
	static int32 GetReassignablePlayerParamPoint();
	static int32 GetScenarioDevilSkillSlotNum();
	static const int32 GetShiseijoWinCount(const E_SHISEIJO& Shiseijo);
	static int32 GetShiseijyoNum();
	static int32 GetSkillTekiseiLimitByCategory(E_SKILL_TEKISEI_CATEGORY InCategory, int32 InLimitType);
	static int32 GetSkillTekiseiParameter(const TArray<int32>& SkillTekisei, int32 SkillId, E_SKILL_TEKISEI_CATEGORY ECategory, int32 EEftType);
	static int32 GetSotrWindowIndex(uint8 Type);
	static uint8 GetSotrWindowOrder(uint8 SortType);
	static int32 GetStockMax();
	static int32 GetStockMaxEnum();
	static uint8 GetStockNkmIndex(int32 InIndex);
	static void GetUniquSkillInfoReductionRelicCollectionTime(int32* OutCharaNum, int32* OutSkillValue);
	static int32 GetUpliftingGauge();
	static void IncShiseijoWinCount(const E_SHISEIJO& Shiseijo);
	static bool IsAogamiExist();
	static bool IsBonusDevil(int32 NkmIndex);
	static bool IsBoyExist();
	static bool IsDouble();
	static bool IsEnableMultiMagatsuhiSkillByDevilIdList(int32 SkillId, const TArray<int32>& DevilIdList, int32 UseDevilId);
	static bool IsEnableMultiMagatsuhiSkillByPartyData(int32 SkillId, int32 UseDevilId, bool CheckDead);
	static bool IsEntryNkm(int32 DevilID);
	static bool IsExistShiseijoBackupData(const E_SHISEIJO& Shiseijo);
	static bool IsGuest(int32 NkmIndex);
	static bool IsNahobino();
	static bool IsScenarioSkillSlotDevil(int32 DevilID);
	static bool IsScenarioSkillSlotNkm(int32 NkmIndex);
	static bool IsShiseijyoTao(const int32 InDevilId);
	static bool IsShiseijyoTaoByNkmIndex(const int32 NkmIndex);
	static bool IsShiseijyoYoko(const int32 InDevilId);
	static bool IsShiseijyoYokoByNkmIndex(const int32 NkmIndex);
	static bool IsValidNkmEntryList(int32 EntryIndex);
	static bool LoadGuestParameter(const int32 DevilID, struct FNkmData* OutGuestData);
	static void MakeupPartnerData();
	static void NkmAddBtlEntryCnt(int32 NkmIndex, uint8 Add);
	static void NkmDataClearAll();
	static void NkmDataInit(int32 NkmIndex, int32 DevilID, E_NKM_INIT_TYPE InitType, bool IsOriginalSummon);
	static void NkmDataSetGlobalFlag(int32 NkmIndex, uint8 Value, bool Sw);
	static int32 NkmGetAbilityBlank(int32 NkmIndex, E_ABILITY_TYPE Type);
	static int32 NkmGetAbilityBlankNoApply(int32 NkmIndex, E_ABILITY_TYPE Type);
	static void NkmGrowUp(int32 NkmIndex, int32 LvUp);
	static bool NkmIndexIsValid(int32 NkmIndex);
	static bool NkmIsBattleUnit(int32 NkmIndex);
	static bool NkmIsHaveSkill(int32 NkmIndex, int32 SkillId);
	static bool NkmIsUseableSkill(int32 NkmIndex, int32 SkillId);
	static bool NkmParamBuildUp(int32 NkmIndex, E_ABILITY_TYPE Type, int32 Point);
	static void NkmSetBtlEntryCnt(int32 NkmIndex, uint8 Val);
	static void NkmSetFriendshipLv(int32 NkmIndex, uint8 Level);
	static bool NkmSkillGet(int32 NkmIndex, int32 SkillId, E_LEARN_SKILL_TYPE LearnType);
	static void OffsetGuestLevel(struct FNkmData* NkmData, const int32 NkmIndex);
	static void PartnerDataSetGlobalFlag(E_PARTNER_ID PartnerID, uint8 Value, bool Sw);
	static bool PartnerIsBattleUnit(E_PARTNER_ID PartnerID);
	static void PartyAllCure();
	static void PayerForceSpecifiedLevel(E_PLAYER_TYPE PlayerType, int32 Level, bool IsAutoParamUp);
	static int32 PlayerGetAbilityBlank(E_PLAYER_TYPE PlayerType, E_ABILITY_TYPE Type);
	static int32 PlayerGetAbilityBlankNoApply(E_PLAYER_TYPE PlayerType, E_ABILITY_TYPE Type);
	static void PlayerGrowUp(E_PLAYER_TYPE PlayerType, int32 LvUp, bool IsAutoParamUp);
	static void PlayerGrowUp_Param(E_PLAYER_TYPE PlayerType, const struct FAbilData& AddAbil);
	static bool PlayerIsHaveSkill(E_PLAYER_TYPE PlayerType, int32 SkillId);
	static bool PlayerIsUseableSkill(E_PLAYER_TYPE PlayerType, int32 SkillId);
	static void PlayerLevelExpSync();
	static bool PlayerParamBuildUp(E_PLAYER_TYPE PlayerType, E_ABILITY_TYPE Type, int32 Point);
	static bool PlayerParamPointUp(E_PLAYER_TYPE PlayerType, E_ABILITY_TYPE Type, int32 Point);
	static void PlayerSetLevelOne(E_PLAYER_TYPE PlayerType);
	static bool PlayerSkillGet(E_PLAYER_TYPE PlayerType, int32 SkillId, E_LEARN_SKILL_TYPE LearnType);
	static bool ReBuildGlobalEntryId();
	static void RemoveNkm(int32 NkmIndex);
	static void RemoveNkmByDevilID(int32 DevilID);
	static void RemoveNkmFixedBattleIndex(int32 NkmIndex);
	static bool RemoveNkmInCamp(int32 NkmIndex);
	static bool ResetGlobalEntryId();
	static void ResetPartyUniqueSkill();
	static void ResetPlayerGrowUp_Param();
	static void ResetSetPlayerDevilIndexAfterBattle(int32 Args32Index, int32 Args32NakamaIndex);
	static bool ReturnStockNkm(int32 InNkmIndex);
	static void SaveGuestParameter(const int32 NkmIndex);
	static void SaveGuestParameterbyNkmData(const struct FNkmData& NkmData);
	static void SaveShiseijoParameterAll();
	static void SetMainHero(E_HERO_KIND MainHero);
	static bool SetNkmBattleUnit(int32 NkmIndex, bool Sw);
	static bool SetNkmBattleUnitBlank(int32 NkmIndex, bool Sw);
	static void SetNkmBst(int32 NkmIndex, int32 bst);
	static void SetNkmDeffenceAishou(int32 NkmIndex, E_ATTRIBUTE_TYPE Type, int32 Value);
	static void SetNkmHPMP(int32 NkmIndex, int32 Hp, int32 Mp);
	static void SetNkmSkill(int32 NkmIndex, int32 SkillSlot, int32 SkillId, E_LEARN_SKILL_TYPE LearnType);
	static void SetNkmSkillTekisei(int32 NkmIndex, E_SKILL_TEKISEI_CATEGORY Type, int32 Value);
	static void SetPartnerBattleUnit(E_PARTNER_ID PartnerID, bool Sw);
	static void SetPartyMakka(int32 Makka);
	static void SetPlayerAbility(E_PLAYER_TYPE PlayerType, E_PARAM_TYPE Type, int32 Value);
	static void SetPlayerBst(E_PLAYER_TYPE PlayerType, int32 bst);
	static void SetPlayerBuildSkillTekisei(E_PLAYER_TYPE PlayerType, E_SKILL_TEKISEI_CATEGORY Type, int32 Value);
	static void SetPlayerDeffenceAishou(E_PLAYER_TYPE PlayerType, E_ATTRIBUTE_TYPE Type, int32 Value);
	static void SetPlayerDevilBuildSkillTekisei(int32 NakamaIndex, E_SKILL_TEKISEI_CATEGORY Type, int32 Value);
	static void SetPlayerDevilIndexAfterBattle(int32 Args32Index, int32 Args32NakamaIndex);
	static void SetPlayerHPMP(E_PLAYER_TYPE PlayerType, int32 Hp, int32 Mp);
	static void SetPlayerMAGGauge(int32 Value);
	static void SetPlayerMAGGaugeStockNum(int32 Value);
	static void SetPlayerName(E_PLAYER_TYPE PlayerType, const class FString& Param_Name);
	static void SetPlayerPanelPositionInBattle(int32 Args32Index);
	static void SetPlayerSkill(E_PLAYER_TYPE PlayerType, int32 SkillSlot, int32 SkillId, E_LEARN_SKILL_TYPE LearnType);
	static void SetPlayerSkillTekisei(E_PLAYER_TYPE PlayerType, E_SKILL_TEKISEI_CATEGORY Type, int32 Value);
	static void SetPlayerUnionLevel(uint8 Value);
	static void SetShiseijoWinCount(const E_SHISEIJO& Shiseijo, const int32& Value);
	static void SetSotrWindowIndex(uint8 Type, int32 Param_Index);
	static void SetSotrWindowOrder(uint8 SprtType, uint8 Order);
	static bool SetStockMax(int32 InStockMax);
	static bool SetStockNkmIndex(int32 InIndex, int32 InNkmIndex);
	static void SortEntryNkmList();
	static bool SummonBattleNkm(int32 InNkmIndex);
	static void UpdateBtlNkmIndexArray();
	static void UpdateNkmParam(int32 NkmIndex);
	static void UpdatePlayerParam(E_PLAYER_TYPE PlayerType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_PartyData">();
	}
	static class UBPL_PartyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_PartyData>();
	}
};
static_assert(alignof(UBPL_PartyData) == 0x000008, "Wrong alignment on UBPL_PartyData");
static_assert(sizeof(UBPL_PartyData) == 0x000028, "Wrong size on UBPL_PartyData");

// Class Project.PauseUserWidget
// 0x0008 (0x0268 - 0x0260)
class UPauseUserWidget : public UUserWidget
{
public:
	bool                                          bTickEvenWhenPaused;                               // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8E[0x7];                                     // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetTickableWhenPaused();
	void SetTickableWhenPaused(bool bTickableWhenPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseUserWidget">();
	}
	static class UPauseUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseUserWidget>();
	}
};
static_assert(alignof(UPauseUserWidget) == 0x000008, "Wrong alignment on UPauseUserWidget");
static_assert(sizeof(UPauseUserWidget) == 0x000268, "Wrong size on UPauseUserWidget");
static_assert(offsetof(UPauseUserWidget, bTickEvenWhenPaused) == 0x000260, "Member 'UPauseUserWidget::bTickEvenWhenPaused' has a wrong offset!");

// Class Project.BPL_SaveLoadROM
// 0x0000 (0x0028 - 0x0028)
class UBPL_SaveLoadROM final : public UBlueprintFunctionLibrary
{
public:
	static void SaveLoadROM_Load(class UMMIAsset* PAsset);
	static void SaveLoadROM_LoadObject(class UObject* PObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_SaveLoadROM">();
	}
	static class UBPL_SaveLoadROM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_SaveLoadROM>();
	}
};
static_assert(alignof(UBPL_SaveLoadROM) == 0x000008, "Wrong alignment on UBPL_SaveLoadROM");
static_assert(sizeof(UBPL_SaveLoadROM) == 0x000028, "Wrong size on UBPL_SaveLoadROM");

// Class Project.BPL_PieceData
// 0x0000 (0x0028 - 0x0028)
class UBPL_PieceData final : public UBlueprintFunctionLibrary
{
public:
	static void AddPieceHaveNum(int32 ItemId, int32 Add, int32* ChangeItemNum, int32* NextPieceNum);
	static const struct FPieceData GetPieceData(int32 ID);
	static bool GetPieceHaveFlag(int32 ItemId);
	static int32 GetPieceHaveNum(int32 ItemId);
	static E_PIECE_MAJOR_TYPE GetPieceMajorType(int32 ID);
	static E_PIECE_TYPE GetPieceType(int32 ID);
	static void SetPieceHaveFlag(int32 ItemId, bool Flag);
	static void SetPieceHaveNum(int32 ItemId, int32 Num);
	static class AActor* SpawnMovePieceActor(class UObject* PWorldContextObject, class UClass* PClass, const struct FTransform& Transform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_PieceData">();
	}
	static class UBPL_PieceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_PieceData>();
	}
};
static_assert(alignof(UBPL_PieceData) == 0x000008, "Wrong alignment on UBPL_PieceData");
static_assert(sizeof(UBPL_PieceData) == 0x000028, "Wrong size on UBPL_PieceData");

// Class Project.PlayerMovementComponent
// 0x0230 (0x0380 - 0x0150)
class alignas(0x10) UPlayerMovementComponent final : public UCharaMovementComponent
{
public:
	float                                         VelocityMin;                                       // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityMax;                                       // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashVelocityMax;                                   // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingVelocityMax;                                // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityMaxFallen;                                 // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeed;                                     // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeed_OnSpot;                              // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransientRotationSpeedRate;                        // 0x016C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashAcceleration;                                  // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingAcceleration;                               // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deceleration;                                      // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepupAngleThreshold;                              // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepupHeightThreshold;                             // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepdownHeightThreshold;                           // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeRotationSpeed;                                // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MomentRotation;                                    // 0x0190(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                IdealVelocity;                                     // 0x019C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardMovementRatio;                              // 0x01A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SlopeRotation;                                     // 0x01AC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         WallSlipCnt;                                       // 0x01B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputInterpSpeed;                                  // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CV_InputMap;                                       // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C94[0x35];                                    // 0x01C8(0x0035)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableBrake;                                      // 0x01FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTurn;                                       // 0x01FE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWalkBrakeStandby;                                 // 0x01FF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunBrakeStandby;                                  // 0x0200(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunTurnStandby;                                   // 0x0201(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDashTurnStandby;                                  // 0x0202(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDashSharpTurn;                                    // 0x0203(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowWalkBrakeMovement;                           // 0x0204(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExceptionBrakeTrigger;                            // 0x0205(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C95[0x16];                                    // 0x0206(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDashing;                                          // 0x021C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSliding;                                    // 0x021D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSliding_Transient_OnWater;                 // 0x021E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C96[0x1];                                     // 0x021F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlidingStartSlopeAngle;                            // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingStartCheckTime;                             // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingStartDashSlopeAngle;                        // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingStartDashCheckTime;                         // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingFinishSlopeAngle;                           // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingFinishCheckTime;                            // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSliding;                                          // 0x0238(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C97[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoRun;                                          // 0x0240(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableJump;                                       // 0x0241(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableJumpTransient;                              // 0x0242(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableJumpForAttack;                              // 0x0243(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityJump;                                       // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityJump;                                      // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnAirTimeForForceTeleport;                         // 0x024C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C98[0x14];                                    // 0x0250(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableEdgeGrip;                                   // 0x0264(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C99[0x3];                                     // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EdgeGripBodyHeight;                                // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeGripJumpVelocity;                              // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9A[0x80];                                    // 0x0270(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFoliageHitEffect>          FoliageHitEffectClass;                             // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFoliageInstancedStaticMeshComponent*> FoliageCompList;                                   // 0x02F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UStaticMesh>>     FoliageCompMeshList;                               // 0x0308(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9B[0x10];                                    // 0x0318(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoPilotWalkBrakeMargine;                         // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnArrivedMoveToTarget;                             // 0x032C(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C9C[0x44];                                    // 0x033C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGimmickForce(const struct FVector& Force, float DumpingSpeed);
	bool BeginEdgeGrip(const struct FVector& WallRight, const struct FVector& GripPoint);
	void ClearFoliageActorList();
	bool EndEdgeGrip();
	void ForceRotateActorWhileKeepingCamera(const struct FRotator& InNewRotation);
	bool Jump();
	void JumpTakeOff();
	void MoveToTarget(class AActor* TargetActor, float MoveSpeed, TDelegate<void()> OnArrived, float Distance, float TimeToGiveUp);
	void MoveToTargetDirection(const struct FVector& TargetDirection, float Distance, float MoveSpeed, TDelegate<void()> OnArrived, float TimeToGiveUp);
	void MoveToTargetLocation(const struct FVector& TargetLocation, float MoveSpeed, TDelegate<void()> OnArrived, float Distance, float TimeToGiveUp);
	TArray<class UParticleSystemComponent*> PlayAttackVsFoliageEffect(const struct FBox& InAttackAABB);
	void ResetBrakeTurnStandby();
	void ResetMovementInputVector();
	void ResetMovementState(bool bResetLanding, bool bResetLandingValue);
	void ResetMovementVelocity();
	void RotateToTarget(class AActor* TargetActor, TDelegate<void()> OnArrived, float TimeToGiveUp);
	void SetKeyFreeForce(const struct FVector& Force);
	void SetParamJump(float Param_GravityJump, float Param_VelocityJump);
	void TurnOnEdgeGripArrivalTrigger();
	void UpdateFoliageActorList();

	bool CanDebugJump() const;
	bool CanJump() const;
	bool EdgeGripAdjustFinished() const;
	float GetJumpHeight() const;
	float GetMovementSpeed() const;
	bool IsAutoPilotMoving() const;
	bool IsDashing() const;
	bool IsDashingForEffect() const;
	bool IsEdgeGripping() const;
	bool IsEdgeGrippingStrictly() const;
	bool IsJumping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMovementComponent">();
	}
	static class UPlayerMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMovementComponent>();
	}
};
static_assert(alignof(UPlayerMovementComponent) == 0x000010, "Wrong alignment on UPlayerMovementComponent");
static_assert(sizeof(UPlayerMovementComponent) == 0x000380, "Wrong size on UPlayerMovementComponent");
static_assert(offsetof(UPlayerMovementComponent, VelocityMin) == 0x000150, "Member 'UPlayerMovementComponent::VelocityMin' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, VelocityMax) == 0x000154, "Member 'UPlayerMovementComponent::VelocityMax' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, DashVelocityMax) == 0x000158, "Member 'UPlayerMovementComponent::DashVelocityMax' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlidingVelocityMax) == 0x00015C, "Member 'UPlayerMovementComponent::SlidingVelocityMax' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, VelocityMaxFallen) == 0x000160, "Member 'UPlayerMovementComponent::VelocityMaxFallen' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, RotationSpeed) == 0x000164, "Member 'UPlayerMovementComponent::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, RotationSpeed_OnSpot) == 0x000168, "Member 'UPlayerMovementComponent::RotationSpeed_OnSpot' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, TransientRotationSpeedRate) == 0x00016C, "Member 'UPlayerMovementComponent::TransientRotationSpeedRate' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, Acceleration) == 0x000170, "Member 'UPlayerMovementComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, DashAcceleration) == 0x000174, "Member 'UPlayerMovementComponent::DashAcceleration' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlidingAcceleration) == 0x000178, "Member 'UPlayerMovementComponent::SlidingAcceleration' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, Deceleration) == 0x00017C, "Member 'UPlayerMovementComponent::Deceleration' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, StepupAngleThreshold) == 0x000180, "Member 'UPlayerMovementComponent::StepupAngleThreshold' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, StepupHeightThreshold) == 0x000184, "Member 'UPlayerMovementComponent::StepupHeightThreshold' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, StepdownHeightThreshold) == 0x000188, "Member 'UPlayerMovementComponent::StepdownHeightThreshold' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlopeRotationSpeed) == 0x00018C, "Member 'UPlayerMovementComponent::SlopeRotationSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, MomentRotation) == 0x000190, "Member 'UPlayerMovementComponent::MomentRotation' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, IdealVelocity) == 0x00019C, "Member 'UPlayerMovementComponent::IdealVelocity' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, ForwardMovementRatio) == 0x0001A8, "Member 'UPlayerMovementComponent::ForwardMovementRatio' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlopeRotation) == 0x0001AC, "Member 'UPlayerMovementComponent::SlopeRotation' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, WallSlipCnt) == 0x0001B8, "Member 'UPlayerMovementComponent::WallSlipCnt' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, InputInterpSpeed) == 0x0001BC, "Member 'UPlayerMovementComponent::InputInterpSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, CV_InputMap) == 0x0001C0, "Member 'UPlayerMovementComponent::CV_InputMap' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bEnableBrake) == 0x0001FD, "Member 'UPlayerMovementComponent::bEnableBrake' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bEnableTurn) == 0x0001FE, "Member 'UPlayerMovementComponent::bEnableTurn' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bWalkBrakeStandby) == 0x0001FF, "Member 'UPlayerMovementComponent::bWalkBrakeStandby' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bRunBrakeStandby) == 0x000200, "Member 'UPlayerMovementComponent::bRunBrakeStandby' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bRunTurnStandby) == 0x000201, "Member 'UPlayerMovementComponent::bRunTurnStandby' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bDashTurnStandby) == 0x000202, "Member 'UPlayerMovementComponent::bDashTurnStandby' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bDashSharpTurn) == 0x000203, "Member 'UPlayerMovementComponent::bDashSharpTurn' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bAllowWalkBrakeMovement) == 0x000204, "Member 'UPlayerMovementComponent::bAllowWalkBrakeMovement' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bExceptionBrakeTrigger) == 0x000205, "Member 'UPlayerMovementComponent::bExceptionBrakeTrigger' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bDashing) == 0x00021C, "Member 'UPlayerMovementComponent::bDashing' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bEnableSliding) == 0x00021D, "Member 'UPlayerMovementComponent::bEnableSliding' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bDisableSliding_Transient_OnWater) == 0x00021E, "Member 'UPlayerMovementComponent::bDisableSliding_Transient_OnWater' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlidingStartSlopeAngle) == 0x000220, "Member 'UPlayerMovementComponent::SlidingStartSlopeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlidingStartCheckTime) == 0x000224, "Member 'UPlayerMovementComponent::SlidingStartCheckTime' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlidingStartDashSlopeAngle) == 0x000228, "Member 'UPlayerMovementComponent::SlidingStartDashSlopeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlidingStartDashCheckTime) == 0x00022C, "Member 'UPlayerMovementComponent::SlidingStartDashCheckTime' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlidingFinishSlopeAngle) == 0x000230, "Member 'UPlayerMovementComponent::SlidingFinishSlopeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, SlidingFinishCheckTime) == 0x000234, "Member 'UPlayerMovementComponent::SlidingFinishCheckTime' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bSliding) == 0x000238, "Member 'UPlayerMovementComponent::bSliding' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bAutoRun) == 0x000240, "Member 'UPlayerMovementComponent::bAutoRun' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bEnableJump) == 0x000241, "Member 'UPlayerMovementComponent::bEnableJump' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bEnableJumpTransient) == 0x000242, "Member 'UPlayerMovementComponent::bEnableJumpTransient' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bEnableJumpForAttack) == 0x000243, "Member 'UPlayerMovementComponent::bEnableJumpForAttack' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, GravityJump) == 0x000244, "Member 'UPlayerMovementComponent::GravityJump' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, VelocityJump) == 0x000248, "Member 'UPlayerMovementComponent::VelocityJump' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, OnAirTimeForForceTeleport) == 0x00024C, "Member 'UPlayerMovementComponent::OnAirTimeForForceTeleport' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, bEnableEdgeGrip) == 0x000264, "Member 'UPlayerMovementComponent::bEnableEdgeGrip' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, EdgeGripBodyHeight) == 0x000268, "Member 'UPlayerMovementComponent::EdgeGripBodyHeight' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, EdgeGripJumpVelocity) == 0x00026C, "Member 'UPlayerMovementComponent::EdgeGripJumpVelocity' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, FoliageHitEffectClass) == 0x0002F0, "Member 'UPlayerMovementComponent::FoliageHitEffectClass' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, FoliageCompList) == 0x0002F8, "Member 'UPlayerMovementComponent::FoliageCompList' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, FoliageCompMeshList) == 0x000308, "Member 'UPlayerMovementComponent::FoliageCompMeshList' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, AutoPilotWalkBrakeMargine) == 0x000328, "Member 'UPlayerMovementComponent::AutoPilotWalkBrakeMargine' has a wrong offset!");
static_assert(offsetof(UPlayerMovementComponent, OnArrivedMoveToTarget) == 0x00032C, "Member 'UPlayerMovementComponent::OnArrivedMoveToTarget' has a wrong offset!");

// Class Project.ProjectDebugManager
// 0x0058 (0x0080 - 0x0028)
class UProjectDebugManager final : public UObject
{
public:
	uint8                                         Pad_1CA1[0x58];                                    // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugDrawFlagChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectDebugManager">();
	}
	static class UProjectDebugManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectDebugManager>();
	}
};
static_assert(alignof(UProjectDebugManager) == 0x000008, "Wrong alignment on UProjectDebugManager");
static_assert(sizeof(UProjectDebugManager) == 0x000080, "Wrong size on UProjectDebugManager");

// Class Project.ProjectGameInstanceBase
// 0x1848 (0x19F0 - 0x01A8)
class alignas(0x10) UProjectGameInstanceBase : public UGameInstance
{
public:
	FMulticastInlineDelegateProperty_             OnEventDispather_UpdateButtonIcon;                 // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UProjectGCManager*                      GCManager;                                         // 0x01B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UProjectGCManager>          GCManagerClass;                                    // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectSoundManager*                   SoundManager;                                      // 0x01C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGardenTalkPointManager*                GardenTalkPointManager;                            // 0x01D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGardenManager*                         GardenManager;                                     // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UProjectSoundManager>       SoundManagerClass;                                 // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectUIManager*                      UIManager;                                         // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UProjectUIManager>          UIManagerClass;                                    // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAchievementManager*                    AchievementManager;                                // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivityManager*                       ActivityManager;                                   // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMinimapManager*                        MinimapManager;                                    // 0x0208(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFrameRateManager*                      FrameRateManager;                                  // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ActionMappingNameDataTable;                        // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             AxisMappingNameDataTable;                          // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DefaultActionMappingDataTable;                     // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DefaultAxisMappingDataTable;                       // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CA2[0x1780];                                  // 0x0238(0x1780)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebugMenuData*                         M_pDebugMenuDataInst;                              // 0x19B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectDebugManager*                   ProjectDebugManager;                               // 0x19C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugCameraManager*                    DebugCameraManager;                                // 0x19C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA3[0x20];                                    // 0x19D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateDebugMenuData(bool IsOverWrite);
	void CreateGameData();
	void GameFirstInitEvent();
	class UAchievementManager* GetAchievementManager();
	const class UDataTable* GetActionMappingNameDataTable();
	class UActivityManager* GetActivityManager();
	const class UDataTable* GetAxisMappingNameDataTable();
	class AActor* GetBattleMain();
	class UDebugCameraManager* GetDebugCameraManager();
	const class UDataTable* GetDefaultActionMappingDataTable();
	const class UDataTable* GetDefaultAxisMappingDataTable();
	void GetDeviceNotifySoundAssets(class USoundAtomCue** Cue);
	void GetDeviceNotifyViewAssets(class UMaterialInterface** OutMaterial, class UFont** OutFont);
	class UScriptMessageAsset* GetDifficultyMessage();
	class AEventBase* GetEventBase();
	class UFrameRateManager* GetFrameRateManager();
	class AGardenManager* GetGardenManager();
	class UGardenTalkPointManager* GetGardenTalkPointManager();
	class UProjectGCManager* GetGCManager();
	class UMinimapManager* GetMinimapManager();
	class UProjectDebugManager* GetProjectDebugManager();
	class UScriptMessageAsset* GetSonySaveMessage();
	class UProjectSoundManager* GetSoundManager();
	class UScriptMessageAsset* GetSystemMessage();
	class AMapWarpPoint* GetTextureBoostMapWarpPoint(const TArray<class AMapWarpPoint*>& MapWarpPoints);
	class UProjectUIManager* GetUIManager();
	void MakeUpAogamiDebrisDataTable(class UMMIAsset* PAsset);
	void MakeUpAttrNameDataTable(class UScriptMessageAsset* PName);
	void MakeUpBattleDataTable(class UMMIAsset* PAsset, class UScriptMessageAsset* PCommonMes);
	void MakeUpBattleEventTable(class UMMIAsset* PAsset);
	void MakeUpBossFlagTable(class UMMIAsset* PAsset);
	void MakeUpButtonHelpTable(class UMMIAsset* PAsset, class UScriptMessageAsset* PText);
	void MakeUpCameraSettingsTable(class UMMIAsset* PAsset);
	void MakeUpCharaNameDataTable(class UScriptMessageAsset* PName);
	void MakeUpCharGrowDataTable(class UMMIAsset* PAsset, class UMMIAsset* PPartnerAsset);
	void MakeUpCoasterDataTable(class UMMIAsset* PAsset);
	void MakeUpDBaseDataTable(class UMMIAsset* PAsset);
	void MakeUpDevilDataTable(class UMMIAsset* PAsset, class UScriptMessageAsset* PDevilName, class UScriptMessageAsset* PRaceName);
	void MakeUpDevilUIGraphicsDataTable(class UMMIAsset* PAsset, class UDataTable* LocalizedNameSortIdTable);
	void MakeUpEncountDataTable(class UMMIAsset* PAsset);
	void MakeUpEventEncountDataTable(class UMMIAsset* PAsset);
	void MakeUpEventFlagDataTable(class UMMIAsset* PAsset);
	void MakeUpFacilityShopTable(class UMMIAsset* PAsset);
	void MakeUpGardenTable(class UMMIAsset* PGardenMessageTable, class UMMIAsset* PGardenSystemTable, class UMMIAsset* PGardenItemTable, class UMMIAsset* PGardenPlayerTalkTable, class UScriptMessageAsset* PText, class UDataTable* GardenQuestDevilTable);
	void MakeUpGodParameterDataTable(class UMMIAsset* PAsset, class UScriptMessageAsset* PName, class UScriptMessageAsset* PHelp);
	void MakeUpGrowEventTable(class UMMIAsset* PAsset);
	void MakeUpItemDataTable(class UMMIAsset* PAsset, class UScriptMessageAsset* PItemName, class UScriptMessageAsset* PHelpMess);
	void MakeUpMapAreaNameDataTable(class UScriptMessageAsset* PName);
	void MakeUpMapEventDataTable(class UMMIAsset* PAsset);
	void MakeUpMimanDataTable(class UMMIAsset* PAsset);
	void MakeUpMimanRewardSetNameDataTable(class UScriptMessageAsset* PName);
	void MakeUpMissionDataTable(class UMMIAsset* PAsset, class UScriptMessageAsset* PName);
	void MakeUpNaviDevilDataTable(class UMMIAsset* PAsset);
	void MakeUpOptionTable(class UMMIAsset* PAsset);
	void MakeUpPieceDataTable(class UMMIAsset* PAsset);
	void MakeUpPlatformTermsTable(class UScriptMessageAsset* PName);
	void MakeUpPurposeTable(class UMMIAsset* PAsset);
	void MakeUpRelicDataTable(class UMMIAsset* PAsset);
	void MakeUpRyuketsuDataTable(class UMMIAsset* PAsset);
	void MakeUpShinseiDataTable(class UMMIAsset* PAsset);
	void MakeUpSkillDataTable(class UMMIAsset* PAsset, class UScriptMessageAsset* PSkillName, class UScriptMessageAsset* PSkillHelp, class UScriptMessageAsset* PSkillMasterHelp, class UMMIAsset* PInfoMesAsset, class UScriptMessageAsset* PInfoMes, class UScriptMessageAsset* PMasterInfoMes);
	void MakeUpSkillTargetNameDataTable(class UScriptMessageAsset* PName);
	void MakeUpSortWindowTable(class UMMIAsset* PAsset, class UScriptMessageAsset* PText);
	void MakeUpStaffRollTable(class UMMIAsset* PAsset);
	void MakeUpTakaraDataTable(class UMMIAsset* PAsset);
	void MakeUpTalkBaseTable(class UMMIAsset* PAsset);
	void MakeUpTutorialWindowTable(class UMMIAsset* PAsset);
	void MakeUpUniqueSymbolDataTable(class UMMIAsset* PAsset);
	void SetBoost(bool bEnabled);
	void SetGardenManager(class AGardenManager* NewGardenManager);

	const struct FTalkBaseTable GetTalkBaseTable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectGameInstanceBase">();
	}
	static class UProjectGameInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectGameInstanceBase>();
	}
};
static_assert(alignof(UProjectGameInstanceBase) == 0x000010, "Wrong alignment on UProjectGameInstanceBase");
static_assert(sizeof(UProjectGameInstanceBase) == 0x0019F0, "Wrong size on UProjectGameInstanceBase");
static_assert(offsetof(UProjectGameInstanceBase, OnEventDispather_UpdateButtonIcon) == 0x0001A8, "Member 'UProjectGameInstanceBase::OnEventDispather_UpdateButtonIcon' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, GCManager) == 0x0001B8, "Member 'UProjectGameInstanceBase::GCManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, GCManagerClass) == 0x0001C0, "Member 'UProjectGameInstanceBase::GCManagerClass' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, SoundManager) == 0x0001C8, "Member 'UProjectGameInstanceBase::SoundManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, GardenTalkPointManager) == 0x0001D0, "Member 'UProjectGameInstanceBase::GardenTalkPointManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, GardenManager) == 0x0001D8, "Member 'UProjectGameInstanceBase::GardenManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, SoundManagerClass) == 0x0001E0, "Member 'UProjectGameInstanceBase::SoundManagerClass' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, UIManager) == 0x0001E8, "Member 'UProjectGameInstanceBase::UIManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, UIManagerClass) == 0x0001F0, "Member 'UProjectGameInstanceBase::UIManagerClass' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, AchievementManager) == 0x0001F8, "Member 'UProjectGameInstanceBase::AchievementManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, ActivityManager) == 0x000200, "Member 'UProjectGameInstanceBase::ActivityManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, MinimapManager) == 0x000208, "Member 'UProjectGameInstanceBase::MinimapManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, FrameRateManager) == 0x000210, "Member 'UProjectGameInstanceBase::FrameRateManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, ActionMappingNameDataTable) == 0x000218, "Member 'UProjectGameInstanceBase::ActionMappingNameDataTable' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, AxisMappingNameDataTable) == 0x000220, "Member 'UProjectGameInstanceBase::AxisMappingNameDataTable' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, DefaultActionMappingDataTable) == 0x000228, "Member 'UProjectGameInstanceBase::DefaultActionMappingDataTable' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, DefaultAxisMappingDataTable) == 0x000230, "Member 'UProjectGameInstanceBase::DefaultAxisMappingDataTable' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, M_pDebugMenuDataInst) == 0x0019B8, "Member 'UProjectGameInstanceBase::M_pDebugMenuDataInst' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, ProjectDebugManager) == 0x0019C0, "Member 'UProjectGameInstanceBase::ProjectDebugManager' has a wrong offset!");
static_assert(offsetof(UProjectGameInstanceBase, DebugCameraManager) == 0x0019C8, "Member 'UProjectGameInstanceBase::DebugCameraManager' has a wrong offset!");

// Class Project.ProjectGCManager
// 0x0088 (0x00B0 - 0x0028)
class UProjectGCManager : public UObject
{
public:
	uint8                                         Pad_1CA4[0x2C];                                    // 0x0028(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CollectObjectCount;                                // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           DisregardForGCClasses;                             // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ResidentClasses;                                   // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         DisregardForGCClassObjects;                        // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        ResidentClassObjects;                              // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             OnPostGC;                                          // 0x0098(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CA5[0x8];                                     // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UProjectGCManager* Get(const class UObject* WorldContextObject);

	void AsyncLoadResidentAssets();
	void Collect(const class FString& LogKeyword, EGCPriority Priority);
	void ReleaseAndCollectResidentAssets(TDelegate<void()> OnReleased);

	bool IsCompletedLoadResidentAssets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectGCManager">();
	}
	static class UProjectGCManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectGCManager>();
	}
};
static_assert(alignof(UProjectGCManager) == 0x000008, "Wrong alignment on UProjectGCManager");
static_assert(sizeof(UProjectGCManager) == 0x0000B0, "Wrong size on UProjectGCManager");
static_assert(offsetof(UProjectGCManager, CollectObjectCount) == 0x000054, "Member 'UProjectGCManager::CollectObjectCount' has a wrong offset!");
static_assert(offsetof(UProjectGCManager, DisregardForGCClasses) == 0x000058, "Member 'UProjectGCManager::DisregardForGCClasses' has a wrong offset!");
static_assert(offsetof(UProjectGCManager, ResidentClasses) == 0x000068, "Member 'UProjectGCManager::ResidentClasses' has a wrong offset!");
static_assert(offsetof(UProjectGCManager, DisregardForGCClassObjects) == 0x000078, "Member 'UProjectGCManager::DisregardForGCClassObjects' has a wrong offset!");
static_assert(offsetof(UProjectGCManager, ResidentClassObjects) == 0x000088, "Member 'UProjectGCManager::ResidentClassObjects' has a wrong offset!");
static_assert(offsetof(UProjectGCManager, OnPostGC) == 0x000098, "Member 'UProjectGCManager::OnPostGC' has a wrong offset!");

// Class Project.BPL_ProjectLevel
// 0x0000 (0x0028 - 0x0028)
class UBPL_ProjectLevel final : public UBlueprintFunctionLibrary
{
public:
	static class FString EProjectStreamingStatusToString(EProjectStreamingStatus Status);
	static TArray<struct FProjectSubLevelStatus> ProjectGetSubLevelStatusArray(class UObject* WorldContextObject);
	static void ProjectHideAllSubLevels(class UObject* WorldContextObject, bool IsForceUpdate);
	static void ProjectLevelFlushLevelStreaming(class UObject* WorldContextObject, bool IsVisibilityOnly);
	static bool ProjectLevelIsReady(class UObject* WorldContextObject, bool UpdateIfNotReady);
	static void ProjectLevelStatusPrint(class UObject* WorldContextObject);
	static bool ProjectLevelUseBridgeLevelForSameLevelChange(class UObject* WorldContextObject, int32 PrevMapId, int32 PrevAreaId, int32 NextMapId, int32 NextAreaId);
	static void ProjectLevelWaitLightMapStream(class UObject* WorldContextObject);
	static void ProjectPrintLightmapInfo(class UObject* WorldContextObject);
	static void ProjectPropagateLightingScenarioChange(class UObject* WorldContextObject);
	static void ProjectSetSubLevelStatus(class UObject* WorldContextObject, const TArray<struct FProjectSubLevelStatus>& SubLevelStatusArray, bool IsForceUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_ProjectLevel">();
	}
	static class UBPL_ProjectLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_ProjectLevel>();
	}
};
static_assert(alignof(UBPL_ProjectLevel) == 0x000008, "Wrong alignment on UBPL_ProjectLevel");
static_assert(sizeof(UBPL_ProjectLevel) == 0x000028, "Wrong size on UBPL_ProjectLevel");

// Class Project.ProjectSoundManager
// 0x04A8 (0x04D0 - 0x0028)
class UProjectSoundManager : public UObject
{
public:
	uint8                                         Pad_1CAD[0x88];                                    // 0x0028(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          CursorSE;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          DecideSE;                                          // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          CancelSE;                                          // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          ErrorSE;                                           // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          ActionWindowOpenSE;                                // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          ActionWindowCloseSE;                               // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          ActionWindowDecideSE;                              // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          MessageSkipSE;                                     // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          BattleCursorSE;                                    // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          BattleCursor2SE;                                   // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          BattleDecideSE;                                    // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          BattleDecide2SE;                                   // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          BattleCancelSE;                                    // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         CursorSEComp;                                      // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         DecideSEComp;                                      // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         CancelSEComp;                                      // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         ErrorSEComp;                                       // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         ActionWindowOpenComp;                              // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         ActionWindowCloseComp;                             // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         ActionWindowDecideComp;                            // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         MessageSkipComp;                                   // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         BattleCursorSEComp;                                // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         BattleCursor2SEComp;                               // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         BattleDecideSEComp;                                // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         BattleDecide2SEComp;                               // 0x0170(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         BattleCancelSEComp;                                // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDevilVoiceAssetMap>        DevilVoiceAssetMap;                                // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBGMSceneChanged;                                 // 0x0188(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          CurrentBGM;                                        // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          NextBGM;                                           // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CAE[0x8];                                     // 0x01A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBgmScene, class USoundAtomCue*>         SceneBGMMap;                                       // 0x01B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CAF[0x50];                                    // 0x0200(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBGMRequest                            BGMRequest;                                        // 0x0250(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CB0[0x28];                                    // 0x0270(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          MapCrisisBGM;                                      // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CB1[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          QuestMapBGM;                                       // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CB2[0x8];                                     // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          CoasterBGM;                                        // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          CurrentMainENV;                                    // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          CurrentSubENV;                                     // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          NotPriorityMainENV;                                // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          NotPrioritySubENV;                                 // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CB3[0x188];                                   // 0x02E0(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapUniqueFuncCounter;                              // 0x0468(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CB4[0x54];                                    // 0x046C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ListenerActor;                                     // 0x04C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CB5[0x8];                                     // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UProjectSoundManager* Get(const class UObject* WorldContextObject);
	static void PrintSoundVerbose(const class FString& InString, bool bVeryVerbose);

	void BeginMapCrisisBGM(class USoundAtomCue* InCue);
	void DecrementDefaultAttenuationRefCnt();
	void EndEncountEffect();
	void EndMapCrisisBGM();
	void ForceStopENV(float FadeTime);
	class USoundAtomCue* GetBGM(EBgmScene Scene);
	void IncrementDefaultAttenuationRefCnt();
	void InReverbArea(EReverbType ReverbType, int32 Priority);
	void OnBeginPlay();
	void OnEndPlay();
	void OutReverbArea(EReverbType ReverbType, int32 Priority);
	void PauseBGM();
	void PauseENV();
	void PlayerPawnOperational();
	void PlayPriorityBGM(class USoundAtomCue* Cue, EFadeType FadeType, float FadeTime, bool bForceReplay);
	void PlayPriorityENV(class USoundAtomCue* Cue, float FadeTime, bool bForceReplay);
	void PlaySystemSE(ESystemSE SE);
	void PreTerminateBattleScene();
	void ResetBGMSelectorLabel(EBgmScene Scene);
	void ResetGameVolume(bool bImmediately);
	void ResetPerGame();
	void ResumeBGM();
	void ResumeENV();
	void SetBattleSub2Mute(bool bMute, bool bFade);
	void SetBattleSub3Mute(bool bMute, bool bFade);
	void SetBattleSubMute(bool bMute, bool bFade);
	void SetBGM(EBgmScene Scene, class USoundAtomCue* Cue, EFadeType FadeType, bool bForceReplay);
	void SetBGMRequestPosition(float InStartPositionSeconds);
	void SetBGMScene(EBgmScene Scene, EFadeType FadeType, bool bForceReplay);
	void SetBGMSelectorLabel(EBgmScene Scene, const class FString& Selector, const class FString& Label);
	void SetCoasterBGM(class USoundAtomCue* Cue);
	void SetFieldBGMVolume(float Volume, float FadeTime);
	void SetGameVolume(EGameVolumeCategory Category, float Volume, float FadeValuePerSecond);
	void SetGardenMode(bool bin);
	void SetListenerActor(class AActor* InListenerActor);
	void SetMainENV(class USoundAtomCue* Cue);
	void SetMapTopCameraMode(bool bin);
	void SetMasterVolume(float Volume);
	void SetOffCategoryAisac(class FName InCategory, class FName InAisac, bool bIgnoreWarning);
	void SetOnCategoryAisac(class FName InCategory, class FName InAisac);
	void SetOptionVolume(EOptionVolumeCategory Category, float Volume);
	void SetQuestMapBGM(class USoundAtomCue* Cue);
	void SetSubENV(class USoundAtomCue* Cue);
	void SetSubENVRate(float InRate);
	void SetVoiceStop_BattleSub1(bool bStop);
	void StartEncountEffect();
	void StopAllSkillSE();
	void StopBattleSubSound();
	void StopBGM(EBgmScene Scene, EFadeoutType FadeType);
	void StopCategory(EGameVolumeCategory InCategory);
	void StopPriorityBGM(EFadeType FadeType, float FadeTime, bool bForceReplay);
	void StopPriorityENV(float FadeTime);

	float GetAttenationVolumeMultiply() const;
	class UAtomComponent* GetBGMComponent() const;
	EBgmScene GetBGMScene() const;
	class USoundAtomCue* GetCurrentBGM() const;
	class USoundAtomCue* GetCurrentMainENV() const;
	class USoundAtomCue* GetCurrentSubENV() const;
	class UDevilVoiceAssetMap* GetDevilVoiceAssetMap() const;
	float GetGameVolume(EGameVolumeCategory Category) const;
	struct FVector GetListenerLocation() const;
	float GetMasterVolume() const;
	float GetOptionVolume(EOptionVolumeCategory Category) const;
	float GetOptionVolumeDefault(EOptionVolumeCategory Category) const;
	class USoundAtomCue* GetQuestMapBGM() const;
	bool IsPlayingMapCrisisBGM() const;
	bool IsPlayingPriorityBGM() const;
	bool IsPlayingPriorityENV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectSoundManager">();
	}
	static class UProjectSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectSoundManager>();
	}
};
static_assert(alignof(UProjectSoundManager) == 0x000008, "Wrong alignment on UProjectSoundManager");
static_assert(sizeof(UProjectSoundManager) == 0x0004D0, "Wrong size on UProjectSoundManager");
static_assert(offsetof(UProjectSoundManager, CursorSE) == 0x0000B0, "Member 'UProjectSoundManager::CursorSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, DecideSE) == 0x0000B8, "Member 'UProjectSoundManager::DecideSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, CancelSE) == 0x0000C0, "Member 'UProjectSoundManager::CancelSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, ErrorSE) == 0x0000C8, "Member 'UProjectSoundManager::ErrorSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, ActionWindowOpenSE) == 0x0000D0, "Member 'UProjectSoundManager::ActionWindowOpenSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, ActionWindowCloseSE) == 0x0000D8, "Member 'UProjectSoundManager::ActionWindowCloseSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, ActionWindowDecideSE) == 0x0000E0, "Member 'UProjectSoundManager::ActionWindowDecideSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, MessageSkipSE) == 0x0000E8, "Member 'UProjectSoundManager::MessageSkipSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleCursorSE) == 0x0000F0, "Member 'UProjectSoundManager::BattleCursorSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleCursor2SE) == 0x0000F8, "Member 'UProjectSoundManager::BattleCursor2SE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleDecideSE) == 0x000100, "Member 'UProjectSoundManager::BattleDecideSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleDecide2SE) == 0x000108, "Member 'UProjectSoundManager::BattleDecide2SE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleCancelSE) == 0x000110, "Member 'UProjectSoundManager::BattleCancelSE' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, CursorSEComp) == 0x000118, "Member 'UProjectSoundManager::CursorSEComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, DecideSEComp) == 0x000120, "Member 'UProjectSoundManager::DecideSEComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, CancelSEComp) == 0x000128, "Member 'UProjectSoundManager::CancelSEComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, ErrorSEComp) == 0x000130, "Member 'UProjectSoundManager::ErrorSEComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, ActionWindowOpenComp) == 0x000138, "Member 'UProjectSoundManager::ActionWindowOpenComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, ActionWindowCloseComp) == 0x000140, "Member 'UProjectSoundManager::ActionWindowCloseComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, ActionWindowDecideComp) == 0x000148, "Member 'UProjectSoundManager::ActionWindowDecideComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, MessageSkipComp) == 0x000150, "Member 'UProjectSoundManager::MessageSkipComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleCursorSEComp) == 0x000158, "Member 'UProjectSoundManager::BattleCursorSEComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleCursor2SEComp) == 0x000160, "Member 'UProjectSoundManager::BattleCursor2SEComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleDecideSEComp) == 0x000168, "Member 'UProjectSoundManager::BattleDecideSEComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleDecide2SEComp) == 0x000170, "Member 'UProjectSoundManager::BattleDecide2SEComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BattleCancelSEComp) == 0x000178, "Member 'UProjectSoundManager::BattleCancelSEComp' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, DevilVoiceAssetMap) == 0x000180, "Member 'UProjectSoundManager::DevilVoiceAssetMap' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, OnBGMSceneChanged) == 0x000188, "Member 'UProjectSoundManager::OnBGMSceneChanged' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, CurrentBGM) == 0x000198, "Member 'UProjectSoundManager::CurrentBGM' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, NextBGM) == 0x0001A0, "Member 'UProjectSoundManager::NextBGM' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, SceneBGMMap) == 0x0001B0, "Member 'UProjectSoundManager::SceneBGMMap' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, BGMRequest) == 0x000250, "Member 'UProjectSoundManager::BGMRequest' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, MapCrisisBGM) == 0x000298, "Member 'UProjectSoundManager::MapCrisisBGM' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, QuestMapBGM) == 0x0002A8, "Member 'UProjectSoundManager::QuestMapBGM' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, CoasterBGM) == 0x0002B8, "Member 'UProjectSoundManager::CoasterBGM' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, CurrentMainENV) == 0x0002C0, "Member 'UProjectSoundManager::CurrentMainENV' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, CurrentSubENV) == 0x0002C8, "Member 'UProjectSoundManager::CurrentSubENV' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, NotPriorityMainENV) == 0x0002D0, "Member 'UProjectSoundManager::NotPriorityMainENV' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, NotPrioritySubENV) == 0x0002D8, "Member 'UProjectSoundManager::NotPrioritySubENV' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, MapUniqueFuncCounter) == 0x000468, "Member 'UProjectSoundManager::MapUniqueFuncCounter' has a wrong offset!");
static_assert(offsetof(UProjectSoundManager, ListenerActor) == 0x0004C0, "Member 'UProjectSoundManager::ListenerActor' has a wrong offset!");

// Class Project.ProjectUIManager
// 0x00F8 (0x0120 - 0x0028)
class UProjectUIManager : public UObject
{
public:
	uint8                                         Pad_1CC8[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            MessageWidget;                                     // 0x0040(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            ScreennFadeWidget;                                 // 0x0048(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 BtnHelpCtrl2;                                      // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFadeBase*                            ScreennFadeObj;                                    // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASystemMess*                            SystemMess;                                        // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 MsgCtrl;                                           // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CommonWindowCtrl;                                  // 0x0070(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CommonHelpWindowCtrl;                              // 0x0078(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 DialogWindowCtrl;                                  // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 InfoWindowCtrl;                                    // 0x0088(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ItemWindowCtrl;                                    // 0x0090(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 MapCharaPanelCtrl;                                 // 0x0098(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TutorialWindowCtrl2;                               // 0x00A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 DLCAnnouncer;                                      // 0x00A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CommonUI_EventCtrl;                                // 0x00B0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 MakkaWindowCtrl2;                                  // 0x00B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 MoonAgeCtrl;                                       // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 SortWindowCtrl2;                                   // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 SkillSearchSortWindowCtrl;                         // 0x00D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 RichTextInsertWidgetPool;                          // 0x00D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CategoryWindowCtrl;                                // 0x00E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ScreenTransitionCtrl;                              // 0x00E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LocationWindowCtrl;                                // 0x00F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 MiitsuWindowCtrl;                                  // 0x00F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 MagatsuhiGaugeCtrl;                                // 0x0100(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC9[0x18];                                    // 0x0108(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UProjectUIManager* Get(const class UObject* WorldContextObject);

	void AddToScreenWidget();
	void CancelMissionMapInfo(int32 MissionId);
	bool CheckNameEntryErrorDialogConfirmed_Internal();
	void CreateBtnHelpCtrl2();
	void CreateCategoryWindowCtrl();
	void CreateCommonHelpWindowCtrl();
	void CreateCommonWindowCtrl();
	void CreateDialogWindowCtrl();
	void CreateInfoWindowCtrl();
	void CreateItemWindowCtrl();
	void CreateLocationWindowCtrl();
	void CreateMagatsuhiGaugeCtrl();
	void CreateMakkaWindowCtrl2();
	void CreateMessageWidget();
	void CreateMiitsuWindowCtrl();
	void CreateMoonAgeCtrl();
	void CreateMsgCtrl();
	void CreateRichTextInsertWidgetPool();
	void CreateScreenFadeObj();
	void CreateScreenFadeWidget();
	void CreateScreenTransitionCtrl();
	void CreateSkillSearchSortWindowCtrl2();
	void CreateSortWindowCtrl2();
	void CreateSystemMess();
	void CreateWidget();
	void DestroyBtnHelpCtrl2();
	void DestroyCategoryWindowCtrl();
	void DestroyCommonHelpWindowCtrl();
	void DestroyCommonWindowCtrl();
	void DestroyDialogWindowCtrl();
	void DestroyInfoWindowCtrl();
	void DestroyItemWindowCtrl();
	void DestroyLocationWindowCtrl();
	void DestroyMagatsuhiGaugeCtrl();
	void DestroyMakkaWindowCtrl2();
	void DestroyMessageWidget();
	void DestroyMiitsuWindowCtrl();
	void DestroyMoonAgeCtrl();
	void DestroyMsgCtrl();
	void DestroyRichTextInsertWidgetPool();
	void DestroyScreenFadeObj();
	void DestroyScreenFadeWidget();
	void DestroyScreenTransitionCtrl();
	void DestroySkillSearchSortWindowCtrl2();
	void DestroySortWindowCtrl2();
	void DestroySystemMess();
	void DestroyWidget();
	class UUserWidget* GetMessageWidget();
	class AActor* GetRichTextInsertWidgetPool();
	class UUIFadeBase* GetScreenFadeObj();
	class UUserWidget* GetScreenFadeWidget();
	class ASystemMess* GetSystemMess();
	void Initialize(class UProjectGameInstanceBase* GameInstance);
	void OpenMapInfo(class FName Label, const TArray<int32>& TagParams, int32 OpenSE_Type);
	void ShowNameEntryErrorDialog_Internal(int32 ErrorType, const class FString& ProgramTagValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectUIManager">();
	}
	static class UProjectUIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectUIManager>();
	}
};
static_assert(alignof(UProjectUIManager) == 0x000008, "Wrong alignment on UProjectUIManager");
static_assert(sizeof(UProjectUIManager) == 0x000120, "Wrong size on UProjectUIManager");
static_assert(offsetof(UProjectUIManager, MessageWidget) == 0x000040, "Member 'UProjectUIManager::MessageWidget' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, ScreennFadeWidget) == 0x000048, "Member 'UProjectUIManager::ScreennFadeWidget' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, BtnHelpCtrl2) == 0x000050, "Member 'UProjectUIManager::BtnHelpCtrl2' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, ScreennFadeObj) == 0x000058, "Member 'UProjectUIManager::ScreennFadeObj' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, SystemMess) == 0x000060, "Member 'UProjectUIManager::SystemMess' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, MsgCtrl) == 0x000068, "Member 'UProjectUIManager::MsgCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, CommonWindowCtrl) == 0x000070, "Member 'UProjectUIManager::CommonWindowCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, CommonHelpWindowCtrl) == 0x000078, "Member 'UProjectUIManager::CommonHelpWindowCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, DialogWindowCtrl) == 0x000080, "Member 'UProjectUIManager::DialogWindowCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, InfoWindowCtrl) == 0x000088, "Member 'UProjectUIManager::InfoWindowCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, ItemWindowCtrl) == 0x000090, "Member 'UProjectUIManager::ItemWindowCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, MapCharaPanelCtrl) == 0x000098, "Member 'UProjectUIManager::MapCharaPanelCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, TutorialWindowCtrl2) == 0x0000A0, "Member 'UProjectUIManager::TutorialWindowCtrl2' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, DLCAnnouncer) == 0x0000A8, "Member 'UProjectUIManager::DLCAnnouncer' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, CommonUI_EventCtrl) == 0x0000B0, "Member 'UProjectUIManager::CommonUI_EventCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, MakkaWindowCtrl2) == 0x0000B8, "Member 'UProjectUIManager::MakkaWindowCtrl2' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, MoonAgeCtrl) == 0x0000C0, "Member 'UProjectUIManager::MoonAgeCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, SortWindowCtrl2) == 0x0000C8, "Member 'UProjectUIManager::SortWindowCtrl2' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, SkillSearchSortWindowCtrl) == 0x0000D0, "Member 'UProjectUIManager::SkillSearchSortWindowCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, RichTextInsertWidgetPool) == 0x0000D8, "Member 'UProjectUIManager::RichTextInsertWidgetPool' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, CategoryWindowCtrl) == 0x0000E0, "Member 'UProjectUIManager::CategoryWindowCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, ScreenTransitionCtrl) == 0x0000E8, "Member 'UProjectUIManager::ScreenTransitionCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, LocationWindowCtrl) == 0x0000F0, "Member 'UProjectUIManager::LocationWindowCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, MiitsuWindowCtrl) == 0x0000F8, "Member 'UProjectUIManager::MiitsuWindowCtrl' has a wrong offset!");
static_assert(offsetof(UProjectUIManager, MagatsuhiGaugeCtrl) == 0x000100, "Member 'UProjectUIManager::MagatsuhiGaugeCtrl' has a wrong offset!");

// Class Project.RailMoveComponentBase
// 0x0000 (0x00B0 - 0x00B0)
class URailMoveComponentBase : public UActorComponent
{
public:
	void CalcTargetLocationWithOffset_Inner(struct FVector& TargetLocation, struct FVector& SocketLocation, bool IsUseTargetLocation, struct FVector& OriginTargetLocation, bool IsLockTarget, struct FRotator& ActorRotation, struct FVector& TargetOffset, struct FVector* OutVec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RailMoveComponentBase">();
	}
	static class URailMoveComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URailMoveComponentBase>();
	}
};
static_assert(alignof(URailMoveComponentBase) == 0x000008, "Wrong alignment on URailMoveComponentBase");
static_assert(sizeof(URailMoveComponentBase) == 0x0000B0, "Wrong size on URailMoveComponentBase");

// Class Project.BPL_Record
// 0x0000 (0x0028 - 0x0028)
class UBPL_Record final : public UBlueprintFunctionLibrary
{
public:
	static void AddRecordCounter(E_RECORD_ID ID, int32 Add);
	static void ChangeRecordMaxCounter(E_RECORD_ID ID, int32 Value);
	static void DestroyRecordDataTable(class URecordDataTable* PTable);
	static int32 GetRecordCounter(E_RECORD_ID ID);
	static struct FRecordData GetRecordData(E_RECORD_ID ID);
	static int32 GetRecordDataMax();
	static class FText GetRecordName(E_RECORD_ID ID);
	static class FText GetRecordUnitName(E_RECORD_ID ID);
	static class FText GetRecordValueText(E_RECORD_ID ID);
	static class URecordDataTable* MakeUpRecordDataTable(class UMMIAsset* PAsset, class UScriptMessageAsset* PRecordName);
	static void SetRecordCounter(E_RECORD_ID ID, int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_Record">();
	}
	static class UBPL_Record* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_Record>();
	}
};
static_assert(alignof(UBPL_Record) == 0x000008, "Wrong alignment on UBPL_Record");
static_assert(sizeof(UBPL_Record) == 0x000028, "Wrong size on UBPL_Record");

// Class Project.RecordDataTable
// 0x0030 (0x0058 - 0x0028)
class URecordDataTable final : public UObject
{
public:
	TArray<struct FRecordData>                    RecordDataArray;                                   // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           RecordTextArray;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CD6[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecordDataTable">();
	}
	static class URecordDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecordDataTable>();
	}
};
static_assert(alignof(URecordDataTable) == 0x000008, "Wrong alignment on URecordDataTable");
static_assert(sizeof(URecordDataTable) == 0x000058, "Wrong size on URecordDataTable");
static_assert(offsetof(URecordDataTable, RecordDataArray) == 0x000028, "Member 'URecordDataTable::RecordDataArray' has a wrong offset!");
static_assert(offsetof(URecordDataTable, RecordTextArray) == 0x000038, "Member 'URecordDataTable::RecordTextArray' has a wrong offset!");

// Class Project.BPL_ResultData
// 0x0000 (0x0028 - 0x0028)
class UBPL_ResultData final : public UBlueprintFunctionLibrary
{
public:
	static TArray<ERESULT_JOINDATA> CreateInitializedJoinData(ERESULT_JOINDATA JoinData);
	static bool ExistPushedResultMainActor();
	static bool GetBattleResultEnable();
	static void OverrideBtlCntInResultData(int32 NewBtlCnt);
	static class AActor* PopResultMainActor();
	static void PushResultMainActor(class AActor* Actor);
	static void ResultDataClear();
	static void SetBattleResultEnable(bool Enable);
	static void StackResultData(struct FResultData& InResultData, bool* Success);
	static void TestFuncAddEnemyExpData(const int32 EnemyLv, const int32 Exp);
	static void TestFuncDropItemRandomGet(const int32 GetNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_ResultData">();
	}
	static class UBPL_ResultData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_ResultData>();
	}
};
static_assert(alignof(UBPL_ResultData) == 0x000008, "Wrong alignment on UBPL_ResultData");
static_assert(sizeof(UBPL_ResultData) == 0x000028, "Wrong size on UBPL_ResultData");

// Class Project.ResultGettingSkillBase
// 0x0000 (0x0220 - 0x0220)
class AResultGettingSkillBase final : public AActor
{
public:
	E_SKILL_ICON GetSkillIconType(E_SKILL_TEKISEI_CATEGORY Category);
	TArray<struct FStatusSkillTekisei> Sort_SkillTekisei(const TArray<struct FStatusSkillTekisei>& SkillTekisei);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResultGettingSkillBase">();
	}
	static class AResultGettingSkillBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AResultGettingSkillBase>();
	}
};
static_assert(alignof(AResultGettingSkillBase) == 0x000008, "Wrong alignment on AResultGettingSkillBase");
static_assert(sizeof(AResultGettingSkillBase) == 0x000220, "Wrong size on AResultGettingSkillBase");

// Class Project.ResultMainBase
// 0x0070 (0x0290 - 0x0220)
class AResultMainBase : public AActor
{
public:
	uint8                                         Pad_1CD9[0x68];                                    // 0x0220(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UResultTopDataObj*                      PTopData;                                          // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static int32 CalcGodPoint(int32 beforeLv, int32 AfterLv);
	static int32 CalcParamPoint(int32 beforeLv, int32 AfterLv);
	static void PopResultData(struct FResultData* OutResultData);

	void AddItemAndMakka(bool GetMakkaFlag, bool GetItemFlag);
	int32 GetInterval_Top2ExpMove();
	void GetItemData(TArray<int32>* ItemId, TArray<int32>* ItemCnt);
	void GetMakkaData(int32* Makka);
	void Init(const struct FResultData& ResultData, bool* Success);
	void SaveResultTopAfterData();
	void SaveResultTopBeforeData(const struct FResultData& ResultData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResultMainBase">();
	}
	static class AResultMainBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AResultMainBase>();
	}
};
static_assert(alignof(AResultMainBase) == 0x000008, "Wrong alignment on AResultMainBase");
static_assert(sizeof(AResultMainBase) == 0x000290, "Wrong size on AResultMainBase");
static_assert(offsetof(AResultMainBase, PTopData) == 0x000288, "Member 'AResultMainBase::PTopData' has a wrong offset!");

// Class Project.UniteLvUpTestObj
// 0x0250 (0x0278 - 0x0028)
class UUniteLvUpTestObj final : public UObject
{
public:
	uint8                                         Pad_1CDB[0x250];                                   // 0x0028(0x0250)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateResultDevilData(int32 DevilID, int32 Exp);
	struct FNkmData GetNkmData();
	void ResetRndNum();
	void ResultLvUp(int32 Exp);
	void SetParamMax(E_ABILITY_TYPE AbiType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniteLvUpTestObj">();
	}
	static class UUniteLvUpTestObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniteLvUpTestObj>();
	}
};
static_assert(alignof(UUniteLvUpTestObj) == 0x000008, "Wrong alignment on UUniteLvUpTestObj");
static_assert(sizeof(UUniteLvUpTestObj) == 0x000278, "Wrong size on UUniteLvUpTestObj");

// Class Project.BPL_RyuketsuData
// 0x0000 (0x0028 - 0x0028)
class UBPL_RyuketsuData final : public UBlueprintFunctionLibrary
{
public:
	static class FName ConvertRyuketsuNameLabel(class FName beforeLabel);
	static const struct FRyuketsuData GetRyuketsuData(int32 ID);
	static const struct FRyuketsuData GetRyuketsuData_FromMapID(int32 MapId, int32 AreaId, int32 Param_Index, int32* ID);
	static void GetRyuketsuDataId_FromMapID(int32 MapId, int32 AreaId, int32 Param_Index, int32* ID);
	static int32 GetRyuketsuDataMax();
	static TArray<int32> GetRyuketsuIDList_Sorted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_RyuketsuData">();
	}
	static class UBPL_RyuketsuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_RyuketsuData>();
	}
};
static_assert(alignof(UBPL_RyuketsuData) == 0x000008, "Wrong alignment on UBPL_RyuketsuData");
static_assert(sizeof(UBPL_RyuketsuData) == 0x000028, "Wrong size on UBPL_RyuketsuData");

// Class Project.SaveLoadBase
// 0x00B8 (0x02D8 - 0x0220)
class ASaveLoadBase final : public AActor
{
public:
	uint8                                         Pad_1CDC[0xB8];                                    // 0x0220(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EntryBibleByShiseijo(const E_SHISEIJO& Shiseijo);
	const class FString GetDefaultFamilyName();
	const class FString GetDefaultGivenName();
	struct FSaveLoadHeaderData GetHeaderData(int32 Param_Index);
	int32 GetHeaderSlotLength();
	int32 GetLastSelectSlotIndex();
	int32 GetLatestTimeStampSlotIndex();
	int32 GetLocationMessageID();
	int32 GetSlotIndexForActivityStart(E_OldNewRoute Route);
	bool IsCompatibleLanguageData(int32 Param_Index);
	bool IsEnableCreationMode();
	void IsEndDataLoad(bool* Complete, bool* Success);
	void IsEndDataSave(bool* Complete, bool* Success);
	void IsEndHeaderLoad(bool* Complete, bool* Success);
	bool IsEnoughDlcContents(int32 Param_Index);
	bool IsInheritSlot(int32 Param_Index);
	bool IsInstalledAreaSave(int32 Param_Index);
	bool IsSavedSlot(int32 Param_Index);
	const bool IsTokyoKeyFreeSave();
	bool IsUnlockedShiseijoBible(const E_SHISEIJO& Shiseijo);
	bool IsValidHeaderSlotIndex(int32 Param_Index);
	bool NeedShiseijoBibleMsg(const E_SHISEIJO& Shiseijo);
	void ResetLuciferDefeatedForSystemData();
	void StartDataLoad(int32 Param_Index);
	void StartDataSave(int32 Param_Index, bool IsInheritSave);
	void StartHeaderLoad();
	void StartHeaderLoadNonAsync();
	void UnlockShiseijoBible();
	bool UpdateLuciferDefeatedForSystemData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadBase">();
	}
	static class ASaveLoadBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASaveLoadBase>();
	}
};
static_assert(alignof(ASaveLoadBase) == 0x000008, "Wrong alignment on ASaveLoadBase");
static_assert(sizeof(ASaveLoadBase) == 0x0002D8, "Wrong size on ASaveLoadBase");

// Class Project.ScreenTransitionBase
// 0x0008 (0x0228 - 0x0220)
class AScreenTransitionBase : public AActor
{
public:
	E_UI_FADE_STATE                               M_fadeState;                                       // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CE6[0x7];                                     // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenTransitionBase">();
	}
	static class AScreenTransitionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScreenTransitionBase>();
	}
};
static_assert(alignof(AScreenTransitionBase) == 0x000008, "Wrong alignment on AScreenTransitionBase");
static_assert(sizeof(AScreenTransitionBase) == 0x000228, "Wrong size on AScreenTransitionBase");
static_assert(offsetof(AScreenTransitionBase, M_fadeState) == 0x000220, "Member 'AScreenTransitionBase::M_fadeState' has a wrong offset!");

// Class Project.BPL_ShinseiData
// 0x0000 (0x0028 - 0x0028)
class UBPL_ShinseiData final : public UBlueprintFunctionLibrary
{
public:
	static const struct FShinseiData GetShinseiData(E_ShinseiKind Kind);
	static const struct FShinseiSaveBuffer GetShinseiSaveBufferData(int32 TableID);
	static int32 GetShinseiSaveBufferDataMax();
	static int32 GetShinseiSaveBufferNum(int32 MapId, int32 AreaId);
	static int32 GetShinseiSaveBufferStart(int32 MapId, int32 AreaId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_ShinseiData">();
	}
	static class UBPL_ShinseiData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_ShinseiData>();
	}
};
static_assert(alignof(UBPL_ShinseiData) == 0x000008, "Wrong alignment on UBPL_ShinseiData");
static_assert(sizeof(UBPL_ShinseiData) == 0x000028, "Wrong size on UBPL_ShinseiData");

// Class Project.BPL_ShopTableFunction
// 0x0000 (0x0028 - 0x0028)
class UBPL_ShopTableFunction final : public UBlueprintFunctionLibrary
{
public:
	static const struct FShopBuyTable GetShopBuyTable(int32 Param_Index);
	static const struct FShopBuyTable GetShopBuyTable_BySortID(int32 InSortID);
	static int32 GetShopBuyTableMax();
	static const struct FShopMimanItemTable GetShopMimanItemTable(int32 Param_Index);
	static int32 GetShopMimanItemTableMax();
	static bool IsExistItemInShop(int32 ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_ShopTableFunction">();
	}
	static class UBPL_ShopTableFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_ShopTableFunction>();
	}
};
static_assert(alignof(UBPL_ShopTableFunction) == 0x000008, "Wrong alignment on UBPL_ShopTableFunction");
static_assert(sizeof(UBPL_ShopTableFunction) == 0x000028, "Wrong size on UBPL_ShopTableFunction");

// Class Project.BPL_SkillCategoryData
// 0x0000 (0x0028 - 0x0028)
class UBPL_SkillCategoryData final : public UBlueprintFunctionLibrary
{
public:
	static const class FText GetAbilityName(E_ABILITYNAME_TYPE InType);
	static const class FText GetAttrName(E_ATTRIBUTE_TYPE ArgrType);
	static const class FText GetBadStatusName(E_BAD_STATUS InType);
	static const class FText GetEndureName(E_ENDURE_TYPE ArgrType);
	static const class FText GetSkillTekiseiName(E_SKILL_TEKISEI_CATEGORY InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_SkillCategoryData">();
	}
	static class UBPL_SkillCategoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_SkillCategoryData>();
	}
};
static_assert(alignof(UBPL_SkillCategoryData) == 0x000008, "Wrong alignment on UBPL_SkillCategoryData");
static_assert(sizeof(UBPL_SkillCategoryData) == 0x000028, "Wrong size on UBPL_SkillCategoryData");

// Class Project.SkillSearchSortWindowBase
// 0x0000 (0x0220 - 0x0220)
class ASkillSearchSortWindowBase : public AActor
{
public:
	TArray<int32> GetSearchSkillIDList(int32 InTargetElement);
	int32 GetSearchSkillNum(int32 InTargetElement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillSearchSortWindowBase">();
	}
	static class ASkillSearchSortWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkillSearchSortWindowBase>();
	}
};
static_assert(alignof(ASkillSearchSortWindowBase) == 0x000008, "Wrong alignment on ASkillSearchSortWindowBase");
static_assert(sizeof(ASkillSearchSortWindowBase) == 0x000220, "Wrong size on ASkillSearchSortWindowBase");

// Class Project.BPL_SkillTargetData
// 0x0000 (0x0028 - 0x0028)
class UBPL_SkillTargetData final : public UBlueprintFunctionLibrary
{
public:
	static const class FText GetSkillTargetName(int32 Argindex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_SkillTargetData">();
	}
	static class UBPL_SkillTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_SkillTargetData>();
	}
};
static_assert(alignof(UBPL_SkillTargetData) == 0x000008, "Wrong alignment on UBPL_SkillTargetData");
static_assert(sizeof(UBPL_SkillTargetData) == 0x000028, "Wrong size on UBPL_SkillTargetData");

// Class Project.SingleKeyboardAsyncFunction
// 0x0048 (0x0078 - 0x0030)
class USingleKeyboardAsyncFunction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CF1[0x38];                                    // 0x0040(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USingleKeyboardAsyncFunction* CallSingleKeyboard(class UObject* WorldContextObject, const struct FSingleKeyboardTextSet& TextSet, const struct FEnableCheckFontData& FontFamilyData, bool IsFirst);
	static class FString CheckFontUnsupportedCharacter(const class FString& InStr, const struct FEnableCheckFontData& FontFamilyData);
	static class FString CheckNameEntryText(const class FString& InputStr, const struct FEnableCheckFontData& FontFamilyData);
	static bool GetFamilyNameFirst();
	static int32 GetNameEntryMaxLength();
	static class FString GetPlayerDataName(bool bFirstInput);
	static float GetVirtualKeyboardIntervalTime();
	static bool PlatformIsSupportedVirtualKeyboard();
	static void SetPlayerName(const class FText& Input, bool bFirstInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleKeyboardAsyncFunction">();
	}
	static class USingleKeyboardAsyncFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleKeyboardAsyncFunction>();
	}
};
static_assert(alignof(USingleKeyboardAsyncFunction) == 0x000008, "Wrong alignment on USingleKeyboardAsyncFunction");
static_assert(sizeof(USingleKeyboardAsyncFunction) == 0x000078, "Wrong size on USingleKeyboardAsyncFunction");
static_assert(offsetof(USingleKeyboardAsyncFunction, Completed) == 0x000030, "Member 'USingleKeyboardAsyncFunction::Completed' has a wrong offset!");

// Class Project.SortWindowBase
// 0x0030 (0x0250 - 0x0220)
class ASortWindowBase : public AActor
{
public:
	uint8                                         Pad_1CF5[0x30];                                    // 0x0220(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetHelpMsgIdx(int32 InCursorIdx);
	TArray<class FText> GetSortItemList_All();
	TArray<class FText> GetSortItemList_InRange(int32 StartIdx, int32 EndIdx);
	void LoadSortItemList(E_SORT_WINDOW_SORT_TYPE InSortScene);
	void ResetSortItemList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SortWindowBase">();
	}
	static class ASortWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASortWindowBase>();
	}
};
static_assert(alignof(ASortWindowBase) == 0x000008, "Wrong alignment on ASortWindowBase");
static_assert(sizeof(ASortWindowBase) == 0x000250, "Wrong size on ASortWindowBase");

// Class Project.BPL_USortWindowData
// 0x0000 (0x0028 - 0x0028)
class UBPL_USortWindowData final : public UBlueprintFunctionLibrary
{
public:
	static TArray<int32> GetHelpIndexList(E_SORT_WINDOW_SORT_TYPE Type);
	static TArray<class FText> GetSortMessageList(E_SORT_WINDOW_SORT_TYPE Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_USortWindowData">();
	}
	static class UBPL_USortWindowData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_USortWindowData>();
	}
};
static_assert(alignof(UBPL_USortWindowData) == 0x000008, "Wrong alignment on UBPL_USortWindowData");
static_assert(sizeof(UBPL_USortWindowData) == 0x000028, "Wrong size on UBPL_USortWindowData");

// Class Project.SoundObjectHolder
// 0x0008 (0x00B8 - 0x00B0)
class USoundObjectHolder final : public UActorComponent
{
public:
	uint8                                         Pad_1CF8[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundObjectHolder">();
	}
	static class USoundObjectHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundObjectHolder>();
	}
};
static_assert(alignof(USoundObjectHolder) == 0x000008, "Wrong alignment on USoundObjectHolder");
static_assert(sizeof(USoundObjectHolder) == 0x0000B8, "Wrong size on USoundObjectHolder");

// Class Project.BPL_StaticMeshTable
// 0x0000 (0x0028 - 0x0028)
class UBPL_StaticMeshTable final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyLightmapSetting(const class UDataTable* DataTable);
	static void ApplyLODSetting(const class UDataTable* DataTable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_StaticMeshTable">();
	}
	static class UBPL_StaticMeshTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_StaticMeshTable>();
	}
};
static_assert(alignof(UBPL_StaticMeshTable) == 0x000008, "Wrong alignment on UBPL_StaticMeshTable");
static_assert(sizeof(UBPL_StaticMeshTable) == 0x000028, "Wrong size on UBPL_StaticMeshTable");

// Class Project.StatusSkillCtrlBase
// 0x0038 (0x0258 - 0x0220)
class AStatusSkillCtrlBase final : public AActor
{
public:
	uint8                                         Pad_1CF9[0x38];                                    // 0x0220(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BIEPanelSkillNoDataTextDispOff();
	void BIEPanelSkillNoDataTextDispOn();
	void BIESetBlankPanel(int32 InIndex, int32 InBlankType, int32 InFaceIconId, int32 InUseSkill, bool InDispOnFlag, bool InDispOnFaceIcon);
	void BIESetInitializeCursorAnimation(int32 InIndex);
	void BIESetInitializeListAnimation(int32 InIndex);
	void BIESetMagatsuhiPanel(int32 InIndex, int32 InSkillId, int32 InFaceIconId, int32 InCost, int32 InUseSkill, int32 InTekiseiParam, int32 InUseType, bool InDispOnFlag);
	void BIESetSkillCursorAnimation(int32 InIndex, int32 InType, int32 InAnimeType, bool InCursorOn);
	void BIESetSkillCursorAnimationByUseAnimeType(int32 InIndex, int32 InType);
	void BIESetSkillNameColor(int32 InIndex, int32 InUseSkill);
	void BIESetSkillPanel(int32 InIndex, int32 InSkillId, int32 InFaceIconId, int32 InCost, int32 InUseSkill, int32 InTekiseiParam, int32 InUseType, bool InDispOnFlag);
	void BIESetSkillPanelFaceIconColor(int32 InIndex, int32 InType);
	void BIESetUniquePanel(int32 InIndex, int32 InSkillId, int32 InFaceIconId, int32 InCost, int32 InUseSkill, int32 InTekiseiParam, int32 InUseType, bool InDispOnFlag);
	void BIESkillPanelDispOff(int32 InIndex);
	bool CreatePartyMagatsuhiSkillList(int32 InNkmIndex);
	bool CreatePartySkillList(int32 InNkmIndex);
	bool DeleteSkillList();
	int32 GetSkillDisplayNumber();
	bool IsListAnimation();
	bool SetPartySkillPanel(int32 InType);
	bool StartFadeOutListAnimation();
	bool StartListAnimation(bool InCursorAnimation);
	bool StopListAnimation();
	bool UpdateSkillListAnimation(int32 InType, bool InCursorOn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusSkillCtrlBase">();
	}
	static class AStatusSkillCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStatusSkillCtrlBase>();
	}
};
static_assert(alignof(AStatusSkillCtrlBase) == 0x000008, "Wrong alignment on AStatusSkillCtrlBase");
static_assert(sizeof(AStatusSkillCtrlBase) == 0x000258, "Wrong size on AStatusSkillCtrlBase");

// Class Project.SubLevelVisibilityVolume
// 0x0028 (0x0280 - 0x0258)
class ASubLevelVisibilityVolume final : public AVolume
{
public:
	TArray<struct FPrimaryAssetId>                StreamingLevelNames;                               // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bDisabled : 1;                                     // 0x0268(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D03[0x3];                                     // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EASubLevelVisibilityVolumeUsage               VisibilityVolumeUsage;                             // 0x026C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D04[0x3];                                     // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULevelStreaming*>                LevelStreamings;                                   // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubLevelVisibilityVolume">();
	}
	static class ASubLevelVisibilityVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASubLevelVisibilityVolume>();
	}
};
static_assert(alignof(ASubLevelVisibilityVolume) == 0x000008, "Wrong alignment on ASubLevelVisibilityVolume");
static_assert(sizeof(ASubLevelVisibilityVolume) == 0x000280, "Wrong size on ASubLevelVisibilityVolume");
static_assert(offsetof(ASubLevelVisibilityVolume, StreamingLevelNames) == 0x000258, "Member 'ASubLevelVisibilityVolume::StreamingLevelNames' has a wrong offset!");
static_assert(offsetof(ASubLevelVisibilityVolume, VisibilityVolumeUsage) == 0x00026C, "Member 'ASubLevelVisibilityVolume::VisibilityVolumeUsage' has a wrong offset!");
static_assert(offsetof(ASubLevelVisibilityVolume, LevelStreamings) == 0x000270, "Member 'ASubLevelVisibilityVolume::LevelStreamings' has a wrong offset!");

// Class Project.SubLevelVisibilityManager
// 0x0028 (0x00D8 - 0x00B0)
class USubLevelVisibilityManager final : public UActorComponent
{
public:
	bool                                          bEnabled;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D05[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASubLevelVisibilityVolume*>      VisibilityVolumes;                                 // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLevelInfo>                     LevelInfos;                                        // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Init();
	void ProcessVisibilityVolume(const struct FVector& ViewLocation);
	void RegisterVibilityVolume(class ASubLevelVisibilityVolume* InSubLevelVisibilityVolume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubLevelVisibilityManager">();
	}
	static class USubLevelVisibilityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubLevelVisibilityManager>();
	}
};
static_assert(alignof(USubLevelVisibilityManager) == 0x000008, "Wrong alignment on USubLevelVisibilityManager");
static_assert(sizeof(USubLevelVisibilityManager) == 0x0000D8, "Wrong size on USubLevelVisibilityManager");
static_assert(offsetof(USubLevelVisibilityManager, bEnabled) == 0x0000B0, "Member 'USubLevelVisibilityManager::bEnabled' has a wrong offset!");
static_assert(offsetof(USubLevelVisibilityManager, VisibilityVolumes) == 0x0000B8, "Member 'USubLevelVisibilityManager::VisibilityVolumes' has a wrong offset!");
static_assert(offsetof(USubLevelVisibilityManager, LevelInfos) == 0x0000C8, "Member 'USubLevelVisibilityManager::LevelInfos' has a wrong offset!");

// Class Project.BPL_SystemData
// 0x0000 (0x0028 - 0x0028)
class UBPL_SystemData final : public UBlueprintFunctionLibrary
{
public:
	static void ApplySystemDefaultValue(const class UObject* WorldContextObject);
	static void ClearDLCAnnoucedFlag();
	static void DebugOverrideMouseInputScale(float Settings);
	static E_OPTION_COMMON_SELECT_TYPE GetAmbientOcclusionType();
	static E_OPTION_COMMON_SELECT_TYPE GetAntialiasingType();
	static E_OPTION_CONTENT_BATTLE_ACTION_TYPE GetAutoBattleActionType();
	static E_OPTION_COMMON_SELECT_TYPE GetAutoBattleType();
	static E_OPTION_COMMON_SELECT_TYPE GetBattleCursorPositionType();
	static E_OPTION_CONTENT_ITEM_PRIORITIZE_TYPE GetBattleItemSortType();
	static int32 GetBattleTempo();
	static float GetBGMVolume();
	static uint8 GetBrightness();
	static E_OPTION_CONTENT_BUTTON_ICON_TYPE GetButtonIconType();
	static uint8 GetCameraAutoCentering();
	static uint8 GetCameraCtrlSpeed();
	static uint8 GetCameraReverseLR();
	static uint8 GetCameraReverseUD();
	static float GetCameraSpeed();
	static uint8 GetCametaInputLR();
	static uint8 GetControllerVibration();
	static E_OPTION_CONTENT_CONTROL_TYPE GetDecideControlType();
	static E_GAME_DIFFICULTY GetDifficulty();
	static uint8 GetDisplayBrightness();
	static uint8 GetDisplaySelection();
	static float GetEnvVolume();
	static E_OPTION_COMMON_SELECT_TYPE GetEstomaConfirm();
	static uint8 GetExperienceTricks();
	static E_OPTION_CONTENT_STICK_PUSH_TYPE GetFieldPushLStickType();
	static E_OPTION_CONTENT_STICK_PUSH_TYPE GetFieldPushRStickType();
	static float GetFontSizeOffset();
	static E_OPTION_CONTENT_FOV_TYPE GetFOVType();
	static E_OPTION_CONTENT_FRAME_RATE_TYPE GetFrameRateType();
	static class FString GetL10NName();
	static uint8 GetLastSelectSlotIndex();
	static E_OPTION_COMMON_SELECT_TYPE GetLoadGamePause();
	static bool GetLuciferDefeated();
	static uint8 GetMakkaTricks();
	static float GetMasterVolume();
	static E_OPTION_COMMON_SELECT_TYPE GetMessageAutoMaintain();
	static E_OPTION_MESSAGE_SPEED_TYPE GetMessageSpeedType();
	static E_OPTION_COMMON_SELECT_TYPE GetMotionBlurType();
	static uint8 GetMouseSensitivity();
	static E_OPTION_COMMON_SELECT_TYPE GetMoveDisplayMinimap();
	static E_OPTION_COMMON_SELECT_TYPE GetMoveDisplayOther();
	static E_OPTION_COMMON_SELECT_TYPE GetMoveDisplayPanel();
	static E_OPTION_COMMON_SELECT_TYPE GetMoveMagatsuhiGauge();
	static E_OPTION_COMMON_SELECT_TYPE GetMovieSubtitleType();
	static E_OPTION_CONTENT_CONTROL_TYPE GetMoviewSkipType();
	static E_OPTION_COMMON_SELECT_TYPE GetNearbyObjectVisibility();
	static struct FIntPoint GetResolution(const E_OPTION_CONTENT_SCREEN_MODE ScreenType);
	static E_OPTION_COMMON_SELECT_TYPE GetRotateMiniMapType();
	static E_OPTION_CONTENT_SCREEN_MODE GetScreenMode();
	static float GetSEVolume();
	static E_OPTION_COMMON_SELECT_TYPE GetSkillDisplayPanelType();
	static E_OPTION_BATTLE_PRODUCTION_TYPE GetSkillShorteningType();
	static E_OPTION_CONTENT_SPEED_TYPE GetSkillSpeedAuto();
	static E_OPTION_CONTENT_SPEED_TYPE GetSkillSpeedDecide();
	static E_OPTION_CONTENT_SPEED_TYPE GetSkillSpeedNormal();
	static E_OPTION_COMMON_SELECT_TYPE GetSkippingSkillDirection();
	static uint8 GetStickSensitivity();
	static uint8 GetStrictTricks();
	static uint8 GetVoiceLanguage();
	static float GetVoiceVolume();
	static E_OPTION_COMMON_SELECT_TYPE GetVSyncType();
	static E_OPTION_COMMON_SELECT_TYPE GetWeakAutoBattle();
	static bool IsAnnoucedDLC(int32 Param_Index);
	static void OverrideOptionSettingByDisableDLC(const class UObject* WorldContextObject, const class FName& DlcTag, bool* Changed);
	static void OverrideOptionSettingByEnableDLC(const class UObject* WorldContextObject, const class FName& DlcTag, bool* Changed);
	static void RecordDLCAnnounced();
	static void RefrectOptionSettingsInMainGame(const class UObject* WorldContextObject);
	static void RefrectWindowsOptionSettingsInMainGame(const class UObject* WorldContextObject, const bool Boot);
	static void SetAmbientOcclusionShowFlagInGame(const class UObject* WorldContextObject, const bool NewFlag);
	static void SetAntiAliasingShowFlagInGame(const class UObject* WorldContextObject, const bool NewFlag);
	static void SetAutoBattleType(const E_OPTION_COMMON_SELECT_TYPE Type);
	static void SetBattleCursorPositionType(const E_OPTION_COMMON_SELECT_TYPE Type);
	static void SetBattleTempo(int32 Value);
	static void SetBGMVolume(const float Volume);
	static void SetCameraAutoCentering(const uint8 Is_auto);
	static void SetCameraCtrlSpeed(const uint8 Type);
	static void SetCameraReverseLR(const uint8 Reverse);
	static void SetCameraReverseUD(const uint8 Reverse);
	static void SetCameraSpeed(const float Speed);
	static void SetCametaInputLR(const uint8 Type);
	static void SetControllerVibration(const uint8 Is_vib);
	static void SetDifficulty(const E_GAME_DIFFICULTY Diff);
	static void SetEnvVolume(const float Volume);
	static void SetExperienceTricks(const uint8 Type);
	static void SetFontSizeOffset(const float Size);
	static void SetLastSelectSlotIndex(const uint8 Param_Index);
	static void SetLuciferDefeated(const bool Flag);
	static void SetMakkaTricks(const uint8 Type);
	static void SetMasterVolume(const float Volume);
	static void SetMessageSpeedType(const E_OPTION_MESSAGE_SPEED_TYPE Tyep);
	static void SetMotionBlurShowFlagInGame(const class UObject* WorldContextObject, const bool NewFlag);
	static void SetMoveDisplayMinimap(const E_OPTION_COMMON_SELECT_TYPE Type);
	static void SetMoveDisplayOther(const E_OPTION_COMMON_SELECT_TYPE Type);
	static void SetMoveDisplayPanel(const E_OPTION_COMMON_SELECT_TYPE Type);
	static void SetSEVolume(const float Volume);
	static void SetSkillDisplayPanelType(const E_OPTION_COMMON_SELECT_TYPE Type);
	static void SetSkillShorteningType(const E_OPTION_BATTLE_PRODUCTION_TYPE Type);
	static void SetStrictTricks(const uint8 Type);
	static void SetVoiceLanguage(const class UObject* WorldContextObject, const uint8 Language);
	static void SetVoiceVolume(const float Volume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_SystemData">();
	}
	static class UBPL_SystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_SystemData>();
	}
};
static_assert(alignof(UBPL_SystemData) == 0x000008, "Wrong alignment on UBPL_SystemData");
static_assert(sizeof(UBPL_SystemData) == 0x000028, "Wrong size on UBPL_SystemData");

// Class Project.BPL_TakaraData
// 0x0000 (0x0028 - 0x0028)
class UBPL_TakaraData final : public UBlueprintFunctionLibrary
{
public:
	static const struct FTakaraData GetTakaraData(int32 MapId, int32 TakaraID, int32* SaveId);
	static const struct FTakaraData GetTakaraData_TableID(int32 TableID);
	static void GetTakaraDataId(int32 MapId, int32 TakaraID, int32* SaveId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_TakaraData">();
	}
	static class UBPL_TakaraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_TakaraData>();
	}
};
static_assert(alignof(UBPL_TakaraData) == 0x000008, "Wrong alignment on UBPL_TakaraData");
static_assert(sizeof(UBPL_TakaraData) == 0x000028, "Wrong size on UBPL_TakaraData");

// Class Project.TalkCtrl
// 0x0188 (0x03A8 - 0x0220)
class ATalkCtrl : public AActor
{
public:
	struct FTalkStartInfo                         M_TalkStartInfo;                                   // 0x0220(0x000C)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         M_DevilID;                                         // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_DevilLevel;                                      // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_DevilGroup;                                      // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_DevilAttr1;                                      // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_DevilCharacterNameIndex;                         // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0F[0x1];                                     // 0x0240(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	E_TALK_MOON_TEMPER_DATA                       M_MoonTemperData;                                  // 0x0241(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_TALK_MOON_TEMPER_STATUS                     M_MoonTemperStatus;                                // 0x0242(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D10[0x1];                                     // 0x0243(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	E_TALK_QUESTION_PART                          M_QuestionPart;                                    // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D11[0x3];                                     // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_QuestionId;                                      // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_TALK_JUDGE_PARAM                            M_JudgeParam;                                      // 0x024C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D12[0x3];                                     // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ReactionDebugIndex;                              // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTalkReactionTable                     M_ReactionInfo;                                    // 0x0254(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	E_TALK_WANT_KIND                              M_WantKind;                                        // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_TALK_WANT_KIND                              M_WantKindPrev;                                    // 0x027D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D13[0x2];                                     // 0x027E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_WantRepeatCount;                                 // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantYesCount;                                    // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantOtherCount;                                  // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantNotHaveCount;                                // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_TALK_WANT_AC                                M_WantAc;                                          // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	E_TALK_WANT_REAC                              M_WantReac;                                        // 0x0291(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_MoneyPaid;                                       // 0x0292(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D14[0x1];                                     // 0x0293(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_WantItemId;                                      // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantItemNum;                                     // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantItemRank;                                    // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantMoney;                                       // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantHP;                                          // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantMP;                                          // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantHPMPRank;                                    // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantReduceItemId;                                // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantReduceItemNum;                               // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantReduceMoney;                                 // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantReduceHP;                                    // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantReduceMP;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_WantReduceHPMPRank;                              // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWantReduce;                                     // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D15[0x7];                                     // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_WantReduceUniqueDevilList_1;                     // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_WantReduceUniqueDevilList_2;                     // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         M_WantReduceUniqueDevilId;                         // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTalkResultInfo                        M_TalkResult;                                      // 0x02F4(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D16[0x2];                                     // 0x02F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_FundCount;                                       // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_FundMoney;                                       // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_FundTotalMoney;                                  // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_UtsusemiItemId;                                  // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_UtsusemiHide;                                    // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D17[0x3];                                     // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_MercyRepeatCount;                                // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D18[0x28];                                    // 0x0310(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_NkmUnconditionalMode;                            // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D19[0x3];                                     // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_MythId;                                          // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_MythFriendId;                                    // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_MythEnemyId;                                     // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_MythNextMessageIndex;                            // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_MythItemId;                                      // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bQuizMode;                                       // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D1A[0x3];                                     // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_QuizDevilId;                                     // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_QuizChoices;                                     // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_IsQuizSuccess;                                   // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D1B[0x7];                                     // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTalkToneTable*                         M_pTalkToneTable;                                  // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                M_pBattleMain;                                     // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTalkMythProcessTable                  M_MythProcessTable;                                // 0x0380(0x0010)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D1C[0x18];                                    // 0x0390(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetTalkSelectLineNum(const class FText& Text);
	static TArray<class FText> GetTalkSelectLineText(const class FText& Text);
	static bool HaveGodParam(ETalkGodParam GodParam);

	void AddFundCount();
	void AddMoneyPaidTotal(int32 Money);
	void AddScoutSuccessCount();
	bool CalcFundAngry();
	void CalcFundMoney();
	void CalcMercyMoney(int32 MercyRepeatCount, int32* OutMoney, bool* OutIsAll);
	void CalcQuestionJudgeParam();
	void CalcUniqueSkillDevilTransform(class UDataTable* DataTable, int32 DevilID, struct FVector* OutLocation, struct FVector* OutRotation);
	void CalcWantHP();
	void CalcWantItem();
	void CalcWantMaseki();
	void CalcWantMoney();
	void CalcWantMP();
	E_TALK_FRIEND_TALK CheckFriendTalk();
	bool CheckHaveWant();
	bool CheckHeroUplifting();
	bool CheckLevelEnough();
	bool CheckNotEscapeBattle();
	bool CheckNotHaveDevil();
	bool CheckStockEnough();
	bool CheckTutorial();
	bool CheckWantItem();
	void ChooseReactionByJudgeParam(E_TALK_JUDGE_PARAM JudgeParam);
	void DestroyTalkToneTable();
	void EntryDevil(int32 DevilID);
	void FriendTalkHealProc();
	int32 GetFundAngryRate();
	const struct FTalkMoonTemperTable GetMoonTemperData();
	TArray<int32> GetQuizChoices();
	E_TALK_SAFETY_TYPE GetSafetyProcType();
	int32 GetSafetyProcUniqueDevil();
	E_TALK_NG_TYPE GetTalkNGType(bool MagatsukaDiscovery);
	struct FTalkResultInfo GetTalkResult();
	bool GetTalkScoutTable(int32 TalkId, struct FTalkScoutTable* Table);
	int32 GetTalkScoutTableMax();
	int32 GetTalkWantMoneyTable(int32 Level);
	int32 GetWantReduceUniqueDevil();
	bool IsApologyWaitFlag();
	bool IsEasyMode();
	bool IsLevelWaitFlag();
	bool IsMoneyPaidTotalAchieved();
	bool IsQuestionNoChoice();
	bool IsScoutSuccessAchieved();
	bool IsStockWaitFlag();
	bool LotApologyWaitFlag();
	void LotBegLifeIncenseItem(int32* OutItemID, int32* OutItemNum);
	void LotFriendTalkGift(int32* OutItemID, int32* OutMoney);
	bool LotFriendTalkHeal();
	E_TALK_HERO_BST_TYPE LotHeroBadStatus();
	bool LotMercyRepeat(int32 MercyRepeatCount);
	bool LotNkmUnconditionalProc();
	void LotQuestionA();
	void LotQuestionB();
	void LotQuestionGiftItem(int32* OutItemID, int32* OutItemNum);
	int32 LotQuestionGiftMoney();
	void LotQuestionReaction(int32 ChoiceIndex);
	void LotQuiz();
	bool LotSafetyProc();
	E_TALK_WANT_KIND LotWantKind();
	E_TALK_WANT_REAC LotWantReaction();
	bool LotWantReduceUniqueSkill();
	void MakeUpMythProcessTable(class UObject* PObject);
	void MakeUpTalkToneTable(class UMMIAsset* PAsset);
	void MakeUpTalkToneTable_Object(class UObject* PObject);
	int32 MythFindMatch();
	void MythSetHappenedFlag(int32 MythId);
	void MythSetInfo(int32 MythId);
	void PlayDevilVoice(class AActor* Talker, EDevilTalkVoice DevilTalkVoice, class FName Socket, bool bDontAttachToTalker);
	void ResetWaitFlag();
	void ReturnToAPart();
	void SafetyRepeatWant();
	void SetApologyWaitFlag(bool Flag);
	void SetCharaNameByID(class UScriptMessageAsset* ScriptMessageAsset, int32 MessageID);
	void SetCharaNameByIdAndDevil(class UScriptMessageAsset* ScriptMessageAsset, int32 MessageID, int32 DevilID);
	void SetCharaNameByLabel(class UScriptMessageAsset* ScriptMessageAsset, class FName MessageLabel);
	void SetLevelWaitFlag(bool Flag);
	void SetMercyRepeatCount(int32 MercyRepeatCount);
	void SetQuizSuccess(bool IsSuccess);
	void SetSafetyHappened(E_TALK_SAFETY_TYPE SafetyType);
	void SetStockWaitFlag(bool Flag);
	void SetTalkResultEndType(E_TALK_END_TYPE EndType);
	void SetTalkResultTargetStatus(E_TALK_RESULT_TARGET_STATUS TargetStatus);
	void SetWantAction(E_TALK_WANT_AC Ac);
	void SubWant();
	void UpdateStartInfo(class UObject* PBattleMain);

	int32 MythGetProcessCount() const;
	const struct FTalkMythProcess MythGetProcessData(int32 MessageID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TalkCtrl">();
	}
	static class ATalkCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATalkCtrl>();
	}
};
static_assert(alignof(ATalkCtrl) == 0x000008, "Wrong alignment on ATalkCtrl");
static_assert(sizeof(ATalkCtrl) == 0x0003A8, "Wrong size on ATalkCtrl");
static_assert(offsetof(ATalkCtrl, M_TalkStartInfo) == 0x000220, "Member 'ATalkCtrl::M_TalkStartInfo' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_DevilID) == 0x00022C, "Member 'ATalkCtrl::M_DevilID' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_DevilLevel) == 0x000230, "Member 'ATalkCtrl::M_DevilLevel' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_DevilGroup) == 0x000234, "Member 'ATalkCtrl::M_DevilGroup' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_DevilAttr1) == 0x000238, "Member 'ATalkCtrl::M_DevilAttr1' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_DevilCharacterNameIndex) == 0x00023C, "Member 'ATalkCtrl::M_DevilCharacterNameIndex' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MoonTemperData) == 0x000241, "Member 'ATalkCtrl::M_MoonTemperData' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MoonTemperStatus) == 0x000242, "Member 'ATalkCtrl::M_MoonTemperStatus' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_QuestionPart) == 0x000244, "Member 'ATalkCtrl::M_QuestionPart' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_QuestionId) == 0x000248, "Member 'ATalkCtrl::M_QuestionId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_JudgeParam) == 0x00024C, "Member 'ATalkCtrl::M_JudgeParam' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_ReactionDebugIndex) == 0x000250, "Member 'ATalkCtrl::M_ReactionDebugIndex' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_ReactionInfo) == 0x000254, "Member 'ATalkCtrl::M_ReactionInfo' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantKind) == 0x00027C, "Member 'ATalkCtrl::M_WantKind' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantKindPrev) == 0x00027D, "Member 'ATalkCtrl::M_WantKindPrev' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantRepeatCount) == 0x000280, "Member 'ATalkCtrl::M_WantRepeatCount' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantYesCount) == 0x000284, "Member 'ATalkCtrl::M_WantYesCount' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantOtherCount) == 0x000288, "Member 'ATalkCtrl::M_WantOtherCount' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantNotHaveCount) == 0x00028C, "Member 'ATalkCtrl::M_WantNotHaveCount' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantAc) == 0x000290, "Member 'ATalkCtrl::M_WantAc' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReac) == 0x000291, "Member 'ATalkCtrl::M_WantReac' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MoneyPaid) == 0x000292, "Member 'ATalkCtrl::M_MoneyPaid' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantItemId) == 0x000294, "Member 'ATalkCtrl::M_WantItemId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantItemNum) == 0x000298, "Member 'ATalkCtrl::M_WantItemNum' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantItemRank) == 0x00029C, "Member 'ATalkCtrl::M_WantItemRank' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantMoney) == 0x0002A0, "Member 'ATalkCtrl::M_WantMoney' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantHP) == 0x0002A4, "Member 'ATalkCtrl::M_WantHP' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantMP) == 0x0002A8, "Member 'ATalkCtrl::M_WantMP' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantHPMPRank) == 0x0002AC, "Member 'ATalkCtrl::M_WantHPMPRank' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReduceItemId) == 0x0002B0, "Member 'ATalkCtrl::M_WantReduceItemId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReduceItemNum) == 0x0002B4, "Member 'ATalkCtrl::M_WantReduceItemNum' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReduceMoney) == 0x0002B8, "Member 'ATalkCtrl::M_WantReduceMoney' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReduceHP) == 0x0002BC, "Member 'ATalkCtrl::M_WantReduceHP' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReduceMP) == 0x0002C0, "Member 'ATalkCtrl::M_WantReduceMP' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReduceHPMPRank) == 0x0002C4, "Member 'ATalkCtrl::M_WantReduceHPMPRank' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_bWantReduce) == 0x0002C8, "Member 'ATalkCtrl::M_bWantReduce' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReduceUniqueDevilList_1) == 0x0002D0, "Member 'ATalkCtrl::M_WantReduceUniqueDevilList_1' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReduceUniqueDevilList_2) == 0x0002E0, "Member 'ATalkCtrl::M_WantReduceUniqueDevilList_2' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_WantReduceUniqueDevilId) == 0x0002F0, "Member 'ATalkCtrl::M_WantReduceUniqueDevilId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_TalkResult) == 0x0002F4, "Member 'ATalkCtrl::M_TalkResult' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_FundCount) == 0x0002F8, "Member 'ATalkCtrl::M_FundCount' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_FundMoney) == 0x0002FC, "Member 'ATalkCtrl::M_FundMoney' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_FundTotalMoney) == 0x000300, "Member 'ATalkCtrl::M_FundTotalMoney' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_UtsusemiItemId) == 0x000304, "Member 'ATalkCtrl::M_UtsusemiItemId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_UtsusemiHide) == 0x000308, "Member 'ATalkCtrl::M_UtsusemiHide' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MercyRepeatCount) == 0x00030C, "Member 'ATalkCtrl::M_MercyRepeatCount' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_NkmUnconditionalMode) == 0x000338, "Member 'ATalkCtrl::M_NkmUnconditionalMode' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MythId) == 0x00033C, "Member 'ATalkCtrl::M_MythId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MythFriendId) == 0x000340, "Member 'ATalkCtrl::M_MythFriendId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MythEnemyId) == 0x000344, "Member 'ATalkCtrl::M_MythEnemyId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MythNextMessageIndex) == 0x000348, "Member 'ATalkCtrl::M_MythNextMessageIndex' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MythItemId) == 0x00034C, "Member 'ATalkCtrl::M_MythItemId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_bQuizMode) == 0x000350, "Member 'ATalkCtrl::M_bQuizMode' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_QuizDevilId) == 0x000354, "Member 'ATalkCtrl::M_QuizDevilId' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_QuizChoices) == 0x000358, "Member 'ATalkCtrl::M_QuizChoices' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_IsQuizSuccess) == 0x000368, "Member 'ATalkCtrl::M_IsQuizSuccess' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_pTalkToneTable) == 0x000370, "Member 'ATalkCtrl::M_pTalkToneTable' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_pBattleMain) == 0x000378, "Member 'ATalkCtrl::M_pBattleMain' has a wrong offset!");
static_assert(offsetof(ATalkCtrl, M_MythProcessTable) == 0x000380, "Member 'ATalkCtrl::M_MythProcessTable' has a wrong offset!");

// Class Project.BPL_TalkDebug
// 0x0000 (0x0028 - 0x0028)
class UBPL_TalkDebug final : public UBlueprintFunctionLibrary
{
public:
	static ETalkDebugFlag ETalkDebugFlag_FromString(const class FString& EnumString);
	static bool TalkDebugFlagGet(ETalkDebugFlag DebugFlag);
	static bool TalkDebugFlagSet(ETalkDebugFlag DebugFlag, bool Value);
	static bool TalkDebugFlagToggle(ETalkDebugFlag DebugFlag);
	static E_TALK_MOON_TEMPER_STATUS TalkDebugMoonTemperStatusGet();
	static E_TALK_MOON_TEMPER_STATUS TalkDebugMoonTemperStatusSet(E_TALK_MOON_TEMPER_STATUS Status);
	static int32 TalkDebugSafetyUniqueSkillDevilIdGet();
	static void TalkDebugSafetyUniqueSkillDevilIdSet(int32 DevilID);
	static int32 TalkDebugWantHPMPRankGet();
	static void TalkDebugWantHPMPRankSet(int32 Rank);
	static E_TALK_WANT_REAC TalkDebugWantReacGet();
	static void TalkDebugWantReacSet(E_TALK_WANT_REAC WantReac);
	static int32 TalkDebugWantReduceUniqueSkillDevilIdGet();
	static void TalkDebugWantReduceUniqueSkillDevilIdSet(int32 DevilID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_TalkDebug">();
	}
	static class UBPL_TalkDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_TalkDebug>();
	}
};
static_assert(alignof(UBPL_TalkDebug) == 0x000008, "Wrong alignment on UBPL_TalkDebug");
static_assert(sizeof(UBPL_TalkDebug) == 0x000028, "Wrong size on UBPL_TalkDebug");

// Class Project.BPL_TestPlayTrace
// 0x0000 (0x0028 - 0x0028)
class UBPL_TestPlayTrace final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetTestTraceData(const class FString& Filename);
	static TArray<class FString> GetTestTraceFileName();
	static bool SetTestTraceData(const class FString& Text, const class FString& Filename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_TestPlayTrace">();
	}
	static class UBPL_TestPlayTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_TestPlayTrace>();
	}
};
static_assert(alignof(UBPL_TestPlayTrace) == 0x000008, "Wrong alignment on UBPL_TestPlayTrace");
static_assert(sizeof(UBPL_TestPlayTrace) == 0x000028, "Wrong size on UBPL_TestPlayTrace");

// Class Project.TransformConverterComponent
// 0x0000 (0x0200 - 0x0200)
class UTransformConverterComponent final : public USceneComponent
{
public:
	EConvertLocationType                          LocationConvert;                                   // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConvertRotationType                          RotationConvert;                                   // 0x01F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConvertScaleType                             ScaleConvert;                                      // 0x01FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D28[0x5];                                     // 0x01FB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformConverterComponent">();
	}
	static class UTransformConverterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformConverterComponent>();
	}
};
static_assert(alignof(UTransformConverterComponent) == 0x000010, "Wrong alignment on UTransformConverterComponent");
static_assert(sizeof(UTransformConverterComponent) == 0x000200, "Wrong size on UTransformConverterComponent");
static_assert(offsetof(UTransformConverterComponent, LocationConvert) == 0x0001F8, "Member 'UTransformConverterComponent::LocationConvert' has a wrong offset!");
static_assert(offsetof(UTransformConverterComponent, RotationConvert) == 0x0001F9, "Member 'UTransformConverterComponent::RotationConvert' has a wrong offset!");
static_assert(offsetof(UTransformConverterComponent, ScaleConvert) == 0x0001FA, "Member 'UTransformConverterComponent::ScaleConvert' has a wrong offset!");

// Class Project.TransportListCtrlBase
// 0x0020 (0x0240 - 0x0220)
class ATransportListCtrlBase final : public AActor
{
public:
	uint8                                         Pad_1D29[0x20];                                    // 0x0220(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddListInfo(const class FText& InLocationName, bool InActiveSlot);
	TArray<struct FTransportLocationSlotInfo> GetListInfo_All();
	TArray<struct FTransportLocationSlotInfo> GetListInfo_InRange(int32 StartIdx, int32 EndIdx);
	void ResetListInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransportListCtrlBase">();
	}
	static class ATransportListCtrlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATransportListCtrlBase>();
	}
};
static_assert(alignof(ATransportListCtrlBase) == 0x000008, "Wrong alignment on ATransportListCtrlBase");
static_assert(sizeof(ATransportListCtrlBase) == 0x000240, "Wrong size on ATransportListCtrlBase");

// Class Project.BPL_TutorialWindowData
// 0x0000 (0x0028 - 0x0028)
class UBPL_TutorialWindowData final : public UBlueprintFunctionLibrary
{
public:
	static struct FTutorialWindowBuffer GetTutorialWindowData(E_TUTORIAL_WINDOW_MESSAGE_TYPE Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_TutorialWindowData">();
	}
	static class UBPL_TutorialWindowData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_TutorialWindowData>();
	}
};
static_assert(alignof(UBPL_TutorialWindowData) == 0x000008, "Wrong alignment on UBPL_TutorialWindowData");
static_assert(sizeof(UBPL_TutorialWindowData) == 0x000028, "Wrong size on UBPL_TutorialWindowData");

// Class Project.UIAnimtionCtrl
// 0x0000 (0x0028 - 0x0028)
class UUIAnimtionCtrl final : public UObject
{
public:
	void MakeUpAnimtionData(struct FUIAnimationPlayData* AnimPlayData, const struct FUIAnimationTableData& PAnimTblData, bool IsReverse);
	struct FUIAnimationPlayData PlayAnimation(const struct FUIAnimationPlayData& AnimPlayData, float AddTime, bool* IsPlayEnd);
	struct FUIAnimationTaskData PlayAnimationTask(const struct FUIAnimationTaskData& AnimTaskData, float AddTime, bool* IsPlayEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAnimtionCtrl">();
	}
	static class UUIAnimtionCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAnimtionCtrl>();
	}
};
static_assert(alignof(UUIAnimtionCtrl) == 0x000008, "Wrong alignment on UUIAnimtionCtrl");
static_assert(sizeof(UUIAnimtionCtrl) == 0x000028, "Wrong size on UUIAnimtionCtrl");

// Class Project.BtlMainCommandWidgetBase
// 0x0010 (0x05F0 - 0x05E0)
class UBtlMainCommandWidgetBase final : public UBtlCommandWidgetBase
{
public:
	TArray<struct FBtlMainCommandUIData>          M_CommandUIDataArray;                              // 0x05D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D2F[0x8];                                     // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCommandUIData(const struct FBtlMainCommandUIData& Data);
	TArray<struct FBtlMainCommandUIData> GetCommandUIDataArray();
	bool IsUseItemCommand();
	void MakeNkmCommandData(int32 NkmIndex);
	void MakePlayerCommandData();
	bool Setting(const struct FBtlParty& PartyData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlMainCommandWidgetBase">();
	}
	static class UBtlMainCommandWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlMainCommandWidgetBase>();
	}
};
static_assert(alignof(UBtlMainCommandWidgetBase) == 0x000010, "Wrong alignment on UBtlMainCommandWidgetBase");
static_assert(sizeof(UBtlMainCommandWidgetBase) == 0x0005F0, "Wrong size on UBtlMainCommandWidgetBase");
static_assert(offsetof(UBtlMainCommandWidgetBase, M_CommandUIDataArray) == 0x0005D8, "Member 'UBtlMainCommandWidgetBase::M_CommandUIDataArray' has a wrong offset!");

// Class Project.UIBtlPressIconPartsBase
// 0x0030 (0x02A8 - 0x0278)
class UUIBtlPressIconPartsBase : public UUIWidgetBase
{
public:
	uint8                                         Pad_1D31[0x4];                                     // 0x0278(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_StartDelayRemainSec;                             // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_StartDelayRemainFrame;                           // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_IsHalfAddEffectPerforming;                       // 0x0284(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_IsDrawIcon;                                      // 0x0285(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D32[0x2];                                     // 0x0286(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEndHalfBlink;                                    // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDrawStarted;                                     // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BP_HalfIconAddEffectStart(bool AutoLoop);
	void BP_HalfIconDrawStart();
	void BP_HalfIconHideStart(bool IsImmediately, bool IsIconBreak);
	bool BP_IsChangable();
	void BP_NormalIconDrawStart(bool IsExtendedIcon);
	void BP_NormalIconHideStart(bool IsImmediately, bool IsIconBreak);
	void CallDrawStartedEvent();
	void CallEndHalfBlinkEvent();
	void DrawStart();
	void EnableExtendedIcon();
	E_BTL_PRESSICON_TYPE GetIconType();
	E_BTL_SIDE GetSide();
	void HalfAddEffectStart(bool AutoLoop);
	void HideStart(bool IsImmediately, bool IsIconBreak);
	bool IsHalfAddEffectPerforming();
	void SetIconType(E_BTL_PRESSICON_TYPE Icon_type);
	void SetSide(E_BTL_SIDE Side);
	void SetStartDelayRemainFrame(int32 InFrame);
	void SetStartDelayRemainSec(float InSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBtlPressIconPartsBase">();
	}
	static class UUIBtlPressIconPartsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBtlPressIconPartsBase>();
	}
};
static_assert(alignof(UUIBtlPressIconPartsBase) == 0x000008, "Wrong alignment on UUIBtlPressIconPartsBase");
static_assert(sizeof(UUIBtlPressIconPartsBase) == 0x0002A8, "Wrong size on UUIBtlPressIconPartsBase");
static_assert(offsetof(UUIBtlPressIconPartsBase, M_StartDelayRemainSec) == 0x00027C, "Member 'UUIBtlPressIconPartsBase::M_StartDelayRemainSec' has a wrong offset!");
static_assert(offsetof(UUIBtlPressIconPartsBase, M_StartDelayRemainFrame) == 0x000280, "Member 'UUIBtlPressIconPartsBase::M_StartDelayRemainFrame' has a wrong offset!");
static_assert(offsetof(UUIBtlPressIconPartsBase, M_IsHalfAddEffectPerforming) == 0x000284, "Member 'UUIBtlPressIconPartsBase::M_IsHalfAddEffectPerforming' has a wrong offset!");
static_assert(offsetof(UUIBtlPressIconPartsBase, M_IsDrawIcon) == 0x000285, "Member 'UUIBtlPressIconPartsBase::M_IsDrawIcon' has a wrong offset!");
static_assert(offsetof(UUIBtlPressIconPartsBase, OnEndHalfBlink) == 0x000288, "Member 'UUIBtlPressIconPartsBase::OnEndHalfBlink' has a wrong offset!");
static_assert(offsetof(UUIBtlPressIconPartsBase, OnDrawStarted) == 0x000298, "Member 'UUIBtlPressIconPartsBase::OnDrawStarted' has a wrong offset!");

// Class Project.UIBtlPressIconBase
// 0x0020 (0x0298 - 0x0278)
class UUIBtlPressIconBase : public UUIWidgetBase
{
public:
	TArray<class UUIBtlPressIconPartsBase*>       M_PressIconParts;                                  // 0x0278(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPressIcon                             M_DrawPressIconNum;                                // 0x0288(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D33[0x4];                                     // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDrawPressIcon(const struct FPressIcon& Add_press_icon, E_BTL_PRESS_TYPE PressType);
	void BP_AddDrawPressIcon(const struct FPressIcon& Add_press_icon, E_BTL_PRESS_TYPE PressType);
	void BP_InStart();
	void BP_OutStart(bool IsIconBreak);
	void BP_SlideInStart();
	void BP_SlideOutStart();
	struct FPressIcon CalcDrawPressIconNum(const struct FPressIcon& Root_press_icon, bool Is_apply);
	struct FPressIcon GetAddDrawPressIconNum(const struct FPressIcon& Root_press_icon);
	void InStart();
	void OutStart(bool IsIconBreak);
	void SetSide(E_BTL_SIDE Side);
	void SlideInStart();
	void SlideOutStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBtlPressIconBase">();
	}
	static class UUIBtlPressIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBtlPressIconBase>();
	}
};
static_assert(alignof(UUIBtlPressIconBase) == 0x000008, "Wrong alignment on UUIBtlPressIconBase");
static_assert(sizeof(UUIBtlPressIconBase) == 0x000298, "Wrong size on UUIBtlPressIconBase");
static_assert(offsetof(UUIBtlPressIconBase, M_PressIconParts) == 0x000278, "Member 'UUIBtlPressIconBase::M_PressIconParts' has a wrong offset!");
static_assert(offsetof(UUIBtlPressIconBase, M_DrawPressIconNum) == 0x000288, "Member 'UUIBtlPressIconBase::M_DrawPressIconNum' has a wrong offset!");

// Class Project.UIStatusCtrlDataObjBtlBase
// 0x0010 (0x01B8 - 0x01A8)
class UUIStatusCtrlDataObjBtlBase : public UUIStatusCtrlDataObjBase
{
public:
	TArray<int32>                                 M_CampLikeList;                                    // 0x01A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void CreateCharaList(const TArray<uint8>& SrcList, TArray<int32>& DstList);
	void GetAnalyzeData(const int32 Param_Index, struct FAnalyzeData* AnalyzeData);
	TArray<int32> GetDedicatedDropData(const int32 Param_Index);
	TArray<int32> GetMagaSkillSupporters(const int32 Param_Index);
	TArray<int32> GetMagatsuhiSkillData(const int32 Param_Index);
	void GetSatanAnalyzeData(struct FAnalyzeData* Data, const int32 DevilID);
	bool IsBossChallangeMode();
	bool RebuildCharaList(const TArray<uint8>& EnemyList, const TArray<uint8>& PartyList, const TArray<uint8>& StockList);
	void SetUIObjBtlCharaStatus(struct FBtlParty& In_btlParty, bool IsEnemy);
	bool UseDedicatedAnalyzeData(const int32 Param_Index);
	bool UseDedicatedDropData(const int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusCtrlDataObjBtlBase">();
	}
	static class UUIStatusCtrlDataObjBtlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatusCtrlDataObjBtlBase>();
	}
};
static_assert(alignof(UUIStatusCtrlDataObjBtlBase) == 0x000008, "Wrong alignment on UUIStatusCtrlDataObjBtlBase");
static_assert(sizeof(UUIStatusCtrlDataObjBtlBase) == 0x0001B8, "Wrong size on UUIStatusCtrlDataObjBtlBase");
static_assert(offsetof(UUIStatusCtrlDataObjBtlBase, M_CampLikeList) == 0x0001A8, "Member 'UUIStatusCtrlDataObjBtlBase::M_CampLikeList' has a wrong offset!");

// Class Project.UIStatusCtrlDataObjResult
// 0x0050 (0x01F8 - 0x01A8)
class UUIStatusCtrlDataObjResult final : public UUIStatusCtrlDataObjBase
{
public:
	uint8                                         Pad_1D40[0x50];                                    // 0x01A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusCtrlDataObjResult">();
	}
	static class UUIStatusCtrlDataObjResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatusCtrlDataObjResult>();
	}
};
static_assert(alignof(UUIStatusCtrlDataObjResult) == 0x000008, "Wrong alignment on UUIStatusCtrlDataObjResult");
static_assert(sizeof(UUIStatusCtrlDataObjResult) == 0x0001F8, "Wrong size on UUIStatusCtrlDataObjResult");

// Class Project.UIStatusCtrlDataObjUnite
// 0x0028 (0x01D0 - 0x01A8)
class UUIStatusCtrlDataObjUnite final : public UUIStatusCtrlDataObjBase
{
public:
	uint8                                         Pad_1D41[0x28];                                    // 0x01A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearStatusList();
	E_UI_STATUS_CTRL_TYPE GetCtrlType();
	void GetReturnCursorPosition(const int32& beforeOffset, int32* RetOffset, int32* RetCursorPos);
	void InitInhelitTestData(int32 ParentSkillNum, int32 DevilID);
	void InitInheritResult();
	void InitResistancesInheritData();
	void InitSkillInherit(const bool ReturnFromResult);
	bool IsUtsusemiInherit();
	void SetElemStatusLinkList(int32 UIindex, E_UI_STATUS_UNITE_SOURCE Type, int32 DataIndex);
	void SetSimpleData_Fusion(E_UI_STATUS_UNITE_SOURCE Type, int32 DataIndex);
	void SetUniteCtrl(class AUniteCtrl* UniteCtrlActor);
	void SetUtsusemiStatusFromDevilID(int32 DevilID);
	void UpdateSkillInherit(int32 ParentCursor, int32 ChildCursorIndex, bool* Moved);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusCtrlDataObjUnite">();
	}
	static class UUIStatusCtrlDataObjUnite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatusCtrlDataObjUnite>();
	}
};
static_assert(alignof(UUIStatusCtrlDataObjUnite) == 0x000008, "Wrong alignment on UUIStatusCtrlDataObjUnite");
static_assert(sizeof(UUIStatusCtrlDataObjUnite) == 0x0001D0, "Wrong size on UUIStatusCtrlDataObjUnite");

// Class Project.UIFade
// 0x0000 (0x0028 - 0x0028)
class UUIFade final : public UBlueprintFunctionLibrary
{
public:
	static void CallDebug();
	static void FadeClear();
	static bool FadeIn_BeforeColor(float Time, bool IsInterrupt);
	static bool FadeIn_Black(float Time, bool IsInterrupt);
	static bool FadeIn_Color(const struct FColor& Color, float Time, bool IsInterrupt);
	static bool FadeIn_White(float Time, bool IsInterrupt);
	static bool FadeOut_BeforeColor(float Time, bool IsInterrupt);
	static bool FadeOut_Black(float Time, bool IsInterrupt);
	static bool FadeOut_Color(const struct FColor& Color, float Time, bool IsInterrupt);
	static bool FadeOut_White(float Time, bool IsInterrupt);
	static class UUIFadeBase* GetBP_ScreenFade();
	static E_UI_FADE_STATE GetFadeState();
	static bool IsFadeAnim();
	static bool IsFadeIn();
	static bool IsFadeOut();
	static bool IsFadePaused();
	static bool SetFadePaused(bool Sw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFade">();
	}
	static class UUIFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFade>();
	}
};
static_assert(alignof(UUIFade) == 0x000008, "Wrong alignment on UUIFade");
static_assert(sizeof(UUIFade) == 0x000028, "Wrong size on UUIFade");

// Class Project.UIFadeBase
// 0x0028 (0x0050 - 0x0028)
class UUIFadeBase : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnEventDispather_EndFadeIn;                        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEventDispather_EndFadeOut;                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FColor                                 M_FadeColor;                                       // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D4D[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CallDebug();
	bool FadeClear();
	bool FadeIn(const struct FColor& Color, float Time, bool IsInterrupt);
	bool FadeOut(const struct FColor& Color, float Time, bool IsInterrupt);
	struct FColor GetFadeColor();
	E_UI_FADE_STATE GetFadeState();
	bool IsFadeAnim();
	bool IsFadeIn();
	bool IsFadeOut();
	bool IsFadePaused();
	void SetFadeColor(const struct FColor& Col);
	bool SetFadePaused(bool Sw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFadeBase">();
	}
	static class UUIFadeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFadeBase>();
	}
};
static_assert(alignof(UUIFadeBase) == 0x000008, "Wrong alignment on UUIFadeBase");
static_assert(sizeof(UUIFadeBase) == 0x000050, "Wrong size on UUIFadeBase");
static_assert(offsetof(UUIFadeBase, OnEventDispather_EndFadeIn) == 0x000028, "Member 'UUIFadeBase::OnEventDispather_EndFadeIn' has a wrong offset!");
static_assert(offsetof(UUIFadeBase, OnEventDispather_EndFadeOut) == 0x000038, "Member 'UUIFadeBase::OnEventDispather_EndFadeOut' has a wrong offset!");
static_assert(offsetof(UUIFadeBase, M_FadeColor) == 0x000048, "Member 'UUIFadeBase::M_FadeColor' has a wrong offset!");

// Class Project.BPL_UIMapInfoSupport
// 0x0000 (0x0028 - 0x0028)
class UBPL_UIMapInfoSupport final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* SpawnMapInfoActor(class UClass* PClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_UIMapInfoSupport">();
	}
	static class UBPL_UIMapInfoSupport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_UIMapInfoSupport>();
	}
};
static_assert(alignof(UBPL_UIMapInfoSupport) == 0x000008, "Wrong alignment on UBPL_UIMapInfoSupport");
static_assert(sizeof(UBPL_UIMapInfoSupport) == 0x000028, "Wrong size on UBPL_UIMapInfoSupport");

// Class Project.UIStatusFaceIconObjBase
// 0x0000 (0x0028 - 0x0028)
class UUIStatusFaceIconObjBase final : public UObject
{
public:
	int32 GetCenterIndex() const;
	int32 GetIconID(int32 PosNum) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusFaceIconObjBase">();
	}
	static class UUIStatusFaceIconObjBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatusFaceIconObjBase>();
	}
};
static_assert(alignof(UUIStatusFaceIconObjBase) == 0x000008, "Wrong alignment on UUIStatusFaceIconObjBase");
static_assert(sizeof(UUIStatusFaceIconObjBase) == 0x000028, "Wrong size on UUIStatusFaceIconObjBase");

// Class Project.UIStatusFaceIconList
// 0x0000 (0x0028 - 0x0028)
class IUIStatusFaceIconList final : public IInterface
{
public:
	int32 GetCenterIndex() const;
	int32 GetIconID(int32 PosNum) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusFaceIconList">();
	}
	static class IUIStatusFaceIconList* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUIStatusFaceIconList>();
	}
};
static_assert(alignof(IUIStatusFaceIconList) == 0x000008, "Wrong alignment on IUIStatusFaceIconList");
static_assert(sizeof(IUIStatusFaceIconList) == 0x000028, "Wrong size on IUIStatusFaceIconList");

// Class Project.SystemMess
// 0x0010 (0x0230 - 0x0220)
class ASystemMess final : public AActor
{
public:
	TArray<class FText>                           M_Texts;                                           // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void Finalize();
	class FText GetText(const int32 Param_Index);
	bool MakeUp(class UScriptMessageAsset* PText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemMess">();
	}
	static class ASystemMess* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASystemMess>();
	}
};
static_assert(alignof(ASystemMess) == 0x000008, "Wrong alignment on ASystemMess");
static_assert(sizeof(ASystemMess) == 0x000230, "Wrong size on ASystemMess");
static_assert(offsetof(ASystemMess, M_Texts) == 0x000220, "Member 'ASystemMess::M_Texts' has a wrong offset!");

// Class Project.UIWidgetAnim
// 0x0028 (0x02A0 - 0x0278)
class UUIWidgetAnim final : public UUIWidgetBase
{
public:
	TArray<struct FUIAnimationTaskData>           M_AnimTaskArray;                                   // 0x0278(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUIAnimationTableData>          M_AnimTableDataArray;                              // 0x0288(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UUIAnimtionCtrl*                        M_pAnimCtrl;                                       // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddAnimTable(const struct FUIAnimationTableData& AnimTableData);
	struct FUIAnimationTaskData CallPlayAnimation(float DeltaTime, const struct FUIAnimationTaskData& AnimTaskData, bool* Ret);
	void CallStopAnimation(int32 TaskIndex);
	void ClearAnimTable();
	void CreateAnimCtrl();
	void CreateAnimTable();
	struct FUIAnimationTaskData CreateAnimTaskData(int32 TaskIndex, const TArray<uint8>& AnimTableArray, bool IsLoop, bool IsRev);
	void DeleteAnimCtrl();
	struct FUIAnimationTableData GetAnimTableData(uint8 TableType);
	TArray<uint8> GetSetAnimDataTable(uint8 AnimType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWidgetAnim">();
	}
	static class UUIWidgetAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWidgetAnim>();
	}
};
static_assert(alignof(UUIWidgetAnim) == 0x000008, "Wrong alignment on UUIWidgetAnim");
static_assert(sizeof(UUIWidgetAnim) == 0x0002A0, "Wrong size on UUIWidgetAnim");
static_assert(offsetof(UUIWidgetAnim, M_AnimTaskArray) == 0x000278, "Member 'UUIWidgetAnim::M_AnimTaskArray' has a wrong offset!");
static_assert(offsetof(UUIWidgetAnim, M_AnimTableDataArray) == 0x000288, "Member 'UUIWidgetAnim::M_AnimTableDataArray' has a wrong offset!");
static_assert(offsetof(UUIWidgetAnim, M_pAnimCtrl) == 0x000298, "Member 'UUIWidgetAnim::M_pAnimCtrl' has a wrong offset!");

// Class Project.BPL_UniqueSymbolData
// 0x0000 (0x0028 - 0x0028)
class UBPL_UniqueSymbolData final : public UBlueprintFunctionLibrary
{
public:
	static const struct FUniqueSymbolData GetUniqueSymbolData(int32 UniqueSymbolID);
	static const TArray<struct FUniqueSymbolData> GetUniqueSymbolDataList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_UniqueSymbolData">();
	}
	static class UBPL_UniqueSymbolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_UniqueSymbolData>();
	}
};
static_assert(alignof(UBPL_UniqueSymbolData) == 0x000008, "Wrong alignment on UBPL_UniqueSymbolData");
static_assert(sizeof(UBPL_UniqueSymbolData) == 0x000028, "Wrong size on UBPL_UniqueSymbolData");

// Class Project.UniteCtrl
// 0x0380 (0x05A0 - 0x0220)
class AUniteCtrl final : public AActor
{
public:
	class UUniteTable*                            M_pUniteTable;                                     // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D58[0x378];                                   // 0x0228(0x0378)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddUnitePartyMember(bool* bEntryBible);
	void ApplyUtsusemiData();
	void ConvSkillInheritUIParam(int32* OutParentTop, int32* OutParentCurrent, int32* OutChildTop, int32* OutChildCategory, int32* OutChildCurrent);
	void DestroyUniteTable();
	int32 GetSkillInheritHelpSkill();
	const struct FAbilData GetUniteBonusParam();
	int32 GetUniteCost();
	int32 GetUniteExp();
	const TArray<struct FUniteSkillData> GetUnitePossibleSkillList();
	int32 GetUniteResultDevilId(bool bCheckAccident);
	const TArray<int32> GetUniteSelectedSkillList();
	int32 GetUniteSourceDevilId(int32 InSourceNo);
	const TArray<struct FUniteSkillData> GetUtsusemiPossibleSkillList();
	int32 GetUtsusemiResultNkmIndex();
	const TArray<int32> GetUtsusemiSelectedSkillList();
	int32 GetUtsusemiSourceDevilId();
	void InitUniteSetupData();
	void InitUtsusemiSetupData();
	bool IsAbleKeyPepeatSkillInheritScrollDown();
	bool IsAbleKeyPepeatSkillInheritScrollUp();
	bool IsUniteAccident();
	bool IsUtsusemiDefenceAishouMode();
	bool IsValidUtsusemi();
	void MakeUpUniteTable(class UMMIAsset* PAsset);
	void SetDoubleUniteData(int32 InResultDevil, int32 InSourceDevil1, int32 InSourceDevil2, int32 InCost);
	void SetSpecialUniteData(int32 InResultDevil, int32 InSourceDevil1, int32 InSourceDevil2, int32 InSourceDevil3, int32 InSourceDevil4, int32 InCost);
	void SetUtsusemiData(int32 InSourceDevil, int32 InResultNkmIndex, bool bInDefenceAishou);
	E_SKILLINHERIT_RESULT SkillInheritCancelButton();
	E_SKILLINHERIT_RESULT SkillInheritDecisionButton();
	void SkillInheritDragScrollBar(bool IsMain, int32 NewTopPos, bool* TopMoved, bool* CursorMoved, bool* IsCurrentList);
	E_SKILLINHERIT_RESULT SkillInheritEndButton();
	void SkillInheritOnClickedSlot(bool IsMain, int32 Param_Index, E_SKILLINHERIT_RESULT* MoveResult, E_SKILLINHERIT_RESULT* DecisionResult);
	E_SKILLINHERIT_RESULT SkillInheritOnHoveredSlot(bool IsMain, int32 Param_Index);
	E_SKILLINHERIT_RESULT SkillInheritScrollDown();
	E_SKILLINHERIT_RESULT SkillInheritScrollPageDown();
	E_SKILLINHERIT_RESULT SkillInheritScrollPageUp();
	E_SKILLINHERIT_RESULT SkillInheritScrollUp();
	void SkillInheritWheelDown(bool MainHover, bool SubHover, int32 HoverPos, bool* TopMoved, bool* CursorMoved, bool* IsCurrentList);
	void SkillInheritWheelUp(bool MainHover, bool SubHover, int32 HoverPos, bool* TopMoved, bool* CursorMoved, bool* IsCurrentList);
	void UpDateUniteFixNkmData(bool bCheckAccident);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniteCtrl">();
	}
	static class AUniteCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUniteCtrl>();
	}
};
static_assert(alignof(AUniteCtrl) == 0x000008, "Wrong alignment on AUniteCtrl");
static_assert(sizeof(AUniteCtrl) == 0x0005A0, "Wrong size on AUniteCtrl");
static_assert(offsetof(AUniteCtrl, M_pUniteTable) == 0x000220, "Member 'AUniteCtrl::M_pUniteTable' has a wrong offset!");

// Class Project.BPL_UniteCtrlData
// 0x0000 (0x0028 - 0x0028)
class UBPL_UniteCtrlData final : public UBlueprintFunctionLibrary
{
public:
	static int32 AdjustUniteDevilCost(int32 InCost);
	static void CalcAccidentSkill(TArray<int32>* OutSkillList, const int32 ResultDevil, const int32 AccidentDevil, const TArray<int32>& SrcDevilList);
	static int32 CalcDevilCost_ByBibleData(int32 DevilID);
	static int32 CalcDevilCost_ByDevilData(int32 DevilID);
	static int32 CalcDevilCost_ByPartyData(int32 DevilID);
	static int32 CalcUniteAddExp(int32 ResultDevil, int32 SourceDevil1, int32 SourceDevil2, int32 SourceDevil3, int32 SourceDevil4);
	static int32 CalcUniteAddExpByList(int32 ResultDevil, const TArray<int32>& SourceList);
	static struct FAbilData CalcUniteBonusParam(int32 ResultDevil, int32 SourceDevil1, int32 SourceDevil2, int32 SourceDevil3, int32 SourceDevil4);
	static struct FAbilData CalcUniteBonusParamByList(int32 ResultDevil, const TArray<int32>& SourceList);
	static bool CheckAnyNewUniteSpFlag();
	static bool CheckNewUniteSpFlag(int32 DevilID);
	static bool CheckNewUniteTutorialFlag(E_TUTORIAL_WINDOW_MESSAGE_TYPE Type);
	static bool CheckUniteBibleEntry(int32 DevilID);
	static bool CheckUniteKamuiOpenAnnounce();
	static void ClearNewUniteMenuFlag();
	static void ClearUniteKamuiOpenAnnounceFlag();
	static void ClearUniteSpOpenAnnounceFlag();
	static int32 GetBibleEntryRate();
	static void GetNkmData_ByBibleData(int32 DevilID, struct FNkmData* NkmData);
	static void GetNkmData_ByDevilData(int32 DevilID, struct FNkmData* NkmData);
	static void GetNkmData_ByPartyData(int32 DevilID, struct FNkmData* NkmData);
	static int32 GetSkillRank(int32 SkillId);
	static float GetUniteBgBlurStrength(float InBlurStrength);
	static struct FUniteCtrlData GetUniteCtrlData();
	static int32 GetUniteDevilLevel(int32 DevilID, E_UNITE_NKM_TYPE NkmType);
	static int32 GetUniteDoubleResult(int32 DevilId1, int32 DevilId2);
	static int32 GetUniteLevel();
	static void GetUniteSpOpenAnnounceList(TArray<int32>* DevilIdList, TArray<int32>* IndexList);
	static void InitUniteDataCtrl();
	static bool IsAbleUniteInheritSkill(int32 ResultDevilId, int32 SkillId);
	static bool IsAbleUniteSozaiDevil(int32 DevilID);
	static bool IsDispUniteUtsusemiNewIcon();
	static bool IsDynamicResolution();
	static bool IsOpenBible();
	static bool IsOpenUnite();
	static bool IsOpenUniteSp();
	static bool IsOpenUniteTutorialType(E_TUTORIAL_WINDOW_MESSAGE_TYPE Type);
	static bool IsOverwriteDefaultSkill();
	static bool IsOverwriteDefenceAishou();
	static bool LotUniteAccident(int32 InSourceDevil1, int32 InSourceDevil2);
	static int32 LotUniteAccidentDevilFromID(int32 ResultDevil);
	static bool ReadUniteCombineTable(class UUniteTableAsset* PUniteAsset);
	static void SetNewUniteSpFlag(int32 DevilID);
	static void SetNewUniteTutorialFlag(E_TUTORIAL_WINDOW_MESSAGE_TYPE Type);
	static void SummonBibleData(int32 DevilID);
	static void SummonDevilData(int32 DevilID);
	static void UninitUniteDataCtrl();
	static bool UniteDebug_Accident();
	static bool UniteDebug_CheckBibleAllOpen();
	static bool UniteDebug_CheckLevelUnlimited();
	static void UniteDebug_InitBibleData();
	static void UniteDebug_InitDebugFlag();
	static void UniteDebug_NearlyCompletedBible();
	static bool UniteDebug_NoCost();
	static bool UniteDebug_NonAccident();
	static void UniteDebug_SetBonusDevilData();
	static void UniteDebug_UpdateDebugFlag(int32 Flagno);
	static void UniteDebug_UpdateDebugHpMpLogFlag();
	static bool UniteDebug_UseDebugSearch();
	static void UpdateUniteKamuiOpenAnnounce();
	static void UpdateUniteSpOpenAnnounce();
	static void WriteNkmData_ByBibleData(int32 NkmIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_UniteCtrlData">();
	}
	static class UBPL_UniteCtrlData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_UniteCtrlData>();
	}
};
static_assert(alignof(UBPL_UniteCtrlData) == 0x000008, "Wrong alignment on UBPL_UniteCtrlData");
static_assert(sizeof(UBPL_UniteCtrlData) == 0x000028, "Wrong size on UBPL_UniteCtrlData");

// Class Project.BPL_BibleData
// 0x0000 (0x0028 - 0x0028)
class UBPL_BibleData final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckBibleEntry(int32 DevilID);
	static bool CompareNkmAndBible(int32 NkmIndex);
	static void EntryBible_ByNkmIndex(int32 NkmIndex);
	static void EntryBibleAll();
	static bool EntryBibleFirst_ByNkmIndex(int32 NkmIndex);
	static struct FBibleData GetBibleData(int32 DevilID);
	static const struct FBibleData GetBibleDataDirect(int32 DevilID);
	static int32 GetBibleEntryNum();
	static int32 GetBibleMax();
	static void InitBible(int32 DevilID);
	static void InitBibleAll();
	static bool IsAbleBibleEntry(int32 DevilID);
	static void SetBibleData(int32 DevilID, const struct FBibleData& Data);
	static void SetBibleEntryFlag(int32 DevilID, bool IsEntry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPL_BibleData">();
	}
	static class UBPL_BibleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPL_BibleData>();
	}
};
static_assert(alignof(UBPL_BibleData) == 0x000008, "Wrong alignment on UBPL_BibleData");
static_assert(sizeof(UBPL_BibleData) == 0x000028, "Wrong size on UBPL_BibleData");

// Class Project.UniteTable
// 0x00D0 (0x00F8 - 0x0028)
class UUniteTable final : public UObject
{
public:
	TArray<struct FUniteDataTable>                UniteDataTableArray;                               // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniteNormalTable>              UniteNormalTableArray;                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniteSeireiBornTable>          UniteSeireiBornTableArray;                         // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniteSeireiTable>              UniteSeireiTableArray;                             // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniteSpTable>                  UniteSpTableArray;                                 // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniteAccidentProbTable>        UniteAccidentProbTableArray;                       // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniteAccidentDevilTable>       UniteAccidentDevilTableArray;                      // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniteAccidentTable>            UniteAccidentTableArray;                           // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BibleCdfsArray;                                    // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BibleCoeArray;                                     // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInheritSkillTekiseiTable>      InheritSkillTekiseiTableArray;                     // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniteDlcDevilTable>            UniteDlcDevilTableArray;                           // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7C[0x10];                                    // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniteTable">();
	}
	static class UUniteTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniteTable>();
	}
};
static_assert(alignof(UUniteTable) == 0x000008, "Wrong alignment on UUniteTable");
static_assert(sizeof(UUniteTable) == 0x0000F8, "Wrong size on UUniteTable");
static_assert(offsetof(UUniteTable, UniteDataTableArray) == 0x000028, "Member 'UUniteTable::UniteDataTableArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, UniteNormalTableArray) == 0x000038, "Member 'UUniteTable::UniteNormalTableArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, UniteSeireiBornTableArray) == 0x000048, "Member 'UUniteTable::UniteSeireiBornTableArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, UniteSeireiTableArray) == 0x000058, "Member 'UUniteTable::UniteSeireiTableArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, UniteSpTableArray) == 0x000068, "Member 'UUniteTable::UniteSpTableArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, UniteAccidentProbTableArray) == 0x000078, "Member 'UUniteTable::UniteAccidentProbTableArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, UniteAccidentDevilTableArray) == 0x000088, "Member 'UUniteTable::UniteAccidentDevilTableArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, UniteAccidentTableArray) == 0x000098, "Member 'UUniteTable::UniteAccidentTableArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, BibleCdfsArray) == 0x0000A8, "Member 'UUniteTable::BibleCdfsArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, BibleCoeArray) == 0x0000B8, "Member 'UUniteTable::BibleCoeArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, InheritSkillTekiseiTableArray) == 0x0000C8, "Member 'UUniteTable::InheritSkillTekiseiTableArray' has a wrong offset!");
static_assert(offsetof(UUniteTable, UniteDlcDevilTableArray) == 0x0000D8, "Member 'UUniteTable::UniteDlcDevilTableArray' has a wrong offset!");

// Class Project.UniteTableAsset
// 0x0018 (0x0040 - 0x0028)
class UUniteTableAsset final : public UObject
{
public:
	struct FUniteCombineHead                      M_Head;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7D[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUniteCombineData>              M_Data;                                            // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniteTableAsset">();
	}
	static class UUniteTableAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniteTableAsset>();
	}
};
static_assert(alignof(UUniteTableAsset) == 0x000008, "Wrong alignment on UUniteTableAsset");
static_assert(sizeof(UUniteTableAsset) == 0x000040, "Wrong size on UUniteTableAsset");
static_assert(offsetof(UUniteTableAsset, M_Head) == 0x000028, "Member 'UUniteTableAsset::M_Head' has a wrong offset!");
static_assert(offsetof(UUniteTableAsset, M_Data) == 0x000030, "Member 'UUniteTableAsset::M_Data' has a wrong offset!");

// Class Project.WindowsDeviceNotify
// 0x00E8 (0x0110 - 0x0028)
class UWindowsDeviceNotify final : public UObject
{
public:
	uint8                                         Pad_1D7E[0xE8];                                    // 0x0028(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindowsDeviceNotify">();
	}
	static class UWindowsDeviceNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWindowsDeviceNotify>();
	}
};
static_assert(alignof(UWindowsDeviceNotify) == 0x000008, "Wrong alignment on UWindowsDeviceNotify");
static_assert(sizeof(UWindowsDeviceNotify) == 0x000110, "Wrong size on UWindowsDeviceNotify");

}

